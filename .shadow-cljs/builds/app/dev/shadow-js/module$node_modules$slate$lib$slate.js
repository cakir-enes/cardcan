["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/slate/lib/slate.js"],"~:js","shadow$provide.module$node_modules$slate$lib$slate=function(global,require,module,exports){function _interopDefault(ex){return ex&&\"object\"===typeof ex&&\"default\"in ex?ex[\"default\"]:ex}function resetGenerator(){n$jscomp$0=0;generate=function(){return\"\"+n$jscomp$0++}}function compare(path,target){for(var m=min$jscomp$0(path,target),i=0;i<m;i++){var pv=path.get(i),tv=target.get(i);if(pv<tv)return-1;if(pv>tv)return 1}return path.size===target.size?0:null}function create$1(attrs){if(null==attrs)return null;\nif(immutable.List.isList(attrs))return attrs;if(Array.isArray(attrs))return immutable.List(attrs);throw Error(\"Paths can only be created from arrays or lists, but you passed: \"+attrs);}function crop(a,b){var size=2<arguments.length&&void 0!==arguments[2]?arguments[2]:min$jscomp$0(a,b),ca=a.slice(0,size);size=b.slice(0,size);return[ca,size]}function decrement(path){return increment(path,0-(1<arguments.length&&void 0!==arguments[1]?arguments[1]:1),2<arguments.length&&void 0!==arguments[2]?arguments[2]:\npath.size-1)}function increment(path){var n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:1,index=2<arguments.length&&void 0!==arguments[2]?arguments[2]:path.size-1,value=path.get(index);return path.set(index,value+n)}function isAbove(path,target){var _crop=crop(path,target),_crop2=slicedToArray(_crop,2);_crop=_crop2[0];_crop2=_crop2[1];return path.size<target.size&&0===compare(_crop,_crop2)}function isYounger(path,target){var index=path.size-1,_crop9=crop(path,target,index),_crop10=slicedToArray(_crop9,\n2);_crop9=_crop10[0];_crop10=_crop10[1];path=path.get(index);target=target.get(index);return _crop9.equals(_crop10)&&path<target}function min$jscomp$0(a,b){return Math.min(a.size,b.size)}function isObject(type,value){return!(!value||!value[TYPES[type]])}function applyOperation(value,op){op=Operation.create(op);var type=op.type;debug(type,op);switch(type){case \"add_annotation\":return value.addAnnotation(op.annotation);case \"add_mark\":return value.addMark(op.path,op.mark);case \"insert_node\":return value.insertNode(op.path,\nop.node);case \"insert_text\":return value.insertText(op.path,op.offset,op.text,op.marks);case \"merge_node\":return value.mergeNode(op.path);case \"move_node\":return value.moveNode(op.path,op.newPath);case \"remove_annotation\":return value.removeAnnotation(op.annotation);case \"remove_mark\":return value.removeMark(op.path,op.mark);case \"remove_node\":return value.removeNode(op.path);case \"remove_text\":return value.removeText(op.path,op.offset,op.text);case \"set_annotation\":return value.setAnnotation(op.properties,\nop.newProperties);case \"set_mark\":return value.setMark(op.path,op.properties,op.newProperties);case \"set_node\":return value.setNode(op.path,op.newProperties);case \"set_selection\":return value.setSelection(op.newProperties);case \"set_value\":return value.setProperties(op.newProperties);case \"split_node\":return value.splitNode(op.path,op.position,op.properties);default:throw Error('Unknown operation type: \"'+type+'\".');}}function invertOperation(op){op=Operation.create(op);var type=op.type;debug$1(type,\nop);switch(type){case \"move_node\":var _op2=op;type=_op2.path;if(PathUtils.isEqual(_op2.newPath,type))return op;_op2=PathUtils.transform(type,op).first();type=PathUtils.transform(PathUtils.increment(type),op).first();return op.set(\"path\",_op2).set(\"newPath\",type);case \"merge_node\":return type=PathUtils.decrement(op.path),op.set(\"type\",\"split_node\").set(\"path\",type);case \"split_node\":return type=PathUtils.increment(op.path),op.set(\"type\",\"merge_node\").set(\"path\",type);case \"set_annotation\":case \"set_node\":case \"set_value\":case \"set_selection\":case \"set_mark\":return type=\nop,_op2=type.properties,op.set(\"properties\",type.newProperties).set(\"newProperties\",_op2);case \"insert_node\":case \"insert_text\":return op.set(\"type\",type.replace(\"insert_\",\"remove_\"));case \"remove_node\":case \"remove_text\":return op.set(\"type\",type.replace(\"remove_\",\"insert_\"));case \"add_annotation\":case \"add_mark\":return op.set(\"type\",type.replace(\"add_\",\"remove_\"));case \"remove_annotation\":case \"remove_mark\":return op.set(\"type\",type.replace(\"remove_\",\"add_\"));default:throw Error('Unknown operation type: \"'+\ntype+'\".');}}function CommandsPlugin(){var commands=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};return{onCommand:function(command,editor,next){var args=command.args;command=commands[command.type];if(!command)return next();editor.command.apply(editor,[command].concat(toConsumableArray(args)))},onConstruct:function(editor,next){for(var command in commands)editor.registerCommand(command);return next()}}}function isSurrogate(code){return 55296<=code&&57343>=code}function isModifier(code,\ntext,offset){return 55356===code?(code=text.charCodeAt(offset+1),57343>=code&&57339<=code):!1}function isWord(char,remaining){if(SPACE.test(char))return!1;if(CHAMELEON.test(char)){var next=remaining.charAt(0),length=getCharLength(next);next=remaining.slice(0,length);remaining=remaining.slice(length);if(isWord(next,remaining))return!0}return PUNCTUATION.test(char)?!1:!0}function getCharLength(char){return isSurrogate(char.charCodeAt(0))?2:1}function getCharOffset(text,chars,forward){var offset=0;if(\"\"===\ntext)return 1;for(var i=0;i<chars;i++)for(var prev=null,charCode=text.charCodeAt(offset);charCode;)if(isSurrogate(charCode)){charCode=isModifier(charCode,text,offset);if(forward){if(!charCode&&prev&&\"ZWJ\"!==prev||charCode&&prev&&\"SURR\"!==prev)break}else if(\"SURR\"===prev||\"BMP\"===prev)break;offset+=2;prev=charCode?\"MOD\":\"SURR\";charCode=text.charCodeAt(offset)}else if(8205===charCode)offset+=1,prev=\"ZWJ\",charCode=text.charCodeAt(offset);else{var JSCompiler_inline_result=10084===charCode||9794===charCode||\n9792===charCode||9760===charCode||9877===charCode||9992===charCode||9711===charCode;if(JSCompiler_inline_result){if(forward&&\"VAR\"===prev||prev&&\"ZWJ\"!==prev&&\"VAR\"!==prev)break;offset+=1;prev=\"BMP\";charCode=text.charCodeAt(offset)}else if(65039>=charCode&&65024<=charCode){if(!forward&&prev&&\"ZWJ\"!==prev)break;offset+=1;prev=\"VAR\";charCode=text.charCodeAt(offset)}else{if(forward){if(charCode=text.charCodeAt(offset+1),isModifier(charCode,text,offset+1)){offset+=3;prev=\"MOD\";charCode=text.charCodeAt(offset);\ncontinue}}else if(\"MOD\"===prev){offset+=1;break}null===prev&&(offset+=1);break}}return offset}function getWordOffset(text){for(var length=0,i=0,started=!1,char;char=text.charAt(i);){var l=getCharLength(char);char=text.slice(i,i+l);var rest=text.slice(i+l);if(isWord(char,rest))started=!0,length+=l;else if(started)break;else length+=l;i+=l}return length}function deleteExpandedAtRange(editor,range){range.isExpanded&&editor.deleteAtRange(range);editor=editor.value.document;var _range=range,end=_range.end;\nreturn range=editor.hasDescendant(_range.start.path)?range.moveToStart():range.moveTo(end.path,0).normalize(editor)}function shouldMerge(o,p){return p?\"set_selection\"===o.type&&\"set_selection\"===p.type||\"insert_text\"===o.type&&\"insert_text\"===p.type&&o.offset===p.offset+p.text.length&&o.path.equals(p.path)||\"remove_text\"===o.type&&\"remove_text\"===p.type&&o.offset+o.text.length===p.offset&&o.path.equals(p.path):!1}function isValidOperation(o){if(\"set_selection\"===o.type){o=o.newProperties;var anchor=\no.anchor,focus=o.focus;if(void 0!==o.isFocused&&!anchor&&!focus)return!1}return!0}function proxy(editor,method){for(var _editor$value$selecti,_len39=arguments.length,args=Array(2<_len39?_len39-2:0),_key39=2;_key39<_len39;_key39++)args[_key39-2]=arguments[_key39];_len39=(_editor$value$selecti=editor.value.selection)[method].apply(_editor$value$selecti,args);editor.select(_len39)}function pointEdgeObject(editor,point,edge,object){var Point=point.slice(0,1).toUpperCase()+point.slice(1),Edge=edge.slice(0,\n1).toUpperCase()+edge.slice(1);edge=object.slice(0,1).toUpperCase()+object.slice(1);Point=\"move\"+Point+\"To\"+Edge+\"OfNode\";Edge=editor.value;if(point=Edge.document[\"text\"===object?\"getNode\":\"getClosest\"+edge](Edge.selection[point].key))editor[Point](point)}function pointEdgeSideObject(editor,point,edge,side,object){var Point=point.slice(0,1).toUpperCase()+point.slice(1);edge=edge.slice(0,1).toUpperCase()+edge.slice(1);var Side=side.slice(0,1).toUpperCase()+side.slice(1);side=object.slice(0,1).toUpperCase()+\nobject.slice(1);Point=\"move\"+Point+\"To\"+edge+\"OfNode\";edge=\"get\"+Side+side;var value=editor.value;Side=value.document;if(point=Side[\"text\"===object?\"getNode\":\"getClosest\"+side](value.selection[point].key))if(point=Side[edge](point.key))editor[Point](point)}function pointBackward(editor,point){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:1;if(0!==n){if(0>n)return pointForward(editor,point,-n);var Point=point.slice(0,1).toUpperCase()+point.slice(1),value=editor.value,document=value.document,\nselection=value.selection,p=selection[point];value=document.hasVoidParent(p.path,editor);if(!value&&0<=p.offset-n)n=selection[\"move\"+Point+\"Backward\"](n),editor.select(n);else if(selection=document.getPreviousText(p.path))p=document.getClosestBlock(p.path).hasNode(selection.key),document=selection&&document.hasVoidParent(selection.key,editor),editor[\"move\"+Point+\"ToEndOfNode\"](selection),value||document||!p||(n=editor.value.selection[\"move\"+Point+\"Backward\"](n),editor.select(n))}}function pointForward(editor,\npoint){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:1;if(0!==n){if(0>n)return pointBackward(editor,point,-n);var Point=point.slice(0,1).toUpperCase()+point.slice(1),value=editor.value,document=value.document,selection=value.selection,p=selection[point],text=document.getNode(p.path);value=document.hasVoidParent(p.path,editor);if(!value&&p.offset+n<=text.text.length)n=selection[\"move\"+Point+\"Forward\"](n),editor.select(n);else if(selection=document.getNextText(p.path))p=document.getClosestBlock(p.path).hasNode(selection.key),\ndocument=document.hasVoidParent(selection.key,editor),editor[\"move\"+Point+\"ToStartOfNode\"](selection),value||document||!p||(n=editor.value.selection[\"move\"+Point+\"Forward\"](n),editor.select(n))}}function pointWordBackward(editor,pointName){var value=editor.value,point=value.selection[pointName];value=value.document.getClosestBlock(point.key);point=value.getOffset(point.key)+point.offset;point=TextUtils.getWordOffsetBackward(value.text,point);editor.command(pointBackward,pointName,0<point?point:1)}\nfunction pointWordForward(editor,pointName){var value=editor.value,point=value.selection[pointName];value=value.document.getClosestBlock(point.key);point=value.getOffset(point.key)+point.offset;point=TextUtils.getWordOffsetForward(value.text,point);editor.command(pointForward,pointName,0<point?point:1)}function QueriesPlugin(){var queries=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};return{onConstruct:function(editor,next){for(var query in queries)editor.registerQuery(query);return next()},\nonQuery:function(query,editor,next){var args=query.args;query=queries[query.type];if(!query)return next();editor=query.apply(void 0,[editor].concat(toConsumableArray(args)));return void 0===editor?next():editor}}}function SchemaPlugin(schema){function validateNode(node,editor,next){editor=schemaRules.filter(function(r){return!validateRules(node,r.match)});return(editor=validateRules(node,editor,schemaRules,{every:!0}))?new SlateError(editor.code,editor):next()}var rules=schema.rules,document=schema.document,\nblocks=schema.blocks,inlines=schema.inlines,marks=schema.marks,annotations=schema.annotations;schema=schema.decorations;var schemaRules=[];rules&&(schemaRules=schemaRules.concat(rules));document&&schemaRules.push(_extends({match:[{object:\"document\"}]},document));if(blocks)for(var key in blocks)schemaRules.push(_extends({match:[{object:\"block\",type:key}]},blocks[key]));if(inlines)for(var _key in inlines)schemaRules.push(_extends({match:[{object:\"inline\",type:_key}]},inlines[_key]));if(marks)for(var _key2 in marks)schemaRules.push(_extends({match:[{object:\"mark\",\ntype:_key2}]},marks[_key2]));if(annotations)for(var _key3 in annotations)schemaRules.push(_extends({match:[{object:\"annotation\",type:_key3}]},annotations[_key3]));if(schema)for(var _key4 in schema)schemaRules.push(_extends({match:[{object:\"decoration\",type:_key4}]},schema[_key4]));rules=QueriesPlugin({isAtomic:function(editor,format){return(editor=schemaRules.find(function(r){return\"isAtomic\"in r&&!validateRules(format,r.match)}))&&editor.isAtomic},isVoid:function(editor,node){return(editor=schemaRules.find(function(r){return\"isVoid\"in\nr&&!validateRules(node,r.match)}))&&editor.isVoid}});return[{normalizeNode:function(node,editor,next){var error=validateNode(node,editor,function(){});return error?function(){var rule=error.rule,size=editor.operations.size;rule.normalize&&rule.normalize(editor,error);editor.operations.size===size&&defaultNormalize(editor,error)}:next()},validateNode:validateNode},rules]}function defaultNormalize(editor,error){var node=error.node,child=error.child,next=error.next,previous=error.previous,key=error.key,\nmark=error.mark;switch(error.code){case \"child_max_invalid\":case \"child_object_invalid\":case \"child_type_invalid\":case \"child_unknown\":case \"first_child_object_invalid\":case \"first_child_type_invalid\":case \"last_child_object_invalid\":case \"last_child_type_invalid\":return\"text\"===child.object&&\"block\"===node.object&&1===node.nodes.size?editor.removeNodeByKey(node.key):editor.removeNodeByKey(child.key);case \"previous_sibling_object_invalid\":case \"previous_sibling_type_invalid\":return\"text\"===previous.object&&\n\"block\"===node.object&&1===node.nodes.size?editor.removeNodeByKey(node.key):editor.removeNodeByKey(previous.key);case \"next_sibling_object_invalid\":case \"next_sibling_type_invalid\":return\"text\"===next.object&&\"block\"===node.object&&1===node.nodes.size?editor.removeNodeByKey(node.key):editor.removeNodeByKey(next.key);case \"child_min_invalid\":case \"node_text_invalid\":case \"parent_object_invalid\":case \"parent_type_invalid\":return\"document\"===node.object?node.nodes.forEach(function(n){return editor.removeNodeByKey(n.key)}):\neditor.removeNodeByKey(node.key);case \"node_data_invalid\":return void 0===node.data.get(key)&&\"document\"!==node.object?editor.removeNodeByKey(node.key):editor.setNodeByKey(node.key,{data:node.data.delete(key)});case \"node_mark_invalid\":return node.getTexts().forEach(function(t){return editor.removeMarkByKey(t.key,0,t.text.length,mark)});default:return editor.removeNodeByKey(node.key)}}function validateRules(object,rule,rules){var options=3<arguments.length&&void 0!==arguments[3]?arguments[3]:{},_options$every=\noptions.every;_options$every=void 0===_options$every?!1:_options$every;options=options.match;options=void 0===options?null:options;if(\"function\"===typeof rule)return rule(object,options)?null:fail(\"node_invalid\",{rule:rule,node:object});if(Array.isArray(rule)){var array=rule.length?rule:[{}];options=void 0;var _iteratorNormalCompletion=!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _iterator=array[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=\n!0){var _error=validateRules(object,_step.value,rules);options=options||_error;if(_options$every&&_error)return _error;if(!_options$every&&!_error)return}}catch(err$5){_didIteratorError=!0,_iteratorError=err$5}finally{try{!_iteratorNormalCompletion&&_iterator.return&&_iterator.return()}finally{if(_didIteratorError)throw _iteratorError;}}return options}_iterator=null==rule.object||rule.object===object.object||\"function\"===typeof rule.object&&rule.object(object.object)?void 0:fail(\"node_object_invalid\",\n{rule:rule,node:object});_iterator||(_iterator=null==rule.type||rule.type===object.type||\"function\"===typeof rule.type&&rule.type(object.type)?void 0:fail(\"node_type_invalid\",{rule:rule,node:object}));if(!_iterator)a:{if(null!=rule.data&&null!=object.data){if(\"function\"===typeof rule.data){_iterator=rule.data(object.data)?void 0:fail(\"node_data_invalid\",{rule:rule,node:object});break a}for(array in rule.data)if(_iterator=rule.data[array],_step=object.data&&object.data.get(array),\"function\"===typeof _iterator?\n!_iterator(_step):_iterator!==_step){_iterator=fail(\"node_data_invalid\",{rule:rule,node:object,key:array,value:_step});break a}}_iterator=void 0}(_iterator=_iterator||validateMarks(object,rule))||(null==rule.text?_iterator=void 0:(_iterator=object.text,_iterator=(\"function\"===typeof rule.text?rule.text(_iterator):rule.text.test(_iterator))?void 0:fail(\"node_text_invalid\",{rule:rule,node:object,text:_iterator})));if(!_iterator)a:{if(null!=rule.first&&(_iterator=object.nodes.first())&&(_step=validateRules(_iterator,\nrule.first))){_step.rule=rule;_step.node=object;_step.child=_iterator;_step.code=_step.code.replace(\"node_\",\"first_child_\");_iterator=_step;break a}_iterator=void 0}if(!_iterator)a:{if(null!=rule.last&&(_iterator=object.nodes.last())&&(_step=validateRules(_iterator,rule.last))){_step.rule=rule;_step.node=object;_step.child=_iterator;_step.code=_step.code.replace(\"node_\",\"last_child_\");_iterator=_step;break a}_iterator=void 0}return _iterator||validateNodes(object,rule,rules)}function validateMarks(node,\nrule){if(null!=rule.marks){var marks=\"text\"===node.object?node.marks.toArray():node.getMarks().toArray(),_loop=function(mark){return rule.marks.some(function(def){return\"function\"===typeof def.type?def.type(mark.type):def.type===mark.type})?\"continue\":{v:fail(\"node_mark_invalid\",{rule:rule,node:node,mark:mark})}},_iteratorNormalCompletion2=!0,_didIteratorError2=!1,_iteratorError2=void 0;try{for(var _iterator2=marks[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=\n!0){var _ret=_loop(_step2.value);switch(_ret){case \"continue\":continue;default:if(\"object\"===(\"undefined\"===typeof _ret?\"undefined\":_typeof(_ret)))return _ret.v}}}catch(err$6){_didIteratorError2=!0,_iteratorError2=err$6}finally{try{!_iteratorNormalCompletion2&&_iterator2.return&&_iterator2.return()}finally{if(_didIteratorError2)throw _iteratorError2;}}}}function validateNodes(node,rule){function nextDef(){if(0===defs.length)return!1;def=defs.shift();lastCount=count;count=0;min=def.min||null;max=def.max||\nnull;return!0}function nextChild(){previous=(index+=1)?children.get(index-1):null;child=children.get(index);next=children.get(index+1);if(!child)return!1;lastCount=count;count+=1;return!0}var rules=2<arguments.length&&void 0!==arguments[2]?arguments[2]:[];if(null!=node.nodes){var children=node.nodes,defs=null!=rule.nodes?rule.nodes.slice():[],count=0,lastCount=0,min=null,index=-1,def=null,max=null,child=null,previous=null,next=null;for(null!=rule.nodes&&nextDef();nextChild();){var err=validateParent(node,\nchild,rules)||validatePrevious(node,child,previous,index,rules)||validateNext(node,child,next,index,rules);if(err)return err;if(null!=rule.nodes){if(!def)return fail(\"child_unknown\",{rule:rule,node:node,child:child,index:index});if(def.match&&(err=validateRules(child,def.match))){if(null!=max&&count-1>max)return 0<index&&(--index,count=lastCount),fail(\"child_max_invalid\",{rule:rule,node:node,index:index,child:children.get(index),count:count,limit:max});var lastMin=min;if(nextDef()){if(lastCount-1>=\nlastMin){--index;continue}if(null==validateRules(child,def.match))return 0<index&&(--index,count=lastCount),fail(\"child_min_invalid\",{rule:rule,node:node,index:index,count:lastCount-1,limit:lastMin});err.rule=rule;err.node=node;err.child=child;err.index=index;err.code=err.code.replace(\"node_\",\"child_\");return err}if(null!=max&&count>max)return fail(\"child_unknown\",{rule:rule,node:node,child:child,index:index});err.rule=rule;err.node=node;err.child=child;err.index=index;err.code=err.code.replace(\"node_\",\n\"child_\");return err}}}if(null!=max&&count>max)return fail(\"child_max_invalid\",{rule:rule,node:node,index:index-1,count:count,child:children.get(index-1),limit:max});if(null!=rule.nodes){do if(count<min)return fail(\"child_min_invalid\",{rule:rule,node:node,index:index,count:count,limit:min});while(nextDef())}}}function validateParent(node,child,rules){var _iteratorNormalCompletion3=!0,_didIteratorError3=!1,_iteratorError3=void 0;try{for(var _iterator3=rules[Symbol.iterator](),_step3;!(_iteratorNormalCompletion3=\n(_step3=_iterator3.next()).done);_iteratorNormalCompletion3=!0){var rule=_step3.value;if(null!=rule.parent&&!validateRules(child,rule.match)){var error=validateRules(node,rule.parent);if(error)return error.rule=rule,error.parent=node,error.node=child,error.code=error.code.replace(\"node_\",\"parent_\"),error}}}catch(err$7){_didIteratorError3=!0,_iteratorError3=err$7}finally{try{!_iteratorNormalCompletion3&&_iterator3.return&&_iterator3.return()}finally{if(_didIteratorError3)throw _iteratorError3;}}}function validatePrevious(node,\nchild,previous,index,rules){if(previous){var _iteratorNormalCompletion4=!0,_didIteratorError4=!1,_iteratorError4=void 0;try{for(var _iterator4=rules[Symbol.iterator](),_step4;!(_iteratorNormalCompletion4=(_step4=_iterator4.next()).done);_iteratorNormalCompletion4=!0){var rule=_step4.value;if(null!=rule.previous&&!validateRules(child,rule.match)){var error=validateRules(previous,rule.previous);if(error)return error.rule=rule,error.node=node,error.child=child,error.index=index,error.previous=previous,\nerror.code=error.code.replace(\"node_\",\"previous_sibling_\"),error}}}catch(err$8){_didIteratorError4=!0,_iteratorError4=err$8}finally{try{!_iteratorNormalCompletion4&&_iterator4.return&&_iterator4.return()}finally{if(_didIteratorError4)throw _iteratorError4;}}}}function validateNext(node,child,next,index,rules){if(next){var _iteratorNormalCompletion5=!0,_didIteratorError5=!1,_iteratorError5=void 0;try{for(var _iterator5=rules[Symbol.iterator](),_step5;!(_iteratorNormalCompletion5=(_step5=_iterator5.next()).done);_iteratorNormalCompletion5=\n!0){var rule=_step5.value;if(null!=rule.next&&!validateRules(child,rule.match)){var error=validateRules(next,rule.next,[],{match:child});if(error)return error.rule=rule,error.node=node,error.child=child,error.index=index,error.next=next,error.code=error.code.replace(\"node_\",\"next_sibling_\"),error}}}catch(err$9){_didIteratorError5=!0,_iteratorError5=err$9}finally{try{!_iteratorNormalCompletion5&&_iterator5.return&&_iterator5.return()}finally{if(_didIteratorError5)throw _iteratorError5;}}}}function fail(code,\nattrs){return _extends({code:code},attrs)}function deleteExpanded(editor){editor.value.selection.isExpanded&&editor.delete()}function CorePlugin(){var _options$plugins=(0<arguments.length&&void 0!==arguments[0]?arguments[0]:{}).plugins;_options$plugins=void 0===_options$plugins?[]:_options$plugins;var commands=CommandsPlugin(_extends({},Commands$1,Commands$2,Commands$3,Commands$4,Commands$5,Commands$6)),queries=QueriesPlugin({isAtomic:function(){return!1},isVoid:function(){return!1}});return[SchemaPlugin({rules:[{match:{object:\"document\"},\nnodes:[{match:{object:\"block\"}}]},{match:{object:\"block\",first:{object:\"block\"}},nodes:[{match:{object:\"block\"}}]},{match:{object:\"block\",first:[{object:\"inline\"},{object:\"text\"}]},nodes:[{match:[{object:\"inline\"},{object:\"text\"}]}]},{match:{object:\"inline\"},nodes:[{match:[{object:\"inline\"},{object:\"text\"}]}]},{match:[{object:\"block\"},{object:\"inline\"}],nodes:[{min:1}],normalize:function(editor,error){var node=error.node;\"child_min_invalid\"===error.code&&node.nodes.isEmpty()&&editor.insertNodeByKey(node.key,\n0,Text$jscomp$0.create())}},{match:{object:\"block\"},first:[{object:\"block\"},{object:\"text\"}],last:[{object:\"block\"},{object:\"text\"}],normalize:function(editor,error){var code=error.code;error=error.node;var text=Text$jscomp$0.create();if(\"first_child_object_invalid\"===code)code=0;else if(\"last_child_object_invalid\"===code)code=error.nodes.size;else return;editor.insertNodeByKey(error.key,code,text)}},{match:{object:\"inline\"},first:[{object:\"block\"},{object:\"text\"}],last:[{object:\"block\"},{object:\"text\"}],\nprevious:[{object:\"block\"},{object:\"text\"}],next:[{object:\"block\"},{object:\"text\"}],normalize:function(editor,error){var code=error.code,node=error.node,index=error.index;error=Text$jscomp$0.create();if(\"first_child_object_invalid\"===code)code=0;else if(\"last_child_object_invalid\"===code)code=node.nodes.size;else if(\"previous_sibling_object_invalid\"===code)code=index;else if(\"next_sibling_object_invalid\"===code)code=index+1;else return;editor.insertNodeByKey(node.key,code,error)}},{match:{object:\"text\"},\nnext:function(_next,match){return\"text\"!==_next.object||!match.marks.equals(_next.marks)},normalize:function(editor,error){var next=error.next;\"next_sibling_invalid\"===error.code&&editor.mergeNodeByKey(next.key)}},{match:{object:\"text\"},previous:function(prev){return\"text\"!==prev.object||\"\"!==prev.text},next:function(_next2){return\"text\"!==_next2.object||\"\"!==_next2.text},normalize:function(editor,error){var code=error.code,next=error.next;error=error.previous;\"next_sibling_invalid\"===code?editor.removeNodeByKey(next.key):\n\"previous_sibling_invalid\"===code&&editor.removeNodeByKey(error.key)}}]})].concat(toConsumableArray(_options$plugins),[commands,queries])}function getDirtyPaths(operation){var node=operation.node,path=operation.path,newPath=operation.newPath;switch(operation.type){case \"add_mark\":case \"insert_text\":case \"remove_mark\":case \"remove_text\":case \"set_mark\":case \"set_node\":return newPath=PathUtils.getAncestors(path).toArray(),[].concat(toConsumableArray(newPath),[path]);case \"insert_node\":return newPath=\nnode.getKeysToPathsTable(),newPath=Object.values(newPath).map(function(p){return path.concat(p)}),node=PathUtils.getAncestors(path).toArray(),[].concat(toConsumableArray(node),[path],toConsumableArray(newPath));case \"split_node\":return newPath=PathUtils.getAncestors(path).toArray(),node=PathUtils.increment(path),[].concat(toConsumableArray(newPath),[path,node]);case \"merge_node\":return newPath=PathUtils.getAncestors(path).toArray(),node=PathUtils.decrement(path),[].concat(toConsumableArray(newPath),\n[node]);case \"move_node\":if(PathUtils.isEqual(path,newPath))return[];node=PathUtils.getAncestors(path).reduce(function(arr,p){arr.push.apply(arr,toConsumableArray(PathUtils.transform(p,operation).toArray()));return arr},[]);newPath=PathUtils.getAncestors(newPath).reduce(function(arr,p){arr.push.apply(arr,toConsumableArray(PathUtils.transform(p,operation).toArray()));return arr},[]);return[].concat(toConsumableArray(node),toConsumableArray(newPath));case \"remove_node\":return newPath=PathUtils.getAncestors(path).toArray(),\n[].concat(toConsumableArray(newPath));default:return[]}}function normalizeDirtyPaths(editor$jscomp$0){editor$jscomp$0.tmp.normalize&&editor$jscomp$0.tmp.dirty.length&&editor$jscomp$0.withoutNormalizing(function(){for(;editor$jscomp$0.tmp.dirty.length;){var path=editor$jscomp$0.tmp.dirty.pop(),editor=editor$jscomp$0,controller=editor.controller,value=editor.value;value=value.document;for(var node=value.assertNode(path),iterations=0,max=100+(\"text\"===node.object?1:node.nodes.size);node;){value=node.normalize(controller);\nif(!value)break;value(controller);value=editor.value;value=value.document;var key=node.key;node=value.getDescendant(path);if(!node||node.key!==key)if(node=value.getDescendant(key))path=value.getPath(key);else break;iterations++;if(iterations>max)throw Error(\"A schema rule could not be normalized after sufficient iterations. This is usually due to a `rule.normalize` or `plugin.normalizeNode` function of a schema being incorrectly written, causing an infinite loop.\");}}})}function registerPlugin(editor,\nplugin){if(Array.isArray(plugin))plugin.forEach(function(p){return registerPlugin(editor,p)});else if(null!=plugin){var commands=plugin.commands,queries=plugin.queries,schema=plugin.schema;plugin=objectWithoutProperties(plugin,[\"commands\",\"queries\",\"schema\"]);commands&&(commands=CommandsPlugin(commands),registerPlugin(editor,commands));queries&&(queries=QueriesPlugin(queries),registerPlugin(editor,queries));schema&&(schema=SchemaPlugin(schema),registerPlugin(editor,schema));for(var key in plugin)schema=\nplugin[key],(editor.middleware[key]=editor.middleware[key]||[]).push(schema)}}function mixin(Interface,Classes){var _iteratorNormalCompletion=!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _iterator=Classes[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=!0){var Class=_step.value;Classes=!0;var _didIteratorError2=!1,_iteratorError2=void 0;try{for(var _iterator2=Object.getOwnPropertyNames(Interface)[Symbol.iterator](),_step2;!(Classes=\n(_step2=_iterator2.next()).done);Classes=!0){var name=_step2.value;if(!Class.hasOwnProperty(name)){var desc=Object.getOwnPropertyDescriptor(Interface,name);Object.defineProperty(Class,name,desc)}}}catch(err$10){_didIteratorError2=!0,_iteratorError2=err$10}finally{try{!Classes&&_iterator2.return&&_iterator2.return()}finally{if(_didIteratorError2)throw _iteratorError2;}}Classes=!0;_didIteratorError2=!1;_iteratorError2=void 0;try{for(var _iterator3=Object.getOwnPropertyNames(Interface.prototype)[Symbol.iterator](),\n_step3;!(Classes=(_step3=_iterator3.next()).done);Classes=!0){var _name=_step3.value;Class.prototype.hasOwnProperty(_name)||(desc=Object.getOwnPropertyDescriptor(Interface.prototype,_name),Object.defineProperty(Class.prototype,_name,desc))}}catch(err$11){_didIteratorError2=!0,_iteratorError2=err$11}finally{try{!Classes&&_iterator3.return&&_iterator3.return()}finally{if(_didIteratorError2)throw _iteratorError2;}}}}catch(err$12){_didIteratorError=!0,_iteratorError=err$12}finally{try{!_iteratorNormalCompletion&&\n_iterator.return&&_iterator.return()}finally{if(_didIteratorError)throw _iteratorError;}}}function create$2(type){var TYPE=TYPES[type],is=\"is\"+(\"\"+type.charAt(0).toUpperCase()+type.slice(1)),ObjectInterface=function(){function ObjectInterface(){classCallCheck(this,ObjectInterface)}createClass(ObjectInterface,[{key:\"object\",get:function(){return type}}]);return ObjectInterface}();ObjectInterface[is]=isObject.bind(null,type);ObjectInterface.prototype[TYPE]=!0;return ObjectInterface}function memoize(object,\nproperties){var _loop=function(property){var original=object[property];if(!original)throw Error('Object does not have a property named \"'+property+'\".');object[property]=function(){for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];if(!ENABLED)return original.apply(this,args);memoizeStore.has(this)||memoizeStore.set(this,{noArgs:{},hasArgs:{}});_len=memoizeStore.get(this);_key=_len.noArgs;var hasArgs=_len.hasArgs,takesArguments=0!==args.length,cachedValue=\nvoid 0;_len=void 0;if(takesArguments){_len=[property].concat(args);a:{var map=hasArgs,_iteratorNormalCompletion2=!0,_didIteratorError2=!1,_iteratorError2=void 0;try{for(var _iterator2=_len[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=!0){var key=_step2.value;void 0===key?key=UNDEFINED:null==key&&(key=NULL);map=\"object\"===(\"undefined\"===typeof key?\"undefined\":_typeof(key))?map[STORE_KEY]&&map[STORE_KEY].get(key):map[key];if(void 0===\nmap){cachedValue=void 0;break a}}}catch(err$14){_didIteratorError2=!0,_iteratorError2=err$14}finally{try{!_iteratorNormalCompletion2&&_iterator2.return&&_iterator2.return()}finally{if(_didIteratorError2)throw _iteratorError2;}}cachedValue=map[LEAF]}}else cachedValue=_key[property];if(void 0!==cachedValue)return cachedValue===UNDEFINED?void 0:cachedValue;args=original.apply(this,args);_iterator2=void 0===args?UNDEFINED:args;if(takesArguments){_key=hasArgs;_step2=!0;key=!1;hasArgs=void 0;try{for(var _iterator3=\n_len[Symbol.iterator](),_step3;!(_step2=(_step3=_iterator3.next()).done);_step2=!0){var key$jscomp$0=_step3.value;void 0===key$jscomp$0?key$jscomp$0=UNDEFINED:null==key$jscomp$0&&(key$jscomp$0=NULL);\"object\"!==(\"undefined\"===typeof key$jscomp$0?\"undefined\":_typeof(key$jscomp$0))?(_key[key$jscomp$0]||(_key[key$jscomp$0]={}),_key=_key[key$jscomp$0]):(_key[STORE_KEY]||(_key[STORE_KEY]=new WeakMap),_key[STORE_KEY].has(key$jscomp$0)?_key=_key[STORE_KEY].get(key$jscomp$0):(_len={},_key[STORE_KEY].set(key$jscomp$0,\n_len),_key=_len))}}catch(err$15){key=!0,hasArgs=err$15}finally{try{!_step2&&_iterator3.return&&_iterator3.return()}finally{if(key)throw hasArgs;}}_key[LEAF]=_iterator2}else _key[property]=_iterator2;return args}},_iteratorNormalCompletion=!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _iterator=properties[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=!0)_loop(_step.value)}catch(err$13){_didIteratorError=!0,_iteratorError=err$13}finally{try{!_iteratorNormalCompletion&&\n_iterator.return&&_iterator.return()}finally{if(_didIteratorError)throw _iteratorError;}}}function resetMemoization(){memoizeStore=new WeakMap}function useMemoization(enabled){ENABLED=enabled}function identity(){return!0}Object.defineProperty(exports,\"__esModule\",{value:!0});var immutable=require(\"module$node_modules$immutable$dist$immutable\"),isPlainObject=_interopDefault(require(\"module$node_modules$is_plain_object$index\")),warning=_interopDefault(require(\"module$node_modules$tiny_warning$dist$tiny_warning_cjs\")),\ninvariant=_interopDefault(require(\"module$node_modules$tiny_invariant$dist$tiny_invariant_cjs\")),Debug=_interopDefault(require(\"module$node_modules$debug$src$browser\")),esrever=require(\"module$node_modules$esrever$esrever\"),pick=_interopDefault(require(\"module$node_modules$lodash$pick\")),omit=_interopDefault(require(\"module$node_modules$lodash$omit\")),getDirection=_interopDefault(require(\"module$node_modules$direction$index\")),n$jscomp$0=void 0,generate=void 0;resetGenerator();var KeyUtils={create:function(key){if(null==\nkey)return generate();if(\"string\"===typeof key)return key;throw Error(\"Keys must be strings, but you passed: \"+key);},setGenerator:function(func){generate=func},resetGenerator:resetGenerator},_typeof=\"function\"===typeof Symbol&&\"symbol\"===typeof Symbol.iterator?function(obj){return typeof obj}:function(obj){return obj&&\"function\"===typeof Symbol&&obj.constructor===Symbol&&obj!==Symbol.prototype?\"symbol\":typeof obj},classCallCheck=function(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError(\"Cannot call a class as a function\");\n},createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){protoProps&&defineProperties(Constructor.prototype,protoProps);staticProps&&defineProperties(Constructor,staticProps);return Constructor}}(),defineProperty=\nfunction(obj,key,value){key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value;return obj},_extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i],key;for(key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},inherits=function(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function, not \"+\ntypeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}});superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass)},objectWithoutProperties=function(obj,keys){var target={},i;for(i in obj)0<=keys.indexOf(i)||Object.prototype.hasOwnProperty.call(obj,i)&&(target[i]=obj[i]);return target},possibleConstructorReturn=function(self,call){if(!self)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\nreturn!call||\"object\"!==typeof call&&\"function\"!==typeof call?self:call},slicedToArray=function(){return function(arr,i){if(Array.isArray(arr))return arr;if(Symbol.iterator in Object(arr)){var _arr=[],_n=!0,_d=!1,_e=void 0;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done)&&(_arr.push(_s.value),!i||_arr.length!==i);_n=!0);}catch(err){_d=!0,_e=err}finally{try{if(!_n&&_i[\"return\"])_i[\"return\"]()}finally{if(_d)throw _e;}}return _arr}throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n}}(),toConsumableArray=function(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++)arr2[i]=arr[i];return arr2}return Array.from(arr)},PathUtils={compare:compare,create:create$1,crop:crop,decrement:decrement,getAncestors:function(path){return immutable.List().withMutations(function(list){for(var i=0;i<path.size;i++)list.push(path.slice(0,i))})},increment:increment,isAbove:isAbove,isAfter:function(path,target){path=crop(path,target);path=slicedToArray(path,2);return 1===\ncompare(path[0],path[1])},isBefore:function(path,target){path=crop(path,target);path=slicedToArray(path,2);return-1===compare(path[0],path[1])},isEqual:function(path,target){return path.equals(target)},isOlder:function(path,target){var index=path.size-1,_crop7=crop(path,target,index),_crop8=slicedToArray(_crop7,2);_crop7=_crop8[0];_crop8=_crop8[1];path=path.get(index);target=target.get(index);return _crop7.equals(_crop8)&&path>target},isPath:function(any){return(immutable.List.isList(any)||Array.isArray(any))&&\nany.every(function(n){return\"number\"===typeof n})},isSibling:function(path,target){if(path.size!==target.size)return!1;path=path.butLast();target=target.butLast();return path.equals(target)},isYounger:isYounger,lift:function(path){return path.slice(0,-1*(1<arguments.length&&void 0!==arguments[1]?arguments[1]:1))},drop:function(path){return path.slice(1<arguments.length&&void 0!==arguments[1]?arguments[1]:1)},max:function(a,b){return Math.max(a.size,b.size)},min:min$jscomp$0,relate:function(a,b){for(var array=\n[],i=0;i<a.size&&i<b.size;i++){var av=a.get(i),bv=b.get(i);if(av!==bv)break;array.push(av)}return create$1(array)},transform:function(path,operation){var type=operation.type,position=operation.position,p=operation.path;if(\"add_mark\"===type||\"insert_text\"===type||\"remove_mark\"===type||\"remove_text\"===type||\"set_mark\"===type||\"set_node\"===type||\"set_selection\"===type||\"set_value\"===type||\"add_annotation\"===type||\"remove_annotation\"===type||\"set_annotation\"===type||0===path.size)return immutable.List([path]);\nvar pIndex=p.size-1,pEqual=p.equals(path),pYounger=isYounger(p,path),pAbove=isAbove(p,path);\"insert_node\"===type&&(pEqual||pYounger||pAbove)&&(path=increment(path,1,pIndex));if(\"remove_node\"===type)if(pYounger)path=decrement(path,1,pIndex);else if(pEqual||pAbove)path=[];\"merge_node\"===type&&(pEqual||pYounger?path=decrement(path,1,pIndex):pAbove&&(path=decrement(path,1,pIndex),path=increment(path,position,pIndex+1)));\"split_node\"===type&&(pEqual?path=[path,increment(path)]:pYounger?path=increment(path,\n1,pIndex):pAbove&&path.get(pIndex+1)>=position&&(path=increment(path,1,pIndex),path=decrement(path,position,pIndex+1)));if(\"move_node\"===type){operation=operation.newPath;if(p.equals(operation))return immutable.List([path]);if(pAbove||pEqual)path=isYounger(p,operation)&&p.size<operation.size?decrement(operation,1,min$jscomp$0(operation,p)-1).concat(path.slice(p.size)):operation.concat(path.slice(p.size));else if(pYounger&&(path=decrement(path,1,pIndex)),isYounger(operation,path)||operation.equals(path)||\nisAbove(operation,path))path=increment(path,1,operation.size-1)}path=Array.isArray(path)?path:[path];return immutable.List(path)}},Point=function(_Record){function Point(){classCallCheck(this,Point);return possibleConstructorReturn(this,(Point.__proto__||Object.getPrototypeOf(Point)).apply(this,arguments))}inherits(Point,_Record);createClass(Point,[{key:\"isAfterPoint\",value:function(point){return this.isUnset?!1:this.key===point.key&&this.offset>point.offset||1===PathUtils.compare(this.path,point.path)}},\n{key:\"isAfterRange\",value:function(range){return this.isUnset?!1:this.isAfterPoint(range.end)}},{key:\"isAtEndOfRange\",value:function(range){return this.isUnset?!1:this.equals(range.end)}},{key:\"isAtStartOfRange\",value:function(range){return this.isUnset?!1:this.equals(range.start)}},{key:\"isBeforePoint\",value:function(point){return this.isUnset?!1:this.key===point.key&&this.offset<point.offset||-1===PathUtils.compare(this.path,point.path)}},{key:\"isBeforeRange\",value:function(range){return this.isUnset?\n!1:this.isBeforePoint(range.start)}},{key:\"isInRange\",value:function(range){return this.isUnset?!1:this.equals(range.start)||this.equals(range.end)||this.isAfterPoint(range.start)&&this.isBeforePoint(range.end)}},{key:\"isAtEndOfNode\",value:function(node){if(this.isUnset)return!1;node=node.getLastText();return this.key===node.key&&this.offset===node.text.length}},{key:\"isAtStartOfNode\",value:function(node){if(this.isUnset||0!==this.offset)return!1;node=node.getFirstText();return this.key===node.key}},\n{key:\"isInNode\",value:function(node){return this.isUnset?!1:\"text\"===node.object&&node.key===this.key||node.hasNode(this.key)?!0:!1}},{key:\"moveBackward\",value:function(){var n=0<arguments.length&&void 0!==arguments[0]?arguments[0]:1;return 0===n?this:0>n?this.moveForward(-n):this.setOffset(this.offset-n)}},{key:\"moveForward\",value:function(){var n=0<arguments.length&&void 0!==arguments[0]?arguments[0]:1;return 0===n?this:0>n?this.moveBackward(-n):this.setOffset(this.offset+n)}},{key:\"moveTo\",value:function(path){var offset=\n1<arguments.length&&void 0!==arguments[1]?arguments[1]:0,key=this.key;\"number\"===typeof path?(offset=path,path=this.path):\"string\"===typeof path?(key=path,path=key===this.key?this.path:null):key=path.equals(this.path)?this.key:null;return this.merge({key:key,path:path,offset:offset})}},{key:\"moveToStartOfNode\",value:function(node){node=node.getFirstText();return this.moveTo(node.key,0)}},{key:\"moveToEndOfNode\",value:function(node){node=node.getLastText();return this.moveTo(node.key,node.text.length)}},\n{key:\"normalize\",value:function(node){if(null==this.key&&null==this.path)return this.setOffset(null);var key=this.key,offset=this.offset,path=this.path,target=path&&node.getNode(path);if(!target&&(target=node.getNode(key)))return this.merge({path:node.getPath(key)});if(!target)return warning(!1,\"A point's `path` or `key` invalid and was reset!\"),(offset=node.getFirstText())?this.merge({key:offset.key,offset:0,path:node.getPath(offset.key)}):Point.create();if(\"text\"!==target.object)return warning(!1,\n\"A point should not reference a non-text node!\"),key=target.getTextAtOffset(offset),target=target.getOffset(key.key),this.merge({offset:offset-target,key:key.key,path:node.getPath(key.key)});target&&path&&key&&key!==target.key&&warning(!1,\"A point's `key` did not match its `path`!\");offset=this.merge({key:target.key,path:null==path?node.getPath(target.key):path,offset:null==offset?0:Math.min(offset,target.text.length)});offset.offset===target.text.length&&(target=node.getClosestBlock(offset.path).getNextText())&&\n(offset=offset.merge({key:target.key,path:node.getPath(target.key),offset:0}));return offset}},{key:\"setKey\",value:function(key){null!=key&&(key=KeyUtils.create(key));return this.set(\"key\",key)}},{key:\"setOffset\",value:function(offset){return this.set(\"offset\",offset)}},{key:\"setPath\",value:function(path){null!=path&&(path=PathUtils.create(path));return this.set(\"path\",path)}},{key:\"toJSON\",value:function(){var options=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},object={object:this.object,\nkey:this.key,offset:this.offset,path:this.path&&this.path.toArray()};options.preserveKeys||delete object.key;return object}},{key:\"unset\",value:function(){return this.merge({key:null,offset:null,path:null})}},{key:\"isSet\",get:function(){return null!=this.key&&null!=this.offset&&null!=this.path}},{key:\"isUnset\",get:function(){return!this.isSet}}],[{key:\"create\",value:function(){var attrs=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};if(Point.isPoint(attrs))return attrs;if(isPlainObject(attrs))return Point.fromJSON(attrs);\nthrow Error(\"`Point.create` only accepts objects or points, but you passed it: \"+attrs);}},{key:\"createProperties\",value:function(){var a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};if(Point.isPoint(a))return{key:a.key,offset:a.offset,path:a.path};if(isPlainObject(a)){var p={};\"key\"in a&&(p.key=a.key);\"offset\"in a&&(p.offset=a.offset);\"path\"in a&&(p.path=PathUtils.create(a.path));\"path\"in a&&!(\"key\"in a)&&(p.key=null);\"key\"in a&&!(\"path\"in a)&&(p.path=null);return p}throw Error(\"`Point.createProperties` only accepts objects or points, but you passed it: \"+\na);}},{key:\"fromJSON\",value:function(object){var _object$key=object.key,_object$offset=object.offset;object=object.path;return new Point({key:void 0===_object$key?null:_object$key,offset:void 0===_object$offset?null:_object$offset,path:PathUtils.create(void 0===object?null:object)})}}]);return Point}(immutable.Record({key:void 0,offset:void 0,path:void 0})),Data=function(){function Data(){classCallCheck(this,Data)}createClass(Data,null,[{key:\"create\",value:function(){var attrs=0<arguments.length&&\nvoid 0!==arguments[0]?arguments[0]:{};if(immutable.Map.isMap(attrs))return attrs;if(isPlainObject(attrs))return Data.fromJSON(attrs);throw Error(\"`Data.create` only accepts objects or maps, but you passed it: \"+attrs);}},{key:\"fromJSON\",value:function(object){return new immutable.Map(object)}}]);return Data}();Data.fromJS=Data.fromJSON;var Mark=function(_Record){function Mark(){classCallCheck(this,Mark);return possibleConstructorReturn(this,(Mark.__proto__||Object.getPrototypeOf(Mark)).apply(this,\narguments))}inherits(Mark,_Record);createClass(Mark,[{key:\"toJSON\",value:function(){return{object:this.object,type:this.type,data:this.data.toJSON()}}}],[{key:\"create\",value:function(){var attrs=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};if(Mark.isMark(attrs))return attrs;\"string\"===typeof attrs&&(attrs={type:attrs});if(isPlainObject(attrs))return Mark.fromJSON(attrs);throw Error(\"`Mark.create` only accepts objects, strings or marks, but you passed it: \"+attrs);}},{key:\"createSet\",\nvalue:function(elements){if(immutable.Set.isSet(elements)||Array.isArray(elements))return new immutable.Set(elements.map(Mark.create));if(null==elements)return immutable.Set();throw Error(\"`Mark.createSet` only accepts sets, arrays or null, but you passed it: \"+elements);}},{key:\"createProperties\",value:function(){var attrs=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};if(Mark.isMark(attrs))return{data:attrs.data,type:attrs.type};if(\"string\"===typeof attrs)return{type:attrs};if(isPlainObject(attrs)){var props=\n{};\"type\"in attrs&&(props.type=attrs.type);\"data\"in attrs&&(props.data=Data.create(attrs.data));return props}throw Error(\"`Mark.createProperties` only accepts objects, strings or marks, but you passed it: \"+attrs);}},{key:\"fromJSON\",value:function(object){var _object$data=object.data;_object$data=void 0===_object$data?{}:_object$data;object=object.type;if(\"string\"!==typeof object)throw Error(\"`Mark.fromJS` requires a `type` string.\");return new Mark({type:object,data:new immutable.Map(_object$data)})}},\n{key:\"isMarkSet\",value:function(any){return immutable.Set.isSet(any)&&any.every(function(item){return Mark.isMark(item)})}}]);return Mark}(immutable.Record({data:void 0,type:void 0})),Decoration=function(_Record){function Decoration(){classCallCheck(this,Decoration);return possibleConstructorReturn(this,(Decoration.__proto__||Object.getPrototypeOf(Decoration)).apply(this,arguments))}inherits(Decoration,_Record);createClass(Decoration,[{key:\"setProperties\",value:function(properties){properties=Decoration.createProperties(properties);\nreturn this.merge(properties)}},{key:\"toJSON\",value:function(){var options=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};return{object:this.object,type:this.type,data:this.data.toJSON(),anchor:this.anchor.toJSON(options),focus:this.focus.toJSON(options)}}}],[{key:\"create\",value:function(){var attrs=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};if(Decoration.isDecoration(attrs))return attrs;if(Range$jscomp$0.isRange(attrs))return Decoration.fromJSON(Range$jscomp$0.createProperties(attrs));\nif(isPlainObject(attrs))return Decoration.fromJSON(attrs);throw Error(\"`Decoration.create` only accepts objects or decorations, but you passed it: \"+attrs);}},{key:\"createList\",value:function(){var elements=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[];if(immutable.List.isList(elements)||Array.isArray(elements))return new immutable.List(elements.map(Decoration.create));throw Error(\"`Decoration.createList` only accepts arrays or lists, but you passed it: \"+elements);}},{key:\"createProperties\",\nvalue:function(){var a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};if(Decoration.isDecoration(a))return{type:a.type,data:a.data,anchor:Point.createProperties(a.anchor),focus:Point.createProperties(a.focus),mark:Mark.create(a.mark)};if(isPlainObject(a)){var p={};\"type\"in a&&(p.type=a.type);\"data\"in a&&(p.data=Data.create(a.data));\"anchor\"in a&&(p.anchor=Point.create(a.anchor));\"focus\"in a&&(p.focus=Point.create(a.focus));return p}throw Error(\"`Decoration.createProperties` only accepts objects or decorations, but you passed it: \"+\na);}},{key:\"fromJSON\",value:function(object){var anchor=object.anchor,focus=object.focus,type=object.type,data=object.data;object.mark&&!type&&(warning(!1,\"As of slate@0.47 the `decoration.mark` property has been changed to `decoration.type` and `decoration.data` directly.\"),type=object.mark.type,data=object.mark.data);if(!type)throw Error(\"Decorations must be created with a `type`, but you passed: \"+JSON.stringify(object));return new Decoration({type:type,data:Data.create(data||{}),anchor:Point.fromJSON(anchor||\n{}),focus:Point.fromJSON(focus||{})})}}]);return Decoration}(immutable.Record({type:void 0,data:void 0,anchor:void 0,focus:void 0})),Selection$jscomp$0=function(_Record){function Selection(){classCallCheck(this,Selection);return possibleConstructorReturn(this,(Selection.__proto__||Object.getPrototypeOf(Selection)).apply(this,arguments))}inherits(Selection,_Record);createClass(Selection,[{key:\"setIsFocused\",value:function(value){return this.set(\"isFocused\",value)}},{key:\"setMarks\",value:function(marks){return this.set(\"marks\",\nmarks)}},{key:\"setProperties\",value:function(properties){var _properties=properties=Selection.createProperties(properties);properties=_properties.anchor;var focus=_properties.focus;_properties=objectWithoutProperties(_properties,[\"anchor\",\"focus\"]);properties&&(_properties.anchor=Point.create(properties));focus&&(_properties.focus=Point.create(focus));return this.merge(_properties)}},{key:\"toJSON\",value:function(){var options=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};return{object:this.object,\nanchor:this.anchor.toJSON(options),focus:this.focus.toJSON(options),isFocused:this.isFocused,marks:null==this.marks?null:this.marks.toArray().map(function(m){return m.toJSON()})}}},{key:\"isBlurred\",get:function(){return!this.isFocused}}],[{key:\"create\",value:function(){var attrs=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};if(Selection.isSelection(attrs))return attrs;if(Range$jscomp$0.isRange(attrs))return Selection.fromJSON(Range$jscomp$0.createProperties(attrs));if(isPlainObject(attrs))return Selection.fromJSON(attrs);\nthrow Error(\"`Selection.create` only accepts objects, ranges or selections, but you passed it: \"+attrs);}},{key:\"createProperties\",value:function(){var a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};if(Selection.isSelection(a))return{anchor:Point.createProperties(a.anchor),focus:Point.createProperties(a.focus),isFocused:a.isFocused,marks:a.marks};if(Range$jscomp$0.isRange(a))return{anchor:Point.createProperties(a.anchor),focus:Point.createProperties(a.focus)};if(isPlainObject(a)){var p=\n{};\"anchor\"in a&&(p.anchor=Point.create(a.anchor));\"focus\"in a&&(p.focus=Point.create(a.focus));\"isFocused\"in a&&(p.isFocused=a.isFocused);\"marks\"in a&&(p.marks=null==a.marks?null:Mark.createSet(a.marks));return p}throw Error(\"`Selection.createProperties` only accepts objects, ranges or selections, but you passed it: \"+a);}},{key:\"fromJSON\",value:function(object){var focus=object.focus,_object$isFocused=object.isFocused;_object$isFocused=void 0===_object$isFocused?!1:_object$isFocused;var _object$marks=\nobject.marks;_object$marks=void 0===_object$marks?null:_object$marks;return new Selection({anchor:Point.fromJSON(object.anchor||{}),focus:Point.fromJSON(focus||{}),isFocused:_object$isFocused,marks:null==_object$marks?null:new immutable.Set(_object$marks.map(Mark.fromJSON))})}}]);return Selection}(immutable.Record({anchor:void 0,focus:void 0,isFocused:void 0,marks:void 0})),TYPES={annotation:\"@@__SLATE_ANNOTATION__@@\",block:\"@@__SLATE_BLOCK__@@\",change:\"@@__SLATE_CHANGE__@@\",decoration:\"@@__SLATE_DECORATION__@@\",\ndocument:\"@@__SLATE_DOCUMENT__@@\",editor:\"@@__SLATE_EDITOR__@@\",inline:\"@@__SLATE_INLINE__@@\",leaf:\"@@__SLATE_LEAF__@@\",mark:\"@@__SLATE_MARK__@@\",operation:\"@@__SLATE_OPERATION__@@\",point:\"@@__SLATE_POINT__@@\",range:\"@@__SLATE_RANGE__@@\",selection:\"@@__SLATE_SELECTION__@@\",text:\"@@__SLATE_TEXT__@@\",value:\"@@__SLATE_VALUE__@@\"},Range$jscomp$0=function(_Record){function Range(){classCallCheck(this,Range);return possibleConstructorReturn(this,(Range.__proto__||Object.getPrototypeOf(Range)).apply(this,\narguments))}inherits(Range,_Record);createClass(Range,[{key:\"toJSON\",value:function(){var options=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};return{object:this.object,anchor:this.anchor.toJSON(options),focus:this.focus.toJSON(options)}}}],[{key:\"create\",value:function(){var attrs=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};if(Range.isRange(attrs))return\"range\"===attrs.object?attrs:Range.fromJSON(Range.createProperties(attrs));if(isPlainObject(attrs))return Range.fromJSON(attrs);\nthrow Error(\"`Range.create` only accepts objects or ranges, but you passed it: \"+attrs);}},{key:\"createList\",value:function(){var elements=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[];if(immutable.List.isList(elements)||Array.isArray(elements))return new immutable.List(elements.map(Range.create));throw Error(\"`Range.createList` only accepts arrays or lists, but you passed it: \"+elements);}},{key:\"createProperties\",value:function(){var a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:\n{};if(Range.isRange(a))return{anchor:Point.createProperties(a.anchor),focus:Point.createProperties(a.focus)};if(isPlainObject(a)){var p={};\"anchor\"in a&&(p.anchor=Point.create(a.anchor));\"focus\"in a&&(p.focus=Point.create(a.focus));return p}throw Error(\"`Range.createProperties` only accepts objects, annotations, decorations, ranges or selections, but you passed it: \"+a);}},{key:\"fromJSON\",value:function(object){var focus=object.focus;return new Range({anchor:Point.fromJSON(object.anchor||{}),focus:Point.fromJSON(focus||\n{})})}},{key:\"isRange\",value:function(value){return isObject(\"range\",value)||Decoration.isDecoration(value)||Selection$jscomp$0.isSelection(value)}}]);return Range}(immutable.Record({anchor:void 0,focus:void 0})),Annotation=function(_Record){function Annotation(){classCallCheck(this,Annotation);return possibleConstructorReturn(this,(Annotation.__proto__||Object.getPrototypeOf(Annotation)).apply(this,arguments))}inherits(Annotation,_Record);createClass(Annotation,[{key:\"setProperties\",value:function(properties){properties=\nAnnotation.createProperties(properties);return this.merge(properties)}},{key:\"toJSON\",value:function(){var options=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};return{object:this.object,key:this.key,type:this.type,data:this.data.toJSON(),anchor:this.anchor.toJSON(options),focus:this.focus.toJSON(options)}}}],[{key:\"create\",value:function(){var attrs=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};if(Annotation.isAnnotation(attrs))return attrs;if(Range$jscomp$0.isRange(attrs))return Annotation.fromJSON(Range$jscomp$0.createProperties(attrs));\nif(isPlainObject(attrs))return Annotation.fromJSON(attrs);throw Error(\"`Annotation.create` only accepts objects or annotations, but you passed it: \"+attrs);}},{key:\"createMap\",value:function(){var elements=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[];if(immutable.Map.isMap(elements))return elements;if(isPlainObject(elements)){var obj={},key;for(key in elements){var annotation=Annotation.create(elements[key]);obj[key]=annotation}return immutable.Map(obj)}throw Error(\"`Annotation.createMap` only accepts arrays or lists, but you passed it: \"+\nelements);}},{key:\"createProperties\",value:function(){var a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};if(Annotation.isAnnotation(a))return{key:a.key,type:a.type,data:a.data,anchor:Point.createProperties(a.anchor),focus:Point.createProperties(a.focus)};if(isPlainObject(a)){var p={};\"key\"in a&&(p.key=a.key);\"type\"in a&&(p.type=a.type);\"data\"in a&&(p.data=Data.create(a.data));\"anchor\"in a&&(p.anchor=Point.create(a.anchor));\"focus\"in a&&(p.focus=Point.create(a.focus));return p}throw Error(\"`Annotation.createProperties` only accepts objects or annotations, but you passed it: \"+\na);}},{key:\"fromJSON\",value:function(object){var key=object.key,type=object.type,data=object.data,anchor=object.anchor,focus=object.focus;if(!key)throw Error(\"Annotations must be created with a `key`, but you passed: \"+JSON.stringify(object));if(!type)throw Error(\"Annotations must be created with a `type`, but you passed: \"+JSON.stringify(object));return new Annotation({key:key,type:type,data:Data.create(data||{}),anchor:Point.fromJSON(anchor||{}),focus:Point.fromJSON(focus||{})})}}]);return Annotation}(immutable.Record({key:void 0,\ntype:void 0,data:void 0,anchor:void 0,focus:void 0})),Document$jscomp$0=function(_Record){function Document(){classCallCheck(this,Document);return possibleConstructorReturn(this,(Document.__proto__||Object.getPrototypeOf(Document)).apply(this,arguments))}inherits(Document,_Record);createClass(Document,[{key:\"toJSON\",value:function(){var options=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},object={object:this.object,data:this.data.toJSON(),nodes:this.nodes.toArray().map(function(n){return n.toJSON(options)})};\noptions.preserveKeys&&(object.key=this.key);return object}}],[{key:\"create\",value:function(){var attrs=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};if(Document.isDocument(attrs))return attrs;if(immutable.List.isList(attrs)||Array.isArray(attrs))attrs={nodes:attrs};if(isPlainObject(attrs))return Document.fromJSON(attrs);throw Error(\"`Document.create` only accepts objects, arrays, lists or documents, but you passed it: \"+attrs);}},{key:\"fromJSON\",value:function(object){if(Document.isDocument(object))return object;\nvar _object$data=object.data;_object$data=void 0===_object$data?{}:_object$data;var _object$key=object.key;_object$key=void 0===_object$key?KeyUtils.create():_object$key;object=object.nodes;object=void 0===object?[]:object;return new Document({key:_object$key,data:new immutable.Map(_object$data),nodes:Node$jscomp$0.createList(object)})}}]);return Document}(immutable.Record({data:void 0,key:void 0,nodes:void 0})),Inline=function(_Record){function Inline(){classCallCheck(this,Inline);return possibleConstructorReturn(this,\n(Inline.__proto__||Object.getPrototypeOf(Inline)).apply(this,arguments))}inherits(Inline,_Record);createClass(Inline,[{key:\"toJSON\",value:function(){var options=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},object={object:this.object,type:this.type,data:this.data.toJSON(),nodes:this.nodes.toArray().map(function(n){return n.toJSON(options)})};options.preserveKeys&&(object.key=this.key);return object}}],[{key:\"create\",value:function(){var attrs=0<arguments.length&&void 0!==arguments[0]?\narguments[0]:{};if(Inline.isInline(attrs))return attrs;\"string\"===typeof attrs&&(attrs={type:attrs});if(isPlainObject(attrs))return Inline.fromJSON(attrs);throw Error(\"`Inline.create` only accepts objects, strings or inlines, but you passed it: \"+attrs);}},{key:\"createList\",value:function(){var elements=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[];if(immutable.List.isList(elements)||Array.isArray(elements))return new immutable.List(elements.map(Inline.create));throw Error(\"`Inline.createList` only accepts arrays or lists, but you passed it: \"+\nelements);}},{key:\"fromJSON\",value:function(object){if(Inline.isInline(object))return object;var _object$data=object.data;_object$data=void 0===_object$data?{}:_object$data;var _object$key=object.key;_object$key=void 0===_object$key?KeyUtils.create():_object$key;var _object$nodes=object.nodes;_object$nodes=void 0===_object$nodes?[]:_object$nodes;object=object.type;if(\"string\"!==typeof object)throw Error(\"`Inline.fromJS` requires a `type` string.\");return new Inline({key:_object$key,type:object,data:new immutable.Map(_object$data),\nnodes:Node$jscomp$0.createList(_object$nodes)})}},{key:\"isInlineList\",value:function(any){return immutable.List.isList(any)&&any.every(function(item){return Inline.isInline(item)})}}]);return Inline}(immutable.Record({data:void 0,key:void 0,nodes:void 0,type:void 0})),Leaf=immutable.Record({text:void 0,marks:void 0,annotations:void 0,decorations:void 0}),Text$jscomp$0=function(_Record){function Text(){classCallCheck(this,Text);return possibleConstructorReturn(this,(Text.__proto__||Object.getPrototypeOf(Text)).apply(this,\narguments))}inherits(Text,_Record);createClass(Text,[{key:\"addMark\",value:function(mark){mark=Mark.create(mark);mark=this.marks.add(mark);return this.set(\"marks\",mark)}},{key:\"addMarks\",value:function(marks){marks=Mark.createSet(marks);return this.set(\"marks\",this.marks.union(marks))}},{key:\"getLeaves\",value:function(annotations,decorations){var leaves=[{text:this.text,marks:this.marks,annotations:[],decorations:[]}],split=function(leaf,at){return[{text:leaf.text.slice(0,at),marks:leaf.marks,annotations:[].concat(toConsumableArray(leaf.annotations)),\ndecorations:[].concat(toConsumableArray(leaf.decorations))},{text:leaf.text.slice(at),marks:leaf.marks,annotations:[].concat(toConsumableArray(leaf.annotations)),decorations:[].concat(toConsumableArray(leaf.decorations))}]},compile=function(kind){var formats=\"annotations\"===kind?annotations.values():decorations,_iteratorNormalCompletion=!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _iterator=formats[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=\n!0){var format=_step.value,start=format.start,end=format.end;formats=[];var o=0,_iteratorNormalCompletion2=!0,_didIteratorError2=!1,_iteratorError2=void 0;try{for(var _iterator2=leaves[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=!0){var leaf=_step2.value,length=leaf.text.length,offset=o;o+=length;if(start.offset<=offset&&end.offset>=offset+length)leaf[kind].push(format),formats.push(leaf);else if(start.offset>offset+length||end.offset<\noffset||end.offset===offset&&0!==offset)formats.push(leaf);else{var middle=leaf,before=void 0,after=void 0;if(end.offset<offset+length){var _split=split(middle,end.offset-offset),_split2=slicedToArray(_split,2);middle=_split2[0];after=_split2[1]}if(start.offset>offset){var _split3=split(middle,start.offset-offset),_split4=slicedToArray(_split3,2);before=_split4[0];middle=_split4[1]}middle[kind].push(format);before&&formats.push(before);formats.push(middle);after&&formats.push(after)}}}catch(err){_didIteratorError2=\n!0,_iteratorError2=err}finally{try{!_iteratorNormalCompletion2&&_iterator2.return&&_iterator2.return()}finally{if(_didIteratorError2)throw _iteratorError2;}}leaves=formats}}catch(err$4){_didIteratorError=!0,_iteratorError=err$4}finally{try{!_iteratorNormalCompletion&&_iterator.return&&_iterator.return()}finally{if(_didIteratorError)throw _iteratorError;}}};compile(\"annotations\");compile(\"decorations\");leaves=leaves.map(function(leaf){return new Leaf(_extends({},leaf,{annotations:immutable.List(leaf.annotations),\ndecorations:immutable.List(leaf.decorations)}))});return immutable.List(leaves)}},{key:\"insertText\",value:function(index,string){var text=this.text;index=text.slice(0,index)+string+text.slice(index);return this.set(\"text\",index)}},{key:\"removeMark\",value:function(mark){mark=Mark.create(mark);mark=this.marks.remove(mark);return this.set(\"marks\",mark)}},{key:\"removeText\",value:function(index,length){var text=this.text;index=text.slice(0,index)+text.slice(index+length);return this.set(\"text\",index)}},\n{key:\"toJSON\",value:function(){var options=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},object={object:this.object,text:this.text,marks:this.marks.toArray().map(function(m){return m.toJSON()})};options.preserveKeys&&(object.key=this.key);return object}},{key:\"setMark\",value:function(properties,newProperties){var marks=this.marks;properties=Mark.create(properties);newProperties=properties.merge(newProperties);marks=marks.remove(properties).add(newProperties);return this.set(\"marks\",marks)}},\n{key:\"splitText\",value:function(index){var text=this.text,one=this.set(\"text\",text.slice(0,index));index=this.set(\"text\",text.slice(index)).regenerateKey();return[one,index]}},{key:\"mergeText\",value:function(other){return this.set(\"text\",this.text+other.text)}}],[{key:\"create\",value:function(){var attrs=0<arguments.length&&void 0!==arguments[0]?arguments[0]:\"\";if(Text.isText(attrs))return attrs;\"string\"===typeof attrs&&(attrs={text:attrs});if(isPlainObject(attrs))return Text.fromJSON(attrs);throw Error(\"`Text.create` only accepts objects, arrays, strings or texts, but you passed it: \"+\nattrs);}},{key:\"createList\",value:function(){var elements=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[];if(immutable.List.isList(elements)||Array.isArray(elements))return new immutable.List(elements.map(Text.create));throw Error(\"`Text.createList` only accepts arrays or lists, but you passed it: \"+elements);}},{key:\"fromJSON\",value:function(object){if(Text.isText(object))return object;invariant(null==object.leaves,\"As of slate@0.46, the `leaves` property of text nodes has been removed! Each individual leaf should be created as a text node instead.\");\nvar _object$text=object.text;_object$text=void 0===_object$text?\"\":_object$text;var _object$marks=object.marks;_object$marks=void 0===_object$marks?[]:_object$marks;object=object.key;object=void 0===object?KeyUtils.create():object;return new Text({key:object,text:_object$text,marks:Mark.createSet(_object$marks)})}},{key:\"isTextList\",value:function(any){return immutable.List.isList(any)&&any.every(function(item){return Text.isText(item)})}}]);return Text}(immutable.Record({key:void 0,marks:void 0,\ntext:void 0})),Node$jscomp$0=function(){function Node(){classCallCheck(this,Node)}createClass(Node,null,[{key:\"create\",value:function(){var attrs=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};if(Node.isNode(attrs))return attrs;if(isPlainObject(attrs)){var object=attrs.object;!object&&attrs.kind&&(warning(!1,\"As of slate@0.32.0, the `kind` property of Slate objects has been renamed to `object`.\"),object=attrs.kind);switch(object){case \"block\":return Block.create(attrs);case \"document\":return Document$jscomp$0.create(attrs);\ncase \"inline\":return Inline.create(attrs);case \"text\":return Text$jscomp$0.create(attrs);default:throw Error(\"`Node.create` requires a `object` string.\");}}throw Error(\"`Node.create` only accepts objects or nodes but you passed it: \"+attrs);}},{key:\"createList\",value:function(){var elements=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[];if(immutable.List.isList(elements)||Array.isArray(elements)){var array=[];elements.forEach(function(el){el&&\"text\"===el.object&&el.leaves&&Array.isArray(el.leaves)?\n(warning(!1,\"As of slate@0.46, the `leaves` property of Text nodes has been removed. Instead, each text node contains a string of text and a unique set of marks and leaves are unnecessary.\"),el=Text$jscomp$0.createList(el.leaves).toArray(),array=array.concat(el)):(el=Node.create(el),array.push(el))});return immutable.List(array)}throw Error(\"`Node.createList` only accepts lists or arrays, but you passed it: \"+elements);}},{key:\"createProperties\",value:function(){var attrs=0<arguments.length&&void 0!==\narguments[0]?arguments[0]:{};if(Block.isBlock(attrs)||Inline.isInline(attrs))return{data:attrs.data,type:attrs.type};if(\"string\"===typeof attrs)return{type:attrs};if(isPlainObject(attrs)){var props={};\"type\"in attrs&&(props.type=attrs.type);\"data\"in attrs&&(props.data=Data.create(attrs.data));return props}throw Error(\"`Node.createProperties` only accepts objects, strings, blocks or inlines, but you passed it: \"+attrs);}},{key:\"fromJSON\",value:function(value){var object=value.object;!object&&value.kind&&\n(warning(!1,\"As of slate@0.32.0, the `kind` property of Slate objects has been renamed to `object`.\"),object=value.kind);switch(object){case \"block\":return Block.fromJSON(value);case \"document\":return Document$jscomp$0.fromJSON(value);case \"inline\":return Inline.fromJSON(value);case \"text\":return Text$jscomp$0.fromJSON(value);default:throw Error(\"`Node.fromJSON` requires an `object` of either 'block', 'document', 'inline' or 'text', but you passed: \"+value);}}},{key:\"isNode\",value:function(any){return Block.isBlock(any)||\nDocument$jscomp$0.isDocument(any)||Inline.isInline(any)||Text$jscomp$0.isText(any)}},{key:\"isNodeList\",value:function(any){return immutable.List.isList(any)&&any.every(function(item){return Node.isNode(item)})}}]);return Node}(),Block=function(_Record){function Block(){classCallCheck(this,Block);return possibleConstructorReturn(this,(Block.__proto__||Object.getPrototypeOf(Block)).apply(this,arguments))}inherits(Block,_Record);createClass(Block,[{key:\"toJSON\",value:function(){var options=0<arguments.length&&\nvoid 0!==arguments[0]?arguments[0]:{},object={object:this.object,type:this.type,data:this.data.toJSON(),nodes:this.nodes.toArray().map(function(n){return n.toJSON(options)})};options.preserveKeys&&(object.key=this.key);return object}}],[{key:\"create\",value:function(){var attrs=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};if(Block.isBlock(attrs))return attrs;\"string\"===typeof attrs&&(attrs={type:attrs});if(isPlainObject(attrs))return Block.fromJSON(attrs);throw Error(\"`Block.create` only accepts objects, strings or blocks, but you passed it: \"+\nattrs);}},{key:\"createList\",value:function(){var attrs=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[];if(immutable.List.isList(attrs)||Array.isArray(attrs))return new immutable.List(attrs.map(Block.create));throw Error(\"`Block.createList` only accepts arrays or lists, but you passed it: \"+attrs);}},{key:\"fromJSON\",value:function(object){if(Block.isBlock(object))return object;var _object$data=object.data;_object$data=void 0===_object$data?{}:_object$data;var _object$key=object.key;_object$key=\nvoid 0===_object$key?KeyUtils.create():_object$key;var _object$nodes=object.nodes;_object$nodes=void 0===_object$nodes?[]:_object$nodes;object=object.type;if(\"string\"!==typeof object)throw Error(\"`Block.fromJSON` requires a `type` string.\");return new Block({key:_object$key,type:object,data:immutable.Map(_object$data),nodes:Node$jscomp$0.createList(_object$nodes)})}},{key:\"isBlockList\",value:function(any){return immutable.List.isList(any)&&any.every(function(item){return Block.isBlock(item)})}}]);\nreturn Block}(immutable.Record({data:void 0,key:void 0,nodes:void 0,type:void 0})),Value=function(_Record){function Value(){classCallCheck(this,Value);return possibleConstructorReturn(this,(Value.__proto__||Object.getPrototypeOf(Value)).apply(this,arguments))}inherits(Value,_Record);createClass(Value,[{key:\"addAnnotation\",value:function(annotation){annotation=Annotation.create(annotation);var value=this,_value=value,annotations=_value.annotations,document=_value.document;_value=annotation.key;annotation=\nannotation.updatePoints(function(point){return point.normalize(document)});annotations=annotations.set(_value,annotation);return value=value.set(\"annotations\",annotations)}},{key:\"addMark\",value:function(path,mark){mark=Mark.create(mark);var value=this,document=value.document;document=document.addMark(path,mark);return value=value.set(\"document\",document)}},{key:\"insertNode\",value:function(path,node){var value=this,document=value.document;document=document.insertNode(path,node);value=value.set(\"document\",\ndocument);return value=value.mapRanges(function(range){return range.updatePoints(function(point){return point.setPath(null)})})}},{key:\"insertText\",value:function(path,offset,text){var value=this,document=value.document,node=document.assertNode(path);document=document.insertText(path,offset,text);node=document.assertNode(path);value=value.set(\"document\",document);return value=value.mapPoints(function(point){return point.key===node.key&&point.offset>=offset?point.setOffset(point.offset+text.length):\npoint})}},{key:\"mergeNode\",value:function(path){var value=this,document=value.document,newDocument=document.mergeNode(path);path=document.resolvePath(path);var withPath=PathUtils.decrement(path),one=document.getNode(withPath),two=document.getNode(path);value=value.set(\"document\",newDocument);return value=value.mapRanges(function(range){if(\"text\"===two.object){var max=one.text.length;range.anchor.key===two.key&&(range=range.moveAnchorTo(one.key,max+range.anchor.offset));range.focus.key===two.key&&\n(range=range.moveFocusTo(one.key,max+range.focus.offset))}return range=range.updatePoints(function(point){return point.setPath(null)})})}},{key:\"moveNode\",value:function(path,newPath){var newIndex=2<arguments.length&&void 0!==arguments[2]?arguments[2]:0,value=this,document=value.document;if(PathUtils.isEqual(path,newPath))return value;document=document.moveNode(path,newPath,newIndex);value=value.set(\"document\",document);return value=value.mapPoints(function(point){return point.setPath(null)})}},{key:\"removeAnnotation\",\nvalue:function(annotation){annotation=Annotation.create(annotation);var value=this,annotations=value.annotations;annotations=annotations.delete(annotation.key);return value=value.set(\"annotations\",annotations)}},{key:\"removeMark\",value:function(path,mark){mark=Mark.create(mark);var value=this,document=value.document;document=document.removeMark(path,mark);return value=value.set(\"document\",document)}},{key:\"removeNode\",value:function(path){var value=this,document=value.document,node=document.assertNode(path),\nfirst=\"text\"===node.object?node:node.getFirstText()||node,last=\"text\"===node.object?node:node.getLastText()||node,prev=document.getPreviousText(first.key),next=document.getNextText(last.key);document=document.removeNode(path);value=value.set(\"document\",document);return value=value.mapRanges(function(range){var _range=range,focus=_range.focus;node.hasNode(_range.anchor.key)&&(range=prev?range.moveAnchorTo(prev.key,prev.text.length):next?range.moveAnchorTo(next.key,0):range.unset());node.hasNode(focus.key)&&\n(range=prev?range.moveFocusTo(prev.key,prev.text.length):next?range.moveFocusTo(next.key,0):range.unset());return range=range.updatePoints(function(point){return point.setPath(null)})})}},{key:\"removeText\",value:function(path,offset,text){var value=this,document=value.document,node=document.assertNode(path);document=document.removeText(path,offset,text);value=value.set(\"document\",document);var length=text.length,end=offset+length;return value=value.mapPoints(function(point){return point.key!==node.key?\npoint:point.offset>=end?point.setOffset(point.offset-length):point.offset>offset?point.setOffset(offset):point})}},{key:\"setAnnotation\",value:function(properties,newProperties){newProperties=Annotation.createProperties(newProperties);properties=Annotation.create(properties);newProperties=properties.merge(newProperties);var value=this,annotations=value.annotations;annotations=annotations.set(properties.key,newProperties);return value=value.set(\"annotations\",annotations)}},{key:\"setNode\",value:function(path,\nproperties){var value=this,document=value.document;document=document.setNode(path,properties);return value=value.set(\"document\",document)}},{key:\"setMark\",value:function(path,mark,properties){var value=this,document=value.document;document=document.setMark(path,mark,properties);return value=value.set(\"document\",document)}},{key:\"setProperties\",value:function(properties){var value=this,document=value.document,data=properties.data;properties=properties.annotations;var props={};data&&(props.data=data);\nproperties&&(props.annotations=properties.map(function(a){return a.isSet?a:document.resolveAnnotation(a)}));return value=value.merge(props)}},{key:\"setSelection\",value:function(properties){var value=this,_value15=value,document=_value15.document;_value15=_value15.selection;properties=_value15.setProperties(properties);_value15=document.resolveSelection(properties);return value=value.set(\"selection\",_value15)}},{key:\"splitNode\",value:function(path,position,properties){var value=this,document=value.document,\nnewDocument=document.splitNode(path,position,properties),node=document.assertNode(path);value=value.set(\"document\",newDocument);return value=value.mapRanges(function(range){var next=newDocument.getNextText(node.key),_range2=range,anchor=_range2.anchor;_range2=_range2.focus;node.key===anchor.key&&position<=anchor.offset&&(range=range.moveAnchorTo(next.key,anchor.offset-position));node.key===_range2.key&&position<=_range2.offset&&(range=range.moveFocusTo(next.key,_range2.offset-position));return range=\nrange.updatePoints(function(point){return point.setPath(null)})})}},{key:\"mapRanges\",value:function(iterator){var value=this,_value17=value,document=_value17.document,selection=_value17.selection;_value17=_value17.annotations;var sel=selection.isSet?iterator(selection):selection;sel||(sel=selection.unset());sel!==selection&&(sel=document.createSelection(sel));value=value.set(\"selection\",sel);selection=_value17.map(function(annotation){var n=annotation.isSet?iterator(annotation):annotation;n&&n!==\nannotation&&(n=document.createAnnotation(n));return n});selection=selection.filter(function(annotation){return!!annotation});return value=value.set(\"annotations\",selection)}},{key:\"mapPoints\",value:function(iterator){return this.mapRanges(function(range){return range.updatePoints(iterator)})}},{key:\"toJSON\",value:function(){var options=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},object={object:this.object,document:this.document.toJSON(options)};options.preserveData&&(object.data=this.data.toJSON(options));\noptions.preserveAnnotations&&(object.annotations=this.annotations.map(function(a){return a.toJSON(options)}).toObject());options.preserveSelection&&(object.selection=this.selection.toJSON(options));return object}},{key:\"change\",value:function(){invariant(!1,\"As of Slate 0.42.0, value object are no longer schema-aware, and the `value.change()` method is no longer available. Use the `editor.change()` method on the new `Editor` controller instead.\")}},{key:\"startBlock\",get:function(){return this.selection.start.key&&\nthis.document.getClosestBlock(this.selection.start.key)}},{key:\"endBlock\",get:function(){return this.selection.end.key&&this.document.getClosestBlock(this.selection.end.key)}},{key:\"anchorBlock\",get:function(){return this.selection.anchor.key&&this.document.getClosestBlock(this.selection.anchor.key)}},{key:\"focusBlock\",get:function(){return this.selection.focus.key&&this.document.getClosestBlock(this.selection.focus.key)}},{key:\"startInline\",get:function(){return this.selection.start.key&&this.document.getClosestInline(this.selection.start.key)}},\n{key:\"endInline\",get:function(){return this.selection.end.key&&this.document.getClosestInline(this.selection.end.key)}},{key:\"anchorInline\",get:function(){return this.selection.anchor.key&&this.document.getClosestInline(this.selection.anchor.key)}},{key:\"focusInline\",get:function(){return this.selection.focus.key&&this.document.getClosestInline(this.selection.focus.key)}},{key:\"startText\",get:function(){return this.selection.start.key&&this.document.getDescendant(this.selection.start.key)}},{key:\"endText\",\nget:function(){return this.selection.end.key&&this.document.getDescendant(this.selection.end.key)}},{key:\"anchorText\",get:function(){return this.selection.anchor.key&&this.document.getDescendant(this.selection.anchor.key)}},{key:\"focusText\",get:function(){return this.selection.focus.key&&this.document.getDescendant(this.selection.focus.key)}},{key:\"nextBlock\",get:function(){return this.selection.end.key&&this.document.getNextBlock(this.selection.end.key)}},{key:\"previousBlock\",get:function(){return this.selection.start.key&&\nthis.document.getPreviousBlock(this.selection.start.key)}},{key:\"nextInline\",get:function(){return this.selection.end.key&&this.document.getNextInline(this.selection.end.key)}},{key:\"previousInline\",get:function(){return this.selection.start.key&&this.document.getPreviousInline(this.selection.start.key)}},{key:\"nextText\",get:function(){return this.selection.end.key&&this.document.getNextText(this.selection.end.key)}},{key:\"previousText\",get:function(){return this.selection.start.key&&this.document.getPreviousText(this.selection.start.key)}},\n{key:\"marks\",get:function(){return this.selection.isUnset?new immutable.Set:this.selection.marks||this.document.getMarksAtRange(this.selection)}},{key:\"activeMarks\",get:function(){return this.selection.isUnset?new immutable.Set:this.selection.marks||this.document.getActiveMarksAtRange(this.selection)}},{key:\"blocks\",get:function(){return this.selection.isUnset?new immutable.List:this.document.getLeafBlocksAtRange(this.selection)}},{key:\"fragment\",get:function(){return this.selection.isUnset?Document$jscomp$0.create():\nthis.document.getFragmentAtRange(this.selection)}},{key:\"inlines\",get:function(){return this.selection.isUnset?new immutable.List:this.document.getLeafInlinesAtRange(this.selection)}},{key:\"texts\",get:function(){return this.selection.isUnset?new immutable.List:this.document.getTextsAtRange(this.selection)}},{key:\"history\",get:function(){invariant(!1,\"As of Slate 0.42.0, the `value.history` model no longer exists, and the history is stored in `value.data` instead using plugins.\")}}],[{key:\"create\",\nvalue:function(){var attrs=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},options=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};if(Value.isValue(attrs))return attrs;if(isPlainObject(attrs))return Value.fromJSON(attrs,options);throw Error(\"`Value.create` only accepts objects or values, but you passed it: \"+attrs);}},{key:\"createProperties\",value:function(){var a=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};if(Value.isValue(a))return{annotations:a.annotations,data:a.data};\nif(isPlainObject(a)){var p={};\"annotations\"in a&&(p.annotations=Annotation.createMap(a.annotations));\"data\"in a&&(p.data=Data.create(a.data));return p}throw Error(\"`Value.createProperties` only accepts objects or values, but you passed it: \"+a);}},{key:\"fromJSON\",value:function(object){var _object$data=object.data;_object$data=void 0===_object$data?{}:_object$data;var _object$annotations=object.annotations;_object$annotations=void 0===_object$annotations?{}:_object$annotations;var _object$document=\nobject.document;_object$document=void 0===_object$document?{}:_object$document;object=object.selection;object=void 0===object?{}:object;_object$data=Data.fromJSON(_object$data);_object$document=Document$jscomp$0.fromJSON(_object$document);object=_object$document.createSelection(object);_object$annotations=Annotation.createMap(_object$annotations);if(object.isUnset){var text=_object$document.getFirstText();text&&(object=object.moveToStartOfNode(text));object=_object$document.createSelection(object)}return new Value({annotations:_object$annotations,\ndata:_object$data,document:_object$document,selection:object})}}]);return Value}(immutable.Record({annotations:void 0,data:void 0,document:void 0,selection:void 0})),debug=Debug(\"slate:operation:apply\"),debug$1=Debug(\"slate:operation:invert\"),OPERATION_ATTRIBUTES={add_mark:[\"path\",\"mark\",\"data\"],add_annotation:[\"annotation\",\"data\"],insert_node:[\"path\",\"node\",\"data\"],insert_text:[\"path\",\"offset\",\"text\",\"data\"],merge_node:[\"path\",\"position\",\"properties\",\"target\",\"data\"],move_node:[\"path\",\"newPath\",\n\"data\"],remove_annotation:[\"annotation\",\"data\"],remove_mark:[\"path\",\"mark\",\"data\"],remove_node:[\"path\",\"node\",\"data\"],remove_text:[\"path\",\"offset\",\"text\",\"data\"],set_annotation:[\"properties\",\"newProperties\",\"data\"],set_mark:[\"path\",\"properties\",\"newProperties\",\"data\"],set_node:[\"path\",\"properties\",\"newProperties\",\"data\"],set_selection:[\"properties\",\"newProperties\",\"data\"],set_value:[\"properties\",\"newProperties\",\"data\"],split_node:[\"path\",\"position\",\"properties\",\"target\",\"data\"]},Operation=function(_Record){function Operation(){classCallCheck(this,\nOperation);return possibleConstructorReturn(this,(Operation.__proto__||Object.getPrototypeOf(Operation)).apply(this,arguments))}inherits(Operation,_Record);createClass(Operation,[{key:\"apply\",value:function(value){return applyOperation(value,this)}},{key:\"invert\",value:function(){return invertOperation(this)}},{key:\"toJSON\",value:function(){var type=this.type,json={object:this.object,type:type},ATTRIBUTES=OPERATION_ATTRIBUTES[type],_iteratorNormalCompletion=!0,_didIteratorError=!1,_iteratorError=\nvoid 0;try{for(var _iterator=ATTRIBUTES[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=!0){var key=_step.value,value=this[key];if(\"annotation\"===key||\"mark\"===key||\"marks\"===key||\"node\"===key||\"path\"===key||\"newPath\"===key)value=value.toJSON();\"properties\"===key&&\"merge_node\"===type&&(ATTRIBUTES={},\"data\"in value&&(ATTRIBUTES.data=value.data.toJS()),\"type\"in value&&(ATTRIBUTES.type=value.type),value=ATTRIBUTES);\"properties\"!==key&&\"newProperties\"!==\nkey||\"set_annotation\"!==type||(ATTRIBUTES={},\"anchor\"in value&&(ATTRIBUTES.anchor=value.anchor.toJS()),\"focus\"in value&&(ATTRIBUTES.focus=value.focus.toJS()),\"key\"in value&&(ATTRIBUTES.key=value.key),\"data\"in value&&(ATTRIBUTES.data=value.data.toJS()),\"type\"in value&&(ATTRIBUTES.type=value.type),value=ATTRIBUTES);\"properties\"!==key&&\"newProperties\"!==key||\"set_mark\"!==type||(ATTRIBUTES={},\"data\"in value&&(ATTRIBUTES.data=value.data.toJS()),\"type\"in value&&(ATTRIBUTES.type=value.type),value=ATTRIBUTES);\n\"properties\"!==key&&\"newProperties\"!==key||\"set_node\"!==type||(ATTRIBUTES={},\"data\"in value&&(ATTRIBUTES.data=value.data.toJS()),\"type\"in value&&(ATTRIBUTES.type=value.type),value=ATTRIBUTES);\"properties\"!==key&&\"newProperties\"!==key||\"set_selection\"!==type||(ATTRIBUTES={},\"anchor\"in value&&(ATTRIBUTES.anchor=value.anchor.toJSON()),\"focus\"in value&&(ATTRIBUTES.focus=value.focus.toJSON()),\"isFocused\"in value&&(ATTRIBUTES.isFocused=value.isFocused),\"marks\"in value&&(ATTRIBUTES.marks=value.marks&&value.marks.toJSON()),\nvalue=ATTRIBUTES);\"properties\"!==key&&\"newProperties\"!==key||\"set_value\"!==type||(ATTRIBUTES={},\"data\"in value&&(ATTRIBUTES.data=value.data.toJS()),value=ATTRIBUTES);\"properties\"===key&&\"split_node\"===type&&(ATTRIBUTES={},\"data\"in value&&(ATTRIBUTES.data=value.data.toJS()),\"type\"in value&&(ATTRIBUTES.type=value.type),value=ATTRIBUTES);\"data\"===key&&(value=value.toJSON());json[key]=value}}catch(err){_didIteratorError=!0,_iteratorError=err}finally{try{!_iteratorNormalCompletion&&_iterator.return&&_iterator.return()}finally{if(_didIteratorError)throw _iteratorError;\n}}return json}}],[{key:\"create\",value:function(){var attrs=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};if(Operation.isOperation(attrs))return attrs;if(isPlainObject(attrs))return Operation.fromJSON(attrs);throw Error(\"`Operation.create` only accepts objects or operations, but you passed it: \"+attrs);}},{key:\"createList\",value:function(){var elements=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[];if(immutable.List.isList(elements)||Array.isArray(elements))return new immutable.List(elements.map(Operation.create));\nthrow Error(\"`Operation.createList` only accepts arrays or lists, but you passed it: \"+elements);}},{key:\"fromJSON\",value:function(object){if(Operation.isOperation(object))return object;var type=object.type,ATTRIBUTES=OPERATION_ATTRIBUTES[type],attrs={type:type};if(!ATTRIBUTES)throw Error('`Operation.fromJSON` was passed an unrecognized operation type: \"'+type+'\"');var _iteratorNormalCompletion2=!0,_didIteratorError2=!1,_iteratorError2=void 0;try{for(var _iterator2=ATTRIBUTES[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=\n(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=!0){var key=_step2.value,v=object[key];\"data\"===key&&void 0===v&&(v={});if(void 0===v)throw Error('`Operation.fromJSON` was passed a \"'+type+'\" operation without the required \"'+key+'\" attribute.');\"annotation\"===key&&(v=Annotation.create(v));if(\"path\"===key||\"newPath\"===key)v=PathUtils.create(v);\"mark\"===key&&(v=Mark.create(v));\"node\"===key&&(v=Node$jscomp$0.create(v));\"properties\"!==key&&\"newProperties\"!==key||\"set_annotation\"!==type||\n(v=Annotation.createProperties(v));\"properties\"!==key&&\"newProperties\"!==key||\"set_mark\"!==type||(v=Mark.createProperties(v));\"properties\"!==key&&\"newProperties\"!==key||\"set_node\"!==type&&\"merge_node\"!==type&&\"split_node\"!==type||(v=Node$jscomp$0.createProperties(v));\"properties\"!==key&&\"newProperties\"!==key||\"set_selection\"!==type||(v=Selection$jscomp$0.createProperties(v));\"properties\"!==key&&\"newProperties\"!==key||\"set_value\"!==type||(v=Value.createProperties(v));\"data\"===key&&(v=immutable.Map(v));\nattrs[key]=v}}catch(err){_didIteratorError2=!0,_iteratorError2=err}finally{try{!_iteratorNormalCompletion2&&_iterator2.return&&_iterator2.return()}finally{if(_didIteratorError2)throw _iteratorError2;}}return new Operation(attrs)}},{key:\"isOperationList\",value:function(any){return immutable.List.isList(any)&&any.every(function(item){return Operation.isOperation(item)})}}]);return Operation}(immutable.Record({annotation:void 0,data:void 0,length:void 0,mark:void 0,marks:void 0,newPath:void 0,newProperties:void 0,\nnode:void 0,offset:void 0,path:void 0,position:void 0,properties:void 0,target:void 0,text:void 0,type:void 0})),Change=function(_Record){function Change(){classCallCheck(this,Change);return possibleConstructorReturn(this,(Change.__proto__||Object.getPrototypeOf(Change)).apply(this,arguments))}inherits(Change,_Record);createClass(Change,[{key:\"toJSON\",value:function(){var options=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};return{object:this.object,value:this.value.toJSON(options),operations:this.operations.toArray().map(function(o){return o.toJSON(options)})}}}],\n[{key:\"create\",value:function(){var attrs=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};if(Change.isChange(attrs))return attrs;if(isPlainObject(attrs))return Change.fromJSON(attrs);throw Error(\"`Change.create` only accepts objects or changes, but you passed it: \"+attrs);}},{key:\"fromJSON\",value:function(object){var _object$operations=object.operations;_object$operations=void 0===_object$operations?[]:_object$operations;return new Change({value:Value.create(object.value),operations:Operation.createList(_object$operations)})}}]);\nreturn Change}(immutable.Record({operations:void 0,value:void 0})),SPACE=/\\s/,CHAMELEON=/['\\u2018\\u2019]/,PUNCTUATION=/[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/,\nTextUtils={getCharLength:getCharLength,getCharOffset:getCharOffset,getCharOffsetBackward:function(text,offset){var chars=2<arguments.length&&void 0!==arguments[2]?arguments[2]:1;text=text.slice(0,offset);text=esrever.reverse(text);return getCharOffset(text,chars)},getCharOffsetForward:function(text,offset){var chars=2<arguments.length&&void 0!==arguments[2]?arguments[2]:1;text=text.slice(offset);return getCharOffset(text,chars,!0)},getWordOffset:getWordOffset,getWordOffsetBackward:function(text,offset){text=\ntext.slice(0,offset);text=esrever.reverse(text);return getWordOffset(text)},getWordOffsetForward:function(text,offset){text=text.slice(offset);return getWordOffset(text)},isSurrogate:isSurrogate,isWord:isWord},Commands$1={addMarkAtRange:function(editor,range,mark){if(!range.isCollapsed){var start=range.start,end=range.end,texts=editor.value.document.getTextsAtRange(range);editor.withoutNormalizing(function(){texts.forEach(function(node){var key=node.key,index=0;node=node.text.length;key===start.key&&\n(index=start.offset);key===end.key&&(node=end.offset);key===start.key&&key===end.key&&(node=end.offset-start.offset);editor.addMarkByKey(key,index,node,mark)})})}},addMarksAtRange:function(editor,range,marks){marks.forEach(function(mark){return editor.addMarkAtRange(range,mark)})},deleteAtRange:function(editor,range){editor.snapshotSelection();var start=range.start;range=range.end;var startKey=start.key,startOffset=start.offset,endKey=range.key,endOffset=range.offset,document=editor.value.document,\nisStartVoid=document.hasVoidParent(startKey,editor),isEndVoid=document.hasVoidParent(endKey,editor),startBlock=document.getClosestBlock(startKey),endBlock=document.getClosestBlock(endKey),isHanging=0===startOffset&&0===endOffset&&!1===isStartVoid&&startKey===startBlock.getFirstText().key&&endKey===endBlock.getFirstText().key&&startKey!==endKey;isHanging&&isEndVoid&&(start=document.getPreviousText(endKey),endKey=start.key,endOffset=start.text.length,isEndVoid=document.hasVoidParent(endKey,editor));\neditor.withoutNormalizing(function(){for(;isStartVoid;){var startVoid=document.getClosestVoid(startKey,editor),nextText=document.getNextText(startKey);editor.removeNodeByKey(startVoid.key);if(startKey===endKey||!nextText)return;document=editor.value.document;startKey=nextText.key;startOffset=0;isStartVoid=document.hasVoidParent(startKey,editor)}for(;isEndVoid;)startVoid=document.getClosestVoid(endKey,editor),nextText=document.getPreviousText(endKey),editor.removeNodeByKey(startVoid.key),document=\neditor.value.document,endKey=nextText.key,endOffset=nextText.text.length,isEndVoid=document.hasVoidParent(endKey,editor);if(startKey===endKey&&isHanging)editor.removeNodeByKey(startBlock.key);else if(startKey===endKey)editor.removeTextByKey(startKey,startOffset,endOffset-startOffset);else{startBlock=document.getClosestBlock(startKey);endBlock=document.getClosestBlock(endKey);var startText=document.getNode(startKey),endText=document.getNode(endKey),startLength=startText.text.length-startOffset,endLength=\nendOffset,ancestor=document.getCommonAncestor(startKey,endKey),startChild=ancestor.getFurthestChild(startKey),endChild=ancestor.getFurthestChild(endKey);startVoid=document.getParent(startBlock.key);nextText=startVoid.nodes.indexOf(startBlock);var endParentIndex=startVoid.nodes.indexOf(endBlock),child=void 0;for(child=startText;child.key!==startChild.key;)startText=document.getParent(child.key),child=startText.nodes.indexOf(child),startText.nodes.slice(child+1).reverse().forEach(function(node){editor.removeNodeByKey(node.key)}),\nchild=startText;startChild=ancestor.nodes.indexOf(startChild);child=ancestor.nodes.indexOf(endChild);ancestor.nodes.slice(startChild+1,child).reverse().forEach(function(node){editor.removeNodeByKey(node.key)});for(child=endText;child.key!==endChild.key;)endText=document.getParent(child.key),ancestor=endText.nodes.indexOf(child),endText.nodes.slice(0,ancestor).reverse().forEach(function(node){editor.removeNodeByKey(node.key)}),child=endText;0!==startLength&&editor.removeTextByKey(startKey,startOffset,\nstartLength);0!==endLength&&editor.removeTextByKey(endKey,0,endOffset);if(startBlock.key!==endBlock.key){document=editor.value.document;startLength=void 0;endLength=!0;endChild=!1;endText=void 0;try{for(var _iterator=document.ancestors(endBlock.key)[Symbol.iterator](),_step;!(endLength=(_step=_iterator.next()).done);endLength=!0){var node$jscomp$0=slicedToArray(_step.value,1)[0];if(1<node$jscomp$0.nodes.size)break;else startLength=node$jscomp$0}}catch(err){endChild=!0,endText=err}finally{try{!endLength&&\n_iterator.return&&_iterator.return()}finally{if(endChild)throw endText;}}endParentIndex!==nextText+1&&editor.moveNodeByKey(endBlock.key,startVoid.key,nextText+1);isHanging?editor.removeNodeByKey(startBlock.key):editor.mergeNodeByKey(endBlock.key);startLength&&editor.removeNodeByKey(startLength.key)}}})},deleteBackwardAtRange:function(editor,range){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:1;if(0!==n){var document=editor.value.document,_range2=range,start=_range2.start;_range2=_range2.focus;\nif(range.isExpanded)editor.deleteAtRange(range);else{var voidParent=document.getClosestVoid(start.path,editor);if(voidParent)editor.removeNodeByKey(voidParent.key);else if(!start.isAtStartOfNode(document))if(voidParent=document.getClosestBlock(start.path),1!==document.nodes.size&&voidParent&&\"\"===voidParent.text&&1===voidParent.nodes.size)editor.removeNodeByKey(voidParent.key);else{var text=document.getDescendant(start.path);if(start.isAtStartOfNode(text)){start=document.getPreviousText(text.key);\ndocument.getClosestInline(text.key)&&\"\"===start.text&&(start=document.getPreviousText(start.key));var prevBlock=document.getClosestBlock(start.key),prevVoid=document.getClosestVoid(start.key,editor);if(prevVoid){editor.removeNodeByKey(prevVoid.key);return}if(1===n&&prevBlock!==voidParent){range=range.moveAnchorTo(start.key,start.text.length);editor.deleteAtRange(range);return}}if(n<=_range2.offset)range=range.moveFocusBackward(n);else{voidParent=text;text=0;for(_range2=_range2.offset;n>_range2;)if(voidParent=\ndocument.getPreviousText(voidParent.key),_range2+=voidParent.text.length,n<=_range2){text=_range2-n;break}range=range.moveAnchorTo(voidParent.key,text)}editor.deleteAtRange(range)}}}},deleteCharBackwardAtRange:function(editor,range){if(range.isExpanded)editor.deleteAtRange(range);else{var start=range.start,startBlock=editor.value.document.getClosestBlock(start.path);start=startBlock.getOffset(start.key)+start.offset;startBlock=TextUtils.getCharOffsetBackward(startBlock.text,start);editor.deleteBackwardAtRange(range,\nstartBlock)}},deleteCharForwardAtRange:function(editor,range){if(range.isExpanded)editor.deleteAtRange(range);else{var start=range.start,startBlock=editor.value.document.getClosestBlock(start.path);start=startBlock.getOffset(start.key)+start.offset;startBlock=TextUtils.getCharOffsetForward(startBlock.text,start);editor.deleteForwardAtRange(range,startBlock)}},deleteForwardAtRange:function(editor,range){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:1;if(0!==n){var document=editor.value.document,\n_range3=range,start=_range3.start;_range3=_range3.focus;if(range.isExpanded)editor.deleteAtRange(range);else{var voidParent=document.getClosestVoid(start.path,editor);if(voidParent)editor.removeNodeByKey(voidParent.key);else{var block=document.getClosestBlock(start.path);if(block&&!editor.isVoid(block)&&\"\"===block.text&&1!==document.nodes.size)n=document.getNextBlock(block.key),editor.removeNodeByKey(block.key),n&&n.key&&editor.moveToStartOfNode(n);else if(!start.isAtEndOfNode(document)){voidParent=\ndocument.getDescendant(start.path);if(start.isAtEndOfNode(voidParent)){start=document.getNextText(voidParent.key);var _nextBlock=document.getClosestBlock(start.key),nextVoid=document.getClosestVoid(start.key,editor);if(nextVoid){editor.removeNodeByKey(nextVoid.key);return}if(1===n&&_nextBlock!==block){range=range.moveFocusTo(start.key,0);editor.deleteAtRange(range);return}}if(n<=voidParent.text.length-_range3.offset)range=range.moveFocusForward(n);else{block=voidParent;start=_range3.offset;for(_range3=\nvoidParent.text.length-_range3.offset;n>_range3;)if(block=document.getNextText(block.key),voidParent=_range3+block.text.length,n<=voidParent){start=n-_range3;break}else _range3=voidParent;range=range.moveFocusTo(block.key,start)}editor.deleteAtRange(range)}}}}},deleteLineBackwardAtRange:function(editor,range){if(range.isExpanded)editor.deleteAtRange(range);else{var start=range.start;start=editor.value.document.getClosestBlock(start.path).getOffset(start.key)+start.offset;editor.deleteBackwardAtRange(range,\nstart)}},deleteLineForwardAtRange:function(editor,range){if(range.isExpanded)editor.deleteAtRange(range);else{var start=range.start,startBlock=editor.value.document.getClosestBlock(start.path);start=startBlock.getOffset(start.key)+start.offset;editor.deleteForwardAtRange(range,startBlock.text.length-start)}},deleteWordBackwardAtRange:function(editor,range){if(range.isExpanded)editor.deleteAtRange(range);else{var start=range.start,startBlock=editor.value.document.getClosestBlock(start.path);start=\nstartBlock.getOffset(start.key)+start.offset;startBlock=startBlock.text;startBlock=0===start?1:TextUtils.getWordOffsetBackward(startBlock,start);editor.deleteBackwardAtRange(range,startBlock)}},deleteWordForwardAtRange:function(editor,range){if(range.isExpanded)editor.deleteAtRange(range);else{var start=range.start,startBlock=editor.value.document.getClosestBlock(start.path);start=startBlock.getOffset(start.key)+start.offset;startBlock=TextUtils.getWordOffsetForward(startBlock.text,start);editor.deleteForwardAtRange(range,\n0===startBlock?1:startBlock)}},insertBlockAtRange:function(editor,range,block){range=deleteExpandedAtRange(editor,range);block=Block.create(block);var document=editor.value.document,start=range.start,startKey=start.key,startOffset=start.offset,startBlock=document.getClosestBlock(startKey),startInline=document.getClosestInline(startKey),parent=document.getParent(startBlock.key),index=parent.nodes.indexOf(startBlock),insertionMode=getInsertionMode(editor,range);\"before\"===insertionMode?editor.insertNodeByKey(parent.key,\nindex,block):\"behind\"===insertionMode?editor.insertNodeByKey(parent.key,index+1,block):(startInline&&editor.isVoid(startInline)&&(document=(start=start.isAtEndOfNode(startInline))?document.getNextText(startKey):document.getPreviousText(startKey),range=start?range.moveToStartOfNode(document):range.moveToEndOfNode(document),startKey=range.start.key,startOffset=range.start.offset),editor.withoutNormalizing(function(){editor.splitDescendantsByKey(startBlock.key,startKey,startOffset);editor.insertNodeByKey(parent.key,\nindex+1,block)}))}},getInsertionMode=function(editor,range){var document=editor.value.document;range=range.start;var startKey=range.key,startBlock=document.getClosestBlock(startKey);document=document.getClosestInline(startKey);if(editor.isVoid(startBlock))return range.isAtEndOfNode(startBlock)?\"behind\":\"before\";if(document||\"\"!==startBlock.text){if(range.isAtStartOfNode(startBlock))return\"before\";if(range.isAtEndOfNode(startBlock))return\"behind\"}else return\"behind\";return\"split\"};Commands$1.insertFragmentAtRange=\nfunction(editor,range,fragment){editor.withoutNormalizing(function(){range=deleteExpandedAtRange(editor,range);if(fragment.nodes.size){fragment=fragment.mapDescendants(function(child){return child.regenerateKey()});var start=range.start,document=editor.value.document,startText=document.getDescendant(start.path),startBlock=document.getClosestBlock(startText.key),startChild=startBlock.getFurthestChild(startText.key),isAtStart=start.isAtStartOfNode(startBlock),parent=document.getParent(startBlock.key),\nindex=parent.nodes.indexOf(startBlock),blocks=fragment.getBlocks();startText=fragment.nodes.first();var lastChild=fragment.nodes.last(),firstBlock=blocks.first(),lastBlock=blocks.last();document=findInsertionNode(fragment,document,startBlock.key);if(firstBlock===lastBlock&&editor.isVoid(firstBlock))editor.insertBlockAtRange(range,firstBlock);else if(document===fragment&&(startText.hasBlockChildren()||lastChild.hasBlockChildren()))(\"before\"===getInsertionMode(editor,range)?fragment.nodes:fragment.nodes.reverse()).forEach(function(node){editor.insertBlockAtRange(range,\nnode)});else{if(firstBlock!==lastBlock){startText=document.getFurthest(firstBlock.key,function(p){return 1===p.nodes.size})||firstBlock;var startIndex=parent.nodes.indexOf(startBlock);document.removeNode(startText.key).nodes.forEach(function(node,i){editor.insertNodeByKey(parent.key,startIndex+i+1,node)})}0!==start.offset&&editor.splitDescendantsByKey(startChild.key,start.key,start.offset);document=editor.value.document;startText=document.getDescendant(start.key);startBlock=document.getClosestBlock(start.key);\nstartChild=startBlock.getFurthestChild(startText.key);if(firstBlock!==lastBlock){var nextChild=isAtStart?startChild:startBlock.getNextSibling(startChild.key);startChild=nextChild?startBlock.nodes.skipUntil(function(n){return n.key===nextChild.key}):immutable.List();var lastIndex=lastBlock.nodes.size;startChild.forEach(function(node,i){editor.moveNodeByKey(node.key,lastBlock.key,lastIndex+i)})}if(editor.isVoid(startBlock)||\"\"!==startBlock.text||startBlock.findDescendant(function(n){return editor.isVoid(n)})){index=\nstartBlock.getFurthestChild(startText.key);var inlineIndex=startBlock.nodes.indexOf(index);firstBlock.nodes.forEach(function(inline,i){editor.insertNodeByKey(startBlock.key,inlineIndex+i+(0===start.offset?0:1),inline)})}else editor.removeNodeByKey(startBlock.key),editor.insertNodeByKey(parent.key,index,firstBlock)}}})};var findInsertionNode=function(fragment,document,documentKey){var ancestorTypesMatch=function(fragmentAncestors,documentAncestors){return documentAncestors.size>=fragmentAncestors.size&&\nfragmentAncestors.every(function(fragmentNode,i){return documentAncestors.get(i).type===fragmentNode.type})},getAncestorBlocks=function(doc,key){return doc.getAncestors(key).slice(1).push(doc.getNode(key)).reverse()},fragmentStartBlock=function(doc){for(var result=doc;1===result.nodes.size&&\"block\"===result.nodes.first().object;)result=result.nodes.first();return result===doc?null:result}(fragment);if(!fragmentStartBlock)return fragment;document=getAncestorBlocks(document,documentKey);getAncestorBlocks=\ngetAncestorBlocks(fragment,fragmentStartBlock.key);return function(documentAncestors,fragmentAncestors){var depthDifference=documentAncestors.size-fragmentAncestors.size;if(0>depthDifference)return fragment;for(var fragIdx=0;fragIdx<fragmentAncestors.size;fragIdx++)for(var docIdx=0;docIdx<=depthDifference;docIdx++)if(ancestorTypesMatch(fragmentAncestors.slice(fragIdx),documentAncestors.slice(docIdx)))return fragmentAncestors.get(fragIdx);return fragment}(document,getAncestorBlocks)};Commands$1.insertInlineAtRange=\nfunction(editor,range,inline){inline=Inline.create(inline);editor.withoutNormalizing(function(){range=deleteExpandedAtRange(editor,range);var document=editor.value.document,start=range.start,parent=document.getParent(start.path);document=document.assertDescendant(start.path);document=parent.nodes.indexOf(document);editor.isVoid(parent)||(editor.splitNodeByPath(start.path,start.offset),editor.insertNodeByKey(parent.key,document+1,inline))})};Commands$1.insertTextAtRange=function(editor,range,text,\nmarks){editor.withoutNormalizing(function(){range=deleteExpandedAtRange(editor,range);var start=range.start,offset=start.offset,parent=editor.value.document.getParent(start.path);editor.isVoid(parent)||editor.insertTextByPath(start.path,offset,text,marks)})};Commands$1.removeMarkAtRange=function(editor,range,mark){if(!range.isCollapsed){var texts=editor.value.document.getTextsAtRange(range),start=range.start,end=range.end;editor.withoutNormalizing(function(){texts.forEach(function(node){var key=node.key,\nindex=0;node=node.text.length;key===start.key&&(index=start.offset);key===end.key&&(node=end.offset);key===start.key&&key===end.key&&(node=end.offset-start.offset);editor.removeMarkByKey(key,index,node,mark)})})}};Commands$1.setBlocksAtRange=function(editor,range,properties){var document=editor.value.document,blocks=document.getLeafBlocksAtRange(range),start=range.start,end=range.end;range=range.isCollapsed;var isStartVoid=document.hasVoidParent(start.path,editor),startBlock=document.getClosestBlock(start.path);\ndocument=document.getClosestBlock(end.key);var sets=!1===range&&0===start.offset&&0===end.offset&&!1===isStartVoid&&start.key===startBlock.getFirstText().key&&end.key===document.getFirstText().key?blocks.slice(0,-1):blocks;editor.withoutNormalizing(function(){sets.forEach(function(block){editor.setNodeByKey(block.key,properties)})})};Commands$1.setInlinesAtRange=function(editor,range,properties){var inlines=editor.value.document.getLeafInlinesAtRange(range);editor.withoutNormalizing(function(){inlines.forEach(function(inline){editor.setNodeByKey(inline.key,\nproperties)})})};Commands$1.splitBlockAtRange=function(editor,range){var height=2<arguments.length&&void 0!==arguments[2]?arguments[2]:1,_range8=range=deleteExpandedAtRange(editor,range),start=_range8.start,end=_range8.end,value=editor.value,document=value.document,node=document.assertDescendant(start.path);_range8=document.getClosestBlock(node.key);for(var h=0;_range8&&\"block\"===_range8.object&&h<height;)node=_range8,_range8=document.getClosestBlock(_range8.key),h++;editor.withoutNormalizing(function(){editor.splitDescendantsByKey(node.key,\nstart.path,start.offset);value=editor.value;document=value.document;if(range.isExpanded){range.isBackward&&(range=range.flip());var nextBlock=document.getNextBlock(node.key);range=range.moveAnchorToStartOfNode(nextBlock);range=range.setFocus(range.focus.setPath(null));start.path.equals(end.path)&&(range=range.moveFocusTo(range.anchor.key,end.offset-start.offset));range=document.resolveRange(range);editor.deleteAtRange(range)}})};Commands$1.splitInlineAtRange=function(editor,range){var height=2<arguments.length&&\nvoid 0!==arguments[2]?arguments[2]:Infinity;range=deleteExpandedAtRange(editor,range);for(var start=range.start,document=editor.value.document,node=document.assertDescendant(start.path),parent=document.getClosestInline(node.key),h=0;parent&&\"inline\"===parent.object&&h<height;)node=parent,parent=document.getClosestInline(parent.key),h++;editor.splitDescendantsByKey(node.key,start.path,start.offset)};Commands$1.toggleMarkAtRange=function(editor,range,mark){range.isCollapsed||(mark=Mark.create(mark),\neditor.value.document.getActiveMarksAtRange(range).some(function(m){return m.equals(mark)})?editor.removeMarkAtRange(range,mark):editor.addMarkAtRange(range,mark))};Commands$1.unwrapBlockAtRange=function(editor,range,properties){properties=Node$jscomp$0.createProperties(properties);var document=editor.value.document,blocks=document.getLeafBlocksAtRange(range),wrappers=blocks.map(function(block){return document.getClosest(block.key,function(parent){return\"block\"!==parent.object||null!=properties.type&&\nparent.type!==properties.type||null!=properties.data&&!parent.data.isSuperset(properties.data)?!1:!0})}).filter(function(exists){return exists}).toOrderedSet().toList();editor.withoutNormalizing(function(){wrappers.forEach(function(block){var first=block.nodes.first(),last=block.nodes.last(),parent=editor.value.document.getParent(block.key),index=parent.nodes.indexOf(block),children=block.nodes.filter(function(child){return blocks.some(function(b){return child===b||child.hasDescendant(b.key)})}),\nfirstMatch=children.first(),lastMatch=children.last();first===firstMatch&&last===lastMatch?(block.nodes.forEach(function(child,i){editor.moveNodeByKey(child.key,parent.key,index+i)}),editor.removeNodeByKey(block.key)):last===lastMatch?block.nodes.skipUntil(function(n){return n===firstMatch}).forEach(function(child,i){editor.moveNodeByKey(child.key,parent.key,index+1+i)}):first===firstMatch?block.nodes.takeUntil(function(n){return n===lastMatch}).push(lastMatch).forEach(function(child,i){editor.moveNodeByKey(child.key,\nparent.key,index+i)}):(first=firstMatch.getFirstText(),editor.splitDescendantsByKey(block.key,first.key,0),document=editor.value.document,children.forEach(function(child,i){if(0===i){var extra=child;child=document.getNextBlock(child.key);editor.removeNodeByKey(extra.key)}editor.moveNodeByKey(child.key,parent.key,index+1+i)}))})})};Commands$1.unwrapInlineAtRange=function(editor,range,properties){properties=Node$jscomp$0.createProperties(properties);var document=editor.value.document,inlines=document.getTextsAtRange(range).map(function(text){return document.getClosest(text.key,\nfunction(parent){return\"inline\"!==parent.object||null!=properties.type&&parent.type!==properties.type||null!=properties.data&&!parent.data.isSuperset(properties.data)?!1:!0})}).filter(function(exists){return exists}).toOrderedSet().toList();editor.withoutNormalizing(function(){inlines.forEach(function(inline){var parent=editor.value.document.getParent(inline.key),index=parent.nodes.indexOf(inline);inline.nodes.forEach(function(child,i){editor.moveNodeByKey(child.key,parent.key,index+i)});editor.removeNodeByKey(inline.key)})})};\nCommands$1.wrapBlockAtRange=function(editor,range,block){block=Block.create(block);block=block.set(\"nodes\",block.nodes.clear());var document=editor.value.document;range=document.getLeafBlocksAtRange(range);var firstblock=range.first(),lastblock=range.last(),parent=void 0,siblings=void 0,index=void 0;1===range.length?(parent=document.getParent(firstblock.key),siblings=range):parent=document.getClosest(firstblock.key,function(p1){return!!document.getClosest(lastblock.key,function(p2){return p1===p2})});\nnull==parent&&(parent=document);null==siblings&&(range=parent.nodes.reduce(function(ind,node,i){if(node===firstblock||node.hasDescendant(firstblock.key))ind[0]=i;if(node===lastblock||node.hasDescendant(lastblock.key))ind[1]=i;return ind},[]),index=range[0],siblings=parent.nodes.slice(range[0],range[1]+1));null==index&&(index=parent.nodes.indexOf(siblings.first()));editor.withoutNormalizing(function(){editor.insertNodeByKey(parent.key,index,block);siblings.forEach(function(node,i){editor.moveNodeByKey(node.key,\nblock.key,i)})})};Commands$1.wrapInlineAtRange=function(editor,range,inline){var document=editor.value.document,start=range.start,end=range.end;if(range.isCollapsed){var inlineParent=document.getClosestInline(start.path);return inlineParent&&editor.isVoid(inlineParent)?editor.wrapInlineByKey(inlineParent.key,inline):void 0}inline=Inline.create(inline);inline=inline.set(\"nodes\",inline.nodes.clear());var blocks=document.getLeafBlocksAtRange(range),startBlock=document.getClosestBlock(start.path),endBlock=\ndocument.getClosestBlock(end.path),startInline=document.getClosestInline(start.path),endInline=document.getClosestInline(end.path),startChild=startBlock.getFurthestChild(start.key),endChild=endBlock.getFurthestChild(end.key);editor.withoutNormalizing(function(){startInline&&startInline===endInline||(editor.splitDescendantsByKey(endChild.key,end.key,end.offset),editor.splitDescendantsByKey(startChild.key,start.key,start.offset));document=editor.value.document;startBlock=document.getDescendant(startBlock.key);\nendBlock=document.getDescendant(endBlock.key);startChild=startBlock.getFurthestChild(start.key);endChild=endBlock.getFurthestChild(end.key);var startIndex=startBlock.nodes.indexOf(startChild),endIndex=endBlock.nodes.indexOf(endChild);if(startInline&&startInline===endInline)startIndex=startBlock.getTextsAtRange(range).map(function(text){return start.key===text.key&&end.key===text.key?text.splitText(start.offset)[1].splitText(end.offset-start.offset)[0].regenerateKey():start.key===text.key?text.splitText(start.offset)[1].regenerateKey():\nend.key===text.key?text.splitText(end.offset)[0].regenerateKey():text.regenerateKey()}),inline=inline.set(\"nodes\",startIndex),editor.insertInlineAtRange(range,inline);else if(startBlock===endBlock){document=editor.value.document;startBlock=document.getClosestBlock(start.key);startChild=startBlock.getFurthestChild(start.key);var startInner=document.getNextSibling(startChild.key);startIndex=startBlock.nodes.indexOf(startInner);var endInner=start.key===end.key?startInner:startBlock.getFurthestChild(end.key);\nendIndex=startBlock.nodes.skipUntil(function(n){return n===startInner}).takeUntil(function(n){return n===endInner}).push(endInner);var node$jscomp$0=inline.regenerateKey();editor.insertNodeByKey(startBlock.key,startIndex,node$jscomp$0);endIndex.forEach(function(child,i){editor.moveNodeByKey(child.key,node$jscomp$0.key,i)})}else{var startInlines=startBlock.nodes.slice(startIndex+1),endInlines=endBlock.nodes.slice(0,endIndex+1),startNode=inline.regenerateKey(),endNode=inline.regenerateKey();editor.insertNodeByKey(startBlock.key,\nstartIndex+1,startNode);editor.insertNodeByKey(endBlock.key,endIndex,endNode);startInlines.forEach(function(child,i){editor.moveNodeByKey(child.key,startNode.key,i)});endInlines.forEach(function(child,i){editor.moveNodeByKey(child.key,endNode.key,i)});blocks.slice(1,-1).forEach(function(block){var node=inline.regenerateKey();editor.insertNodeByKey(block.key,0,node);block.nodes.forEach(function(child,i){editor.moveNodeByKey(child.key,node.key,i)})})}})};Commands$1.wrapTextAtRange=function(editor,range,\nprefix){var suffix=3<arguments.length&&void 0!==arguments[3]?arguments[3]:prefix,start=range.start,end=range.end,startRange=range.moveToStart(),endRange=range.moveToEnd();start.path.equals(end.path)&&(endRange=endRange.moveForward(prefix.length));editor.withoutNormalizing(function(){editor.insertTextAtRange(startRange,prefix);editor.insertTextAtRange(endRange,suffix)})};var Commands$2={addMarkByPath:function(editor,path,offset,length,mark){mark=Mark.create(mark);editor.addMarksByPath(path,offset,\nlength,[mark])},addMarksByPath:function(editor,path,offset,length,marks){marks=Mark.createSet(marks);if(marks.size){var node=editor.value.document.assertNode(path);editor.withoutNormalizing(function(){offset+length<node.text.length&&editor.splitNodeByPath(path,offset+length);0<offset&&(editor.splitNodeByPath(path,offset),path=PathUtils.increment(path),offset=0);marks.forEach(function(mark){editor.applyOperation({type:\"add_mark\",path:path,mark:Mark.create(mark)})})})}},replaceMarksByPath:function(editor,\npath,offset,length,marks){var marksSet=Mark.createSet(marks),node=editor.value.document.assertNode(path);node.marks.equals(marksSet)||editor.withoutNormalizing(function(){offset+length<node.text.length&&editor.splitNodeByPath(path,offset+length);0<offset&&(editor.splitNodeByPath(path,offset),path=PathUtils.increment(path),offset=0);var marksToApply=marksSet.subtract(node.marks);node.marks.subtract(marksSet).forEach(function(mark){editor.applyOperation({type:\"remove_mark\",path:path,mark:Mark.create(mark)})});\nmarksToApply.forEach(function(mark){editor.applyOperation({type:\"add_mark\",path:path,mark:Mark.create(mark)})})})},insertFragmentByPath:function(editor,path,index,fragment){fragment.nodes.forEach(function(node,i){editor.insertNodeByPath(path,index+i,node)})},insertNodeByPath:function(editor,path,index,node){editor.applyOperation({type:\"insert_node\",path:path.concat(index),node:node})},insertTextByPath:function(editor,path,offset,text,marks){var value=editor.value,annotations=value.annotations;value.document.assertNode(path);\neditor.withoutNormalizing(function(){var _iteratorNormalCompletion=!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _iterator=annotations.values()[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=!0){var annotation=_step.value,start=annotation.start,end=annotation.end;editor.isAtomic(annotation)&&start.path.equals(path)&&start.offset<offset&&(!end.path.equals(path)||end.offset>offset)&&editor.removeAnnotation(annotation)}}catch(err){_didIteratorError=\n!0,_iteratorError=err}finally{try{!_iteratorNormalCompletion&&_iterator.return&&_iterator.return()}finally{if(_didIteratorError)throw _iteratorError;}}editor.applyOperation({type:\"insert_text\",path:path,offset:offset,text:text});marks&&editor.replaceMarksByPath(path,offset,text.length,marks)})},mergeNodeByPath:function(editor,path){var document=editor.value.document,original=document.getDescendant(path);document=document.getPreviousSibling(path);if(!document)throw Error('Unable to merge node with path \"'+\npath+'\", because it has no previous sibling.');editor.applyOperation({type:\"merge_node\",path:path,position:\"text\"===document.object?document.text.length:document.nodes.size,properties:{type:original.type,data:original.data},target:null})},moveNodeByPath:function(editor,path,newParentPath,newIndex){if(PathUtils.isEqual(path,newParentPath))return editor;newParentPath=newParentPath.concat(newIndex);if(PathUtils.isEqual(path,newParentPath))return editor;editor.applyOperation({type:\"move_node\",path:path,\nnewPath:newParentPath})},removeMarkByPath:function(editor,path,offset,length,mark){mark=Mark.create(mark);editor.removeMarksByPath(path,offset,length,[mark])},removeMarksByPath:function(editor,path,offset,length,marks){marks=Mark.createSet(marks);if(marks.size){var node=editor.value.document.assertNode(path);marks.intersect(node.marks).isEmpty()||editor.withoutNormalizing(function(){offset+length<node.text.length&&editor.splitNodeByPath(path,offset+length);0<offset&&(editor.splitNodeByPath(path,offset),\npath=PathUtils.increment(path),offset=0);marks.forEach(function(mark){editor.applyOperation({type:\"remove_mark\",path:path,offset:offset,length:length,mark:mark})})})}},removeAllMarksByPath:function(editor,path){var node=editor.state.document.assertNode(path);editor.withoutNormalizing(function(){if(\"text\"===node.object)editor.removeMarksByPath(path,0,node.text.length,node.marks);else{var _iteratorNormalCompletion2=!0,_didIteratorError2=!1,_iteratorError2=void 0;try{for(var _iterator2=node.texts()[Symbol.iterator](),\n_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=!0){var _ref2=slicedToArray(_step2.value,2),n=_ref2[0],pth=path.concat(_ref2[1]);editor.removeMarksByPath(pth,0,n.text.length,n.marks)}}catch(err){_didIteratorError2=!0,_iteratorError2=err}finally{try{!_iteratorNormalCompletion2&&_iterator2.return&&_iterator2.return()}finally{if(_didIteratorError2)throw _iteratorError2;}}}})},removeNodeByPath:function(editor,path){var node=editor.value.document.assertNode(path);\neditor.applyOperation({type:\"remove_node\",path:path,node:node})},removeTextByPath:function(editor,path,offset,length){var value=editor.value,annotations=value.annotations,text=value.document.assertNode(path).text.slice(offset,offset+length);editor.withoutNormalizing(function(){var _iteratorNormalCompletion3=!0,_didIteratorError3=!1,_iteratorError3=void 0;try{for(var _iterator3=annotations.values()[Symbol.iterator](),_step3;!(_iteratorNormalCompletion3=(_step3=_iterator3.next()).done);_iteratorNormalCompletion3=\n!0){var annotation=_step3.value,start=annotation.start,end=annotation.end;editor.isAtomic(annotation)&&start.path.equals(path)&&start.offset<offset&&(!end.path.equals(path)||end.offset>offset)&&editor.removeAnnotation(annotation)}}catch(err){_didIteratorError3=!0,_iteratorError3=err}finally{try{!_iteratorNormalCompletion3&&_iterator3.return&&_iterator3.return()}finally{if(_didIteratorError3)throw _iteratorError3;}}editor.applyOperation({type:\"remove_text\",path:path,offset:offset,text:text})})},replaceNodeByPath:function(editor,\npath,newNode){newNode=Node$jscomp$0.create(newNode);var index=path.last(),parentPath=PathUtils.lift(path);editor.withoutNormalizing(function(){editor.removeNodeByPath(path);editor.insertNodeByPath(parentPath,index,newNode)})},replaceTextByPath:function(editor,path,offset,length,text,marks){editor.withoutNormalizing(function(){editor.removeTextByPath(path,offset,length);editor.insertTextByPath(path,offset,text,marks)})},setMarkByPath:function(editor,path,offset,length,properties,newProperties){properties=\nMark.create(properties);newProperties=Mark.createProperties(newProperties);var node=editor.value.document.assertNode(path);editor.withoutNormalizing(function(){offset+length<node.text.length&&editor.splitNodeByPath(path,offset+length);0<offset&&(editor.splitNodeByPath(path,offset),path=PathUtils.increment(path),offset=0);editor.applyOperation({type:\"set_mark\",path:path,properties:properties,newProperties:newProperties})})},setNodeByPath:function(editor,path,newProperties){var node=editor.value.document.assertNode(path);\nnewProperties=Node$jscomp$0.createProperties(newProperties);node=pick(node,Object.keys(newProperties));editor.applyOperation({type:\"set_node\",path:path,properties:node,newProperties:newProperties})},setTextByPath:function(editor,path,text,marks){var end=editor.value.document.assertNode(path).text.length;editor.replaceTextByPath(path,0,end,text,marks)},splitNodeByPath:function(editor,path,position){var _options$target=(3<arguments.length&&void 0!==arguments[3]?arguments[3]:{}).target;_options$target=\nvoid 0===_options$target?null:_options$target;var node=editor.value.document.getDescendant(path);editor.applyOperation({type:\"split_node\",path:path,position:position,target:_options$target,properties:{type:node.type,data:node.data}})},splitDescendantsByPath:function(editor,path,textPath,textOffset){if(path.equals(textPath))editor.splitNodeByPath(textPath,textOffset);else{var document=editor.value.document,index=textOffset,lastPath=textPath;editor.withoutNormalizing(function(){editor.splitNodeByKey(textPath,\ntextOffset);var _iteratorNormalCompletion4=!0,_didIteratorError4=!1,_iteratorError4=void 0;try{for(var _iterator4=document.ancestors(textPath)[Symbol.iterator](),_step4;!(_iteratorNormalCompletion4=(_step4=_iterator4.next()).done);_iteratorNormalCompletion4=!0){var ancestorPath=slicedToArray(_step4.value,2)[1],target=index;index=lastPath.last()+1;lastPath=ancestorPath;editor.splitNodeByPath(ancestorPath,index,{target:target});if(ancestorPath.equals(path))break}}catch(err){_didIteratorError4=!0,_iteratorError4=\nerr}finally{try{!_iteratorNormalCompletion4&&_iterator4.return&&_iterator4.return()}finally{if(_didIteratorError4)throw _iteratorError4;}}})}},unwrapInlineByPath:function(editor,path,properties){var value=editor.value,selection=value.selection;value=value.document.assertNode(path);path=value.getFirstText();value=value.getLastText();selection=selection.moveToRangeOfNode(path,value);editor.unwrapInlineAtRange(selection,properties)},unwrapBlockByPath:function(editor,path,properties){var value=editor.value,\nselection=value.selection;value=value.document.assertNode(path);path=value.getFirstText();value=value.getLastText();selection=selection.moveToRangeOfNode(path,value);editor.unwrapBlockAtRange(selection,properties)},unwrapNodeByPath:function(editor,path){var document=editor.value.document;document.assertNode(path);var parentPath=PathUtils.lift(path),parent=document.assertNode(parentPath),index=path.last(),parentIndex=parentPath.last(),grandPath=PathUtils.lift(parentPath),isFirst=0===index,isLast=index===\nparent.nodes.size-1;editor.withoutNormalizing(function(){if(1===parent.nodes.size)editor.moveNodeByPath(path,grandPath,parentIndex+1),editor.removeNodeByPath(parentPath);else if(isFirst)editor.moveNodeByPath(path,grandPath,parentIndex);else if(isLast)editor.moveNodeByPath(path,grandPath,parentIndex+1);else{var updatedPath=PathUtils.increment(path,1,parentPath.size-1);updatedPath=updatedPath.set(updatedPath.size-1,0);editor.splitNodeByPath(parentPath,index);editor.moveNodeByPath(updatedPath,grandPath,\nparentIndex+1)}})},unwrapChildrenByPath:function(editor,path){path=PathUtils.create(path);var node=editor.value.document.assertNode(path),parentPath=PathUtils.lift(path),index=path.last(),nodes=node.nodes;editor.withoutNormalizing(function(){nodes.reverse().forEach(function(child,i){child=path.push(nodes.size-i-1);editor.moveNodeByPath(child,parentPath,index+1)});editor.removeNodeByPath(path)})},wrapBlockByPath:function(editor,path,block){block=Block.create(block);block=block.set(\"nodes\",block.nodes.clear());\nvar parentPath=PathUtils.lift(path),index=path.last(),newPath=PathUtils.increment(path);editor.withoutNormalizing(function(){editor.insertNodeByPath(parentPath,index,block);editor.moveNodeByPath(newPath,path,0)})},wrapInlineByPath:function(editor,path,inline){inline=Inline.create(inline);inline=inline.set(\"nodes\",inline.nodes.clear());var parentPath=PathUtils.lift(path),index=path.last(),newPath=PathUtils.increment(path);editor.withoutNormalizing(function(){editor.insertNodeByPath(parentPath,index,\ninline);editor.moveNodeByPath(newPath,path,0)})},wrapNodeByPath:function(editor,path,node){node=Node$jscomp$0.create(node);\"block\"===node.object?editor.wrapBlockByPath(path,node):\"inline\"===node.object&&editor.wrapInlineByPath(path,node)}},COMMANDS=\"addMark insertFragment insertNode insertText mergeNode removeAllMarks removeMark removeNode removeText replaceMarks replaceNode replaceText setMark setNode setText splitNode unwrapBlock unwrapChildren unwrapInline unwrapNode wrapBlock wrapInline wrapNode\".split(\" \"),\n_loop=function(method){Commands$2[method+\"ByKey\"]=function(editor,key){for(var _len3=arguments.length,args=Array(2<_len3?_len3-2:0),_key3=2;_key3<_len3;_key3++)args[_key3-2]=arguments[_key3];_len3=editor.value.document.assertPath(key);editor[method+\"ByPath\"].apply(editor,[_len3].concat(args))}},_iteratorNormalCompletion5=!0,_didIteratorError5=!1,_iteratorError5=void 0;try{for(var _iterator5=COMMANDS[Symbol.iterator](),_step5;!(_iteratorNormalCompletion5=(_step5=_iterator5.next()).done);_iteratorNormalCompletion5=\n!0)_loop(_step5.value)}catch(err){_didIteratorError5=!0,_iteratorError5=err}finally{try{!_iteratorNormalCompletion5&&_iterator5.return&&_iterator5.return()}finally{if(_didIteratorError5)throw _iteratorError5;}}Commands$2.moveNodeByKey=function(editor,key,newKey){for(var _len=arguments.length,args=Array(3<_len?_len-3:0),_key=3;_key<_len;_key++)args[_key-3]=arguments[_key];_key=editor.value.document;_len=_key.assertPath(key);_key=_key.assertPath(newKey);editor.moveNodeByPath.apply(editor,[_len,_key].concat(args))};\nCommands$2.splitDescendantsByKey=function(editor,key,textKey){for(var _len2=arguments.length,args=Array(3<_len2?_len2-3:0),_key2=3;_key2<_len2;_key2++)args[_key2-3]=arguments[_key2];_key2=editor.value.document;_len2=_key2.assertPath(key);_key2=_key2.assertPath(textKey);editor.splitDescendantsByPath.apply(editor,[_len2,_key2].concat(args))};var Commands$3={save:function(editor,operation){var operations=editor.operations,data=editor.value.data,_editor$tmp=editor.tmp,merge=_editor$tmp.merge;if(!1!==\n_editor$tmp.save&&isValidOperation(operation)){var undos=data.get(\"undos\")||immutable.List(),lastOperation=(_editor$tmp=undos.last())&&_editor$tmp.last();null==merge&&(merge=0!==operations.size?!0:shouldMerge(operation,lastOperation));merge&&_editor$tmp?(operation=_editor$tmp.push(operation),undos=undos.pop(),undos=undos.push(operation)):(operation=immutable.List([operation]),undos=undos.push(operation));100<undos.size&&(undos=undos.takeLast(100));editor.withoutSaving(function(){var redos=immutable.List();\nredos=data.set(\"undos\",undos).set(\"redos\",redos);editor.setData(redos)})}},redo:function(editor){var data=editor.value.data,redos=data.get(\"redos\")||immutable.List(),undos=data.get(\"undos\")||immutable.List(),batch=redos.last();batch&&editor.withoutSaving(function(){editor.withoutNormalizing(function(){batch.forEach(function(op){var _op=op,newProperties=_op.newProperties;\"set_selection\"===_op.type&&(op=op.set(\"newProperties\",omit(newProperties,\"isFocused\")));editor.applyOperation(op)});redos=redos.pop();\nundos=undos.push(batch);var newData=data.set(\"undos\",undos).set(\"redos\",redos);editor.setData(newData)})})},undo:function(editor){var data=editor.value.data,redos=data.get(\"redos\")||immutable.List(),undos=data.get(\"undos\")||immutable.List(),batch=undos.last();batch&&editor.withoutSaving(function(){editor.withoutNormalizing(function(){batch.slice().reverse().map(function(op){return op.invert()}).forEach(function(inverse){var _inverse=inverse,newProperties=_inverse.newProperties;\"set_selection\"===_inverse.type&&\n(inverse=inverse.set(\"newProperties\",omit(newProperties,\"isFocused\")));editor.applyOperation(inverse)});redos=redos.push(batch);undos=undos.pop();var newData=data.set(\"undos\",undos).set(\"redos\",redos);editor.setData(newData)})})},withoutMerging:function(editor,fn){var value=editor.tmp.merge;editor.tmp.merge=!1;fn(editor);editor.tmp.merge=value},withoutSaving:function(editor,fn){var value=editor.tmp.save;editor.tmp.save=!1;fn(editor);editor.tmp.save=value}},Commands$4={blur:function(editor){editor.select({isFocused:!1})},\ndeselect:function(editor){var range=Selection$jscomp$0.create();editor.select(range)},focus:function(editor){editor.select({isFocused:!0})},flip:function(editor){editor.command(proxy,\"flip\")},moveAnchorBackward:function(editor){for(var _len=arguments.length,args=Array(1<_len?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];editor.command.apply(editor,[pointBackward,\"anchor\"].concat(args))},moveAnchorWordBackward:function(editor){for(var _len2=arguments.length,args=Array(1<_len2?_len2-\n1:0),_key2=1;_key2<_len2;_key2++)args[_key2-1]=arguments[_key2];editor.command.apply(editor,[pointWordBackward,\"anchor\"].concat(args))},moveAnchorForward:function(editor){for(var _len3=arguments.length,args=Array(1<_len3?_len3-1:0),_key3=1;_key3<_len3;_key3++)args[_key3-1]=arguments[_key3];editor.command.apply(editor,[pointForward,\"anchor\"].concat(args))},moveAnchorWordForward:function(editor){for(var _len4=arguments.length,args=Array(1<_len4?_len4-1:0),_key4=1;_key4<_len4;_key4++)args[_key4-1]=arguments[_key4];\neditor.command.apply(editor,[pointWordForward,\"anchor\"].concat(args))},moveAnchorTo:function(editor){for(var _len5=arguments.length,args=Array(1<_len5?_len5-1:0),_key5=1;_key5<_len5;_key5++)args[_key5-1]=arguments[_key5];editor.command.apply(editor,[proxy,\"moveAnchorTo\"].concat(args))},moveAnchorToEndOfBlock:function(editor){editor.command(pointEdgeObject,\"anchor\",\"end\",\"block\")},moveAnchorToEndOfInline:function(editor){editor.command(pointEdgeObject,\"anchor\",\"end\",\"inline\")},moveAnchorToEndOfDocument:function(editor){editor.moveAnchorToEndOfNode(editor.value.document).moveToAnchor()},\nmoveAnchorToEndOfNextBlock:function(editor){editor.command(pointEdgeSideObject,\"anchor\",\"end\",\"next\",\"block\")},moveAnchorToEndOfNextInline:function(editor){editor.command(pointEdgeSideObject,\"anchor\",\"end\",\"next\",\"inline\")},moveAnchorToEndOfNextText:function(editor){editor.command(pointEdgeSideObject,\"anchor\",\"end\",\"next\",\"text\")},moveAnchorToEndOfNode:function(editor){for(var _len6=arguments.length,args=Array(1<_len6?_len6-1:0),_key6=1;_key6<_len6;_key6++)args[_key6-1]=arguments[_key6];editor.command.apply(editor,\n[proxy,\"moveAnchorToEndOfNode\"].concat(args))},moveAnchorToEndOfPreviousBlock:function(editor){editor.command(pointEdgeSideObject,\"anchor\",\"end\",\"previous\",\"block\")},moveAnchorToEndOfPreviousInline:function(editor){editor.command(pointEdgeSideObject,\"anchor\",\"end\",\"previous\",\"inline\")},moveAnchorToEndOfPreviousText:function(editor){editor.command(pointEdgeSideObject,\"anchor\",\"end\",\"previous\",\"text\")},moveAnchorToEndOfText:function(editor){editor.command(pointEdgeObject,\"anchor\",\"end\",\"text\")},moveAnchorToStartOfBlock:function(editor){editor.command(pointEdgeObject,\n\"anchor\",\"start\",\"block\")},moveAnchorToStartOfDocument:function(editor){editor.moveAnchorToStartOfNode(editor.value.document).moveToAnchor()},moveAnchorToStartOfInline:function(editor){editor.command(pointEdgeObject,\"anchor\",\"start\",\"inline\")},moveAnchorToStartOfNextBlock:function(editor){editor.command(pointEdgeSideObject,\"anchor\",\"start\",\"next\",\"block\")},moveAnchorToStartOfNextInline:function(editor){editor.command(pointEdgeSideObject,\"anchor\",\"start\",\"next\",\"inline\")},moveAnchorToStartOfNextText:function(editor){editor.command(pointEdgeSideObject,\n\"anchor\",\"start\",\"next\",\"text\")},moveAnchorToStartOfNode:function(editor){for(var _len7=arguments.length,args=Array(1<_len7?_len7-1:0),_key7=1;_key7<_len7;_key7++)args[_key7-1]=arguments[_key7];editor.command.apply(editor,[proxy,\"moveAnchorToStartOfNode\"].concat(args))},moveAnchorToStartOfPreviousBlock:function(editor){editor.command(pointEdgeSideObject,\"anchor\",\"start\",\"previous\",\"block\")},moveAnchorToStartOfPreviousInline:function(editor){editor.command(pointEdgeSideObject,\"anchor\",\"start\",\"previous\",\n\"inline\")},moveAnchorToStartOfPreviousText:function(editor){editor.command(pointEdgeSideObject,\"anchor\",\"start\",\"previous\",\"text\")},moveAnchorToStartOfText:function(editor){editor.command(pointEdgeObject,\"anchor\",\"start\",\"text\")},moveBackward:function(editor){var chars=1<arguments.length&&void 0!==arguments[1]?arguments[1]:1;if(0!==chars){var value=editor.value,start=value.selection.start;value=value.document.getClosestBlock(start.key);start=value.getOffset(start.key)+start.offset;chars=TextUtils.getCharOffsetBackward(value.text,\nstart,chars);editor.moveAnchorBackward(chars).moveFocusBackward(chars)}},moveWordBackward:function(editor){for(var _len8=arguments.length,args=Array(1<_len8?_len8-1:0),_key8=1;_key8<_len8;_key8++)args[_key8-1]=arguments[_key8];editor.moveFocusWordBackward.apply(editor,args).moveToFocus()},moveEndBackward:function(editor){for(var _len9=arguments.length,args=Array(1<_len9?_len9-1:0),_key9=1;_key9<_len9;_key9++)args[_key9-1]=arguments[_key9];editor.command.apply(editor,[pointBackward,\"end\"].concat(args))},\nmoveEndWordBackward:function(editor){for(var _len10=arguments.length,args=Array(1<_len10?_len10-1:0),_key10=1;_key10<_len10;_key10++)args[_key10-1]=arguments[_key10];editor.command.apply(editor,[pointWordBackward,\"end\"].concat(args))},moveEndForward:function(editor){for(var _len11=arguments.length,args=Array(1<_len11?_len11-1:0),_key11=1;_key11<_len11;_key11++)args[_key11-1]=arguments[_key11];editor.command.apply(editor,[pointForward,\"end\"].concat(args))},moveEndWordForward:function(editor){for(var _len12=\narguments.length,args=Array(1<_len12?_len12-1:0),_key12=1;_key12<_len12;_key12++)args[_key12-1]=arguments[_key12];editor.command.apply(editor,[pointWordForward,\"end\"].concat(args))},moveEndTo:function(editor){for(var _len13=arguments.length,args=Array(1<_len13?_len13-1:0),_key13=1;_key13<_len13;_key13++)args[_key13-1]=arguments[_key13];editor.command.apply(editor,[proxy,\"moveEndTo\"].concat(args))},moveEndToEndOfBlock:function(editor){editor.command(pointEdgeObject,\"end\",\"end\",\"block\")},moveEndToEndOfDocument:function(editor){editor.moveEndToEndOfNode(editor.value.document).moveToEnd()},\nmoveEndToEndOfInline:function(editor){editor.command(pointEdgeObject,\"end\",\"end\",\"inline\")},moveEndToEndOfNextBlock:function(editor){editor.command(pointEdgeSideObject,\"end\",\"end\",\"next\",\"block\")},moveEndToEndOfNextInline:function(editor){editor.command(pointEdgeSideObject,\"end\",\"end\",\"next\",\"inline\")},moveEndToEndOfNextText:function(editor){editor.command(pointEdgeSideObject,\"end\",\"end\",\"next\",\"text\")},moveEndToEndOfNode:function(editor){for(var _len14=arguments.length,args=Array(1<_len14?_len14-\n1:0),_key14=1;_key14<_len14;_key14++)args[_key14-1]=arguments[_key14];editor.command.apply(editor,[proxy,\"moveEndToEndOfNode\"].concat(args))},moveEndToEndOfPreviousBlock:function(editor){editor.command(pointEdgeSideObject,\"end\",\"end\",\"previous\",\"block\")},moveEndToEndOfPreviousInline:function(editor){editor.command(pointEdgeSideObject,\"end\",\"end\",\"previous\",\"inline\")},moveEndToEndOfPreviousText:function(editor){editor.command(pointEdgeSideObject,\"end\",\"end\",\"previous\",\"text\")},moveEndToEndOfText:function(editor){editor.command(pointEdgeObject,\n\"end\",\"end\",\"text\")},moveEndToStartOfBlock:function(editor){editor.command(pointEdgeObject,\"end\",\"start\",\"block\")},moveEndToStartOfDocument:function(editor){editor.moveEndToStartOfNode(editor.value.document).moveToEnd()},moveEndToStartOfInline:function(editor){editor.command(pointEdgeObject,\"end\",\"start\",\"inline\")},moveEndToStartOfNextBlock:function(editor){editor.command(pointEdgeSideObject,\"end\",\"start\",\"next\",\"block\")},moveEndToStartOfNextInline:function(editor){editor.command(pointEdgeSideObject,\n\"end\",\"start\",\"next\",\"inline\")},moveEndToStartOfNextText:function(editor){editor.command(pointEdgeSideObject,\"end\",\"start\",\"next\",\"text\")},moveEndToStartOfNode:function(editor){for(var _len15=arguments.length,args=Array(1<_len15?_len15-1:0),_key15=1;_key15<_len15;_key15++)args[_key15-1]=arguments[_key15];editor.command.apply(editor,[proxy,\"moveEndToStartOfNode\"].concat(args))},moveEndToStartOfPreviousBlock:function(editor){editor.command(pointEdgeSideObject,\"end\",\"start\",\"previous\",\"block\")},moveEndToStartOfPreviousInline:function(editor){editor.command(pointEdgeSideObject,\n\"end\",\"start\",\"previous\",\"inline\")},moveEndToStartOfPreviousText:function(editor){editor.command(pointEdgeSideObject,\"end\",\"start\",\"previous\",\"text\")},moveEndToStartOfText:function(editor){editor.command(pointEdgeObject,\"end\",\"start\",\"text\")},moveFocusBackward:function(editor){for(var _len16=arguments.length,args=Array(1<_len16?_len16-1:0),_key16=1;_key16<_len16;_key16++)args[_key16-1]=arguments[_key16];editor.command.apply(editor,[pointBackward,\"focus\"].concat(args))},moveFocusWordBackward:function(editor){for(var _len17=\narguments.length,args=Array(1<_len17?_len17-1:0),_key17=1;_key17<_len17;_key17++)args[_key17-1]=arguments[_key17];editor.command.apply(editor,[pointWordBackward,\"focus\"].concat(args))},moveFocusForward:function(editor){for(var _len18=arguments.length,args=Array(1<_len18?_len18-1:0),_key18=1;_key18<_len18;_key18++)args[_key18-1]=arguments[_key18];editor.command.apply(editor,[pointForward,\"focus\"].concat(args))},moveFocusWordForward:function(editor){for(var _len19=arguments.length,args=Array(1<_len19?\n_len19-1:0),_key19=1;_key19<_len19;_key19++)args[_key19-1]=arguments[_key19];editor.command.apply(editor,[pointWordForward,\"focus\"].concat(args))},moveFocusTo:function(editor){for(var _len20=arguments.length,args=Array(1<_len20?_len20-1:0),_key20=1;_key20<_len20;_key20++)args[_key20-1]=arguments[_key20];editor.command.apply(editor,[proxy,\"moveFocusTo\"].concat(args))},moveFocusToEndOfBlock:function(editor){editor.command(pointEdgeObject,\"focus\",\"end\",\"block\")},moveFocusToEndOfDocument:function(editor){editor.moveFocusToEndOfNode(editor.value.document).moveToFocus()},\nmoveFocusToEndOfInline:function(editor){editor.command(pointEdgeObject,\"focus\",\"end\",\"inline\")},moveFocusToEndOfNextBlock:function(editor){editor.command(pointEdgeSideObject,\"focus\",\"end\",\"next\",\"block\")},moveFocusToEndOfNextInline:function(editor){editor.command(pointEdgeSideObject,\"focus\",\"end\",\"next\",\"inline\")},moveFocusToEndOfNextText:function(editor){editor.command(pointEdgeSideObject,\"focus\",\"end\",\"next\",\"text\")},moveFocusToEndOfNode:function(editor){for(var _len21=arguments.length,args=Array(1<\n_len21?_len21-1:0),_key21=1;_key21<_len21;_key21++)args[_key21-1]=arguments[_key21];editor.command.apply(editor,[proxy,\"moveFocusToEndOfNode\"].concat(args))},moveFocusToEndOfPreviousBlock:function(editor){editor.command(pointEdgeSideObject,\"focus\",\"end\",\"previous\",\"block\")},moveFocusToEndOfPreviousInline:function(editor){editor.command(pointEdgeSideObject,\"focus\",\"end\",\"previous\",\"inline\")},moveFocusToEndOfPreviousText:function(editor){editor.command(pointEdgeSideObject,\"focus\",\"end\",\"previous\",\"text\")},\nmoveFocusToEndOfText:function(editor){editor.command(pointEdgeObject,\"focus\",\"end\",\"text\")},moveFocusToStartOfBlock:function(editor){editor.command(pointEdgeObject,\"focus\",\"start\",\"block\")},moveFocusToStartOfDocument:function(editor){editor.moveFocusToStartOfNode(editor.value.document).moveToFocus()},moveFocusToStartOfInline:function(editor){editor.command(pointEdgeObject,\"focus\",\"start\",\"inline\")},moveFocusToStartOfNextBlock:function(editor){editor.command(pointEdgeSideObject,\"focus\",\"start\",\"next\",\n\"block\")},moveFocusToStartOfNextInline:function(editor){editor.command(pointEdgeSideObject,\"focus\",\"start\",\"next\",\"inline\")},moveFocusToStartOfNextText:function(editor){editor.command(pointEdgeSideObject,\"focus\",\"start\",\"next\",\"text\")},moveFocusToStartOfNode:function(editor){for(var _len22=arguments.length,args=Array(1<_len22?_len22-1:0),_key22=1;_key22<_len22;_key22++)args[_key22-1]=arguments[_key22];editor.command.apply(editor,[proxy,\"moveFocusToStartOfNode\"].concat(args))},moveFocusToStartOfPreviousBlock:function(editor){editor.command(pointEdgeSideObject,\n\"focus\",\"start\",\"previous\",\"block\")},moveFocusToStartOfPreviousInline:function(editor){editor.command(pointEdgeSideObject,\"focus\",\"start\",\"previous\",\"inline\")},moveFocusToStartOfPreviousText:function(editor){editor.command(pointEdgeSideObject,\"focus\",\"start\",\"previous\",\"text\")},moveFocusToStartOfText:function(editor){editor.command(pointEdgeObject,\"focus\",\"start\",\"text\")},moveForward:function(editor){var chars=1<arguments.length&&void 0!==arguments[1]?arguments[1]:1;if(0!==chars){var value=editor.value,\nstart=value.selection.start;value=value.document.getClosestBlock(start.path);start=value.getOffset(start.key)+start.offset;chars=TextUtils.getCharOffsetForward(value.text,start,chars);editor.moveAnchorForward(chars).moveFocusForward(chars)}},moveWordForward:function(editor){for(var _editor$moveFocusWord,_len23=arguments.length,args=Array(1<_len23?_len23-1:0),_key23=1;_key23<_len23;_key23++)args[_key23-1]=arguments[_key23];(_editor$moveFocusWord=editor.moveFocusWordForward.apply(editor,args)).moveToFocus.apply(_editor$moveFocusWord,\nargs)},moveStartBackward:function(editor){for(var _len24=arguments.length,args=Array(1<_len24?_len24-1:0),_key24=1;_key24<_len24;_key24++)args[_key24-1]=arguments[_key24];editor.command.apply(editor,[pointBackward,\"start\"].concat(args))},moveStartWordBackward:function(editor){for(var _len25=arguments.length,args=Array(1<_len25?_len25-1:0),_key25=1;_key25<_len25;_key25++)args[_key25-1]=arguments[_key25];editor.command.apply(editor,[pointWordBackward,\"start\"].concat(args))},moveStartForward:function(editor){for(var _len26=\narguments.length,args=Array(1<_len26?_len26-1:0),_key26=1;_key26<_len26;_key26++)args[_key26-1]=arguments[_key26];editor.command.apply(editor,[pointForward,\"start\"].concat(args))},moveStartWordForward:function(editor){for(var _len27=arguments.length,args=Array(1<_len27?_len27-1:0),_key27=1;_key27<_len27;_key27++)args[_key27-1]=arguments[_key27];editor.command.apply(editor,[pointWordForward,\"start\"].concat(args))},moveStartTo:function(editor){for(var _len28=arguments.length,args=Array(1<_len28?_len28-\n1:0),_key28=1;_key28<_len28;_key28++)args[_key28-1]=arguments[_key28];editor.command.apply(editor,[proxy,\"moveStartTo\"].concat(args))},moveStartToEndOfBlock:function(editor){editor.command(pointEdgeObject,\"start\",\"end\",\"block\")},moveStartToEndOfDocument:function(editor){editor.moveStartToEndOfNode(editor.value.document).moveToStart()},moveStartToEndOfInline:function(editor){editor.command(pointEdgeObject,\"start\",\"end\",\"inline\")},moveStartToEndOfNextBlock:function(editor){editor.command(pointEdgeSideObject,\n\"start\",\"end\",\"next\",\"block\")},moveStartToEndOfNextInline:function(editor){editor.command(pointEdgeSideObject,\"start\",\"end\",\"next\",\"inline\")},moveStartToEndOfNextText:function(editor){editor.command(pointEdgeSideObject,\"start\",\"end\",\"next\",\"text\")},moveStartToEndOfNode:function(editor){for(var _len29=arguments.length,args=Array(1<_len29?_len29-1:0),_key29=1;_key29<_len29;_key29++)args[_key29-1]=arguments[_key29];editor.command.apply(editor,[proxy,\"moveStartToEndOfNode\"].concat(args))},moveStartToEndOfPreviousBlock:function(editor){editor.command(pointEdgeSideObject,\n\"start\",\"end\",\"previous\",\"block\")},moveStartToEndOfPreviousInline:function(editor){editor.command(pointEdgeSideObject,\"start\",\"end\",\"previous\",\"inline\")},moveStartToEndOfPreviousText:function(editor){editor.command(pointEdgeSideObject,\"start\",\"end\",\"previous\",\"text\")},moveStartToEndOfText:function(editor){editor.command(pointEdgeObject,\"start\",\"end\",\"text\")},moveStartToStartOfBlock:function(editor){editor.command(pointEdgeObject,\"start\",\"start\",\"block\")},moveStartToStartOfDocument:function(editor){editor.moveStartToStartOfNode(editor.value.document).moveToStart()},\nmoveStartToStartOfInline:function(editor){editor.command(pointEdgeObject,\"start\",\"start\",\"inline\")},moveStartToStartOfNextBlock:function(editor){editor.command(pointEdgeSideObject,\"start\",\"start\",\"next\",\"block\")},moveStartToStartOfNextInline:function(editor){editor.command(pointEdgeSideObject,\"start\",\"start\",\"next\",\"inline\")},moveStartToStartOfNextText:function(editor){editor.command(pointEdgeSideObject,\"start\",\"start\",\"next\",\"text\")},moveStartToStartOfNode:function(editor){for(var _len30=arguments.length,\nargs=Array(1<_len30?_len30-1:0),_key30=1;_key30<_len30;_key30++)args[_key30-1]=arguments[_key30];editor.command.apply(editor,[proxy,\"moveStartToStartOfNode\"].concat(args))},moveStartToStartOfPreviousBlock:function(editor){editor.command(pointEdgeSideObject,\"start\",\"start\",\"previous\",\"block\")},moveStartToStartOfPreviousInline:function(editor){editor.command(pointEdgeSideObject,\"start\",\"start\",\"previous\",\"inline\")},moveStartToStartOfPreviousText:function(editor){editor.command(pointEdgeSideObject,\"start\",\n\"start\",\"previous\",\"text\")},moveStartToStartOfText:function(editor){editor.command(pointEdgeObject,\"start\",\"start\",\"text\")},moveTo:function(editor){for(var _len31=arguments.length,args=Array(1<_len31?_len31-1:0),_key31=1;_key31<_len31;_key31++)args[_key31-1]=arguments[_key31];editor.command.apply(editor,[proxy,\"moveTo\"].concat(args))},moveToAnchor:function(editor){editor.command(proxy,\"moveToAnchor\")},moveToEnd:function(editor){editor.command(proxy,\"moveToEnd\")},moveToEndOfBlock:function(editor){editor.moveEndToEndOfBlock().moveToEnd()},\nmoveToEndOfDocument:function(editor){editor.moveEndToEndOfNode(editor.value.document).moveToEnd()},moveToEndOfInline:function(editor){editor.moveEndToEndOfInline().moveToEnd()},moveToEndOfNextBlock:function(editor){editor.moveEndToEndOfNextBlock().moveToEnd()},moveToEndOfNextInline:function(editor){editor.moveEndToEndOfNextInline().moveToEnd()},moveToEndOfNextText:function(editor){editor.moveEndToEndOfNextText().moveToEnd()},moveToEndOfNode:function(editor){for(var _len32=arguments.length,args=Array(1<\n_len32?_len32-1:0),_key32=1;_key32<_len32;_key32++)args[_key32-1]=arguments[_key32];editor.command.apply(editor,[proxy,\"moveToEndOfNode\"].concat(args))},moveToEndOfPreviousBlock:function(editor){editor.moveStartToEndOfPreviousBlock().moveToStart()},moveToEndOfPreviousInline:function(editor){editor.moveStartToEndOfPreviousInline().moveToStart()},moveToEndOfPreviousText:function(editor){editor.moveStartToEndOfPreviousText().moveToStart()},moveToEndOfText:function(editor){editor.moveEndToEndOfText().moveToEnd()},\nmoveToFocus:function(editor){editor.command(proxy,\"moveToFocus\")},moveToRangeOfDocument:function(editor){editor.moveToRangeOfNode(editor.value.document)},moveToRangeOfNode:function(editor){for(var _len33=arguments.length,args=Array(1<_len33?_len33-1:0),_key33=1;_key33<_len33;_key33++)args[_key33-1]=arguments[_key33];editor.command.apply(editor,[proxy,\"moveToRangeOfNode\"].concat(args))},moveToStart:function(editor){editor.command(proxy,\"moveToStart\")},moveToStartOfBlock:function(editor){editor.moveStartToStartOfBlock().moveToStart()},\nmoveToStartOfDocument:function(editor){editor.moveStartToStartOfNode(editor.value.document).moveToStart()},moveToStartOfInline:function(editor){editor.moveStartToStartOfInline().moveToStart()},moveToStartOfNextBlock:function(editor){editor.moveEndToStartOfNextBlock().moveToEnd()},moveToStartOfNextInline:function(editor){editor.moveEndToStartOfNextInline().moveToEnd()},moveToStartOfNextText:function(editor){editor.moveEndToStartOfNextText().moveToEnd()},moveToStartOfNode:function(editor){for(var _len34=\narguments.length,args=Array(1<_len34?_len34-1:0),_key34=1;_key34<_len34;_key34++)args[_key34-1]=arguments[_key34];editor.command.apply(editor,[proxy,\"moveToStartOfNode\"].concat(args))},moveToStartOfPreviousBlock:function(editor){editor.moveStartToStartOfPreviousBlock().moveToStart()},moveToStartOfPreviousInline:function(editor){editor.moveStartToStartOfPreviousInline().moveToStart()},moveToStartOfPreviousText:function(editor){editor.moveStartToStartOfPreviousText().moveToStart()},moveToStartOfText:function(editor){editor.moveStartToStartOfText().moveToStart()},\nselect:function(editor,properties){var options=2<arguments.length&&void 0!==arguments[2]?arguments[2]:{};properties=Selection$jscomp$0.createProperties(properties);options=options.snapshot;options=void 0===options?!1:options;var value=editor.value,document=value.document,selection=value.selection,newProperties={},next=selection.setProperties(properties);next=document.resolveSelection(next);properties=pick(next,Object.keys(properties));for(var k in properties)!0!==options&&immutable.is(properties[k],\nselection[k])||(newProperties[k]=properties[k]);selection.marks&&!newProperties.marks&&(newProperties.anchor||newProperties.focus)&&(newProperties.marks=null);0!==Object.keys(newProperties).length&&(k=pick(selection.toJSON(),Object.keys(newProperties)),editor.applyOperation({type:\"set_selection\",value:value,properties:k,newProperties:newProperties},options?{skip:!1,merge:!1}:{}))},setAnchor:function(editor){for(var _len35=arguments.length,args=Array(1<_len35?_len35-1:0),_key35=1;_key35<_len35;_key35++)args[_key35-\n1]=arguments[_key35];editor.command.apply(editor,[proxy,\"setAnchor\"].concat(args))},setEnd:function(editor){for(var _len36=arguments.length,args=Array(1<_len36?_len36-1:0),_key36=1;_key36<_len36;_key36++)args[_key36-1]=arguments[_key36];editor.command.apply(editor,[proxy,\"setEnd\"].concat(args))},setFocus:function(editor){for(var _len37=arguments.length,args=Array(1<_len37?_len37-1:0),_key37=1;_key37<_len37;_key37++)args[_key37-1]=arguments[_key37];editor.command.apply(editor,[proxy,\"setFocus\"].concat(args))},\nsetStart:function(editor){for(var _len38=arguments.length,args=Array(1<_len38?_len38-1:0),_key38=1;_key38<_len38;_key38++)args[_key38-1]=arguments[_key38];editor.command.apply(editor,[proxy,\"setStart\"].concat(args))},snapshotSelection:function(editor){editor.withoutMerging(function(){editor.select(editor.value.selection,{snapshot:!0})})}},Commands$5={setData:function(editor){var value=editor.value,newProperties=Value.createProperties({data:1<arguments.length&&void 0!==arguments[1]?arguments[1]:{}});\nvalue=pick(value,Object.keys(newProperties));editor.applyOperation({type:\"set_value\",properties:value,newProperties:newProperties})},addAnnotation:function(editor,annotation){annotation=Annotation.create(annotation);editor.applyOperation({type:\"add_annotation\",annotation:annotation})},removeAnnotation:function(editor,annotation){annotation=Annotation.create(annotation);editor.applyOperation({type:\"remove_annotation\",annotation:annotation})},setAnnotation:function(editor,annotation,newProperties){annotation=\nAnnotation.create(annotation);newProperties=Annotation.createProperties(newProperties);editor.applyOperation({type:\"set_annotation\",properties:annotation,newProperties:newProperties})},setAnnotations:function(editor){var value=editor.value,newProperties=Value.createProperties({annotations:1<arguments.length&&void 0!==arguments[1]?arguments[1]:[]});value=pick(value,Object.keys(newProperties));editor.applyOperation({type:\"set_value\",properties:value,newProperties:newProperties})}},SlateError=function(_Error){function SlateError(code){var attrs=\n1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};classCallCheck(this,SlateError);var _this=possibleConstructorReturn(this,(SlateError.__proto__||Object.getPrototypeOf(SlateError)).call(this,code));_this.code=code;for(var key in attrs)_this[key]=attrs[key];Error.captureStackTrace?Error.captureStackTrace(_this,_this.constructor):_this.stack=Error().stack;return _this}inherits(SlateError,_Error);return SlateError}(Error),Commands$6={addMark:function(editor,mark){mark=Mark.create(mark);var value=\neditor.value,document=value.document;value=value.selection;value.isExpanded?editor.addMarkAtRange(value,mark):value.marks?(mark=value.marks.add(mark),value=value.set(\"marks\",mark),editor.select(value)):(mark=document.getActiveMarksAtRange(value).add(mark),value=value.set(\"marks\",mark),editor.select(value))},addMarks:function(editor,marks){marks.forEach(function(mark){return editor.addMark(mark)})},delete:function(editor){editor.deleteAtRange(editor.value.selection);editor.moveToFocus()},deleteBackward:function(editor){var n=\n1<arguments.length&&void 0!==arguments[1]?arguments[1]:1,selection=editor.value.selection;selection.isExpanded?editor.delete():editor.deleteBackwardAtRange(selection,n)},deleteCharBackward:function(editor){var selection=editor.value.selection;selection.isExpanded?editor.delete():editor.deleteCharBackwardAtRange(selection)},deleteLineBackward:function(editor){var selection=editor.value.selection;selection.isExpanded?editor.delete():editor.deleteLineBackwardAtRange(selection)},deleteWordBackward:function(editor){var selection=\neditor.value.selection;selection.isExpanded?editor.delete():editor.deleteWordBackwardAtRange(selection)},deleteForward:function(editor){var n=1<arguments.length&&void 0!==arguments[1]?arguments[1]:1,selection=editor.value.selection;selection.isExpanded?editor.delete():editor.deleteForwardAtRange(selection,n)},deleteCharForward:function(editor){var selection=editor.value.selection;selection.isExpanded?editor.delete():editor.deleteCharForwardAtRange(selection)},deleteLineForward:function(editor){var selection=\neditor.value.selection;selection.isExpanded?editor.delete():editor.deleteLineForwardAtRange(selection)},deleteWordForward:function(editor){var selection=editor.value.selection;selection.isExpanded?editor.delete():editor.deleteWordForwardAtRange(selection)},insertBlock:function(editor,block){deleteExpanded(editor);block=Block.create(block);editor.insertBlockAtRange(editor.value.selection,block);(block=editor.value.document.getNode(block.key))&&editor.moveToEndOfNode(block)},insertFragment:function(editor,\nfragment){if(fragment.nodes.size){deleteExpanded(editor);var value=editor.value,_value=value;value=_value.document;var selection=_value.selection;_value=selection.start;var keys=Array.from(value.texts(),function(_ref){return slicedToArray(_ref,1)[0].key});editor.insertFragmentAtRange(selection,fragment);value=editor.value;value=value.document;var newTexts=value.getTexts().filter(function(n){return!keys.includes(n.key)});0!==newTexts.size&&(fragment=fragment.text.length,selection=value.getNode(_value.key)||\nnewTexts.first(),newTexts=newTexts.last()||selection,selection===newTexts?editor.moveTo(newTexts.key,fragment):(value=value.getCommonAncestor(selection.key,newTexts.key),_value=value.getOffset(selection.key)+(_value.key===selection.key?_value.offset:0),newTexts=value.getTextAtOffset(_value+fragment-1)||newTexts,editor.moveTo(newTexts.key,_value+fragment-value.getOffset(newTexts.key))))}},insertInline:function(editor,inline){deleteExpanded(editor);inline=Inline.create(inline);editor.insertInlineAtRange(editor.value.selection,\ninline);(inline=editor.value.document.getNode(inline.key))&&editor.moveToEndOfNode(inline)},insertText:function(editor,text,marks){deleteExpanded(editor);var value=editor.value,document=value.document,selection=value.selection;marks=marks||selection.marks||document.getInsertMarksAtRange(selection);editor.withoutNormalizing(function(){editor.insertTextAtRange(selection,text,marks);selection.marks&&document!==editor.value.document&&editor.select({marks:null})})},removeMark:function(editor,mark){mark=\nMark.create(mark);var value=editor.value,document=value.document;value=value.selection;value.isExpanded?editor.removeMarkAtRange(value,mark):value.marks?(mark=value.marks.remove(mark),value=value.set(\"marks\",mark),editor.select(value)):(mark=document.getActiveMarksAtRange(value).remove(mark),value=value.set(\"marks\",mark),editor.select(value))},replaceMark:function(editor,oldMark,newMark){editor.removeMark(oldMark);editor.addMark(newMark)},setBlocks:function(editor,properties){editor.setBlocksAtRange(editor.value.selection,\nproperties)},setInlines:function(editor,properties){editor.setInlinesAtRange(editor.value.selection,properties)},splitBlock:function(editor){var depth=1<arguments.length&&void 0!==arguments[1]?arguments[1]:1;deleteExpanded(editor);var value=editor.value,selection=value.selection;value=value.document;value=selection.marks||value.getInsertMarksAtRange(selection);editor.splitBlockAtRange(selection,depth).moveToEnd();value&&0!==value.size&&editor.select({marks:value})},splitInline:function(editor,height){deleteExpanded(editor);\neditor.splitInlineAtRange(editor.value.selection,height)},toggleMark:function(editor,mark){mark=Mark.create(mark);editor.value.activeMarks.has(mark)?editor.removeMark(mark):editor.addMark(mark)},unwrapBlock:function(editor,properties){editor.unwrapBlockAtRange(editor.value.selection,properties)},unwrapInline:function(editor,properties){editor.unwrapInlineAtRange(editor.value.selection,properties)},wrapBlock:function(editor,block){editor.wrapBlockAtRange(editor.value.selection,block)},wrapInline:function(editor,\ninline){editor.wrapInlineAtRange(editor.value.selection,inline)},wrapText:function(editor,prefix){var suffix=2<arguments.length&&void 0!==arguments[2]?arguments[2]:prefix,selection=editor.value.selection;editor.wrapTextAtRange(selection,prefix,suffix);selection.isCollapsed&&editor.moveStartBackward(prefix.length);editor.moveEndBackward(suffix.length);selection.isForward!==editor.value.selection.isForward&&editor.flip()}},debug$2=Debug(\"slate:editor\"),Editor=function(){function Editor(){var attrs=\n0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},options=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};classCallCheck(this,Editor);var _options$controller=options.controller;_options$controller=void 0===_options$controller?this:_options$controller;var _options$construct=options.construct;_options$construct=void 0===_options$construct?!0:_options$construct;var _attrs$onChange=attrs.onChange;_attrs$onChange=void 0===_attrs$onChange?function(){}:_attrs$onChange;var _attrs$plugins=\nattrs.plugins;_attrs$plugins=void 0===_attrs$plugins?[]:_attrs$plugins;var _attrs$readOnly=attrs.readOnly;_attrs$readOnly=void 0===_attrs$readOnly?!1:_attrs$readOnly;attrs=attrs.value;attrs=void 0===attrs?Value.create():attrs;this.controller=_options$controller;this.middleware={};this.onChange=_attrs$onChange;this.operations=immutable.List();this.value=this.readOnly=null;this.tmp={dirty:[],flushing:!1,merge:null,normalize:!0,save:!0};_options$controller=CorePlugin({plugins:_attrs$plugins});registerPlugin(this,\n_options$controller);_options$construct&&(this.run(\"onConstruct\"),this.setReadOnly(_attrs$readOnly),this.setValue(attrs,options))}createClass(Editor,[{key:\"applyOperation\",value:function(operation){var _this=this,operations=this.operations,controller=this.controller,value=this.value;isPlainObject(operation)&&(operation=_extends({},operation,{value:value}));operation=Operation.create(operation);this.withoutNormalizing(function(){controller.save(operation);value=_this.value});debug$2(\"apply\",{operation:operation});\nthis.value=operation.apply(value);this.operations=operations.push(operation);operations=getDirtyPaths(operation);var dirty=this.tmp.dirty.map(function(path){path=PathUtils.create(path);return PathUtils.transform(path,operation).toArray()}),pathIndex={};operations=Array.prototype.concat.apply(operations,dirty);this.tmp.dirty=[];operations.forEach(function(dirtyPath){var key=dirtyPath.join(\",\");pathIndex[key]||_this.tmp.dirty.push(dirtyPath);pathIndex[key]=!0});this.tmp.flushing||(this.tmp.flushing=\n!0,Promise.resolve().then(function(){return _this.flush()}));return controller}},{key:\"flush\",value:function(){this.run(\"onChange\");var controller=this.controller,change={value:this.value,operations:this.operations};this.operations=immutable.List();this.tmp.flushing=!1;this.onChange(change);return controller}},{key:\"command\",value:function(type){for(var _len=arguments.length,args=Array(1<_len?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];_len=this.controller;if(\"function\"===typeof type)return type.apply(void 0,\n[_len].concat(args)),normalizeDirtyPaths(this),_len;debug$2(\"command\",{type:type,args:args});this.run(\"onCommand\",{type:type,args:args});normalizeDirtyPaths(this);return _len}},{key:\"hasCommand\",value:function(type){var controller=this.controller;return type in controller&&controller[type].__command}},{key:\"hasQuery\",value:function(type){var controller=this.controller;return type in controller&&controller[type].__query}},{key:\"normalize\",value:function(){var value=this.value,controller=this.controller,\ndocument=value.document;document=document.getKeysToPathsTable();document=Object.values(document).map(PathUtils.create);this.tmp.dirty=this.tmp.dirty.concat(document);normalizeDirtyPaths(this);var selection=value.selection;document=value.document;selection.isUnset&&document.nodes.size&&controller.moveToStartOfDocument();return controller}},{key:\"query\",value:function(type){for(var _len2=arguments.length,args=Array(1<_len2?_len2-1:0),_key2=1;_key2<_len2;_key2++)args[_key2-1]=arguments[_key2];_len2=\nthis.controller;if(\"function\"===typeof type)return type.apply(void 0,[_len2].concat(args));debug$2(\"query\",{type:type,args:args});return this.run(\"onQuery\",{type:type,args:args})}},{key:\"registerCommand\",value:function(type){var _this2=this,controller=this.controller;if(type in controller&&controller[type].__command)return controller;invariant(!(type in controller),\"You cannot register a `\"+type+\"` command because it would overwrite an existing property of the `Editor`.\");var method=function(){for(var _len3=\narguments.length,args=Array(_len3),_key3=0;_key3<_len3;_key3++)args[_key3]=arguments[_key3];return _this2.command.apply(_this2,[type].concat(args))};controller[type]=method;method.__command=!0;return controller}},{key:\"registerQuery\",value:function(type){var _this3=this,controller=this.controller;if(type in controller&&controller[type].__query)return controller;invariant(!(type in controller),\"You cannot register a `\"+type+\"` query because it would overwrite an existing property of the `Editor`.\");\nvar method=function(){for(var _len4=arguments.length,args=Array(_len4),_key4=0;_key4<_len4;_key4++)args[_key4]=arguments[_key4];return _this3.query.apply(_this3,[type].concat(args))};controller[type]=method;method.__query=!0;return controller}},{key:\"run\",value:function(key){function next(){var fn=fns[i++];if(fn){for(var _len6=arguments.length,overrides=Array(_len6),_key6=0;_key6<_len6;_key6++)overrides[_key6]=arguments[_key6];overrides.length&&(args=overrides);return fn.apply(void 0,toConsumableArray(args).concat([controller,\nnext]))}}for(var _len5=arguments.length,args=Array(1<_len5?_len5-1:0),_key5=1;_key5<_len5;_key5++)args[_key5-1]=arguments[_key5];var controller=this.controller,fns=this.middleware[key]||[],i=0;Object.defineProperty(next,\"change\",{get:function(){invariant(!1,\"As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.\")}});Object.defineProperty(next,\"onChange\",{get:function(){invariant(!1,\"As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.\")}});\nObject.defineProperty(next,\"props\",{get:function(){invariant(!1,\"As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.\")}});Object.defineProperty(next,\"schema\",{get:function(){invariant(!1,\"As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.\")}});Object.defineProperty(next,\"stack\",{get:function(){invariant(!1,\"As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.\")}});\nreturn next()}},{key:\"setReadOnly\",value:function(readOnly){this.readOnly=readOnly;return this}},{key:\"setValue\",value:function(value){var _options$normalize=(1<arguments.length&&void 0!==arguments[1]?arguments[1]:{}).normalize;_options$normalize=void 0===_options$normalize?value!==this.value:_options$normalize;this.value=value;_options$normalize&&this.normalize();return this}},{key:\"withoutNormalizing\",value:function(fn){var controller=this.controller,value=this.tmp.normalize;this.tmp.normalize=\n!1;fn(controller);this.tmp.normalize=value;normalizeDirtyPaths(this);return controller}},{key:\"change\",value:function(fn){warning(!1,\"As of Slate 0.43 the `change` object has been replaced with `editor`, so the `editor.change()` method is deprecated.`\");for(var _len7=arguments.length,args=Array(1<_len7?_len7-1:0),_key7=1;_key7<_len7;_key7++)args[_key7-1]=arguments[_key7];fn.apply(void 0,[this.controller].concat(args))}},{key:\"call\",value:function(fn){warning(!1,\"As of Slate 0.43 the `editor.call(fn)` method has been deprecated, please use `editor.command(fn)` instead.\");\nfor(var _len8=arguments.length,args=Array(1<_len8?_len8-1:0),_key8=1;_key8<_len8;_key8++)args[_key8-1]=arguments[_key8];fn.apply(void 0,[this.controller].concat(args));return this.controller}},{key:\"applyOperations\",value:function(operations){var _this4=this;warning(!1,\"As of Slate 0.43 the `applyOperations` method is deprecated, please apply each operation in a loop instead.\");operations.forEach(function(op){return _this4.applyOperation(op)});return this.controller}},{key:\"setOperationFlag\",value:function(key,\nvalue){warning(!1,\"As of slate@0.41 the `change.setOperationFlag` method has been deprecated.\");this.tmp[key]=value;return this}},{key:\"getFlag\",value:function(key){var options=1<arguments.length&&void 0!==arguments[1]?arguments[1]:{};warning(!1,\"As of slate@0.41 the `change.getFlag` method has been deprecated.\");return void 0!==options[key]?options[key]:this.tmp[key]}},{key:\"unsetOperationFlag\",value:function(key){warning(!1,\"As of slate@0.41 the `change.unsetOperationFlag` method has been deprecated.\");\ndelete this.tmp[key];return this}},{key:\"withoutNormalization\",value:function(fn){warning(!1,\"As of slate@0.41 the `change.withoutNormalization` helper has been renamed to `change.withoutNormalizing`.\");return this.withoutNormalizing(fn)}},{key:\"editor\",get:function(){warning(!1,\"As of Slate 0.43 the `change` object has been replaced with `editor`, so you don't need to access `change.editor`.\");return this.controller}}]);return Editor}(),Leaf$1=function(_Record){function Leaf(){classCallCheck(this,\nLeaf);return possibleConstructorReturn(this,(Leaf.__proto__||Object.getPrototypeOf(Leaf)).apply(this,arguments))}inherits(Leaf,_Record);createClass(Leaf,[{key:\"updateMark\",value:function(mark,newMark){var marks=this.marks;if(newMark.equals(mark)||!marks.has(mark))return this;marks=marks.withMutations(function(collection){collection.remove(mark).add(newMark)});return this.set(\"marks\",marks)}},{key:\"addMark\",value:function(mark){return this.set(\"marks\",this.marks.add(mark))}},{key:\"addMarks\",value:function(set$$1){return this.set(\"marks\",\nthis.marks.union(set$$1))}},{key:\"insertText\",value:function(offset,string){var text=this.text;offset=text.slice(0,offset)+string+text.slice(offset);return this.set(\"text\",offset)}},{key:\"removeMark\",value:function(mark){return this.set(\"marks\",this.marks.remove(mark))}},{key:\"toJSON\",value:function(){return{object:this.object,text:this.text,marks:this.marks.toArray().map(function(m){return m.toJSON()})}}}],[{key:\"create\",value:function(){var attrs=0<arguments.length&&void 0!==arguments[0]?arguments[0]:\n{};warning(!1,\"As of slate@0.47 the `Leaf` model is deprecated.\");if(Leaf.isLeaf(attrs))return attrs;\"string\"===typeof attrs&&(attrs={text:attrs});if(isPlainObject(attrs))return Leaf.fromJSON(attrs);throw Error(\"`Leaf.create` only accepts objects, strings or leaves, but you passed it: \"+attrs);}},{key:\"createLeaves\",value:function(leaves){if(1>=leaves.size)return leaves;var invalid=!1,result=immutable.List().withMutations(function(cache){leaves.findLast(function(leaf,index){if(index=cache.first()){if(index.marks.equals(leaf.marks)){invalid=\n!0;cache.set(0,index.set(\"text\",\"\"+leaf.text+index.text));return}if(\"\"===index.text){invalid=!0;cache.set(0,leaf);return}if(\"\"===leaf.text){invalid=!0;return}}cache.unshift(leaf)})});return invalid?result:leaves}},{key:\"splitLeaves\",value:function(leaves,offset){if(0>offset)return[immutable.List(),leaves];if(0===leaves.size)return[immutable.List(),immutable.List()];var endOffset=0,index=-1,left=void 0,right=void 0;leaves.find(function(leaf){index++;var startOffset=endOffset,text=leaf.text;endOffset+=\ntext.length;if(endOffset<offset||startOffset>offset)return!1;startOffset=offset-startOffset;left=leaf.set(\"text\",text.slice(0,startOffset));right=leaf.set(\"text\",text.slice(startOffset));return!0});return left?\"\"===left.text?0===index?[immutable.List.of(left),leaves]:[leaves.take(index),leaves.skip(index)]:\"\"===right.text?index===leaves.size-1?[leaves,immutable.List.of(right)]:[leaves.take(index+1),leaves.skip(index+1)]:[leaves.take(index).push(left),leaves.skip(index+1).unshift(right)]:[leaves,immutable.List()]}},\n{key:\"createList\",value:function(){var attrs=0<arguments.length&&void 0!==arguments[0]?arguments[0]:[];if(immutable.List.isList(attrs)||Array.isArray(attrs))return new immutable.List(attrs.map(Leaf.create));throw Error(\"`Leaf.createList` only accepts arrays or lists, but you passed it: \"+attrs);}},{key:\"fromJSON\",value:function(object){var _object$text=object.text;object=object.marks;return new Leaf({text:void 0===_object$text?\"\":_object$text,marks:immutable.Set((void 0===object?[]:object).map(Mark.fromJSON))})}},\n{key:\"isLeafList\",value:function(any){return immutable.List.isList(any)&&any.every(function(item){return Leaf.isLeaf(item)})}}]);return Leaf}(immutable.Record({marks:void 0,text:void 0}));Object.entries({Annotation:Annotation,Block:Block,Change:Change,Decoration:Decoration,Document:Document$jscomp$0,Editor:Editor,Inline:Inline,Leaf:Leaf$1,Mark:Mark,Node:Node$jscomp$0,Operation:Operation,Point:Point,Range:Range$jscomp$0,Selection:Selection$jscomp$0,Text:Text$jscomp$0,Value:Value}).forEach(function(_ref){_ref=\nslicedToArray(_ref,2);var obj=_ref[1];return mixin(create$2(_ref[0].toLowerCase()),[obj])});var ModelInterface=function(){function ModelInterface(){classCallCheck(this,ModelInterface)}createClass(ModelInterface,[{key:\"toJS\",value:function(){return this.toJSON.apply(this,arguments)}}],[{key:\"fromJS\",value:function(){return this.fromJSON.apply(this,arguments)}}]);return ModelInterface}();mixin(ModelInterface,[Annotation,Block,Decoration,Document$jscomp$0,Inline,Leaf$1,Mark,Node$jscomp$0,Operation,Point,\nRange$jscomp$0,Selection$jscomp$0,Text$jscomp$0,Value]);var ENABLED=!0,LEAF=Symbol(\"LEAF\"),STORE_KEY=Symbol(\"STORE_KEY\"),UNDEFINED=Symbol(\"undefined\"),NULL=Symbol(\"null\"),memoizeStore=new WeakMap,NodeInterface=function(){function NodeInterface(){classCallCheck(this,NodeInterface)}createClass(NodeInterface,[{key:\"getFirstText\",value:function(){if(\"text\"===this.object)return this;var descendant=null,found=this.nodes.find(function(node){if(\"text\"===node.object)return!0;descendant=node.getFirstText();\nreturn!!descendant});return descendant||found}},{key:\"getKeysToPathsTable\",value:function(){var ret=defineProperty({},this.key,[]);this.nodes&&this.nodes.forEach(function(node,i){node=node.getKeysToPathsTable();for(var key in node){var path=node[key];warning(!(key in ret),'A node with a duplicate key of \"'+key+'\" was found! Duplicate keys are not allowed, you should use `node.regenerateKey` before inserting if you are reusing an existing node.');ret[key]=[i].concat(toConsumableArray(path))}});return ret}},\n{key:\"getLastText\",value:function(){if(\"text\"===this.object)return this;var descendant=null,found=this.nodes.findLast(function(node){return\"text\"===node.object?!0:descendant=node.getLastText()});return descendant||found}},{key:\"getNode\",value:function(path){path=this.resolvePath(path);return!path||\"text\"===this.object&&path.size?null:path.size?this.getDescendant(path):this}},{key:\"getPath\",value:function(key){if(immutable.List.isList(key))return key;if(Node$jscomp$0.isNode(key)&&this.descendants){var _iteratorNormalCompletion=\n!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _iterator=this.descendants()[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=!0){var _ref2=slicedToArray(_step.value,2),_path=_ref2[1];if(key===_ref2[0])return _path}}catch(err$16){_didIteratorError=!0,_iteratorError=err$16}finally{try{!_iteratorNormalCompletion&&_iterator.return&&_iterator.return()}finally{if(_didIteratorError)throw _iteratorError;}}}return(key=this.getKeysToPathsTable()[key])?\nimmutable.List(key):null}},{key:\"getText\",value:function(){return\"text\"===this.object?this.text:this.nodes.reduce(function(memo,c){return memo+c.text},\"\")}},{key:\"hasNode\",value:function(path){return!!this.getNode(path)}},{key:\"normalize\",value:function(editor){return editor.run(\"normalizeNode\",this)}},{key:\"regenerateKey\",value:function(){var key=KeyUtils.create();return this.set(\"key\",key)}},{key:\"resolvePath\",value:function(path,index){\"string\"===typeof path?(path=this.getPath(path),null!=index&&\n(path=path.concat(index))):path=PathUtils.create(path);return path}},{key:\"validate\",value:function(editor){return editor.run(\"validateNode\",this)}}]);return NodeInterface}();memoize(NodeInterface.prototype,\"getFirstText getKeysToPathsTable getLastText getText normalize validate\".split(\" \"));mixin(NodeInterface,[Block,Document$jscomp$0,Inline,Text$jscomp$0]);var global$1=\"undefined\"!==typeof global?global:\"undefined\"!==typeof self?self:\"undefined\"!==typeof window?window:{},ElementInterface=function(){function ElementInterface(){classCallCheck(this,\nElementInterface)}createClass(ElementInterface,[{key:\"addMark\",value:function(path,mark){path=this.resolvePath(path);var node=this.assertDescendant(path);node=node.addMark(mark);return this.replaceNode(path,node)}},{key:\"ancestors\",value:function(path){return this.createIterable({path:path,direction:null,downward:!1,includeTargetAncestors:!0,includeRoot:!0})}},{key:\"blocks\",value:function(){var options=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},onlyLeaves=options.onlyLeaves,onlyRoots=\noptions.onlyRoots,onlyTypes=options.onlyTypes,_match=options.match;options=objectWithoutProperties(options,[\"onlyLeaves\",\"onlyRoots\",\"onlyTypes\",\"match\"]);return this.descendants(_extends({includeDocument:!1,includeInlines:!1,includeTexts:!1},options,{match:function(node,path){return onlyTypes&&!onlyTypes.includes(node.type)?!1:onlyRoots&&1!==path.size?!1:onlyLeaves&&!node.isLeafBlock()?!1:_match&&!_match(node,path)?!1:!0}}))}},{key:\"createAnnotation\",value:function(properties){properties=Annotation.createProperties(properties);\nreturn this.resolveAnnotation(properties)}},{key:\"createDecoration\",value:function(properties){properties=Decoration.createProperties(properties);return this.resolveDecoration(properties)}},{key:\"createIterable\",value:function(){var options=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},_options$direction=options.direction,direction=void 0===_options$direction?\"forward\":_options$direction;_options$direction=options.downward;var downward=void 0===_options$direction?!0:_options$direction;\n_options$direction=options.upward;var upward=void 0===_options$direction?!0:_options$direction;_options$direction=options.includeBlocks;var includeBlocks=void 0===_options$direction?!0:_options$direction;_options$direction=options.includeDocument;var includeDocument=void 0===_options$direction?!0:_options$direction;_options$direction=options.includeInlines;var includeInlines=void 0===_options$direction?!0:_options$direction;_options$direction=options.includeRoot;var includeRoot=void 0===_options$direction?\n!1:_options$direction;_options$direction=options.includeTarget;var includeTarget=void 0===_options$direction?!!options.range:_options$direction;_options$direction=options.includeTargetAncestors;var includeTargetAncestors=void 0===_options$direction?!1:_options$direction;_options$direction=options.includeTexts;var includeTexts=void 0===_options$direction?!0:_options$direction;_options$direction=options.match;var match=void 0===_options$direction?null:_options$direction,root=this,targetPath=null,targetRange=\nnull;options.range?(targetRange=root.resolveRange(options.range),targetPath=root.resolvePath(targetRange.start.path)):options.path&&(targetPath=root.resolvePath(options.path));var targetNode=targetPath&&root.assertNode(targetPath),NativeSet=\"undefined\"===typeof window?global$1.Set:window.Set;return defineProperty({},Symbol.iterator,function(){var visited=new NativeSet,startPath=targetRange&&targetRange.start.path,endPath=targetRange&&targetRange.end.path,path=targetPath,node=targetNode,includedTarget=\n!1,includedStart=!1,includingStart=!1,result=function(){return path&&node?!includeRoot&&node===root||!includeBlocks&&\"block\"===node.object||!includeDocument&&\"document\"===node.object||!includeInlines&&\"inline\"===node.object||!includeTexts&&\"text\"===node.object||match&&!match(node,path)?next$jscomp$0():{value:[node,path],done:!1}:{done:!0}},next$jscomp$0=function next(){if(!path||!node)return result();if(startPath&&!includedStart){if(!includingStart)return includingStart=!0,path=PathUtils.create([]),\nnode=root,result();if(path.size===startPath.size-1)return includedStart=!0,path=targetPath,node=targetNode,next();path=startPath.slice(0,path.size+1);node=root.assertNode(path);return result()}if(includeTarget&&!includedTarget)return includedTarget=!0,result();if(endPath&&path.equals(endPath))return path=node=null,next();if(downward&&node.nodes&&node.nodes.size&&!visited.has(node))return visited.add(node),path=path.push(\"forward\"===direction?0:node.nodes.size-1),node=root.assertNode(path),result();\nif(\"forward\"===direction){var newPath=PathUtils.increment(path),newNode=root.getNode(newPath);if(newNode)return path=newPath,node=newNode,result()}if(\"backward\"===direction&&0!==path.last()&&(newPath=PathUtils.decrement(path),newNode=root.getNode(newPath)))return path=newPath,node=newNode,result();if(upward&&path.size){path=PathUtils.lift(path);node=root.assertNode(path);if(visited.has(node))return next();visited.add(node);return includeTargetAncestors?result():next()}node=path=null;return next()};\nreturn{next:next$jscomp$0}})}},{key:\"createPoint\",value:function(properties){properties=Point.createProperties(properties);return this.resolvePoint(properties)}},{key:\"createRange\",value:function(properties){properties=Range$jscomp$0.createProperties(properties);return this.resolveRange(properties)}},{key:\"createSelection\",value:function(properties){properties=Selection$jscomp$0.createProperties(properties);return this.resolveSelection(properties)}},{key:\"descendants\",value:function(options){return this.createIterable(_extends({path:[]},\noptions))}},{key:\"filterDescendants\",value:function(){var predicate=0<arguments.length&&void 0!==arguments[0]?arguments[0]:identity,matches=[],_iteratorNormalCompletion=!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _iterator=this.descendants()[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=!0){var _ref3=slicedToArray(_step.value,2),node=_ref3[0];predicate(node,_ref3[1])&&matches.push(node)}}catch(err$17){_didIteratorError=\n!0,_iteratorError=err$17}finally{try{!_iteratorNormalCompletion&&_iterator.return&&_iterator.return()}finally{if(_didIteratorError)throw _iteratorError;}}return immutable.List(matches)}},{key:\"findDescendant\",value:function(){var predicate=0<arguments.length&&void 0!==arguments[0]?arguments[0]:identity,_iteratorNormalCompletion2=!0,_didIteratorError2=!1,_iteratorError2=void 0;try{for(var _iterator2=this.descendants()[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=\n!0){var _ref5=slicedToArray(_step2.value,2),node=_ref5[0];if(predicate(node,_ref5[1]))return node}}catch(err$18){_didIteratorError2=!0,_iteratorError2=err$18}finally{try{!_iteratorNormalCompletion2&&_iterator2.return&&_iterator2.return()}finally{if(_didIteratorError2)throw _iteratorError2;}}return null}},{key:\"forEachDescendant\",value:function(){var predicate=0<arguments.length&&void 0!==arguments[0]?arguments[0]:identity,_iteratorNormalCompletion3=!0,_didIteratorError3=!1,_iteratorError3=void 0;\ntry{for(var _iterator3=this.descendants()[Symbol.iterator](),_step3;!(_iteratorNormalCompletion3=(_step3=_iterator3.next()).done)&&!1!==predicate.apply(void 0,toConsumableArray(_step3.value));_iteratorNormalCompletion3=!0);}catch(err$19){_didIteratorError3=!0,_iteratorError3=err$19}finally{try{!_iteratorNormalCompletion3&&_iterator3.return&&_iterator3.return()}finally{if(_didIteratorError3)throw _iteratorError3;}}}},{key:\"getActiveMarksAtRange\",value:function(range){range=this.resolveRange(range);\nif(range.isUnset)return immutable.Set();if(range.isCollapsed)return this.getInsertMarksAtPoint(range.start);var _range2=range;range=_range2.start;var end=_range2.end;_range2=range.path;var startOffset=range.offset;range=end.path;var endOffset=end.offset;end=this.getDescendant(_range2);var endText=this.getDescendant(range);if(!_range2.equals(range)){for(;!_range2.equals(range)&&0===endOffset;)range=this.texts({path:range,direction:\"backward\"}),range=slicedToArray(range,1),range=slicedToArray(range[0],\n2),endText=range[0],range=range[1],endOffset=endText.text.length;for(;!_range2.equals(range)&&startOffset===end.text.length;)_range2=this.texts({path:_range2}),_range2=slicedToArray(_range2,1),_range2=slicedToArray(_range2[0],2),end=_range2[0],_range2=_range2[1],startOffset=0}if(_range2.equals(range))return end.marks;end=end.marks;if(0===end.size)return immutable.Set();endText=end.intersect(endText.marks);if(0===endText.size)return endText;_range2=this.texts({path:_range2});_range2=slicedToArray(_range2,\n1);_range2=slicedToArray(_range2[0],2);end=_range2[0];for(_range2=_range2[1];!_range2.equals(range);){if(0!==end.text.length&&(endText=endText.intersect(end.marks),0===endText.size))return immutable.Set();_range2=this.texts({path:_range2});_range2=slicedToArray(_range2,1);_range2=slicedToArray(_range2[0],2);end=_range2[0];_range2=_range2[1]}return endText}},{key:\"getAncestors\",value:function(path){path=this.ancestors(path);path=Array.from(path,function(_ref6){return slicedToArray(_ref6,1)[0]}).reverse();\nreturn immutable.List(path)}},{key:\"getBlocks\",value:function(){var iterable=this.blocks({onlyLeaves:!0});iterable=Array.from(iterable,function(_ref8){return slicedToArray(_ref8,1)[0]});return immutable.List(iterable)}},{key:\"getBlocksByType\",value:function(type){type=this.blocks({onlyLeaves:!0,onlyTypes:[type]});type=Array.from(type,function(_ref10){return slicedToArray(_ref10,1)[0]});return immutable.List(type)}},{key:\"getChild\",value:function(path){path=this.resolvePath(path);return!path||1<path.size?\nnull:this.nodes.get(path.first())}},{key:\"getClosest\",value:function(path,predicate){var _iteratorNormalCompletion4=!0,_didIteratorError4=!1,_iteratorError4=void 0;try{for(var _iterator4=this.ancestors(path)[Symbol.iterator](),_step4;!(_iteratorNormalCompletion4=(_step4=_iterator4.next()).done);_iteratorNormalCompletion4=!0){var _ref13=slicedToArray(_step4.value,2),n=_ref13[0];if(predicate(n,_ref13[1]))return n}}catch(err$20){_didIteratorError4=!0,_iteratorError4=err$20}finally{try{!_iteratorNormalCompletion4&&\n_iterator4.return&&_iterator4.return()}finally{if(_didIteratorError4)throw _iteratorError4;}}return null}},{key:\"getClosestBlock\",value:function(path){return this.getClosest(path,function(n){return\"block\"===n.object})}},{key:\"getClosestInline\",value:function(path){return this.getClosest(path,function(n){return\"inline\"===n.object})}},{key:\"getClosestVoid\",value:function(path,editor){invariant(!Value.isValue(editor),\"As of Slate 0.42.0, the `node.getClosestVoid` method takes an `editor` instead of a `value`.\");\nreturn this.getClosest(path,function(n){return editor.isVoid(n)})}},{key:\"getCommonAncestor\",value:function(a,b){a=this.resolvePath(a);b=this.resolvePath(b);if(!a||!b)return null;a=PathUtils.relate(a,b);return this.getNode(a)}},{key:\"getDecorations\",value:function(editor){editor=editor.run(\"decorateNode\",this);return editor=Decoration.createList(editor)}},{key:\"getDepth\",value:function(path){var startAt=1<arguments.length&&void 0!==arguments[1]?arguments[1]:1;return(path=this.resolvePath(path))?this.getNode(path)?\npath.size-1+startAt:null:null}},{key:\"getDescendant\",value:function(path){path=this.resolvePath(path);if(!path||!path.size)return null;var node=this;path.forEach(function(index){node=node.getIn([\"nodes\",index]);return!!node});return node}},{key:\"getDescendantsAtRange\",value:function(range){range=this.descendants({range:range});range=Array.from(range,function(_ref14){return slicedToArray(_ref14,1)[0]});return immutable.List(range)}},{key:\"getFragmentAtRange\",value:function(range){range=this.resolveRange(range);\nif(range.isUnset)return Document$jscomp$0.create();var start=range.start,end=range.end;range=this;for(var targetPath=end.path,targetPosition=end.offset,side=\"end\";targetPath.size;){var index=targetPath.last();range=range.splitNode(targetPath,targetPosition);targetPosition=index+1;targetPath=PathUtils.lift(targetPath);targetPath.size||\"end\"!==side||(targetPath=start.path,targetPosition=start.offset,side=\"start\")}start=start.path.first()+1;end=end.path.first()+2;range=range.nodes.slice(start,end);return Document$jscomp$0.create({nodes:range})}},\n{key:\"getFurthest\",value:function(path){var predicate=1<arguments.length&&void 0!==arguments[1]?arguments[1]:identity,iterable=this.ancestors(path);iterable=Array.from(iterable).reverse();var _iteratorNormalCompletion5=!0,_didIteratorError5=!1,_iteratorError5=void 0;try{for(var _iterator5=iterable[Symbol.iterator](),_step5;!(_iteratorNormalCompletion5=(_step5=_iterator5.next()).done);_iteratorNormalCompletion5=!0){var _ref17=slicedToArray(_step5.value,2),n=_ref17[0];if(predicate(n,_ref17[1]))return n}}catch(err$21){_didIteratorError5=\n!0,_iteratorError5=err$21}finally{try{!_iteratorNormalCompletion5&&_iterator5.return&&_iterator5.return()}finally{if(_didIteratorError5)throw _iteratorError5;}}return null}},{key:\"getFurthestBlock\",value:function(path){return this.getFurthest(path,function(n){return\"block\"===n.object})}},{key:\"getFurthestChild\",value:function(path){return(path=this.resolvePath(path))&&path.size?this.nodes.get(path.first()):null}},{key:\"getFurthestInline\",value:function(path){return this.getFurthest(path,function(n){return\"inline\"===\nn.object})}},{key:\"getInlines\",value:function(){var iterable=this.inlines({onlyLeaves:!0});iterable=Array.from(iterable,function(_ref18){return slicedToArray(_ref18,1)[0]});return immutable.List(iterable)}},{key:\"getInlinesByType\",value:function(type){type=this.inlines({onlyLeaves:!0,onlyTypes:[type]});type=Array.from(type,function(_ref20){return slicedToArray(_ref20,1)[0]});return immutable.List(type)}},{key:\"getInsertMarksAtPoint\",value:function(point){point=this.resolvePoint(point);var path=point.path,\noffset=point.offset;point=this.getDescendant(path);if(0!==offset)return point.marks;var blockPath=offset=void 0,_iteratorNormalCompletion6=!0,_didIteratorError6=!1,_iteratorError6=void 0;try{for(var _iterator6=this.ancestors(path)[Symbol.iterator](),_step6;!(_iteratorNormalCompletion6=(_step6=_iterator6.next()).done);_iteratorNormalCompletion6=!0){var _entry=slicedToArray(_step6.value,2),n=_entry[0],p=_entry[1];\"block\"===n.object&&(offset=n,blockPath=p)}}catch(err$22){_didIteratorError6=!0,_iteratorError6=\nerr$22}finally{try{!_iteratorNormalCompletion6&&_iterator6.return&&_iterator6.return()}finally{if(_didIteratorError6)throw _iteratorError6;}}_iterator6=PathUtils.drop(path,blockPath.size);_iterator6=offset.texts({path:_iterator6,direction:\"backward\"});return(_iterator6=slicedToArray(_iterator6,1)[0])?slicedToArray(_iterator6,1)[0].marks:point.marks}},{key:\"getInsertMarksAtRange\",value:function(range){range=this.resolveRange(range);var start=range.start;return range.isUnset?immutable.Set():range.isCollapsed?\nthis.getInsertMarksAtPoint(start):this.getDescendant(start.path).marks}},{key:\"getLeafBlocksAtRange\",value:function(range){range=this.blocks({range:range,onlyLeaves:!0});range=Array.from(range,function(_ref22){return slicedToArray(_ref22,1)[0]});return immutable.List(range)}},{key:\"getLeafInlinesAtRange\",value:function(range){range=this.inlines({range:range,onlyLeaves:!0});range=Array.from(range,function(_ref24){return slicedToArray(_ref24,1)[0]});return immutable.List(range)}},{key:\"getNodesToPathsMap\",\nvalue:function(){var map=\"undefined\"===typeof window?new global$1.Map:new window.Map;map.set(this,PathUtils.create([]));this.forEachDescendant(function(node,path){map.set(node,path)});return map}},{key:\"getMarks\",value:function(){var iterable=this.marks();iterable=Array.from(iterable,function(_ref26){return slicedToArray(_ref26,1)[0]});return immutable.OrderedSet(iterable)}},{key:\"getMarksAtRange\",value:function(range){range=this.marks({range:range});range=Array.from(range,function(_ref28){return slicedToArray(_ref28,\n1)[0]});return immutable.OrderedSet(range)}},{key:\"getMarksByType\",value:function(type){type=this.marks({onlyTypes:[type]});type=Array.from(type,function(_ref30){return slicedToArray(_ref30,1)[0]});return immutable.OrderedSet(type)}},{key:\"getNextBlock\",value:function(path){path=this.blocks({path:path,onlyLeaves:!0});return(path=slicedToArray(path,1)[0])?path[0]:null}},{key:\"getNextNode\",value:function(path){path=this.createIterable({path:path,downward:!1});return(path=slicedToArray(path,1)[0])?path[0]:\nnull}},{key:\"getNextSibling\",value:function(path){path=this.siblings(path);return(path=slicedToArray(path,1)[0])?path[0]:null}},{key:\"getNextText\",value:function(path){path=this.texts({path:path});return(path=slicedToArray(path,1)[0])?path[0]:null}},{key:\"getOffset\",value:function(path){path=this.resolvePath(path);this.assertDescendant(path);var index=path.first(),offset=this.nodes.slice(0,index).reduce(function(memo,n){return memo+n.text.length},0);return 1===path.size?offset:offset+this.nodes.get(index).getOffset(PathUtils.drop(path))}},\n{key:\"getOffsetAtRange\",value:function(range){range=this.resolveRange(range);if(range.isUnset)throw Error(\"The range cannot be unset to calculcate its offset.\");if(range.isExpanded)throw Error(\"The range must be collapsed to calculcate its offset.\");range=range.start;return this.getOffset(range.path)+range.offset}},{key:\"getParent\",value:function(path){path=this.resolvePath(path);if(!path||!path.size)return null;path=PathUtils.lift(path);return this.getNode(path)}},{key:\"getPreviousBlock\",value:function(path){path=\nthis.blocks({path:path,onlyLeaves:!0,direction:\"backward\"});return(path=slicedToArray(path,1)[0])?path[0]:null}},{key:\"getPreviousNode\",value:function(path){path=this.createIterable({path:path,downward:!1,direction:\"backward\"});return(path=slicedToArray(path,1)[0])?path[0]:null}},{key:\"getPreviousSibling\",value:function(path){path=this.siblings(path,{direction:\"backward\"});return(path=slicedToArray(path,1)[0])?path[0]:null}},{key:\"getPreviousText\",value:function(path){path=this.texts({path:path,direction:\"backward\"});\nreturn(path=slicedToArray(path,1)[0])?path[0]:null}},{key:\"getRootBlocksAtRange\",value:function(range){range=this.blocks({range:range,onlyRoots:!0});range=Array.from(range,function(_ref32){return slicedToArray(_ref32,1)[0]});return immutable.List(range)}},{key:\"getRootInlinesAtRange\",value:function(range){range=this.inlines({range:range,onlyRoots:!0});range=Array.from(range,function(_ref34){return slicedToArray(_ref34,1)[0]});return immutable.List(range)}},{key:\"getTextAtOffset\",value:function(offset){if(0===\noffset)return this.getFirstText();if(offset===this.text.length)return this.getLastText();if(0>offset||offset>this.text.length)return null;var length=0,_iteratorNormalCompletion7=!0,_didIteratorError7=!1,_iteratorError7=void 0;try{for(var _iterator7=this.texts()[Symbol.iterator](),_step7;!(_iteratorNormalCompletion7=(_step7=_iterator7.next()).done);_iteratorNormalCompletion7=!0){var node=slicedToArray(_step7.value,1)[0];length+=node.text.length;if(length>offset)return node}}catch(err$23){_didIteratorError7=\n!0,_iteratorError7=err$23}finally{try{!_iteratorNormalCompletion7&&_iterator7.return&&_iterator7.return()}finally{if(_didIteratorError7)throw _iteratorError7;}}return null}},{key:\"getTextDirection\",value:function(){var dir=getDirection(this.text);return\"neutral\"===dir?null:dir}},{key:\"getTexts\",value:function(){var iterable=this.texts();iterable=Array.from(iterable,function(_ref38){return slicedToArray(_ref38,1)[0]});return immutable.List(iterable)}},{key:\"getTextsAtRange\",value:function(range){range=\nthis.texts({range:range});range=Array.from(range,function(_ref40){return slicedToArray(_ref40,1)[0]});return immutable.List(range)}},{key:\"hasBlockChildren\",value:function(){return!(!this.nodes||!this.nodes.find(function(n){return\"block\"===n.object}))}},{key:\"hasChild\",value:function(path){return!!this.getChild(path)}},{key:\"hasInlineChildren\",value:function(){return!(!this.nodes||!this.nodes.find(function(n){return\"inline\"===n.object||\"text\"===n.object}))}},{key:\"hasDescendant\",value:function(path){return!!this.getDescendant(path)}},\n{key:\"hasVoidParent\",value:function(path,editor){invariant(!Value.isValue(editor),\"As of Slate 0.42.0, the `node.hasVoidParent` method takes an `editor` instead of a `value`.\");return!!this.getClosestVoid(path,editor)}},{key:\"inlines\",value:function(){var _this=this,options=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},onlyLeaves=options.onlyLeaves,onlyRoots=options.onlyRoots,onlyTypes=options.onlyTypes,_match2=options.match;options=objectWithoutProperties(options,[\"onlyLeaves\",\"onlyRoots\",\n\"onlyTypes\",\"match\"]);return this.descendants(_extends({includeBlocks:!1,includeTexts:!1,includeDocument:!1},options,{match:function(node,path){return onlyTypes&&!onlyTypes.includes(node.type)?!1:onlyLeaves&&!node.isLeafInline()?!1:onlyRoots&&\"block\"!==_this.getParent(path).object?!1:_match2&&!_match2(node,path)?!1:!0}}))}},{key:\"insertNode\",value:function(path,node){path=this.resolvePath(path);var index=path.last();path=PathUtils.lift(path);var parent=this.assertNode(path);node=parent.nodes.splice(index,\n0,node);parent=parent.set(\"nodes\",node);return this.replaceNode(path,parent)}},{key:\"insertText\",value:function(path,offset,text){path=this.resolvePath(path);var node=this.assertDescendant(path);node=node.insertText(offset,text);return this.replaceNode(path,node)}},{key:\"isLeafBlock\",value:function(){return\"block\"!==this.object||this.nodes.some(function(n){return\"block\"===n.object})?!1:!0}},{key:\"isLeafInline\",value:function(){return\"inline\"!==this.object||this.nodes.some(function(n){return\"inline\"===\nn.object})?!1:!0}},{key:\"isInRange\",value:function(path,range){path=this.resolvePath(path);range=this.resolveRange(range);if(range.isUnset)return!1;var toStart=PathUtils.compare(path,range.start.path);path=PathUtils.compare(path,range.end.path);return-1!==toStart&&1!==path}},{key:\"mapChildren\",value:function(){var _this2=this,predicate=0<arguments.length&&void 0!==arguments[0]?arguments[0]:identity,nodes=this.nodes;nodes.forEach(function(node,i){i=predicate(node,i,_this2.nodes);i!==node&&(nodes=nodes.set(i.key,\ni))});return this.set(\"nodes\",nodes)}},{key:\"mapDescendants\",value:function(){var _this3=this,predicate=0<arguments.length&&void 0!==arguments[0]?arguments[0]:identity,nodes=this.nodes;nodes.forEach(function(node,index){var ret=node;\"text\"!==ret.object&&(ret=ret.mapDescendants(predicate));ret=predicate(ret,index,_this3.nodes);ret!==node&&(nodes=nodes.set(index,ret))});return this.set(\"nodes\",nodes)}},{key:\"marks\",value:function(){var options=0<arguments.length&&void 0!==arguments[0]?arguments[0]:\n{},_options$onlyTypes=options.onlyTypes,onlyTypes=void 0===_options$onlyTypes?null:_options$onlyTypes,match=options.match;options=objectWithoutProperties(options,[\"onlyTypes\",\"match\"]);var texts=this.texts(options);return defineProperty({},Symbol.iterator,function(){var iterator=texts[Symbol.iterator](),node=null,path=null,remaining=[];return{next:function next(){if(remaining.length){var mark=remaining.shift();return onlyTypes&&!onlyTypes.includes(mark.type)||match&&!match(mark,node,path)?next():\n{value:[mark,node,path],done:!1}}mark=iterator.next();if(mark.done)return{done:!0};mark=slicedToArray(mark.value,2);node=mark[0];path=mark[1];remaining=node.marks.toArray();return next()}}})}},{key:\"mergeNode\",value:function(path){var b=this.assertNode(path);path=this.resolvePath(path);if(0===path.last())throw Error(\"Unable to merge node because it has no previous sibling: \"+b);var withPath=PathUtils.decrement(path),a=this.assertNode(withPath);if(a.object!==b.object)throw Error(\"Unable to merge two different kinds of nodes: \"+\na+\" and \"+b);b=\"text\"===a.object?a.mergeText(b):a.set(\"nodes\",a.nodes.concat(b.nodes));path=this.removeNode(path);path=path.removeNode(withPath);return path=path.insertNode(withPath,b)}},{key:\"moveNode\",value:function(path,newPath){var newIndex=2<arguments.length&&void 0!==arguments[2]?arguments[2]:0,node=this.assertNode(path);path=this.resolvePath(path);newPath=this.resolvePath(newPath,newIndex);newIndex=PathUtils.lift(newPath);this.assertNode(newIndex);newIndex=Operation.create({type:\"move_node\",\npath:path,newPath:newPath});newPath=PathUtils.transform(path,newIndex).first();newIndex=this.removeNode(path);return newIndex=newIndex.insertNode(newPath,node)}},{key:\"removeMark\",value:function(path,mark){path=this.resolvePath(path);var node=this.assertDescendant(path);node=node.removeMark(mark);return this.replaceNode(path,node)}},{key:\"removeNode\",value:function(path){this.assertDescendant(path);path=this.resolvePath(path);path=path.flatMap(function(x){return[\"nodes\",x]});return this.deleteIn(path)}},\n{key:\"removeText\",value:function(path,offset,text){var node=this.assertDescendant(path);node=node.removeText(offset,text.length);return this.replaceNode(path,node)}},{key:\"replaceNode\",value:function(path,node){path=this.resolvePath(path);if(!path)throw Error(\"Unable to replace a node because it could not be found in the first place: \"+path);if(!path.size)return node;this.assertNode(path);path=path.flatMap(function(x){return[\"nodes\",x]});return this.setIn(path,node)}},{key:\"resolveAnnotation\",value:function(annotation){annotation=\nAnnotation.create(annotation);return annotation=annotation.normalize(this)}},{key:\"resolveDecoration\",value:function(decoration){decoration=Decoration.create(decoration);return decoration=decoration.normalize(this)}},{key:\"resolvePoint\",value:function(point){point=Point.create(point);return point=point.normalize(this)}},{key:\"resolveRange\",value:function(range){range=Range$jscomp$0.create(range);return range=range.normalize(this)}},{key:\"resolveSelection\",value:function(selection){selection=Selection$jscomp$0.create(selection);\nreturn selection=selection.normalize(this)}},{key:\"setNode\",value:function(path,properties){var node=this.assertNode(path);node=node.merge(properties);return this.replaceNode(path,node)}},{key:\"setMark\",value:function(path,properties,newProperties){path=this.resolvePath(path);var node=this.assertDescendant(path);node=node.setMark(properties,newProperties);return this.replaceNode(path,node)}},{key:\"siblings\",value:function(path,options){return this.createIterable(_extends({path:path,upward:!1,downward:!1},\noptions))}},{key:\"splitNode\",value:function(path,position,properties){var child=this.assertNode(path);path=this.resolvePath(path);if(\"text\"===child.object){var a=child.splitText(position);position=slicedToArray(a,2);a=position[0];position=position[1]}else a=child.nodes.take(position),position=child.nodes.skip(position),a=child.set(\"nodes\",a),position=child.set(\"nodes\",position).regenerateKey();properties&&\"text\"!==child.object&&(position=position.merge(properties));properties=this.removeNode(path);\nproperties=properties.insertNode(path,position);return properties=properties.insertNode(path,a)}},{key:\"texts\",value:function(options){return this.descendants(_extends({includeBlocks:!1,includeInlines:!1,includeDocument:!1},options))}},{key:\"getBlocksAtRange\",value:function(range){warning(!1,\"As of slate@0.44 the `node.getBlocksAtRange` method has been renamed to `getLeafBlocksAtRange`.\");return this.getLeafBlocksAtRange(range)}},{key:\"getBlocksAtRangeAsArray\",value:function(range){warning(!1,\"As of slate@0.44 the `node.getBlocksAtRangeAsArray` method has been renamed to `getLeafBlocksAtRangeAsArray`.\");\nreturn this.getLeafBlocksAtRangeAsArray(range)}},{key:\"getInlinesAtRange\",value:function(range){warning(!1,\"As of slate@0.44 the `node.getInlinesAtRange` method has been renamed to `getLeafInlinesAtRange`.\");return this.getLeafInlinesAtRange(range)}},{key:\"getInlinesAtRangeAsArray\",value:function(range){warning(!1,\"As of slate@0.44 the `node.getInlinesAtRangeAsArray` method has been renamed to `getLeafInlinesAtRangeAsArray`.\");return this.getLeafInlinesAtRangeAsArray(range)}},{key:\"getNextTextAndPath\",\nvalue:function(path){warning(!1,\"As of slate@0.47, the `getNextTextAndPath` method has been renamed to `getNextTextEntry`.\");return this.getNextTextEntry(path)}},{key:\"getNextDeepMatchingNodeAndPath\",value:function(path){var iterator=1<arguments.length&&void 0!==arguments[1]?arguments[1]:function(){return!0};warning(!1,\"As of slate@0.47, the `getNextDeepMatchingNodeAndPath` method is deprecated.\");var match=this.getNextMatchingNodeAndPath(path);if(!match)return null;var _match3=slicedToArray(match,\n2),nextNode=_match3[0],nextPath=_match3[1],childMatch=void 0;for(_match3=function(){return childMatch=\"text\"!==nextNode.object&&nextNode.findFirstDescendantAndPath(iterator,nextPath)};_match3(childMatch);){var _childMatch2=slicedToArray(childMatch,2);nextNode=_childMatch2[0];nextPath=_childMatch2[1]}return nextNode?iterator(nextNode)?[nextNode,nextPath]:this.getNextDeepMatchingNodeAndPath(match[1],iterator):null}},{key:\"getPreviousTextAndPath\",value:function(path){warning(!1,\"As of slate@0.47, the `getPreviousTextAndPath` method has been renamed to `getPreviousTextEntry`.\");\nreturn this.getPreviousTextEntry(path)}},{key:\"findFirstDescendantAndPath\",value:function(iterator,pathToThisNode){warning(!1,\"As of slate@0.47, the `findFirstDescendantAndPath` method is deprecated.\");return this.findDescendantAndPath(iterator,pathToThisNode,!1)}},{key:\"getPreviousMatchingNodeAndPath\",value:function(path){var iterator=1<arguments.length&&void 0!==arguments[1]?arguments[1]:function(){return!0};warning(!1,\"As of slate@0.47, the `getPreviousMatchingNodeAndPath` method is deprecated.\");\nif(!path)return null;for(var i=path.size;0<i;i--){var p=path.slice(0,i);if(0!==p.last()){p=PathUtils.decrement(p);for(var previousNode=this.getNode(p);previousNode&&!iterator(previousNode);)p=PathUtils.decrement(p),previousNode=this.getNode(p);if(previousNode)return[previousNode,p]}}return null}},{key:\"getPreviousDeepMatchingNodeAndPath\",value:function(path){var iterator=1<arguments.length&&void 0!==arguments[1]?arguments[1]:function(){return!0};warning(!1,\"As of slate@0.47, the `getPreviousDeepMatchingNodeAndPath` method is deprecated.\");\nvar match=this.getPreviousMatchingNodeAndPath(path);if(!match)return null;var _match4=slicedToArray(match,2),previousNode=_match4[0],previousPath=_match4[1],childMatch=void 0;for(_match4=function(){return childMatch=\"text\"!==previousNode.object&&previousNode.findLastDescendantAndPath(iterator,previousPath)};_match4(childMatch);){var _childMatch4=slicedToArray(childMatch,2);previousNode=_childMatch4[0];previousPath=_childMatch4[1]}return previousNode?iterator(previousNode)?[previousNode,previousPath]:\nthis.getPreviousDeepMatchingNodeAndPath(match[1],iterator):null}},{key:\"findLastDescendantAndPath\",value:function(iterator,pathToThisNode){warning(!1,\"As of slate@0.47, the `findLastDescendantAndPath` method is deprecated.\");return this.findDescendantAndPath(iterator,pathToThisNode,!0)}},{key:\"findDescendantAndPath\",value:function(iterator){var pathToThisNode=1<arguments.length&&void 0!==arguments[1]?arguments[1]:PathUtils.create([]),findLast=2<arguments.length&&void 0!==arguments[2]?arguments[2]:\n!1;warning(!1,\"As of slate@0.47, the `findDescendantAndPath` method is deprecated.\");var found=void 0,foundPath=void 0;this.forEachDescendantWithPath(function(node,path,nodes){if(iterator(node,path,nodes))return found=node,foundPath=path,!1},pathToThisNode,findLast);return found?[found,foundPath]:null}},{key:\"forEachDescendantWithPath\",value:function(iterator){var path=1<arguments.length&&void 0!==arguments[1]?arguments[1]:PathUtils.create([]),findLast=arguments[2];warning(!1,\"As of slate@0.47, the `forEachDescendantWithPath` method is deprecated.\");\nvar nodes=this.nodes,ret=void 0;findLast&&(nodes=nodes.reverse());nodes.forEach(function(child,i){i=path.concat(i);if(!1===iterator(child,i,nodes))return ret=!1;if(\"text\"!==child.object)return ret=child.forEachDescendantWithPath(iterator,i,findLast)});return ret}},{key:\"getNextMatchingNodeAndPath\",value:function(path){var iterator=1<arguments.length&&void 0!==arguments[1]?arguments[1]:function(){return!0};warning(!1,\"As of slate@0.47, the `getNextMatchingNodeAndPath` method is deprecated.\");if(!path)return null;\nfor(var i=path.size;0<i;i--){var p=path.slice(0,i);p=PathUtils.increment(p);for(var nextNode=this.getNode(p);nextNode&&!iterator(nextNode);)p=PathUtils.increment(p),nextNode=this.getNode(p);if(nextNode)return[nextNode,p]}return null}},{key:\"getSelectionIndexes\",value:function(range){var isSelected=1<arguments.length&&void 0!==arguments[1]?arguments[1]:!0;warning(!1,\"As of slate@0.47, the `getSelectionIndexes` method is deprecated.\");var start=range.start,end=range.end;if(!isSelected||range.isUnset)return null;\nif(start.path.equals(end.path))return isSelected=(isSelected=this.getFurthestAncestor(start.path))?this.nodes.indexOf(isSelected):null,{start:isSelected,end:isSelected+1};var startIndex=null,endIndex=null;this.nodes.forEach(function(child,i){\"text\"===child.object?(null==startIndex&&child.key===start.key&&(startIndex=i),null==endIndex&&child.key===end.key&&(endIndex=i+1)):(null==startIndex&&child.hasDescendant(start.key)&&(startIndex=i),null==endIndex&&child.hasDescendant(end.key)&&(endIndex=i+1));\nreturn null==startIndex||null==endIndex});isSelected&&null==startIndex&&(startIndex=0);isSelected&&null==endIndex&&(endIndex=this.nodes.size);return null==startIndex?null:{start:startIndex,end:endIndex}}},{key:\"getTextsBetweenPositionsAsArray\",value:function(startPath,endPath){warning(!1,\"As of slate@0.47, the `getTextsBetweenPositionsAsArray` method is deprecated.\");startPath=this.resolvePath(startPath);endPath=this.resolvePath(endPath);return this.getTextsBetweenPathPositionsAsArray(startPath,endPath)}},\n{key:\"getOrderedMarksBetweenPositions\",value:function(startPath,startOffset,endPath,endOffset){warning(!1,\"As of slate@0.47, the `getOrderedMarksBetweenPositions` method is deprecated.\");startPath=this.resolvePath(startPath);endPath=this.resolvePath(endPath);startOffset=this.getDescendant(startPath);if(PathUtils.isEqual(startPath,endPath))return startOffset.marks;var texts=this.getTextsBetweenPathPositionsAsArray(startPath,endPath);return immutable.OrderedSet().withMutations(function(result){texts.forEach(function(text){result.union(text.marks)})})}},\n{key:\"getTextsBetweenPathPositionsAsArray\",value:function(startPath,endPath){warning(!1,\"As of slate@0.47, the `getTextsBetweenPathPositionsAsArray` method is deprecated.\");if(startPath&&endPath&&PathUtils.isEqual(startPath,endPath))return[this.getDescendant(startPath)];if(!startPath&&!endPath)return this.getTextsAsArray();var startIndex=startPath?startPath.get(0,0):0,endIndex=endPath?endPath.get(0,this.nodes.size-1):this.nodes.size-1,array=[];this.nodes.slice(startIndex,endIndex+1).forEach(function(node,\ni){if(\"text\"===node.object)array.push(node);else{var childStartPath=startPath&&0===i?PathUtils.drop(startPath):null;i=endPath&&i===endIndex-startIndex?PathUtils.drop(endPath):null;array=array.concat(node.getTextsBetweenPathPositionsAsArray(childStartPath,i))}});return array}},{key:\"getFurthestAncestor\",value:function(path){warning(!1,\"As of slate@0.47, the `getFurthestAncestor` method has been renamed to `getFurthestChild`.\");return this.getFurthestChild(path)}},{key:\"getLeafBlocksAtRangeAsArray\",\nvalue:function(range){warning(!1,\"As of slate@0.47, the `getLeafBlocksAtRangeAsArray` method is deprecated.\");range=this.resolveRange(range);return range.isUnset?[]:this.getLeafBlocksBetweenPathPositionsAsArray(range.start.path,range.end.path)}},{key:\"getLeafBlocksBetweenPathPositionsAsArray\",value:function(startPath,endPath){warning(!1,\"As of slate@0.47, the `getLeafBlocksBetweenPathPositionsAsArray` method is deprecated.\");if(startPath&&endPath&&PathUtils.isEqual(startPath,endPath))return[this.getClosestBlock(startPath)];\nif(!startPath&&!endPath)return this.getBlocksAsArray();var startIndex=startPath?startPath.get(0,0):0,endIndex=endPath?endPath.get(0,this.nodes.size-1):this.nodes.size-1,array=[];this.nodes.slice(startIndex,endIndex+1).forEach(function(node,i){if(\"block\"===node.object)if(node.isLeafBlock())array.push(node);else{var childStartPath=startPath&&0===i?PathUtils.drop(startPath):null;i=endPath&&i===endIndex-startIndex?PathUtils.drop(endPath):null;array=array.concat(node.getLeafBlocksBetweenPathPositionsAsArray(childStartPath,\ni))}});return array}},{key:\"getBlocksAsArray\",value:function(){warning(!1,\"As of slate@0.47, the `getBlocksAsArray` method is deprecated.\");var iterable=this.blocks({onlyLeaves:!0});return Array.from(iterable,function(_ref43){return slicedToArray(_ref43,1)[0]})}},{key:\"getBlocksByTypeAsArray\",value:function(type){warning(!1,\"As of slate@0.47, the `getBlocksByTypeAsArray` method is deprecated.\");type=this.blocks({onlyLeaves:!0,onlyTypes:[type]});return Array.from(type,function(_ref45){return slicedToArray(_ref45,\n1)[0]})}},{key:\"getFurthestOnlyChildAncestor\",value:function(path){warning(!1,\"As of slate@0.47, the `getFurthestOnlyChildAncestor` method is deprecated.\");return(path=this.getAncestors(path))?path.rest().reverse().takeUntil(function(p){return 1<p.nodes.size}).last()||null:null}},{key:\"getInlinesAsArray\",value:function(){warning(!1,\"As of slate@0.47, the `getInlinesAsArray` method is deprecated.\");return Array.from(this.inlines({onlyLeaves:!0}),function(_ref47){return slicedToArray(_ref47,1)[0]})}},\n{key:\"getInlinesByTypeAsArray\",value:function(type){warning(!1,\"As of slate@0.47, the `getInlinesByTypeAsArray` method is deprecated.\");return Array.from(this.inlines({onlyLeaves:!0,onlyTypes:[type]}),function(_ref49){return slicedToArray(_ref49,1)[0]})}},{key:\"getLeafInlinesAtRangeAsArray\",value:function(range){var _this4=this;warning(!1,\"As of slate@0.47, the `getLeafInlinesAtRangeAsArray` method is deprecated.\");range=this.resolveRange(range);return range.isUnset?[]:this.getTextsAtRangeAsArray(range).map(function(text){return _this4.getClosestInline(text.key)}).filter(function(exists){return exists})}},\n{key:\"getOrderedMarks\",value:function(){warning(!1,\"As of slate@0.47, the `getOrderedMarks` method has been folded into `getMarks`, which will now return an ordered set.\");return this.getMarks()}},{key:\"getOrderedMarksAtRange\",value:function(range){warning(!1,\"As of slate@0.47, the `getOrderedMarksAtRange` method has been folded into `getMarksAtRange`, which will now return an ordered set.\");return this.getMarksAtRange(range)}},{key:\"getOrderedMarksByType\",value:function(type){warning(!1,\"As of slate@0.47, the `getOrderedMarksByType` method has been folded into `getMarksByType`, which will now return an ordered set.\");\nreturn this.getMarksByType(type)}},{key:\"getMarksByTypeAsArray\",value:function(type){warning(!1,\"As of slate@0.47, the `getMarksByTypeAsArray` method is deprecated.\");return this.nodes.reduce(function(memo,node){return\"text\"===node.object?memo.concat(node.marks.filter(function(m){return m.type===type})):memo.concat(node.getMarksByTypeAsArray(type))},[])}},{key:\"getMarksAsArray\",value:function(){var _ref53;warning(!1,\"As of slate@0.47, the `getMarksAsArray` method is deprecated.\");var result=[],_iteratorNormalCompletion8=\n!0,_didIteratorError8=!1,_iteratorError8=void 0;try{for(var _iterator8=this.texts()[Symbol.iterator](),_step8;!(_iteratorNormalCompletion8=(_step8=_iterator8.next()).done);_iteratorNormalCompletion8=!0){var node=slicedToArray(_step8.value,1)[0];result.push(node.marks.toArray())}}catch(err$24){_didIteratorError8=!0,_iteratorError8=err$24}finally{try{!_iteratorNormalCompletion8&&_iterator8.return&&_iterator8.return()}finally{if(_didIteratorError8)throw _iteratorError8;}}return(_ref53=[]).concat.apply(_ref53,\nresult)}},{key:\"getRootInlinesAtRangeAsArray\",value:function(range){var _this5=this;warning(!1,\"As of slate@0.47, the `getRootInlinesAtRangeAsArray` method is deprecated.\");range=this.resolveRange(range);return range.isUnset?immutable.List():this.getTextsAtRangeAsArray(range).map(function(text){return _this5.getFurthestInline(text.key)}).filter(function(exists){return exists})}},{key:\"getTextsAsArray\",value:function(){warning(!1,\"As of slate@0.47, the `getTextsAsArray` method is deprecated.\");var iterable=\nthis.texts();return Array.from(iterable,function(_ref54){return slicedToArray(_ref54,1)[0]})}},{key:\"getTextsAtRangeAsArray\",value:function(range){warning(!1,\"As of slate@0.47, the `getTextsAtRangeAsArray` method is deprecated.\");range=this.texts({range:range});return Array.from(range,function(_ref56){return slicedToArray(_ref56,1)[0]})}},{key:\"getMarksAtPosition\",value:function(path,offset){warning(!1,\"As of slate@0.47, the `getMarksAtPosition` method is deprecated.\");path=this.resolvePath(path);\nvar currentMarks=this.getDescendant(path).marks;if(0!==offset)return immutable.OrderedSet(currentMarks);offset=this.getClosestBlock(path);if(\"\"===offset.text)return immutable.OrderedSet(currentMarks);path=this.texts({path:path,direction:\"backward\"});path=slicedToArray(path,1)[0];if(!path)return immutable.OrderedSet();path=slicedToArray(path,2);var previousText=path[0];return offset.hasDescendant(path[1])?immutable.OrderedSet(previousText.marks):immutable.OrderedSet(currentMarks)}},{key:\"getNodesAtRange\",\nvalue:function(range){warning(!1,\"As of slate@0.47, the `getNodesAtRange` method has been renamed to `getDescendantsAtRange`.\");range=this.descendants({range:range});range=Array.from(range,function(_ref58){return slicedToArray(_ref58,1)[0]});return immutable.List(range)}},{key:\"isNodeInRange\",value:function(path,range){warning(!1,\"As of slate@0.47, the `isNodeInRange` method has been renamed to `isInRange`.\");return this.isInRange(path,range)}},{key:\"text\",get:function(){return this.getText()}}]);\nreturn ElementInterface}(),ASSERTS=\"Child Depth Descendant Node Parent Path\".split(\" \"),_loop$1=function(method){ElementInterface.prototype[\"assert\"+method]=function(path){for(var _len=arguments.length,args=Array(1<_len?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];_len=this[\"get\"+method].apply(this,[path].concat(args));if(null==_len)throw Error(\"`Node.assert\"+method+\"` could not find node with path or key: \"+path);return _len}},_iteratorNormalCompletion9=!0,_didIteratorError9=!1,\n_iteratorError9=void 0;try{for(var _iterator9=ASSERTS[Symbol.iterator](),_step9;!(_iteratorNormalCompletion9=(_step9=_iterator9.next()).done);_iteratorNormalCompletion9=!0)_loop$1(_step9.value)}catch(err$25){_didIteratorError9=!0,_iteratorError9=err$25}finally{try{!_iteratorNormalCompletion9&&_iterator9.return&&_iterator9.return()}finally{if(_didIteratorError9)throw _iteratorError9;}}memoize(ElementInterface.prototype,\"getBlocksAsArray getBlocksByTypeAsArray getDecorations getFragmentAtRange getInlinesAsArray getInlinesByTypeAsArray getInsertMarksAtRange getLeafBlocksAtRangeAsArray getLeafBlocksAtRangeAsArray getLeafInlinesAtRangeAsArray getMarksAsArray getMarksAtPosition getMarksByTypeAsArray getNextBlock getNodesAtRange getNodesToPathsMap getOffset getOffsetAtRange getOrderedMarksBetweenPositions getPreviousBlock getRootBlocksAtRange getRootInlinesAtRangeAsArray getTextAtOffset getTextDirection getTextsAsArray getTextsBetweenPathPositionsAsArray\".split(\" \"));\nmixin(ElementInterface,[Block,Document$jscomp$0,Inline]);var RangeInterface=function(){function RangeInterface(){classCallCheck(this,RangeInterface)}createClass(RangeInterface,[{key:\"flip\",value:function(){return this.setPoints([this.focus,this.anchor])}},{key:\"moveForward\",value:function(n){return this.updatePoints(function(point){return point.moveForward(n)})}},{key:\"moveBackward\",value:function(n){return this.updatePoints(function(point){return point.moveBackward(n)})}},{key:\"moveAnchorBackward\",\nvalue:function(n){return this.setAnchor(this.anchor.moveBackward(n))}},{key:\"moveAnchorForward\",value:function(n){return this.setAnchor(this.anchor.moveForward(n))}},{key:\"moveAnchorTo\",value:function(path,offset){return this.setAnchor(this.anchor.moveTo(path,offset))}},{key:\"moveAnchorToStartOfNode\",value:function(node){return this.setAnchor(this.anchor.moveToStartOfNode(node))}},{key:\"moveAnchorToEndOfNode\",value:function(node){return this.setAnchor(this.anchor.moveToEndOfNode(node))}},{key:\"moveEndBackward\",\nvalue:function(n){return this.setEnd(this.end.moveBackward(n))}},{key:\"moveEndForward\",value:function(n){return this.setEnd(this.end.moveForward(n))}},{key:\"moveEndTo\",value:function(path,offset){return this.setEnd(this.end.moveTo(path,offset))}},{key:\"moveEndToStartOfNode\",value:function(node){return this.setEnd(this.end.moveToStartOfNode(node))}},{key:\"moveEndToEndOfNode\",value:function(node){return this.setEnd(this.end.moveToEndOfNode(node))}},{key:\"moveFocusBackward\",value:function(n){return this.setFocus(this.focus.moveBackward(n))}},\n{key:\"moveFocusForward\",value:function(n){return this.setFocus(this.focus.moveForward(n))}},{key:\"moveFocusTo\",value:function(path,offset){return this.setFocus(this.focus.moveTo(path,offset))}},{key:\"moveFocusToStartOfNode\",value:function(node){return this.setFocus(this.focus.moveToStartOfNode(node))}},{key:\"moveFocusToEndOfNode\",value:function(node){return this.setFocus(this.focus.moveToEndOfNode(node))}},{key:\"moveStartBackward\",value:function(n){return this.setStart(this.start.moveBackward(n))}},\n{key:\"moveStartForward\",value:function(n){return this.setStart(this.start.moveForward(n))}},{key:\"moveStartTo\",value:function(path,offset){return this.setStart(this.start.moveTo(path,offset))}},{key:\"moveStartToStartOfNode\",value:function(node){return this.setStart(this.start.moveToStartOfNode(node))}},{key:\"moveStartToEndOfNode\",value:function(node){return this.setStart(this.start.moveToEndOfNode(node))}},{key:\"moveTo\",value:function(path,offset){return this.updatePoints(function(point){return point.moveTo(path,\noffset)})}},{key:\"moveToAnchor\",value:function(){return this.setFocus(this.anchor)}},{key:\"moveToEnd\",value:function(){return this.setStart(this.end)}},{key:\"moveToEndOfNode\",value:function(node){return this.updatePoints(function(point){return point.moveToEndOfNode(node)})}},{key:\"moveToFocus\",value:function(){return this.setAnchor(this.focus)}},{key:\"moveToRangeOfNode\",value:function(start){var end=1<arguments.length&&void 0!==arguments[1]?arguments[1]:start;return this.setPoints([this.anchor.moveToStartOfNode(start),\nthis.focus.moveToEndOfNode(end)])}},{key:\"moveToStart\",value:function(){return this.setEnd(this.start)}},{key:\"moveToStartOfNode\",value:function(node){return this.updatePoints(function(point){return point.moveToStartOfNode(node)})}},{key:\"normalize\",value:function(node){return this.updatePoints(function(point){return point.normalize(node)})}},{key:\"setAnchor\",value:function(anchor){return this.set(\"anchor\",anchor)}},{key:\"setEnd\",value:function(point){return this.isBackward?this.setAnchor(point):\nthis.setFocus(point)}},{key:\"setFocus\",value:function(focus){return this.set(\"focus\",focus)}},{key:\"setPoints\",value:function(values){values=slicedToArray(values,2);var focus=values[1];return this.set(\"anchor\",values[0]).set(\"focus\",focus)}},{key:\"updatePoints\",value:function(updater){var anchor=this.anchor,focus=this.focus;anchor=updater(anchor);focus=updater(focus);return this.merge({anchor:anchor,focus:focus})}},{key:\"setStart\",value:function(point){return this.isBackward?this.setFocus(point):\nthis.setAnchor(point)}},{key:\"setProperties\",value:function(properties){var _properties=properties=Range$jscomp$0.createProperties(properties);properties=_properties.anchor;var focus=_properties.focus;_properties=objectWithoutProperties(_properties,[\"anchor\",\"focus\"]);properties&&(_properties.anchor=Point.create(properties));focus&&(_properties.focus=Point.create(focus));return this.merge(_properties)}},{key:\"toJSON\",value:function(){var options=0<arguments.length&&void 0!==arguments[0]?arguments[0]:\n{};return{object:this.object,anchor:this.anchor.toJSON(options),focus:this.focus.toJSON(options)}}},{key:\"toRange\",value:function(){var properties=Range$jscomp$0.createProperties(this);return Range$jscomp$0.create(properties)}},{key:\"unset\",value:function(){return this.updatePoints(function(p){return p.unset()})}},{key:\"isCollapsed\",get:function(){return this.anchor===this.focus||this.anchor.key===this.focus.key&&this.anchor.offset===this.focus.offset}},{key:\"isExpanded\",get:function(){return!this.isCollapsed}},\n{key:\"isBackward\",get:function(){var anchor=this.anchor,focus=this.focus;return this.isUnset?null:anchor.key===focus.key?anchor.offset>focus.offset:PathUtils.isBefore(focus.path,anchor.path)}},{key:\"isForward\",get:function(){var isBackward=this.isBackward;return null==isBackward?null:!isBackward}},{key:\"isUnset\",get:function(){var focus=this.focus;return this.anchor.isUnset||focus.isUnset}},{key:\"isSet\",get:function(){return!this.isUnset}},{key:\"start\",get:function(){return this.isBackward?this.focus:\nthis.anchor}},{key:\"end\",get:function(){return this.isBackward?this.anchor:this.focus}}]);return RangeInterface}();mixin(RangeInterface,[Annotation,Decoration,Range$jscomp$0,Selection$jscomp$0]);var index$jscomp$0={Annotation:Annotation,Block:Block,Change:Change,Data:Data,Decoration:Decoration,Document:Document$jscomp$0,Editor:Editor,Inline:Inline,KeyUtils:KeyUtils,Leaf:Leaf$1,Mark:Mark,Node:Node$jscomp$0,Operation:Operation,PathUtils:PathUtils,Point:Point,Range:Range$jscomp$0,resetMemoization:resetMemoization,\nSelection:Selection$jscomp$0,Text:Text$jscomp$0,TextUtils:TextUtils,useMemoization:useMemoization,Value:Value};exports.Annotation=Annotation;exports.Block=Block;exports.Change=Change;exports.Data=Data;exports.Decoration=Decoration;exports.Document=Document$jscomp$0;exports.Editor=Editor;exports.Inline=Inline;exports.KeyUtils=KeyUtils;exports.Leaf=Leaf$1;exports.Mark=Mark;exports.Node=Node$jscomp$0;exports.Operation=Operation;exports.PathUtils=PathUtils;exports.Point=Point;exports.Range=Range$jscomp$0;\nexports.resetMemoization=resetMemoization;exports.Selection=Selection$jscomp$0;exports.Text=Text$jscomp$0;exports.TextUtils=TextUtils;exports.useMemoization=useMemoization;exports.Value=Value;exports.default=index$jscomp$0}","~:source","shadow$provide[\"module$node_modules$slate$lib$slate\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar immutable = require('immutable');\nvar isPlainObject = _interopDefault(require('is-plain-object'));\nvar warning = _interopDefault(require('tiny-warning'));\nvar invariant = _interopDefault(require('tiny-invariant'));\nvar Debug = _interopDefault(require('debug'));\nvar esrever = require('esrever');\nvar pick = _interopDefault(require('lodash/pick'));\nvar omit = _interopDefault(require('lodash/omit'));\nvar getDirection = _interopDefault(require('direction'));\n\n/**\n * An auto-incrementing index for generating keys.\n *\n * @type {Number}\n */\n\nvar n = void 0;\n\n/**\n * The global key generating function.\n *\n * @type {Function}\n */\n\nvar generate = void 0;\n\n/**\n * Create a key, using a provided key if available.\n *\n * @param {String|Void} key\n * @return {String}\n */\n\nfunction create(key) {\n  if (key == null) {\n    return generate();\n  }\n\n  if (typeof key === 'string') {\n    return key;\n  }\n\n  throw new Error('Keys must be strings, but you passed: ' + key);\n}\n\n/**\n * Set a different unique ID generating `function`.\n *\n * @param {Function} func\n */\n\nfunction setGenerator(func) {\n  generate = func;\n}\n\n/**\n * Reset the key generating function to its initial state.\n */\n\nfunction resetGenerator() {\n  n = 0;\n  generate = function generate() {\n    return '' + n++;\n  };\n}\n\n/**\n * Set the initial state.\n */\n\nresetGenerator();\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nvar KeyUtils = {\n  create: create,\n  setGenerator: setGenerator,\n  resetGenerator: resetGenerator\n};\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\nvar objectWithoutProperties = function (obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n};\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\n\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/**\n * Compare paths `path` and `target` to see which is before or after.\n *\n * @param {List} path\n * @param {List} target\n * @return {Number|Null}\n */\n\nfunction compare(path, target) {\n  var m = min(path, target);\n\n  for (var i = 0; i < m; i++) {\n    var pv = path.get(i);\n    var tv = target.get(i);\n\n    // If the path's value is ever less than the target's, it's before.\n    if (pv < tv) return -1;\n\n    // If the target's value is ever less than the path's, it's after.\n    if (pv > tv) return 1;\n  }\n\n  // Paths should now be equal, otherwise something is wrong\n  return path.size === target.size ? 0 : null;\n}\n\n/**\n * Create a path from `attrs`.\n *\n * @param {Array|List} attrs\n * @return {List}\n */\n\nfunction create$1(attrs) {\n  if (attrs == null) {\n    return null;\n  }\n\n  if (immutable.List.isList(attrs)) {\n    return attrs;\n  }\n\n  if (Array.isArray(attrs)) {\n    return immutable.List(attrs);\n  }\n\n  throw new Error('Paths can only be created from arrays or lists, but you passed: ' + attrs);\n}\n\n/**\n * Crop paths `a` and `b` to an equal size, defaulting to the shortest.\n *\n * @param {List} a\n * @param {List} b\n */\n\nfunction crop(a, b) {\n  var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : min(a, b);\n\n  var ca = a.slice(0, size);\n  var cb = b.slice(0, size);\n  return [ca, cb];\n}\n\n/**\n * Decrement a `path` by `n` at `index`, defaulting to the last index.\n *\n * @param {List} path\n * @param {Number} n\n * @param {Number} index\n */\n\nfunction decrement(path) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path.size - 1;\n\n  return increment(path, 0 - n, index);\n}\n\n/**\n * Get all ancestor paths of th given path.\n *\n * @param {List} path\n * @returns {List}\n */\n\nfunction getAncestors(path) {\n  var ancestors = immutable.List().withMutations(function (list) {\n    for (var i = 0; i < path.size; i++) {\n      list.push(path.slice(0, i));\n    }\n  });\n\n  return ancestors;\n}\n\n/**\n * Increment a `path` by `n` at `index`, defaulting to the last index.\n *\n * @param {List} path\n * @param {Number} n\n * @param {Number} index\n */\n\nfunction increment(path) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path.size - 1;\n\n  var value = path.get(index);\n  var newValue = value + n;\n  var newPath = path.set(index, newValue);\n  return newPath;\n}\n\n/**\n * Is a `path` above another `target` path?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isAbove(path, target) {\n  var _crop = crop(path, target),\n      _crop2 = slicedToArray(_crop, 2),\n      p = _crop2[0],\n      t = _crop2[1];\n\n  return path.size < target.size && compare(p, t) === 0;\n}\n\n/**\n * Is a `path` after another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isAfter(path, target) {\n  var _crop3 = crop(path, target),\n      _crop4 = slicedToArray(_crop3, 2),\n      p = _crop4[0],\n      t = _crop4[1];\n\n  return compare(p, t) === 1;\n}\n\n/**\n * Is a `path` before another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isBefore(path, target) {\n  var _crop5 = crop(path, target),\n      _crop6 = slicedToArray(_crop5, 2),\n      p = _crop6[0],\n      t = _crop6[1];\n\n  return compare(p, t) === -1;\n}\n\n/**\n * Is a `path` equal to another `target` path in a document?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isEqual(path, target) {\n  return path.equals(target);\n}\n\n/**\n * Is a `path` older than a `target` path? Meaning that it ends as an older\n * sibling of one of the indexes in the target.\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isOlder(path, target) {\n  var index = path.size - 1;\n\n  var _crop7 = crop(path, target, index),\n      _crop8 = slicedToArray(_crop7, 2),\n      p = _crop8[0],\n      t = _crop8[1];\n\n  var pl = path.get(index);\n  var tl = target.get(index);\n  return isEqual(p, t) && pl > tl;\n}\n\n/**\n * Is an `any` object a path?\n *\n * @param {Mixed} any\n * @return {Boolean}\n */\n\nfunction isPath(any) {\n  return (immutable.List.isList(any) || Array.isArray(any)) && any.every(function (n) {\n    return typeof n === 'number';\n  });\n}\n\n/**\n * Is a `path` a sibling of a `target` path?\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isSibling(path, target) {\n  if (path.size !== target.size) return false;\n  var p = path.butLast();\n  var t = target.butLast();\n  return p.equals(t);\n}\n\n/**\n * Is a `path` younger than a `target` path? Meaning that it ends as a younger\n * sibling of one of the indexes in the target.\n *\n * @param {List} path\n * @param {List} target\n * @return {Boolean}\n */\n\nfunction isYounger(path, target) {\n  var index = path.size - 1;\n\n  var _crop9 = crop(path, target, index),\n      _crop10 = slicedToArray(_crop9, 2),\n      p = _crop10[0],\n      t = _crop10[1];\n\n  var pl = path.get(index);\n  var tl = target.get(index);\n  return isEqual(p, t) && pl < tl;\n}\n\n/**\n * Lift a `path` to refer to its `n`th ancestor.\n *\n * @param {List} path\n * @return {List}\n */\n\nfunction lift(path) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n  var ancestor = path.slice(0, -1 * n);\n  return ancestor;\n}\n\n/**\n * Drop a `path`, returning a relative path from a depth of `n`.\n *\n * @param {List} path\n * @param {Number} n\n * @return {List}\n */\n\nfunction drop(path) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n  var relative = path.slice(n);\n  return relative;\n}\n\n/**\n * Get the maximum length of paths `a` and `b`.\n *\n * @param {List} path\n * @param {List} path\n * @return {Number}\n */\n\nfunction max(a, b) {\n  var n = Math.max(a.size, b.size);\n  return n;\n}\n\n/**\n * Get the minimum length of paths `a` and `b`.\n *\n * @param {List} path\n * @param {List} path\n * @return {Number}\n */\n\nfunction min(a, b) {\n  var n = Math.min(a.size, b.size);\n  return n;\n}\n\n/**\n * Get the common ancestor path of path `a` and path `b`.\n *\n * @param {List} a\n * @param {List} b\n * @return {List}\n */\n\nfunction relate(a, b) {\n  var array = [];\n\n  for (var i = 0; i < a.size && i < b.size; i++) {\n    var av = a.get(i);\n    var bv = b.get(i);\n\n    // If the values aren't equal, they've diverged and don't share an ancestor.\n    if (av !== bv) break;\n\n    // Otherwise, the current value is still a common ancestor.\n    array.push(av);\n  }\n\n  var path = create$1(array);\n  return path;\n}\n\n/**\n * Transform a `path` by an `operation`, adjusting it to stay current.\n *\n * @param {List} path\n * @param {Operation} operation\n * @return {List<List>}\n */\n\nfunction transform(path, operation) {\n  var type = operation.type,\n      position = operation.position,\n      p = operation.path;\n\n\n  if (type === 'add_mark' || type === 'insert_text' || type === 'remove_mark' || type === 'remove_text' || type === 'set_mark' || type === 'set_node' || type === 'set_selection' || type === 'set_value' || type === 'add_annotation' || type === 'remove_annotation' || type === 'set_annotation' || path.size === 0) {\n    return immutable.List([path]);\n  }\n\n  var pIndex = p.size - 1;\n  var pEqual = isEqual(p, path);\n  var pYounger = isYounger(p, path);\n  var pAbove = isAbove(p, path);\n\n  if (type === 'insert_node') {\n    if (pEqual || pYounger || pAbove) {\n      path = increment(path, 1, pIndex);\n    }\n  }\n\n  if (type === 'remove_node') {\n    if (pYounger) {\n      path = decrement(path, 1, pIndex);\n    } else if (pEqual || pAbove) {\n      path = [];\n    }\n  }\n\n  if (type === 'merge_node') {\n    if (pEqual || pYounger) {\n      path = decrement(path, 1, pIndex);\n    } else if (pAbove) {\n      path = decrement(path, 1, pIndex);\n      path = increment(path, position, pIndex + 1);\n    }\n  }\n\n  if (type === 'split_node') {\n    if (pEqual) {\n      path = [path, increment(path)];\n    } else if (pYounger) {\n      path = increment(path, 1, pIndex);\n    } else if (pAbove) {\n      if (path.get(pIndex + 1) >= position) {\n        path = increment(path, 1, pIndex);\n        path = decrement(path, position, pIndex + 1);\n      }\n    }\n  }\n\n  if (type === 'move_node') {\n    var np = operation.newPath;\n\n\n    if (isEqual(p, np)) {\n      return immutable.List([path]);\n    }\n\n    if (pAbove || pEqual) {\n      // We are comparing something that was moved\n      // The new path is unaffected unless the old path was the left-sibling of an ancestor\n      if (isYounger(p, np) && p.size < np.size) {\n        path = decrement(np, 1, min(np, p) - 1).concat(path.slice(p.size));\n      } else {\n        path = np.concat(path.slice(p.size));\n      }\n    } else {\n      // This is equivalent logic to remove_node for path\n      if (pYounger) {\n        path = decrement(path, 1, pIndex);\n      }\n\n      // This is the equivalent logic to insert_node for newPath\n      if (isYounger(np, path) || isEqual(np, path) || isAbove(np, path)) {\n        path = increment(path, 1, np.size - 1);\n      }\n    }\n  }\n\n  var paths = Array.isArray(path) ? path : [path];\n  return immutable.List(paths);\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nvar PathUtils = {\n  compare: compare,\n  create: create$1,\n  crop: crop,\n  decrement: decrement,\n  getAncestors: getAncestors,\n  increment: increment,\n  isAbove: isAbove,\n  isAfter: isAfter,\n  isBefore: isBefore,\n  isEqual: isEqual,\n  isOlder: isOlder,\n  isPath: isPath,\n  isSibling: isSibling,\n  isYounger: isYounger,\n  lift: lift,\n  drop: drop,\n  max: max,\n  min: min,\n  relate: relate,\n  transform: transform\n};\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS = {\n  key: undefined,\n  offset: undefined,\n  path: undefined\n\n  /**\n   * Point.\n   *\n   * @type {Point}\n   */\n\n};\nvar Point = function (_Record) {\n  inherits(Point, _Record);\n\n  function Point() {\n    classCallCheck(this, Point);\n    return possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).apply(this, arguments));\n  }\n\n  createClass(Point, [{\n    key: 'isAfterPoint',\n\n\n    /**\n     * Check whether the point is after another `point`.\n     *\n     * @return {Boolean}\n     */\n\n    value: function isAfterPoint(point) {\n      if (this.isUnset) return false;\n      var is = this.key === point.key && this.offset > point.offset || PathUtils.compare(this.path, point.path) === 1;\n      return is;\n    }\n\n    /**\n     * Check whether the point is after a `range`.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAfterRange',\n    value: function isAfterRange(range) {\n      if (this.isUnset) return false;\n      var is = this.isAfterPoint(range.end);\n      return is;\n    }\n\n    /**\n     * Check whether the point is at the end of a `range`.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAtEndOfRange',\n    value: function isAtEndOfRange(range) {\n      if (this.isUnset) return false;\n      var is = this.equals(range.end);\n      return is;\n    }\n\n    /**\n     * Check whether the point is at the start of a `range`.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAtStartOfRange',\n    value: function isAtStartOfRange(range) {\n      if (this.isUnset) return false;\n      var is = this.equals(range.start);\n      return is;\n    }\n\n    /**\n     * Check whether the point is before another `point`.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBeforePoint',\n    value: function isBeforePoint(point) {\n      if (this.isUnset) return false;\n      var is = this.key === point.key && this.offset < point.offset || PathUtils.compare(this.path, point.path) === -1;\n      return is;\n    }\n\n    /**\n     * Check whether the point is before a `range`.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBeforeRange',\n    value: function isBeforeRange(range) {\n      if (this.isUnset) return false;\n      var is = this.isBeforePoint(range.start);\n      return is;\n    }\n\n    /**\n     * Check whether the point is inside a `range`.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isInRange',\n    value: function isInRange(range) {\n      if (this.isUnset) return false;\n      var is = this.equals(range.start) || this.equals(range.end) || this.isAfterPoint(range.start) && this.isBeforePoint(range.end);\n      return is;\n    }\n\n    /**\n     * Check whether the point is at the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAtEndOfNode',\n    value: function isAtEndOfNode(node) {\n      if (this.isUnset) return false;\n      var last = node.getLastText();\n      var is = this.key === last.key && this.offset === last.text.length;\n      return is;\n    }\n\n    /**\n     * Check whether the point is at the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isAtStartOfNode',\n    value: function isAtStartOfNode(node) {\n      if (this.isUnset) return false;\n\n      // PERF: Do a check for a `0` offset first since it's quickest.\n      if (this.offset !== 0) return false;\n\n      var first = node.getFirstText();\n      var is = this.key === first.key;\n      return is;\n    }\n\n    /**\n     * Check whether the point is in a `node`.\n     *\n     * @param {Node} node\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isInNode',\n    value: function isInNode(node) {\n      if (this.isUnset) return false;\n      if (node.object === 'text' && node.key === this.key) return true;\n      if (node.hasNode(this.key)) return true;\n      return false;\n    }\n\n    /**\n     * Move the point's offset backward `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Point}\n     */\n\n  }, {\n    key: 'moveBackward',\n    value: function moveBackward() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      if (n === 0) return this;\n      if (n < 0) return this.moveForward(-n);\n      var point = this.setOffset(this.offset - n);\n      return point;\n    }\n\n    /**\n     * Move the point's offset forward `n` characters.\n     *\n     * @param {Number} n (optional)\n     * @return {Point}\n     */\n\n  }, {\n    key: 'moveForward',\n    value: function moveForward() {\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      if (n === 0) return this;\n      if (n < 0) return this.moveBackward(-n);\n      var point = this.setOffset(this.offset + n);\n      return point;\n    }\n\n    /**\n     * Move the point's anchor point to a new `path` and `offset`.\n     *\n     * Optionally, the `path` can be a key string, or omitted entirely in which\n     * case it would be the offset number.\n     *\n     * @param {List|String|Number} path\n     * @param {Number} offset\n     * @return {Point}\n     */\n\n  }, {\n    key: 'moveTo',\n    value: function moveTo(path) {\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n      var key = this.key;\n\n      if (typeof path === 'number') {\n        offset = path;\n        path = this.path;\n      } else if (typeof path === 'string') {\n        key = path;\n        path = key === this.key ? this.path : null;\n      } else {\n        key = path.equals(this.path) ? this.key : null;\n      }\n\n      var point = this.merge({ key: key, path: path, offset: offset });\n      return point;\n    }\n\n    /**\n     * Move the point's anchor point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Point}\n     */\n\n  }, {\n    key: 'moveToStartOfNode',\n    value: function moveToStartOfNode(node) {\n      var first = node.getFirstText();\n      var point = this.moveTo(first.key, 0);\n      return point;\n    }\n\n    /**\n     * Move the point's anchor point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Point}\n     */\n\n  }, {\n    key: 'moveToEndOfNode',\n    value: function moveToEndOfNode(node) {\n      var last = node.getLastText();\n      var point = this.moveTo(last.key, last.text.length);\n      return point;\n    }\n\n    /**\n     * Normalize the point relative to a `node`, ensuring that its key and path\n     * reference a text node, or that it gets unset.\n     *\n     * @param {Node} node\n     * @return {Point}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(node) {\n      // If both the key and path are null, there's no reference to a node, so\n      // make sure it is entirely unset.\n      if (this.key == null && this.path == null) {\n        return this.setOffset(null);\n      }\n\n      var key = this.key,\n          offset = this.offset,\n          path = this.path;\n\n      // PERF: this function gets called a lot.\n      // to avoid creating the key -> path lookup table, we attempt to look up by path first.\n\n      var target = path && node.getNode(path);\n\n      if (!target) {\n        target = node.getNode(key);\n\n        if (target) {\n          // There is a misalignment of path and key\n          var _point = this.merge({\n            path: node.getPath(key)\n          });\n\n          return _point;\n        }\n      }\n\n      if (!target) {\n        warning(false, \"A point's `path` or `key` invalid and was reset!\");\n\n        var text = node.getFirstText();\n        if (!text) return Point.create();\n\n        var _point2 = this.merge({\n          key: text.key,\n          offset: 0,\n          path: node.getPath(text.key)\n        });\n\n        return _point2;\n      }\n\n      if (target.object !== 'text') {\n        warning(false, 'A point should not reference a non-text node!');\n\n        var _text = target.getTextAtOffset(offset);\n        var before = target.getOffset(_text.key);\n        var _point3 = this.merge({\n          offset: offset - before,\n          key: _text.key,\n          path: node.getPath(_text.key)\n        });\n\n        return _point3;\n      }\n\n      if (target && path && key && key !== target.key) {\n        warning(false, \"A point's `key` did not match its `path`!\");\n\n        // TODO: if we look up by path above and it differs by key, do we want to reset it to looking up by key?\n      }\n\n      var point = this.merge({\n        key: target.key,\n        path: path == null ? node.getPath(target.key) : path,\n        offset: offset == null ? 0 : Math.min(offset, target.text.length)\n      });\n\n      // COMPAT: There is an ambiguity, since a point can exist at the end of a\n      // text node, or at the start of the following one. To eliminate it we\n      // enforce that if there is a following text node, we always move it there.\n      if (point.offset === target.text.length) {\n        var block = node.getClosestBlock(point.path);\n        // TODO: this next line is broken because `getNextText` takes a path\n        var next = block.getNextText();\n\n        if (next) {\n          point = point.merge({\n            key: next.key,\n            path: node.getPath(next.key),\n            offset: 0\n          });\n        }\n      }\n\n      return point;\n    }\n\n    /**\n     * Set the point's key to a new `key`.\n     *\n     * @param {String} key\n     * @return {Point}\n     */\n\n  }, {\n    key: 'setKey',\n    value: function setKey(key) {\n      if (key != null) {\n        key = KeyUtils.create(key);\n      }\n\n      var point = this.set('key', key);\n      return point;\n    }\n\n    /**\n     * Set the point's offset to a new `offset`.\n     *\n     * @param {Number} offset\n     * @return {Point}\n     */\n\n  }, {\n    key: 'setOffset',\n    value: function setOffset(offset) {\n      var point = this.set('offset', offset);\n      return point;\n    }\n\n    /**\n     * Set the point's path to a new `path`.\n     *\n     * @param {List|Array} path\n     * @return {Point}\n     */\n\n  }, {\n    key: 'setPath',\n    value: function setPath(path) {\n      if (path != null) {\n        path = PathUtils.create(path);\n      }\n\n      var point = this.set('path', path);\n      return point;\n    }\n\n    /**\n     * Return a JSON representation of the point.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        key: this.key,\n        offset: this.offset,\n        path: this.path && this.path.toArray()\n      };\n\n      if (!options.preserveKeys) {\n        delete object.key;\n      }\n\n      return object;\n    }\n\n    /**\n     * Unset the point.\n     *\n     * @return {Point}\n     */\n\n  }, {\n    key: 'unset',\n    value: function unset() {\n      return this.merge({\n        key: null,\n        offset: null,\n        path: null\n      });\n    }\n  }, {\n    key: 'isSet',\n\n\n    /**\n     * Check whether all properties of the point are set.\n     *\n     * @return {Boolean}\n     */\n\n    get: function get$$1() {\n      return this.key != null && this.offset != null && this.path != null;\n    }\n\n    /**\n     * Check whether any property of the point is not set.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isUnset',\n    get: function get$$1() {\n      return !this.isSet;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Point` with `attrs`.\n     *\n     * @param {Object|Point} attrs\n     * @return {Point}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Point.isPoint(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Point.fromJSON(attrs);\n      }\n\n      throw new Error('`Point.create` only accepts objects or points, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a dictionary of settable point properties from `attrs`.\n     *\n     * @param {Object|Point} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Point.isPoint(a)) {\n        return {\n          key: a.key,\n          offset: a.offset,\n          path: a.path\n        };\n      }\n\n      if (isPlainObject(a)) {\n        var p = {};\n        if ('key' in a) p.key = a.key;\n        if ('offset' in a) p.offset = a.offset;\n        if ('path' in a) p.path = PathUtils.create(a.path);\n\n        // If only a path is set, or only a key is set, ensure that the other is\n        // set to null so that it can be normalized back to the right value.\n        // Otherwise we won't realize that the path and key don't match anymore.\n        if ('path' in a && !('key' in a)) p.key = null;\n        if ('key' in a && !('path' in a)) p.path = null;\n\n        return p;\n      }\n\n      throw new Error('`Point.createProperties` only accepts objects or points, but you passed it: ' + a);\n    }\n\n    /**\n     * Create a `Point` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Point}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var _object$key = object.key,\n          key = _object$key === undefined ? null : _object$key,\n          _object$offset = object.offset,\n          offset = _object$offset === undefined ? null : _object$offset,\n          _object$path = object.path,\n          path = _object$path === undefined ? null : _object$path;\n\n\n      var point = new Point({\n        key: key,\n        offset: offset,\n        path: PathUtils.create(path)\n      });\n\n      return point;\n    }\n  }]);\n  return Point;\n}(immutable.Record(DEFAULTS));\n\n/**\n * Data.\n *\n * This isn't an immutable record, it's just a thin wrapper around `Map` so that\n * we can allow for more convenient creation.\n *\n * @type {Object}\n */\n\nvar Data = function () {\n  function Data() {\n    classCallCheck(this, Data);\n  }\n\n  createClass(Data, null, [{\n    key: 'create',\n\n    /**\n     * Create a new `Data` with `attrs`.\n     *\n     * @param {Object|Data|Map} attrs\n     * @return {Data} data\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (immutable.Map.isMap(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Data.fromJSON(attrs);\n      }\n\n      throw new Error('`Data.create` only accepts objects or maps, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Data` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Data}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      return new immutable.Map(object);\n    }\n\n    /**\n     * Alias `fromJS`.\n     */\n\n  }]);\n  return Data;\n}();\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nData.fromJS = Data.fromJSON;\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$1 = {\n  data: undefined,\n  type: undefined\n\n  /**\n   * Mark.\n   *\n   * @type {Mark}\n   */\n\n};\nvar Mark = function (_Record) {\n  inherits(Mark, _Record);\n\n  function Mark() {\n    classCallCheck(this, Mark);\n    return possibleConstructorReturn(this, (Mark.__proto__ || Object.getPrototypeOf(Mark)).apply(this, arguments));\n  }\n\n  createClass(Mark, [{\n    key: 'toJSON',\n\n\n    /**\n     * Return a JSON representation of the mark.\n     *\n     * @return {Object}\n     */\n\n    value: function toJSON() {\n      var object = {\n        object: this.object,\n        type: this.type,\n        data: this.data.toJSON()\n      };\n\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Mark` with `attrs`.\n     *\n     * @param {Object|Mark} attrs\n     * @return {Mark}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Mark.isMark(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs === 'string') {\n        attrs = { type: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Mark.fromJSON(attrs);\n      }\n\n      throw new Error('`Mark.create` only accepts objects, strings or marks, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a set of marks.\n     *\n     * @param {Array<Object|Mark>} elements\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'createSet',\n    value: function createSet(elements) {\n      if (immutable.Set.isSet(elements) || Array.isArray(elements)) {\n        var marks = new immutable.Set(elements.map(Mark.create));\n        return marks;\n      }\n\n      if (elements == null) {\n        return immutable.Set();\n      }\n\n      throw new Error('`Mark.createSet` only accepts sets, arrays or null, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a dictionary of settable mark properties from `attrs`.\n     *\n     * @param {Object|String|Mark} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Mark.isMark(attrs)) {\n        return {\n          data: attrs.data,\n          type: attrs.type\n        };\n      }\n\n      if (typeof attrs === 'string') {\n        return { type: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        var props = {};\n        if ('type' in attrs) props.type = attrs.type;\n        if ('data' in attrs) props.data = Data.create(attrs.data);\n        return props;\n      }\n\n      throw new Error('`Mark.createProperties` only accepts objects, strings or marks, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Mark` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Mark}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          type = object.type;\n\n\n      if (typeof type !== 'string') {\n        throw new Error('`Mark.fromJS` requires a `type` string.');\n      }\n\n      var mark = new Mark({\n        type: type,\n        data: new immutable.Map(data)\n      });\n\n      return mark;\n    }\n\n    /**\n     * Check if `any` is a set of marks.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isMarkSet',\n    value: function isMarkSet(any) {\n      return immutable.Set.isSet(any) && any.every(function (item) {\n        return Mark.isMark(item);\n      });\n    }\n  }]);\n  return Mark;\n}(immutable.Record(DEFAULTS$1));\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$2 = {\n  type: undefined,\n  data: undefined,\n  anchor: undefined,\n  focus: undefined\n\n  /**\n   * Decoration.\n   *\n   * @type {Decoration}\n   */\n\n};\nvar Decoration = function (_Record) {\n  inherits(Decoration, _Record);\n\n  function Decoration() {\n    classCallCheck(this, Decoration);\n    return possibleConstructorReturn(this, (Decoration.__proto__ || Object.getPrototypeOf(Decoration)).apply(this, arguments));\n  }\n\n  createClass(Decoration, [{\n    key: 'setProperties',\n\n\n    /**\n     * Set new `properties` on the decoration.\n     *\n     * @param {Object|Range|Selection} properties\n     * @return {Range}\n     */\n\n    value: function setProperties(properties) {\n      properties = Decoration.createProperties(properties);\n      var decoration = this.merge(properties);\n      return decoration;\n    }\n\n    /**\n     * Return a JSON representation of the decoration.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        type: this.type,\n        data: this.data.toJSON(),\n        anchor: this.anchor.toJSON(options),\n        focus: this.focus.toJSON(options)\n      };\n\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Decoration` with `attrs`.\n     *\n     * @param {Object|Decoration} attrs\n     * @return {Decoration}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Decoration.isDecoration(attrs)) {\n        return attrs;\n      }\n\n      if (Range.isRange(attrs)) {\n        return Decoration.fromJSON(Range.createProperties(attrs));\n      }\n\n      if (isPlainObject(attrs)) {\n        return Decoration.fromJSON(attrs);\n      }\n\n      throw new Error('`Decoration.create` only accepts objects or decorations, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Ranges` from `elements`.\n     *\n     * @param {Array<Decoration|Object>|List<Decoration|Object>} elements\n     * @return {List<Decoration>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\n        var list = new immutable.List(elements.map(Decoration.create));\n        return list;\n      }\n\n      throw new Error('`Decoration.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a dictionary of settable decoration properties from `attrs`.\n     *\n     * @param {Object|String|Decoration} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Decoration.isDecoration(a)) {\n        return {\n          type: a.type,\n          data: a.data,\n          anchor: Point.createProperties(a.anchor),\n          focus: Point.createProperties(a.focus),\n          mark: Mark.create(a.mark)\n        };\n      }\n\n      if (isPlainObject(a)) {\n        var p = {};\n        if ('type' in a) p.type = a.type;\n        if ('data' in a) p.data = Data.create(a.data);\n        if ('anchor' in a) p.anchor = Point.create(a.anchor);\n        if ('focus' in a) p.focus = Point.create(a.focus);\n        return p;\n      }\n\n      throw new Error('`Decoration.createProperties` only accepts objects or decorations, but you passed it: ' + a);\n    }\n\n    /**\n     * Create a `Decoration` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Decoration}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var anchor = object.anchor,\n          focus = object.focus;\n      var type = object.type,\n          data = object.data;\n\n\n      if (object.mark && !type) {\n        warning(false, 'As of slate@0.47 the `decoration.mark` property has been changed to `decoration.type` and `decoration.data` directly.');\n\n        type = object.mark.type;\n        data = object.mark.data;\n      }\n\n      if (!type) {\n        throw new Error('Decorations must be created with a `type`, but you passed: ' + JSON.stringify(object));\n      }\n\n      var decoration = new Decoration({\n        type: type,\n        data: Data.create(data || {}),\n        anchor: Point.fromJSON(anchor || {}),\n        focus: Point.fromJSON(focus || {})\n      });\n\n      return decoration;\n    }\n  }]);\n  return Decoration;\n}(immutable.Record(DEFAULTS$2));\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$3 = {\n  anchor: undefined,\n  focus: undefined,\n  isFocused: undefined,\n  marks: undefined\n\n  /**\n   * Selection.\n   *\n   * @type {Selection}\n   */\n\n};\nvar Selection = function (_Record) {\n  inherits(Selection, _Record);\n\n  function Selection() {\n    classCallCheck(this, Selection);\n    return possibleConstructorReturn(this, (Selection.__proto__ || Object.getPrototypeOf(Selection)).apply(this, arguments));\n  }\n\n  createClass(Selection, [{\n    key: 'setIsFocused',\n\n\n    /**\n     * Set the `isFocused` property to a new `value`.\n     *\n     * @param {Boolean} value\n     * @return {Selection}\n     */\n\n    value: function setIsFocused(value) {\n      var selection = this.set('isFocused', value);\n      return selection;\n    }\n\n    /**\n     * Set the `marks` property to a new set of `marks`.\n     *\n     * @param {Set} marks\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'setMarks',\n    value: function setMarks(marks) {\n      var selection = this.set('marks', marks);\n      return selection;\n    }\n\n    /**\n     * Set new `properties` on the selection.\n     *\n     * @param {Object|Range|Selection} properties\n     * @return {Range}\n     */\n\n  }, {\n    key: 'setProperties',\n    value: function setProperties(properties) {\n      properties = Selection.createProperties(properties);\n      var _properties = properties,\n          anchor = _properties.anchor,\n          focus = _properties.focus,\n          props = objectWithoutProperties(_properties, ['anchor', 'focus']);\n\n\n      if (anchor) {\n        props.anchor = Point.create(anchor);\n      }\n\n      if (focus) {\n        props.focus = Point.create(focus);\n      }\n\n      var selection = this.merge(props);\n      return selection;\n    }\n\n    /**\n     * Return a JSON representation of the selection.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        anchor: this.anchor.toJSON(options),\n        focus: this.focus.toJSON(options),\n        isFocused: this.isFocused,\n        marks: this.marks == null ? null : this.marks.toArray().map(function (m) {\n          return m.toJSON();\n        })\n      };\n\n      return object;\n    }\n  }, {\n    key: 'isBlurred',\n\n\n    /**\n     * Check whether the selection is blurred.\n     *\n     * @return {Boolean}\n     */\n\n    get: function get$$1() {\n      return !this.isFocused;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Selection` with `attrs`.\n     *\n     * @param {Object|Selection} attrs\n     * @return {Selection}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Selection.isSelection(attrs)) {\n        return attrs;\n      }\n\n      if (Range.isRange(attrs)) {\n        return Selection.fromJSON(Range.createProperties(attrs));\n      }\n\n      if (isPlainObject(attrs)) {\n        return Selection.fromJSON(attrs);\n      }\n\n      throw new Error('`Selection.create` only accepts objects, ranges or selections, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a dictionary of settable selection properties from `attrs`.\n     *\n     * @param {Object|String|Selection} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Selection.isSelection(a)) {\n        return {\n          anchor: Point.createProperties(a.anchor),\n          focus: Point.createProperties(a.focus),\n          isFocused: a.isFocused,\n          marks: a.marks\n        };\n      }\n\n      if (Range.isRange(a)) {\n        return {\n          anchor: Point.createProperties(a.anchor),\n          focus: Point.createProperties(a.focus)\n        };\n      }\n\n      if (isPlainObject(a)) {\n        var p = {};\n        if ('anchor' in a) p.anchor = Point.create(a.anchor);\n        if ('focus' in a) p.focus = Point.create(a.focus);\n        if ('isFocused' in a) p.isFocused = a.isFocused;\n        if ('marks' in a) p.marks = a.marks == null ? null : Mark.createSet(a.marks);\n        return p;\n      }\n\n      throw new Error('`Selection.createProperties` only accepts objects, ranges or selections, but you passed it: ' + a);\n    }\n\n    /**\n     * Create a `Selection` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var anchor = object.anchor,\n          focus = object.focus,\n          _object$isFocused = object.isFocused,\n          isFocused = _object$isFocused === undefined ? false : _object$isFocused,\n          _object$marks = object.marks,\n          marks = _object$marks === undefined ? null : _object$marks;\n\n      var selection = new Selection({\n        anchor: Point.fromJSON(anchor || {}),\n        focus: Point.fromJSON(focus || {}),\n        isFocused: isFocused,\n        marks: marks == null ? null : new immutable.Set(marks.map(Mark.fromJSON))\n      });\n\n      return selection;\n    }\n  }]);\n  return Selection;\n}(immutable.Record(DEFAULTS$3));\n\n/**\n * Slate-specific object types.\n *\n * @type {Object}\n */\n\nvar TYPES = {\n  annotation: '@@__SLATE_ANNOTATION__@@',\n  block: '@@__SLATE_BLOCK__@@',\n  change: '@@__SLATE_CHANGE__@@',\n  decoration: '@@__SLATE_DECORATION__@@',\n  document: '@@__SLATE_DOCUMENT__@@',\n  editor: '@@__SLATE_EDITOR__@@',\n  inline: '@@__SLATE_INLINE__@@',\n  leaf: '@@__SLATE_LEAF__@@',\n  mark: '@@__SLATE_MARK__@@',\n  operation: '@@__SLATE_OPERATION__@@',\n  point: '@@__SLATE_POINT__@@',\n  range: '@@__SLATE_RANGE__@@',\n  selection: '@@__SLATE_SELECTION__@@',\n  text: '@@__SLATE_TEXT__@@',\n  value: '@@__SLATE_VALUE__@@'\n\n  /**\n   * Determine whether a `value` is of `type`.\n   *\n   * @param {string} type\n   * @param {any} value\n   * @return {boolean}\n   */\n\n};function isObject(type, value) {\n  return !!(value && value[TYPES[type]]);\n}\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$4 = {\n  anchor: undefined,\n  focus: undefined\n\n  /**\n   * Range.\n   *\n   * @type {Range}\n   */\n\n};\nvar Range = function (_Record) {\n  inherits(Range, _Record);\n\n  function Range() {\n    classCallCheck(this, Range);\n    return possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).apply(this, arguments));\n  }\n\n  createClass(Range, [{\n    key: 'toJSON',\n\n\n    /**\n     * Return a JSON representation of the range.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        anchor: this.anchor.toJSON(options),\n        focus: this.focus.toJSON(options)\n      };\n\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Range` with `attrs`.\n     *\n     * @param {Object|Range} attrs\n     * @return {Range}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Range.isRange(attrs)) {\n        if (attrs.object === 'range') {\n          return attrs;\n        } else {\n          return Range.fromJSON(Range.createProperties(attrs));\n        }\n      }\n\n      if (isPlainObject(attrs)) {\n        return Range.fromJSON(attrs);\n      }\n\n      throw new Error('`Range.create` only accepts objects or ranges, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Ranges` from `elements`.\n     *\n     * @param {Array<Range|Object>|List<Range|Object>} elements\n     * @return {List<Range>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\n        var list = new immutable.List(elements.map(Range.create));\n        return list;\n      }\n\n      throw new Error('`Range.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a dictionary of settable range properties from `attrs`.\n     *\n     * @param {Object|String|Range} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Range.isRange(a)) {\n        return {\n          anchor: Point.createProperties(a.anchor),\n          focus: Point.createProperties(a.focus)\n        };\n      }\n\n      if (isPlainObject(a)) {\n        var p = {};\n        if ('anchor' in a) p.anchor = Point.create(a.anchor);\n        if ('focus' in a) p.focus = Point.create(a.focus);\n        return p;\n      }\n\n      throw new Error('`Range.createProperties` only accepts objects, annotations, decorations, ranges or selections, but you passed it: ' + a);\n    }\n\n    /**\n     * Create a `Range` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Range}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var anchor = object.anchor,\n          focus = object.focus;\n\n      var range = new Range({\n        anchor: Point.fromJSON(anchor || {}),\n        focus: Point.fromJSON(focus || {})\n      });\n\n      return range;\n    }\n\n    /**\n     * Check if a `value` is a `Range`, or is range-like.\n     *\n     * @param {Any} value\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isRange',\n    value: function isRange(value) {\n      return isObject('range', value) || Decoration.isDecoration(value) || Selection.isSelection(value);\n    }\n  }]);\n  return Range;\n}(immutable.Record(DEFAULTS$4));\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$5 = {\n  key: undefined,\n  type: undefined,\n  data: undefined,\n  anchor: undefined,\n  focus: undefined\n\n  /**\n   * Annotation.\n   *\n   * @type {Annotation}\n   */\n\n};\nvar Annotation = function (_Record) {\n  inherits(Annotation, _Record);\n\n  function Annotation() {\n    classCallCheck(this, Annotation);\n    return possibleConstructorReturn(this, (Annotation.__proto__ || Object.getPrototypeOf(Annotation)).apply(this, arguments));\n  }\n\n  createClass(Annotation, [{\n    key: 'setProperties',\n\n\n    /**\n     * Set new `properties` on the annotation.\n     *\n     * @param {Object|Range|Selection} properties\n     * @return {Range}\n     */\n\n    value: function setProperties(properties) {\n      properties = Annotation.createProperties(properties);\n      var annotation = this.merge(properties);\n      return annotation;\n    }\n\n    /**\n     * Return a JSON representation of the annotation.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        key: this.key,\n        type: this.type,\n        data: this.data.toJSON(),\n        anchor: this.anchor.toJSON(options),\n        focus: this.focus.toJSON(options)\n      };\n\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Annotation` with `attrs`.\n     *\n     * @param {Object|Annotation} attrs\n     * @return {Annotation}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Annotation.isAnnotation(attrs)) {\n        return attrs;\n      }\n\n      if (Range.isRange(attrs)) {\n        return Annotation.fromJSON(Range.createProperties(attrs));\n      }\n\n      if (isPlainObject(attrs)) {\n        return Annotation.fromJSON(attrs);\n      }\n\n      throw new Error('`Annotation.create` only accepts objects or annotations, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a map of annotations from `elements`.\n     *\n     * @param {Object<String,Annotation>|Map<String,Annotation>} elements\n     * @return {Map<String,Annotation>}\n     */\n\n  }, {\n    key: 'createMap',\n    value: function createMap() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.Map.isMap(elements)) {\n        return elements;\n      }\n\n      if (isPlainObject(elements)) {\n        var obj = {};\n\n        for (var key in elements) {\n          var value = elements[key];\n          var annotation = Annotation.create(value);\n          obj[key] = annotation;\n        }\n\n        return immutable.Map(obj);\n      }\n\n      throw new Error('`Annotation.createMap` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a dictionary of settable annotation properties from `attrs`.\n     *\n     * @param {Object|String|Annotation} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Annotation.isAnnotation(a)) {\n        return {\n          key: a.key,\n          type: a.type,\n          data: a.data,\n          anchor: Point.createProperties(a.anchor),\n          focus: Point.createProperties(a.focus)\n        };\n      }\n\n      if (isPlainObject(a)) {\n        var p = {};\n        if ('key' in a) p.key = a.key;\n        if ('type' in a) p.type = a.type;\n        if ('data' in a) p.data = Data.create(a.data);\n        if ('anchor' in a) p.anchor = Point.create(a.anchor);\n        if ('focus' in a) p.focus = Point.create(a.focus);\n        return p;\n      }\n\n      throw new Error('`Annotation.createProperties` only accepts objects or annotations, but you passed it: ' + a);\n    }\n\n    /**\n     * Create a `Annotation` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Annotation}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var key = object.key,\n          type = object.type,\n          data = object.data,\n          anchor = object.anchor,\n          focus = object.focus;\n\n\n      if (!key) {\n        throw new Error('Annotations must be created with a `key`, but you passed: ' + JSON.stringify(object));\n      }\n\n      if (!type) {\n        throw new Error('Annotations must be created with a `type`, but you passed: ' + JSON.stringify(object));\n      }\n\n      var annotation = new Annotation({\n        key: key,\n        type: type,\n        data: Data.create(data || {}),\n        anchor: Point.fromJSON(anchor || {}),\n        focus: Point.fromJSON(focus || {})\n      });\n\n      return annotation;\n    }\n  }]);\n  return Annotation;\n}(immutable.Record(DEFAULTS$5));\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$6 = {\n  data: undefined,\n  key: undefined,\n  nodes: undefined\n\n  /**\n   * Document.\n   *\n   * @type {Document}\n   */\n\n};\nvar Document = function (_Record) {\n  inherits(Document, _Record);\n\n  function Document() {\n    classCallCheck(this, Document);\n    return possibleConstructorReturn(this, (Document.__proto__ || Object.getPrototypeOf(Document)).apply(this, arguments));\n  }\n\n  createClass(Document, [{\n    key: 'toJSON',\n\n\n    /**\n     * Return a JSON representation of the document.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        data: this.data.toJSON(),\n        nodes: this.nodes.toArray().map(function (n) {\n          return n.toJSON(options);\n        })\n      };\n\n      if (options.preserveKeys) {\n        object.key = this.key;\n      }\n\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Document` with `attrs`.\n     *\n     * @param {Object|Array|List|Text} attrs\n     * @return {Document}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Document.isDocument(attrs)) {\n        return attrs;\n      }\n\n      if (immutable.List.isList(attrs) || Array.isArray(attrs)) {\n        attrs = { nodes: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Document.fromJSON(attrs);\n      }\n\n      throw new Error('`Document.create` only accepts objects, arrays, lists or documents, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Document` from a JSON `object`.\n     *\n     * @param {Object|Document} object\n     * @return {Document}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Document.isDocument(object)) {\n        return object;\n      }\n\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          _object$key = object.key,\n          key = _object$key === undefined ? KeyUtils.create() : _object$key,\n          _object$nodes = object.nodes,\n          nodes = _object$nodes === undefined ? [] : _object$nodes;\n\n\n      var document = new Document({\n        key: key,\n        data: new immutable.Map(data),\n        nodes: Node.createList(nodes)\n      });\n\n      return document;\n    }\n  }]);\n  return Document;\n}(immutable.Record(DEFAULTS$6));\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$7 = {\n  data: undefined,\n  key: undefined,\n  nodes: undefined,\n  type: undefined\n\n  /**\n   * Inline.\n   *\n   * @type {Inline}\n   */\n\n};\nvar Inline = function (_Record) {\n  inherits(Inline, _Record);\n\n  function Inline() {\n    classCallCheck(this, Inline);\n    return possibleConstructorReturn(this, (Inline.__proto__ || Object.getPrototypeOf(Inline)).apply(this, arguments));\n  }\n\n  createClass(Inline, [{\n    key: 'toJSON',\n\n\n    /**\n     * Return a JSON representation of the inline.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        type: this.type,\n        data: this.data.toJSON(),\n        nodes: this.nodes.toArray().map(function (n) {\n          return n.toJSON(options);\n        })\n      };\n\n      if (options.preserveKeys) {\n        object.key = this.key;\n      }\n\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Inline` with `attrs`.\n     *\n     * @param {Object|String|Inline} attrs\n     * @return {Inline}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Inline.isInline(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs === 'string') {\n        attrs = { type: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Inline.fromJSON(attrs);\n      }\n\n      throw new Error('`Inline.create` only accepts objects, strings or inlines, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Inlines` from an array.\n     *\n     * @param {Array<Inline|Object>|List<Inline|Object>} elements\n     * @return {List<Inline>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\n        var list = new immutable.List(elements.map(Inline.create));\n        return list;\n      }\n\n      throw new Error('`Inline.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a `Inline` from a JSON `object`.\n     *\n     * @param {Object|Inline} object\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Inline.isInline(object)) {\n        return object;\n      }\n\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          _object$key = object.key,\n          key = _object$key === undefined ? KeyUtils.create() : _object$key,\n          _object$nodes = object.nodes,\n          nodes = _object$nodes === undefined ? [] : _object$nodes,\n          type = object.type;\n\n\n      if (typeof type !== 'string') {\n        throw new Error('`Inline.fromJS` requires a `type` string.');\n      }\n\n      var inline = new Inline({\n        key: key,\n        type: type,\n        data: new immutable.Map(data),\n        nodes: Node.createList(nodes)\n      });\n\n      return inline;\n    }\n\n    /**\n     * Check if `any` is a list of inlines.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isInlineList',\n    value: function isInlineList(any) {\n      return immutable.List.isList(any) && any.every(function (item) {\n        return Inline.isInline(item);\n      });\n    }\n  }]);\n  return Inline;\n}(immutable.Record(DEFAULTS$7));\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$8 = {\n  key: undefined,\n  marks: undefined,\n  text: undefined\n};\n\nvar Leaf = immutable.Record({\n  text: undefined,\n  marks: undefined,\n  annotations: undefined,\n  decorations: undefined\n});\n\n/**\n * Text.\n *\n * @type {Text}\n */\n\nvar Text = function (_Record) {\n  inherits(Text, _Record);\n\n  function Text() {\n    classCallCheck(this, Text);\n    return possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).apply(this, arguments));\n  }\n\n  createClass(Text, [{\n    key: 'addMark',\n\n\n    /**\n     * Add a `mark`.\n     *\n     * @param {Mark} mark\n     * @return {Text}\n     */\n\n    value: function addMark(mark) {\n      mark = Mark.create(mark);\n      var marks = this.marks;\n\n      var next = marks.add(mark);\n      var node = this.set('marks', next);\n      return node;\n    }\n\n    /**\n     * Add a set of `marks`.\n     *\n     * @param {Set<Mark>} marks\n     * @return {Text}\n     */\n\n  }, {\n    key: 'addMarks',\n    value: function addMarks(marks) {\n      marks = Mark.createSet(marks);\n      var node = this.set('marks', this.marks.union(marks));\n      return node;\n    }\n\n    /**\n     * Get a list of uniquely-formatted leaves for the text node, given its\n     * existing marks, and its current `annotations` and `decorations`.\n     *\n     * @param {Map<String,Annotation>} annotations\n     * @param {List<Decoration>} decorations\n     * @return {List<Leaf>}\n     */\n\n  }, {\n    key: 'getLeaves',\n    value: function getLeaves(annotations, decorations) {\n      var text = this.text,\n          marks = this.marks;\n\n      var leaves = [{ text: text, marks: marks, annotations: [], decorations: [] }];\n\n      // Helper to split a leaf into two `at` an offset.\n      var split = function split(leaf, at) {\n        return [{\n          text: leaf.text.slice(0, at),\n          marks: leaf.marks,\n          annotations: [].concat(toConsumableArray(leaf.annotations)),\n          decorations: [].concat(toConsumableArray(leaf.decorations))\n        }, {\n          text: leaf.text.slice(at),\n          marks: leaf.marks,\n          annotations: [].concat(toConsumableArray(leaf.annotations)),\n          decorations: [].concat(toConsumableArray(leaf.decorations))\n        }];\n      };\n\n      // Helper to compile the leaves for a `kind` of format.\n      var compile = function compile(kind) {\n        var formats = kind === 'annotations' ? annotations.values() : decorations;\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = formats[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var format = _step.value;\n            var start = format.start,\n                end = format.end;\n\n            var next = [];\n            var o = 0;\n\n            var _iteratorNormalCompletion2 = true;\n            var _didIteratorError2 = false;\n            var _iteratorError2 = undefined;\n\n            try {\n              for (var _iterator2 = leaves[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                var leaf = _step2.value;\n                var length = leaf.text.length;\n\n                var offset = o;\n                o += length;\n\n                // If the range encompases the entire leaf, add the format.\n                if (start.offset <= offset && end.offset >= offset + length) {\n                  leaf[kind].push(format);\n                  next.push(leaf);\n                  continue;\n                }\n\n                // If the range starts after the leaf, or ends before it, continue.\n                if (start.offset > offset + length || end.offset < offset || end.offset === offset && offset !== 0) {\n                  next.push(leaf);\n                  continue;\n                }\n\n                // Otherwise we need to split the leaf, at the start, end, or both,\n                // and add the format to the middle intersecting section. Do the end\n                // split first since we don't need to update the offset that way.\n                var middle = leaf;\n                var before = void 0;\n                var after = void 0;\n\n                if (end.offset < offset + length) {\n                  \n                  var _split = split(middle, end.offset - offset);\n\n                  var _split2 = slicedToArray(_split, 2);\n\n                  middle = _split2[0];\n                  after = _split2[1];\n                }\n\n                if (start.offset > offset) {\n                  \n                  var _split3 = split(middle, start.offset - offset);\n\n                  var _split4 = slicedToArray(_split3, 2);\n\n                  before = _split4[0];\n                  middle = _split4[1];\n                }\n\n                middle[kind].push(format);\n\n                if (before) {\n                  next.push(before);\n                }\n\n                next.push(middle);\n\n                if (after) {\n                  next.push(after);\n                }\n              }\n            } catch (err) {\n              _didIteratorError2 = true;\n              _iteratorError2 = err;\n            } finally {\n              try {\n                if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                  _iterator2.return();\n                }\n              } finally {\n                if (_didIteratorError2) {\n                  throw _iteratorError2;\n                }\n              }\n            }\n\n            leaves = next;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      };\n\n      compile('annotations');\n      compile('decorations');\n\n      leaves = leaves.map(function (leaf) {\n        return new Leaf(_extends({}, leaf, {\n          annotations: immutable.List(leaf.annotations),\n          decorations: immutable.List(leaf.decorations)\n        }));\n      });\n\n      var list = immutable.List(leaves);\n      return list;\n    }\n\n    /**\n     * Insert `text` at `index`.\n     *\n     * @param {Number} index\n     * @param {String} string\n     * @return {Text}\n     */\n\n  }, {\n    key: 'insertText',\n    value: function insertText(index, string) {\n      var text = this.text;\n\n      var next = text.slice(0, index) + string + text.slice(index);\n      var node = this.set('text', next);\n      return node;\n    }\n\n    /**\n     * Remove a `mark`.\n     *\n     * @param {Mark} mark\n     * @return {Text}\n     */\n\n  }, {\n    key: 'removeMark',\n    value: function removeMark(mark) {\n      mark = Mark.create(mark);\n      var marks = this.marks;\n\n      var next = marks.remove(mark);\n      var node = this.set('marks', next);\n      return node;\n    }\n\n    /**\n     * Remove text from the text node at `index` for `length`.\n     *\n     * @param {Number} index\n     * @param {Number} length\n     * @return {Text}\n     */\n\n  }, {\n    key: 'removeText',\n    value: function removeText(index, length) {\n      var text = this.text;\n\n      var next = text.slice(0, index) + text.slice(index + length);\n      var node = this.set('text', next);\n      return node;\n    }\n\n    /**\n     * Return a JSON representation of the text.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        text: this.text,\n        marks: this.marks.toArray().map(function (m) {\n          return m.toJSON();\n        })\n      };\n\n      if (options.preserveKeys) {\n        object.key = this.key;\n      }\n\n      return object;\n    }\n\n    /**\n     * Set a `newProperties` on an existing `mark`.\n     *\n     * @param {Object} mark\n     * @param {Object} newProperties\n     * @return {Text}\n     */\n\n  }, {\n    key: 'setMark',\n    value: function setMark(properties, newProperties) {\n      var marks = this.marks;\n\n      var mark = Mark.create(properties);\n      var newMark = mark.merge(newProperties);\n      var next = marks.remove(mark).add(newMark);\n      var node = this.set('marks', next);\n      return node;\n    }\n\n    /**\n     * Split the node into two at `index`.\n     *\n     * @param {Number} index\n     * @returns {Array<Text>}\n     */\n\n  }, {\n    key: 'splitText',\n    value: function splitText(index) {\n      var text = this.text;\n\n      var one = this.set('text', text.slice(0, index));\n      var two = this.set('text', text.slice(index)).regenerateKey();\n      return [one, two];\n    }\n\n    /**\n     * Merge the node with an `other` text node.\n     *\n     * @param {Text} other\n     * @returns {Text}\n     */\n\n  }, {\n    key: 'mergeText',\n    value: function mergeText(other) {\n      var next = this.text + other.text;\n      var node = this.set('text', next);\n      return node;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Text` with `attrs`.\n     *\n     * @param {Object|Array|List|String|Text} attrs\n     * @return {Text}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\n      if (Text.isText(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs === 'string') {\n        attrs = { text: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Text.fromJSON(attrs);\n      }\n\n      throw new Error('`Text.create` only accepts objects, arrays, strings or texts, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Texts` from `elements`.\n     *\n     * @param {Array<Text|Object>|List<Text|Object>} elements\n     * @return {List<Text>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\n        var list = new immutable.List(elements.map(Text.create));\n        return list;\n      }\n\n      throw new Error('`Text.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a `Text` from a JSON `object`.\n     *\n     * @param {Object|Text} object\n     * @return {Text}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Text.isText(object)) {\n        return object;\n      }\n\n      invariant(object.leaves == null, 'As of slate@0.46, the `leaves` property of text nodes has been removed! Each individual leaf should be created as a text node instead.');\n\n      var _object$text = object.text,\n          text = _object$text === undefined ? '' : _object$text,\n          _object$marks = object.marks,\n          marks = _object$marks === undefined ? [] : _object$marks,\n          _object$key = object.key,\n          key = _object$key === undefined ? KeyUtils.create() : _object$key;\n\n      var node = new Text({\n        key: key,\n        text: text,\n        marks: Mark.createSet(marks)\n      });\n\n      return node;\n    }\n\n    /**\n     * Check if `any` is a list of texts.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isTextList',\n    value: function isTextList(any) {\n      return immutable.List.isList(any) && any.every(function (item) {\n        return Text.isText(item);\n      });\n    }\n  }]);\n  return Text;\n}(immutable.Record(DEFAULTS$8));\n\n/**\n * A pseudo-model that is used for its static methods only.\n *\n * @type {Node}\n */\n\nvar Node = function () {\n  function Node() {\n    classCallCheck(this, Node);\n  }\n\n  createClass(Node, null, [{\n    key: 'create',\n\n    /**\n     * Create a new `Node` with `attrs`.\n     *\n     * @param {Object|Node} attrs\n     * @return {Node}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Node.isNode(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        var object = attrs.object;\n\n\n        if (!object && attrs.kind) {\n          warning(false, 'As of slate@0.32.0, the `kind` property of Slate objects has been renamed to `object`.');\n\n          object = attrs.kind;\n        }\n\n        switch (object) {\n          case 'block':\n            return Block.create(attrs);\n          case 'document':\n            return Document.create(attrs);\n          case 'inline':\n            return Inline.create(attrs);\n          case 'text':\n            return Text.create(attrs);\n\n          default:\n            {\n              throw new Error('`Node.create` requires a `object` string.');\n            }\n        }\n      }\n\n      throw new Error('`Node.create` only accepts objects or nodes but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Nodes` from an array.\n     *\n     * @param {Array<Object|Node>} elements\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\n        var array = [];\n\n        elements.forEach(function (el) {\n          if (el && el.object === 'text' && el.leaves && Array.isArray(el.leaves)) {\n            warning(false, 'As of slate@0.46, the `leaves` property of Text nodes has been removed. Instead, each text node contains a string of text and a unique set of marks and leaves are unnecessary.');\n\n            var texts = Text.createList(el.leaves).toArray();\n            array = array.concat(texts);\n            return;\n          }\n\n          var node = Node.create(el);\n          array.push(node);\n        });\n\n        var list = immutable.List(array);\n        return list;\n      }\n\n      throw new Error('`Node.createList` only accepts lists or arrays, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a dictionary of settable node properties from `attrs`.\n     *\n     * @param {Object|String|Node} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Block.isBlock(attrs) || Inline.isInline(attrs)) {\n        return {\n          data: attrs.data,\n          type: attrs.type\n        };\n      }\n\n      if (typeof attrs === 'string') {\n        return { type: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        var props = {};\n        if ('type' in attrs) props.type = attrs.type;\n        if ('data' in attrs) props.data = Data.create(attrs.data);\n        return props;\n      }\n\n      throw new Error('`Node.createProperties` only accepts objects, strings, blocks or inlines, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Node` from a JSON `value`.\n     *\n     * @param {Object} value\n     * @return {Node}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(value) {\n      var object = value.object;\n\n\n      if (!object && value.kind) {\n        warning(false, 'As of slate@0.32.0, the `kind` property of Slate objects has been renamed to `object`.');\n\n        object = value.kind;\n      }\n\n      switch (object) {\n        case 'block':\n          return Block.fromJSON(value);\n        case 'document':\n          return Document.fromJSON(value);\n        case 'inline':\n          return Inline.fromJSON(value);\n        case 'text':\n          return Text.fromJSON(value);\n\n        default:\n          {\n            throw new Error('`Node.fromJSON` requires an `object` of either \\'block\\', \\'document\\', \\'inline\\' or \\'text\\', but you passed: ' + value);\n          }\n      }\n    }\n\n    /**\n     * Check if `any` is a `Node`.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isNode',\n    value: function isNode(any) {\n      return Block.isBlock(any) || Document.isDocument(any) || Inline.isInline(any) || Text.isText(any);\n    }\n\n    /**\n     * Check if `any` is a list of nodes.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isNodeList',\n    value: function isNodeList(any) {\n      return immutable.List.isList(any) && any.every(function (item) {\n        return Node.isNode(item);\n      });\n    }\n  }]);\n  return Node;\n}();\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$9 = {\n  data: undefined,\n  key: undefined,\n  nodes: undefined,\n  type: undefined\n\n  /**\n   * Block.\n   *\n   * @type {Block}\n   */\n\n};\nvar Block = function (_Record) {\n  inherits(Block, _Record);\n\n  function Block() {\n    classCallCheck(this, Block);\n    return possibleConstructorReturn(this, (Block.__proto__ || Object.getPrototypeOf(Block)).apply(this, arguments));\n  }\n\n  createClass(Block, [{\n    key: 'toJSON',\n\n\n    /**\n     * Return a JSON representation of the block.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        type: this.type,\n        data: this.data.toJSON(),\n        nodes: this.nodes.toArray().map(function (n) {\n          return n.toJSON(options);\n        })\n      };\n\n      if (options.preserveKeys) {\n        object.key = this.key;\n      }\n\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Block` from `attrs`.\n     *\n     * @param {Object|String|Block} attrs\n     * @return {Block}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Block.isBlock(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs === 'string') {\n        attrs = { type: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Block.fromJSON(attrs);\n      }\n\n      throw new Error('`Block.create` only accepts objects, strings or blocks, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Blocks` from `attrs`.\n     *\n     * @param {Array<Block|Object>|List<Block|Object>} attrs\n     * @return {List<Block>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(attrs) || Array.isArray(attrs)) {\n        var list = new immutable.List(attrs.map(Block.create));\n        return list;\n      }\n\n      throw new Error('`Block.createList` only accepts arrays or lists, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Block` from a JSON `object`.\n     *\n     * @param {Object|Block} object\n     * @return {Block}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Block.isBlock(object)) {\n        return object;\n      }\n\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          _object$key = object.key,\n          key = _object$key === undefined ? KeyUtils.create() : _object$key,\n          _object$nodes = object.nodes,\n          nodes = _object$nodes === undefined ? [] : _object$nodes,\n          type = object.type;\n\n\n      if (typeof type !== 'string') {\n        throw new Error('`Block.fromJSON` requires a `type` string.');\n      }\n\n      var block = new Block({\n        key: key,\n        type: type,\n        data: immutable.Map(data),\n        nodes: Node.createList(nodes)\n      });\n\n      return block;\n    }\n\n    /**\n     * Check if `any` is a block list.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBlockList',\n    value: function isBlockList(any) {\n      return immutable.List.isList(any) && any.every(function (item) {\n        return Block.isBlock(item);\n      });\n    }\n  }]);\n  return Block;\n}(immutable.Record(DEFAULTS$9));\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$10 = {\n  annotations: undefined,\n  data: undefined,\n  document: undefined,\n  selection: undefined\n\n  /**\n   * Value.\n   *\n   * @type {Value}\n   */\n\n};\nvar Value = function (_Record) {\n  inherits(Value, _Record);\n\n  function Value() {\n    classCallCheck(this, Value);\n    return possibleConstructorReturn(this, (Value.__proto__ || Object.getPrototypeOf(Value)).apply(this, arguments));\n  }\n\n  createClass(Value, [{\n    key: 'addAnnotation',\n\n\n    /**\n     * Add an `annotation` to the value.\n     *\n     * @param {Annotation} annotation\n     * @param {Mark} mark\n     * @return {Value}\n     */\n\n    value: function addAnnotation(annotation) {\n      annotation = Annotation.create(annotation);\n      var value = this;\n      var _value = value,\n          annotations = _value.annotations,\n          document = _value.document;\n      var _annotation = annotation,\n          key = _annotation.key;\n\n      annotation = annotation.updatePoints(function (point) {\n        return point.normalize(document);\n      });\n      annotations = annotations.set(key, annotation);\n      value = value.set('annotations', annotations);\n      return value;\n    }\n\n    /**\n     * Add `mark` to text at `path`.\n     *\n     * @param {List|String} path\n     * @param {Mark} mark\n     * @return {Value}\n     */\n\n  }, {\n    key: 'addMark',\n    value: function addMark(path, mark) {\n      mark = Mark.create(mark);\n      var value = this;\n      var _value2 = value,\n          document = _value2.document;\n\n      document = document.addMark(path, mark);\n      value = value.set('document', document);\n      return value;\n    }\n\n    /**\n     * Insert a `node`.\n     *\n     * @param {List|String} path\n     * @param {Node} node\n     * @return {Value}\n     */\n\n  }, {\n    key: 'insertNode',\n    value: function insertNode(path, node) {\n      var value = this;\n      var _value3 = value,\n          document = _value3.document;\n\n      document = document.insertNode(path, node);\n      value = value.set('document', document);\n\n      value = value.mapRanges(function (range) {\n        return range.updatePoints(function (point) {\n          return point.setPath(null);\n        });\n      });\n\n      return value;\n    }\n\n    /**\n     * Insert `text` at `offset` in node by `path`.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @param {String} text\n     * @return {Value}\n     */\n\n  }, {\n    key: 'insertText',\n    value: function insertText(path, offset, text) {\n      var value = this;\n      var _value4 = value,\n          document = _value4.document;\n\n      var node = document.assertNode(path);\n      document = document.insertText(path, offset, text);\n      node = document.assertNode(path);\n      value = value.set('document', document);\n\n      value = value.mapPoints(function (point) {\n        if (point.key === node.key && point.offset >= offset) {\n          return point.setOffset(point.offset + text.length);\n        } else {\n          return point;\n        }\n      });\n\n      return value;\n    }\n\n    /**\n     * Merge a node backwards its previous sibling.\n     *\n     * @param {List|Key} path\n     * @return {Value}\n     */\n\n  }, {\n    key: 'mergeNode',\n    value: function mergeNode(path) {\n      var value = this;\n      var _value5 = value,\n          document = _value5.document;\n\n      var newDocument = document.mergeNode(path);\n      path = document.resolvePath(path);\n      var withPath = PathUtils.decrement(path);\n      var one = document.getNode(withPath);\n      var two = document.getNode(path);\n      value = value.set('document', newDocument);\n\n      value = value.mapRanges(function (range) {\n        if (two.object === 'text') {\n          var max = one.text.length;\n\n          if (range.anchor.key === two.key) {\n            range = range.moveAnchorTo(one.key, max + range.anchor.offset);\n          }\n\n          if (range.focus.key === two.key) {\n            range = range.moveFocusTo(one.key, max + range.focus.offset);\n          }\n        }\n\n        range = range.updatePoints(function (point) {\n          return point.setPath(null);\n        });\n\n        return range;\n      });\n\n      return value;\n    }\n\n    /**\n     * Move a node by `path` to `newPath`.\n     *\n     * A `newIndex` can be provided when move nodes by `key`, to account for not\n     * being able to have a key for a location in the tree that doesn't exist yet.\n     *\n     * @param {List|Key} path\n     * @param {List|Key} newPath\n     * @param {Number} newIndex\n     * @return {Value}\n     */\n\n  }, {\n    key: 'moveNode',\n    value: function moveNode(path, newPath) {\n      var newIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      var value = this;\n      var _value6 = value,\n          document = _value6.document;\n\n\n      if (PathUtils.isEqual(path, newPath)) {\n        return value;\n      }\n\n      document = document.moveNode(path, newPath, newIndex);\n      value = value.set('document', document);\n      value = value.mapPoints(function (point) {\n        return point.setPath(null);\n      });\n      return value;\n    }\n\n    /**\n     * Remove an `annotation` from the value.\n     *\n     * @param {Annotation} annotation\n     * @param {Mark} mark\n     * @return {Value}\n     */\n\n  }, {\n    key: 'removeAnnotation',\n    value: function removeAnnotation(annotation) {\n      annotation = Annotation.create(annotation);\n      var value = this;\n      var _value7 = value,\n          annotations = _value7.annotations;\n      var _annotation2 = annotation,\n          key = _annotation2.key;\n\n      annotations = annotations.delete(key);\n      value = value.set('annotations', annotations);\n      return value;\n    }\n\n    /**\n     * Remove `mark` at `path`.\n     *\n     * @param {List|String} path\n     * @param {Mark} mark\n     * @return {Value}\n     */\n\n  }, {\n    key: 'removeMark',\n    value: function removeMark(path, mark) {\n      mark = Mark.create(mark);\n      var value = this;\n      var _value8 = value,\n          document = _value8.document;\n\n      document = document.removeMark(path, mark);\n      value = value.set('document', document);\n      return value;\n    }\n\n    /**\n     * Remove a node by `path`.\n     *\n     * @param {List|String} path\n     * @return {Value}\n     */\n\n  }, {\n    key: 'removeNode',\n    value: function removeNode(path) {\n      var value = this;\n      var _value9 = value,\n          document = _value9.document;\n\n      var node = document.assertNode(path);\n      var first = node.object === 'text' ? node : node.getFirstText() || node;\n      var last = node.object === 'text' ? node : node.getLastText() || node;\n      var prev = document.getPreviousText(first.key);\n      var next = document.getNextText(last.key);\n\n      document = document.removeNode(path);\n      value = value.set('document', document);\n\n      value = value.mapRanges(function (range) {\n        var _range = range,\n            anchor = _range.anchor,\n            focus = _range.focus;\n\n\n        if (node.hasNode(anchor.key)) {\n          range = prev ? range.moveAnchorTo(prev.key, prev.text.length) : next ? range.moveAnchorTo(next.key, 0) : range.unset();\n        }\n\n        if (node.hasNode(focus.key)) {\n          range = prev ? range.moveFocusTo(prev.key, prev.text.length) : next ? range.moveFocusTo(next.key, 0) : range.unset();\n        }\n\n        range = range.updatePoints(function (point) {\n          return point.setPath(null);\n        });\n\n        return range;\n      });\n\n      return value;\n    }\n\n    /**\n     * Remove `text` at `offset` in node by `path`.\n     *\n     * @param {List|Key} path\n     * @param {Number} offset\n     * @param {String} text\n     * @return {Value}\n     */\n\n  }, {\n    key: 'removeText',\n    value: function removeText(path, offset, text) {\n      var value = this;\n      var _value10 = value,\n          document = _value10.document;\n\n      var node = document.assertNode(path);\n      document = document.removeText(path, offset, text);\n      value = value.set('document', document);\n\n      var length = text.length;\n\n      var start = offset;\n      var end = offset + length;\n\n      value = value.mapPoints(function (point) {\n        if (point.key !== node.key) {\n          return point;\n        }\n\n        if (point.offset >= end) {\n          return point.setOffset(point.offset - length);\n        }\n\n        if (point.offset > start) {\n          return point.setOffset(start);\n        }\n\n        return point;\n      });\n\n      return value;\n    }\n\n    /**\n     * Add an `annotation` to the value.\n     *\n     * @param {Annotation} annotation\n     * @param {Mark} mark\n     * @return {Value}\n     */\n\n  }, {\n    key: 'setAnnotation',\n    value: function setAnnotation(properties, newProperties) {\n      newProperties = Annotation.createProperties(newProperties);\n      var annotation = Annotation.create(properties);\n      var next = annotation.merge(newProperties);\n      var value = this;\n      var _value11 = value,\n          annotations = _value11.annotations;\n      var key = annotation.key;\n\n      annotations = annotations.set(key, next);\n      value = value.set('annotations', annotations);\n      return value;\n    }\n\n    /**\n     * Set `properties` on a node.\n     *\n     * @param {List|String} path\n     * @param {Object} properties\n     * @return {Value}\n     */\n\n  }, {\n    key: 'setNode',\n    value: function setNode(path, properties) {\n      var value = this;\n      var _value12 = value,\n          document = _value12.document;\n\n      document = document.setNode(path, properties);\n      value = value.set('document', document);\n      return value;\n    }\n\n    /**\n     * Set `properties` on `mark` on text at `offset` and `length` in node.\n     *\n     * @param {List|String} path\n     * @param {Mark} mark\n     * @param {Object} properties\n     * @return {Value}\n     */\n\n  }, {\n    key: 'setMark',\n    value: function setMark(path, mark, properties) {\n      var value = this;\n      var _value13 = value,\n          document = _value13.document;\n\n      document = document.setMark(path, mark, properties);\n      value = value.set('document', document);\n      return value;\n    }\n\n    /**\n     * Set `properties` on the value.\n     *\n     * @param {Object} properties\n     * @return {Value}\n     */\n\n  }, {\n    key: 'setProperties',\n    value: function setProperties(properties) {\n      var value = this;\n      var _value14 = value,\n          document = _value14.document;\n      var data = properties.data,\n          annotations = properties.annotations;\n\n      var props = {};\n\n      if (data) {\n        props.data = data;\n      }\n\n      if (annotations) {\n        props.annotations = annotations.map(function (a) {\n          return a.isSet ? a : document.resolveAnnotation(a);\n        });\n      }\n\n      value = value.merge(props);\n      return value;\n    }\n\n    /**\n     * Set `properties` on the selection.\n     *\n     * @param {Value} value\n     * @param {Operation} operation\n     * @return {Value}\n     */\n\n  }, {\n    key: 'setSelection',\n    value: function setSelection(properties) {\n      var value = this;\n      var _value15 = value,\n          document = _value15.document,\n          selection = _value15.selection;\n\n      var next = selection.setProperties(properties);\n      selection = document.resolveSelection(next);\n      value = value.set('selection', selection);\n      return value;\n    }\n\n    /**\n     * Split a node by `path` at `position` with optional `properties` to apply\n     * to the newly split node.\n     *\n     * @param {List|String} path\n     * @param {Number} position\n     * @param {Object} properties\n     * @return {Value}\n     */\n\n  }, {\n    key: 'splitNode',\n    value: function splitNode(path, position, properties) {\n      var value = this;\n      var _value16 = value,\n          document = _value16.document;\n\n      var newDocument = document.splitNode(path, position, properties);\n      var node = document.assertNode(path);\n      value = value.set('document', newDocument);\n\n      value = value.mapRanges(function (range) {\n        var next = newDocument.getNextText(node.key);\n        var _range2 = range,\n            anchor = _range2.anchor,\n            focus = _range2.focus;\n\n        // If the anchor was after the split, move it to the next node.\n\n        if (node.key === anchor.key && position <= anchor.offset) {\n          range = range.moveAnchorTo(next.key, anchor.offset - position);\n        }\n\n        // If the focus was after the split, move it to the next node.\n        if (node.key === focus.key && position <= focus.offset) {\n          range = range.moveFocusTo(next.key, focus.offset - position);\n        }\n\n        range = range.updatePoints(function (point) {\n          return point.setPath(null);\n        });\n\n        return range;\n      });\n\n      return value;\n    }\n\n    /**\n     * Map all range objects to apply adjustments with an `iterator`.\n     *\n     * @param {Function} iterator\n     * @return {Value}\n     */\n\n  }, {\n    key: 'mapRanges',\n    value: function mapRanges(iterator) {\n      var value = this;\n      var _value17 = value,\n          document = _value17.document,\n          selection = _value17.selection,\n          annotations = _value17.annotations;\n\n\n      var sel = selection.isSet ? iterator(selection) : selection;\n      if (!sel) sel = selection.unset();\n      if (sel !== selection) sel = document.createSelection(sel);\n      value = value.set('selection', sel);\n\n      var anns = annotations.map(function (annotation) {\n        var n = annotation.isSet ? iterator(annotation) : annotation;\n        if (n && n !== annotation) n = document.createAnnotation(n);\n        return n;\n      });\n\n      anns = anns.filter(function (annotation) {\n        return !!annotation;\n      });\n      value = value.set('annotations', anns);\n      return value;\n    }\n  }, {\n    key: 'mapPoints',\n    value: function mapPoints(iterator) {\n      return this.mapRanges(function (range) {\n        return range.updatePoints(iterator);\n      });\n    }\n\n    /**\n     * Return a JSON representation of the value.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        document: this.document.toJSON(options)\n      };\n\n      if (options.preserveData) {\n        object.data = this.data.toJSON(options);\n      }\n\n      if (options.preserveAnnotations) {\n        object.annotations = this.annotations.map(function (a) {\n          return a.toJSON(options);\n        }).toObject();\n      }\n\n      if (options.preserveSelection) {\n        object.selection = this.selection.toJSON(options);\n      }\n\n      return object;\n    }\n\n    /**\n     * Deprecated.\n     */\n\n  }, {\n    key: 'change',\n    value: function change() {\n      invariant(false, 'As of Slate 0.42.0, value object are no longer schema-aware, and the `value.change()` method is no longer available. Use the `editor.change()` method on the new `Editor` controller instead.');\n    }\n  }, {\n    key: 'startBlock',\n\n\n    /**\n     * Get the current start text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n    get: function get$$1() {\n      return this.selection.start.key && this.document.getClosestBlock(this.selection.start.key);\n    }\n\n    /**\n     * Get the current end text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'endBlock',\n    get: function get$$1() {\n      return this.selection.end.key && this.document.getClosestBlock(this.selection.end.key);\n    }\n\n    /**\n     * Get the current anchor text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'anchorBlock',\n    get: function get$$1() {\n      return this.selection.anchor.key && this.document.getClosestBlock(this.selection.anchor.key);\n    }\n\n    /**\n     * Get the current focus text node's closest block parent.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'focusBlock',\n    get: function get$$1() {\n      return this.selection.focus.key && this.document.getClosestBlock(this.selection.focus.key);\n    }\n\n    /**\n     * Get the current start text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'startInline',\n    get: function get$$1() {\n      return this.selection.start.key && this.document.getClosestInline(this.selection.start.key);\n    }\n\n    /**\n     * Get the current end text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'endInline',\n    get: function get$$1() {\n      return this.selection.end.key && this.document.getClosestInline(this.selection.end.key);\n    }\n\n    /**\n     * Get the current anchor text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'anchorInline',\n    get: function get$$1() {\n      return this.selection.anchor.key && this.document.getClosestInline(this.selection.anchor.key);\n    }\n\n    /**\n     * Get the current focus text node's closest inline parent.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'focusInline',\n    get: function get$$1() {\n      return this.selection.focus.key && this.document.getClosestInline(this.selection.focus.key);\n    }\n\n    /**\n     * Get the current start text node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'startText',\n    get: function get$$1() {\n      return this.selection.start.key && this.document.getDescendant(this.selection.start.key);\n    }\n\n    /**\n     * Get the current end node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'endText',\n    get: function get$$1() {\n      return this.selection.end.key && this.document.getDescendant(this.selection.end.key);\n    }\n\n    /**\n     * Get the current anchor node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'anchorText',\n    get: function get$$1() {\n      return this.selection.anchor.key && this.document.getDescendant(this.selection.anchor.key);\n    }\n\n    /**\n     * Get the current focus node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'focusText',\n    get: function get$$1() {\n      return this.selection.focus.key && this.document.getDescendant(this.selection.focus.key);\n    }\n\n    /**\n     * Get the next block node.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'nextBlock',\n    get: function get$$1() {\n      return this.selection.end.key && this.document.getNextBlock(this.selection.end.key);\n    }\n\n    /**\n     * Get the previous block node.\n     *\n     * @return {Block}\n     */\n\n  }, {\n    key: 'previousBlock',\n    get: function get$$1() {\n      return this.selection.start.key && this.document.getPreviousBlock(this.selection.start.key);\n    }\n\n    /**\n     * Get the next inline node.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'nextInline',\n    get: function get$$1() {\n      return this.selection.end.key && this.document.getNextInline(this.selection.end.key);\n    }\n\n    /**\n     * Get the previous inline node.\n     *\n     * @return {Inline}\n     */\n\n  }, {\n    key: 'previousInline',\n    get: function get$$1() {\n      return this.selection.start.key && this.document.getPreviousInline(this.selection.start.key);\n    }\n\n    /**\n     * Get the next text node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'nextText',\n    get: function get$$1() {\n      return this.selection.end.key && this.document.getNextText(this.selection.end.key);\n    }\n\n    /**\n     * Get the previous text node.\n     *\n     * @return {Text}\n     */\n\n  }, {\n    key: 'previousText',\n    get: function get$$1() {\n      return this.selection.start.key && this.document.getPreviousText(this.selection.start.key);\n    }\n\n    /**\n     * Get the marks of the current selection.\n     *\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'marks',\n    get: function get$$1() {\n      return this.selection.isUnset ? new immutable.Set() : this.selection.marks || this.document.getMarksAtRange(this.selection);\n    }\n\n    /**\n     * Get the active marks of the current selection.\n     *\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'activeMarks',\n    get: function get$$1() {\n      return this.selection.isUnset ? new immutable.Set() : this.selection.marks || this.document.getActiveMarksAtRange(this.selection);\n    }\n\n    /**\n     * Get the block nodes in the current selection.\n     *\n     * @return {List<Block>}\n     */\n\n  }, {\n    key: 'blocks',\n    get: function get$$1() {\n      return this.selection.isUnset ? new immutable.List() : this.document.getLeafBlocksAtRange(this.selection);\n    }\n\n    /**\n     * Get the fragment of the current selection.\n     *\n     * @return {Document}\n     */\n\n  }, {\n    key: 'fragment',\n    get: function get$$1() {\n      return this.selection.isUnset ? Document.create() : this.document.getFragmentAtRange(this.selection);\n    }\n\n    /**\n     * Get the bottom-most inline nodes in the current selection.\n     *\n     * @return {List<Inline>}\n     */\n\n  }, {\n    key: 'inlines',\n    get: function get$$1() {\n      return this.selection.isUnset ? new immutable.List() : this.document.getLeafInlinesAtRange(this.selection);\n    }\n\n    /**\n     * Get the text nodes in the current selection.\n     *\n     * @return {List<Text>}\n     */\n\n  }, {\n    key: 'texts',\n    get: function get$$1() {\n      return this.selection.isUnset ? new immutable.List() : this.document.getTextsAtRange(this.selection);\n    }\n  }, {\n    key: 'history',\n    get: function get$$1() {\n      invariant(false, 'As of Slate 0.42.0, the `value.history` model no longer exists, and the history is stored in `value.data` instead using plugins.');\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Value` with `attrs`.\n     *\n     * @param {Object|Value} attrs\n     * @param {Object} options\n     * @return {Value}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (Value.isValue(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Value.fromJSON(attrs, options);\n      }\n\n      throw new Error('`Value.create` only accepts objects or values, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a dictionary of settable value properties from `attrs`.\n     *\n     * @param {Object|Value} attrs\n     * @return {Object}\n     */\n\n  }, {\n    key: 'createProperties',\n    value: function createProperties() {\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Value.isValue(a)) {\n        return {\n          annotations: a.annotations,\n          data: a.data\n        };\n      }\n\n      if (isPlainObject(a)) {\n        var p = {};\n        if ('annotations' in a) p.annotations = Annotation.createMap(a.annotations);\n        if ('data' in a) p.data = Data.create(a.data);\n        return p;\n      }\n\n      throw new Error('`Value.createProperties` only accepts objects or values, but you passed it: ' + a);\n    }\n\n    /**\n     * Create a `Value` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @param {Object} options\n     *   @property {Boolean} normalize\n     *   @property {Array} plugins\n     * @return {Value}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var _object$data = object.data,\n          data = _object$data === undefined ? {} : _object$data,\n          _object$annotations = object.annotations,\n          annotations = _object$annotations === undefined ? {} : _object$annotations,\n          _object$document = object.document,\n          document = _object$document === undefined ? {} : _object$document,\n          _object$selection = object.selection,\n          selection = _object$selection === undefined ? {} : _object$selection;\n\n      data = Data.fromJSON(data);\n      document = Document.fromJSON(document);\n      selection = document.createSelection(selection);\n      annotations = Annotation.createMap(annotations);\n\n      if (selection.isUnset) {\n        var text = document.getFirstText();\n        if (text) selection = selection.moveToStartOfNode(text);\n        selection = document.createSelection(selection);\n      }\n\n      var value = new Value({\n        annotations: annotations,\n        data: data,\n        document: document,\n        selection: selection\n      });\n\n      return value;\n    }\n  }]);\n  return Value;\n}(immutable.Record(DEFAULTS$10));\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = Debug('slate:operation:apply');\n\n/**\n * Apply an `op` to a `value`.\n *\n * @param {Value} value\n * @param {Object|Operation} op\n * @return {Value} value\n */\n\nfunction applyOperation(value, op) {\n  op = Operation.create(op);\n  var _op = op,\n      type = _op.type;\n\n  debug(type, op);\n\n  switch (type) {\n    case 'add_annotation':\n      {\n        var _op2 = op,\n            annotation = _op2.annotation;\n\n        var next = value.addAnnotation(annotation);\n        return next;\n      }\n\n    case 'add_mark':\n      {\n        var _op3 = op,\n            path = _op3.path,\n            mark = _op3.mark;\n\n        var _next = value.addMark(path, mark);\n        return _next;\n      }\n\n    case 'insert_node':\n      {\n        var _op4 = op,\n            _path = _op4.path,\n            node = _op4.node;\n\n        var _next2 = value.insertNode(_path, node);\n        return _next2;\n      }\n\n    case 'insert_text':\n      {\n        var _op5 = op,\n            _path2 = _op5.path,\n            offset = _op5.offset,\n            text = _op5.text,\n            marks = _op5.marks;\n\n        var _next3 = value.insertText(_path2, offset, text, marks);\n        return _next3;\n      }\n\n    case 'merge_node':\n      {\n        var _op6 = op,\n            _path3 = _op6.path;\n\n        var _next4 = value.mergeNode(_path3);\n        return _next4;\n      }\n\n    case 'move_node':\n      {\n        var _op7 = op,\n            _path4 = _op7.path,\n            newPath = _op7.newPath;\n\n        var _next5 = value.moveNode(_path4, newPath);\n        return _next5;\n      }\n\n    case 'remove_annotation':\n      {\n        var _op8 = op,\n            _annotation = _op8.annotation;\n\n        var _next6 = value.removeAnnotation(_annotation);\n        return _next6;\n      }\n\n    case 'remove_mark':\n      {\n        var _op9 = op,\n            _path5 = _op9.path,\n            _mark = _op9.mark;\n\n        var _next7 = value.removeMark(_path5, _mark);\n        return _next7;\n      }\n\n    case 'remove_node':\n      {\n        var _op10 = op,\n            _path6 = _op10.path;\n\n        var _next8 = value.removeNode(_path6);\n        return _next8;\n      }\n\n    case 'remove_text':\n      {\n        var _op11 = op,\n            _path7 = _op11.path,\n            _offset = _op11.offset,\n            _text = _op11.text;\n\n        var _next9 = value.removeText(_path7, _offset, _text);\n        return _next9;\n      }\n\n    case 'set_annotation':\n      {\n        var _op12 = op,\n            properties = _op12.properties,\n            newProperties = _op12.newProperties;\n\n        var _next10 = value.setAnnotation(properties, newProperties);\n        return _next10;\n      }\n\n    case 'set_mark':\n      {\n        var _op13 = op,\n            _path8 = _op13.path,\n            _properties = _op13.properties,\n            _newProperties = _op13.newProperties;\n\n        var _next11 = value.setMark(_path8, _properties, _newProperties);\n        return _next11;\n      }\n\n    case 'set_node':\n      {\n        var _op14 = op,\n            _path9 = _op14.path,\n            _newProperties2 = _op14.newProperties;\n\n        var _next12 = value.setNode(_path9, _newProperties2);\n        return _next12;\n      }\n\n    case 'set_selection':\n      {\n        var _op15 = op,\n            _newProperties3 = _op15.newProperties;\n\n        var _next13 = value.setSelection(_newProperties3);\n        return _next13;\n      }\n\n    case 'set_value':\n      {\n        var _op16 = op,\n            _newProperties4 = _op16.newProperties;\n\n        var _next14 = value.setProperties(_newProperties4);\n        return _next14;\n      }\n\n    case 'split_node':\n      {\n        var _op17 = op,\n            _path10 = _op17.path,\n            position = _op17.position,\n            _properties2 = _op17.properties;\n\n        var _next15 = value.splitNode(_path10, position, _properties2);\n        return _next15;\n      }\n\n    default:\n      {\n        throw new Error('Unknown operation type: \"' + type + '\".');\n      }\n  }\n}\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug$1 = Debug('slate:operation:invert');\n\n/**\n * Invert an `op`.\n *\n * @param {Object} op\n * @return {Object}\n */\n\nfunction invertOperation(op) {\n  op = Operation.create(op);\n  var _op = op,\n      type = _op.type;\n\n  debug$1(type, op);\n\n  switch (type) {\n    case 'move_node':\n      {\n        var _op2 = op,\n            newPath = _op2.newPath,\n            path = _op2.path;\n\n        // PERF: this case can exit early.\n\n        if (PathUtils.isEqual(newPath, path)) {\n          return op;\n        }\n\n        var inversePath = PathUtils.transform(path, op).first();\n\n        // Get the true path we are trying to move back to\n        // We transform the right-sibling of the path\n        // This will end up at the operation.path most of the time\n        // But if the newPath is a left-sibling or left-ancestor-sibling, this will account for it\n        var inverseNewPath = PathUtils.transform(PathUtils.increment(path), op).first();\n\n        var inverse = op.set('path', inversePath).set('newPath', inverseNewPath);\n        return inverse;\n      }\n\n    case 'merge_node':\n      {\n        var _op3 = op,\n            _path = _op3.path;\n\n        var _inversePath = PathUtils.decrement(_path);\n        var _inverse = op.set('type', 'split_node').set('path', _inversePath);\n        return _inverse;\n      }\n\n    case 'split_node':\n      {\n        var _op4 = op,\n            _path2 = _op4.path;\n\n        var _inversePath2 = PathUtils.increment(_path2);\n        var _inverse2 = op.set('type', 'merge_node').set('path', _inversePath2);\n        return _inverse2;\n      }\n\n    case 'set_annotation':\n    case 'set_node':\n    case 'set_value':\n    case 'set_selection':\n    case 'set_mark':\n      {\n        var _op5 = op,\n            properties = _op5.properties,\n            newProperties = _op5.newProperties;\n\n        var _inverse3 = op.set('properties', newProperties).set('newProperties', properties);\n        return _inverse3;\n      }\n\n    case 'insert_node':\n    case 'insert_text':\n      {\n        var _inverse4 = op.set('type', type.replace('insert_', 'remove_'));\n        return _inverse4;\n      }\n\n    case 'remove_node':\n    case 'remove_text':\n      {\n        var _inverse5 = op.set('type', type.replace('remove_', 'insert_'));\n        return _inverse5;\n      }\n\n    case 'add_annotation':\n    case 'add_mark':\n      {\n        var _inverse6 = op.set('type', type.replace('add_', 'remove_'));\n        return _inverse6;\n      }\n\n    case 'remove_annotation':\n    case 'remove_mark':\n      {\n        var _inverse7 = op.set('type', type.replace('remove_', 'add_'));\n        return _inverse7;\n      }\n\n    default:\n      {\n        throw new Error('Unknown operation type: \"' + type + '\".');\n      }\n  }\n}\n\n/**\n * Operation attributes.\n *\n * @type {Array}\n */\n\nvar OPERATION_ATTRIBUTES = {\n  add_mark: ['path', 'mark', 'data'],\n  add_annotation: ['annotation', 'data'],\n  insert_node: ['path', 'node', 'data'],\n  insert_text: ['path', 'offset', 'text', 'data'],\n  merge_node: ['path', 'position', 'properties', 'target', 'data'],\n  move_node: ['path', 'newPath', 'data'],\n  remove_annotation: ['annotation', 'data'],\n  remove_mark: ['path', 'mark', 'data'],\n  remove_node: ['path', 'node', 'data'],\n  remove_text: ['path', 'offset', 'text', 'data'],\n  set_annotation: ['properties', 'newProperties', 'data'],\n  set_mark: ['path', 'properties', 'newProperties', 'data'],\n  set_node: ['path', 'properties', 'newProperties', 'data'],\n  set_selection: ['properties', 'newProperties', 'data'],\n  set_value: ['properties', 'newProperties', 'data'],\n  split_node: ['path', 'position', 'properties', 'target', 'data']\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n};var DEFAULTS$11 = {\n  annotation: undefined,\n  data: undefined,\n  length: undefined,\n  mark: undefined,\n  marks: undefined,\n  newPath: undefined,\n  newProperties: undefined,\n  node: undefined,\n  offset: undefined,\n  path: undefined,\n  position: undefined,\n  properties: undefined,\n  target: undefined,\n  text: undefined,\n  type: undefined\n\n  /**\n   * Operation.\n   *\n   * @type {Operation}\n   */\n\n};\nvar Operation = function (_Record) {\n  inherits(Operation, _Record);\n\n  function Operation() {\n    classCallCheck(this, Operation);\n    return possibleConstructorReturn(this, (Operation.__proto__ || Object.getPrototypeOf(Operation)).apply(this, arguments));\n  }\n\n  createClass(Operation, [{\n    key: 'apply',\n\n\n    /**\n     * Apply the operation to a `value`.\n     *\n     * @param {Value} value\n     * @return {Value}\n     */\n\n    value: function apply(value) {\n      var next = applyOperation(value, this);\n      return next;\n    }\n\n    /**\n     * Invert the operation.\n     *\n     * @return {Operation}\n     */\n\n  }, {\n    key: 'invert',\n    value: function invert() {\n      var inverted = invertOperation(this);\n      return inverted;\n    }\n\n    /**\n     * Return a JSON representation of the operation.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var object = this.object,\n          type = this.type;\n\n      var json = { object: object, type: type };\n      var ATTRIBUTES = OPERATION_ATTRIBUTES[type];\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = ATTRIBUTES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var key = _step.value;\n\n          var value = this[key];\n\n          if (key === 'annotation' || key === 'mark' || key === 'marks' || key === 'node' || key === 'path' || key === 'newPath') {\n            value = value.toJSON();\n          }\n\n          if (key === 'properties' && type === 'merge_node') {\n            var v = {};\n            if ('data' in value) v.data = value.data.toJS();\n            if ('type' in value) v.type = value.type;\n            value = v;\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_annotation') {\n            var _v = {};\n            if ('anchor' in value) _v.anchor = value.anchor.toJS();\n            if ('focus' in value) _v.focus = value.focus.toJS();\n            if ('key' in value) _v.key = value.key;\n            if ('data' in value) _v.data = value.data.toJS();\n            if ('type' in value) _v.type = value.type;\n            value = _v;\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_mark') {\n            var _v2 = {};\n            if ('data' in value) _v2.data = value.data.toJS();\n            if ('type' in value) _v2.type = value.type;\n            value = _v2;\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_node') {\n            var _v3 = {};\n            if ('data' in value) _v3.data = value.data.toJS();\n            if ('type' in value) _v3.type = value.type;\n            value = _v3;\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_selection') {\n            var _v4 = {};\n            if ('anchor' in value) _v4.anchor = value.anchor.toJSON();\n            if ('focus' in value) _v4.focus = value.focus.toJSON();\n            if ('isFocused' in value) _v4.isFocused = value.isFocused;\n            if ('marks' in value) _v4.marks = value.marks && value.marks.toJSON();\n            value = _v4;\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_value') {\n            var _v5 = {};\n            if ('data' in value) _v5.data = value.data.toJS();\n            value = _v5;\n          }\n\n          if (key === 'properties' && type === 'split_node') {\n            var _v6 = {};\n            if ('data' in value) _v6.data = value.data.toJS();\n            if ('type' in value) _v6.type = value.type;\n            value = _v6;\n          }\n\n          if (key === 'data') {\n            value = value.toJSON();\n          }\n\n          json[key] = value;\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return json;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Operation` with `attrs`.\n     *\n     * @param {Object|Array|List|String|Operation} attrs\n     * @return {Operation}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Operation.isOperation(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Operation.fromJSON(attrs);\n      }\n\n      throw new Error('`Operation.create` only accepts objects or operations, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a list of `Operations` from `elements`.\n     *\n     * @param {Array<Operation|Object>|List<Operation|Object>} elements\n     * @return {List<Operation>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\n        var list = new immutable.List(elements.map(Operation.create));\n        return list;\n      }\n\n      throw new Error('`Operation.createList` only accepts arrays or lists, but you passed it: ' + elements);\n    }\n\n    /**\n     * Create a `Operation` from a JSON `object`.\n     *\n     * @param {Object|Operation} object\n     * @return {Operation}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      if (Operation.isOperation(object)) {\n        return object;\n      }\n\n      var type = object.type;\n\n      var ATTRIBUTES = OPERATION_ATTRIBUTES[type];\n      var attrs = { type: type };\n\n      if (!ATTRIBUTES) {\n        throw new Error('`Operation.fromJSON` was passed an unrecognized operation type: \"' + type + '\"');\n      }\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = ATTRIBUTES[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var key = _step2.value;\n\n          var v = object[key];\n\n          // Default `data` to an empty object.\n          if (key === 'data' && v === undefined) {\n            v = {};\n          }\n\n          if (v === undefined) {\n            throw new Error('`Operation.fromJSON` was passed a \"' + type + '\" operation without the required \"' + key + '\" attribute.');\n          }\n\n          if (key === 'annotation') {\n            v = Annotation.create(v);\n          }\n\n          if (key === 'path' || key === 'newPath') {\n            v = PathUtils.create(v);\n          }\n\n          if (key === 'mark') {\n            v = Mark.create(v);\n          }\n\n          if (key === 'node') {\n            v = Node.create(v);\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_annotation') {\n            v = Annotation.createProperties(v);\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_mark') {\n            v = Mark.createProperties(v);\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && (type === 'set_node' || type === 'merge_node' || type === 'split_node')) {\n            v = Node.createProperties(v);\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_selection') {\n            v = Selection.createProperties(v);\n          }\n\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_value') {\n            v = Value.createProperties(v);\n          }\n\n          if (key === 'data') {\n            v = immutable.Map(v);\n          }\n\n          attrs[key] = v;\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      var op = new Operation(attrs);\n      return op;\n    }\n\n    /**\n     * Check if `any` is a list of operations.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isOperationList',\n    value: function isOperationList(any) {\n      return immutable.List.isList(any) && any.every(function (item) {\n        return Operation.isOperation(item);\n      });\n    }\n  }]);\n  return Operation;\n}(immutable.Record(DEFAULTS$11));\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$12 = {\n  operations: undefined,\n  value: undefined\n\n  /**\n   * Change.\n   *\n   * @type {Change}\n   */\n\n};\nvar Change = function (_Record) {\n  inherits(Change, _Record);\n\n  function Change() {\n    classCallCheck(this, Change);\n    return possibleConstructorReturn(this, (Change.__proto__ || Object.getPrototypeOf(Change)).apply(this, arguments));\n  }\n\n  createClass(Change, [{\n    key: 'toJSON',\n\n\n    /**\n     * Return a JSON representation of the change.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        value: this.value.toJSON(options),\n        operations: this.operations.toArray().map(function (o) {\n          return o.toJSON(options);\n        })\n      };\n\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Change` with `attrs`.\n     *\n     * @param {Object|Change} attrs\n     * @return {Change}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (Change.isChange(attrs)) {\n        return attrs;\n      }\n\n      if (isPlainObject(attrs)) {\n        return Change.fromJSON(attrs);\n      }\n\n      throw new Error('`Change.create` only accepts objects or changes, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Change` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Change}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var value = object.value,\n          _object$operations = object.operations,\n          operations = _object$operations === undefined ? [] : _object$operations;\n\n\n      var change = new Change({\n        value: Value.create(value),\n        operations: Operation.createList(operations)\n      });\n\n      return change;\n    }\n  }]);\n  return Change;\n}(immutable.Record(DEFAULTS$12));\n\n/**\n * A plugin that adds a set of commands to the editor.\n *\n * @param {Object} commands\n * @return {Object}\n */\n\nfunction CommandsPlugin() {\n  var commands = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  /**\n   * On command, if it exists in our list of commands, call it.\n   *\n   * @param {Object} command\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCommand(command, editor, next) {\n    var type = command.type,\n        args = command.args;\n\n    var fn = commands[type];\n    if (!fn) return next();\n    editor.command.apply(editor, [fn].concat(toConsumableArray(args)));\n  }\n\n  /**\n   * On construct, register all the commands.\n   *\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onConstruct(editor, next) {\n    for (var command in commands) {\n      editor.registerCommand(command);\n    }\n\n    return next();\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onCommand: onCommand,\n    onConstruct: onConstruct\n  };\n}\n\n/**\n * Surrogate pair start and end points.\n *\n * @type {Number}\n */\n\nvar SURROGATE_START = 0xd800;\nvar SURROGATE_END = 0xdfff;\n\n/**\n * A regex to match space characters.\n *\n * @type {RegExp}\n */\n\nvar SPACE = /\\s/;\n\n/**\n * A regex to match chameleon characters, that count as word characters as long\n * as they are inside of a word.\n *\n * @type {RegExp}\n */\n\nvar CHAMELEON = /['\\u2018\\u2019]/;\n\n/**\n * A regex that matches punctuation.\n *\n * @type {RegExp}\n */\n\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\n\n/**\n * Is a character `code` in a surrogate character.\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isSurrogate(code) {\n  return SURROGATE_START <= code && code <= SURROGATE_END;\n}\n\n/**\n * Does `code` form Modifier with next one.\n *\n * https://emojipedia.org/modifiers/\n *\n * @param {Number} code\n * @param {String} text\n * @param {Number} offset\n * @return {Boolean}\n */\n\nfunction isModifier(code, text, offset) {\n  if (code === 0xd83c) {\n    var next = text.charCodeAt(offset + 1);\n    return next <= 0xdfff && next >= 0xdffb;\n  }\n  return false;\n}\n\n/**\n * Is `code` a Variation Selector.\n *\n * https://codepoints.net/variation_selectors\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isVariationSelector(code) {\n  return code <= 0xfe0f && code >= 0xfe00;\n}\n\n/**\n * Is `code` one of the BMP codes used in emoji sequences.\n *\n * https://emojipedia.org/emoji-zwj-sequences/\n *\n * @param {Number} code\n * @return {Boolean}\n */\n\nfunction isBMPEmoji(code) {\n  // This requires tiny bit of maintanance, better ideas?\n  // Fortunately it only happens if new Unicode Standard\n  // is released. Fails gracefully if upkeep lags behind,\n  // same way Slate previously behaved with all emojis.\n  return code === 0x2764 || // heart (❤)\n  code === 0x2642 || // male (♂)\n  code === 0x2640 || // female (♀)\n  code === 0x2620 || // scull (☠)\n  code === 0x2695 || // medical (⚕)\n  code === 0x2708 || // plane (✈️)\n  code === 0x25ef // large circle (◯)\n  ;\n}\n\n/**\n * Is a character a word character? Needs the `remaining` characters too.\n *\n * @param {String} char\n * @param {String|Void} remaining\n * @return {Boolean}\n */\n\nfunction isWord(char, remaining) {\n  if (SPACE.test(char)) return false;\n\n  // If it's a chameleon character, recurse to see if the next one is or not.\n  if (CHAMELEON.test(char)) {\n    var next = remaining.charAt(0);\n    var length = getCharLength(next);\n    next = remaining.slice(0, length);\n    var rest = remaining.slice(length);\n    if (isWord(next, rest)) return true;\n  }\n\n  if (PUNCTUATION.test(char)) return false;\n  return true;\n}\n\n/**\n * Get the length of a `character`.\n *\n * @param {String} char\n * @return {Number}\n */\n\nfunction getCharLength(char) {\n  return isSurrogate(char.charCodeAt(0)) ? 2 : 1;\n}\n\n/**\n * Get the offset to the end of the character(s) in `text`.\n * This function is emoji aware and handles them correctly.\n *\n * @param {String} text\n * @param {Number} chars\n * @param {Boolean} forward\n * @return {Number}\n */\n\nfunction getCharOffset(text, chars, forward) {\n  var offset = 0;\n\n  // Handle end/beginning of node: we have to return 1 in order not to\n  // break cursor's jumping to next/previous node. We need to return early\n  // because otherwise, ''.charCodeAt(0) returned NaN and, the default\n  // handling 'latin characters' at the end of the while loop would\n  // would never be reached an we returned '0' as offset.\n  if (text === '') return 1;\n\n  // Calculate offset sum of each character\n  for (var i = 0; i < chars; i++) {\n    // `prev` types (better ideas?):\n    // - SURR: surrogate pair\n    // - MOD: modifier (technically also surrogate pair)\n    // - ZWJ: zero width joiner\n    // - VAR: variation selector\n    // - BMP: sequenceable character from Basic Multilingual Plane\n    var prev = null;\n    var charCode = text.charCodeAt(offset);\n\n    while (charCode) {\n      if (isSurrogate(charCode)) {\n        var modifier = isModifier(charCode, text, offset);\n\n        // Early returns are the heart of this loop where\n        // we decide if previous and current codepoints\n        // should form a single character (in other words:\n        // how many of them should selection jump over).\n        if (forward) {\n          if (!modifier && prev && prev !== 'ZWJ' || modifier && prev && prev !== 'SURR') {\n            break;\n          }\n        } else if (prev === 'SURR' || prev === 'BMP') {\n          break;\n        }\n\n        offset += 2;\n        prev = modifier ? 'MOD' : 'SURR';\n        charCode = text.charCodeAt(offset);\n        // It's okay to `continue` without checking\n        // because if `charCode` is NaN (which is\n        // the case when out of `text` range), next\n        // `while` loop won't execute and we're done.\n        continue;\n      }\n\n      // If zero width joiner\n      if (charCode === 0x200d) {\n        offset += 1;\n        prev = 'ZWJ';\n        charCode = text.charCodeAt(offset);\n        continue;\n      }\n\n      if (isBMPEmoji(charCode)) {\n        if (forward && prev === 'VAR' || prev && prev !== 'ZWJ' && prev !== 'VAR') {\n          break;\n        }\n\n        offset += 1;\n        prev = 'BMP';\n        charCode = text.charCodeAt(offset);\n        continue;\n      }\n\n      if (isVariationSelector(charCode)) {\n        if (!forward && prev && prev !== 'ZWJ') {\n          break;\n        }\n\n        offset += 1;\n        prev = 'VAR';\n        charCode = text.charCodeAt(offset);\n        continue;\n      }\n\n      // Modifier \"fuses\" with what ever character is before that\n      // (even whitespace), need to look ahead if loop gets here.\n      if (forward) {\n        var nextCharCode = text.charCodeAt(offset + 1);\n\n        if (isModifier(nextCharCode, text, offset + 1)) {\n          offset += 3;\n          prev = 'MOD';\n          charCode = text.charCodeAt(offset);\n          continue;\n        }\n      } else if (prev === 'MOD') {\n        offset += 1;\n        break;\n      }\n\n      // If while loop ever gets here, we're\n      // done (e.g Latin characters, length 1).\n      if (prev === null) offset += 1;\n      break;\n    }\n  }\n\n  return offset;\n}\n\n/**\n * Get the offset to the end of character(s) before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @param {Number} chars\n * @return {Number}\n */\n\nfunction getCharOffsetBackward(text, offset) {\n  var chars = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n  text = text.slice(0, offset);\n  text = esrever.reverse(text);\n  return getCharOffset(text, chars);\n}\n\n/**\n * Get the offset to the end of character(s) after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @param {Number} chars\n * @return {Number}\n */\n\nfunction getCharOffsetForward(text, offset) {\n  var chars = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n  text = text.slice(offset);\n  return getCharOffset(text, chars, true);\n}\n\n/**\n * Get the offset to the end of the first word in `text`.\n *\n * @param {String} text\n * @return {Number}\n */\n\nfunction getWordOffset(text) {\n  var length = 0;\n  var i = 0;\n  var started = false;\n  var char = void 0;\n\n  while (char = text.charAt(i)) {\n    var l = getCharLength(char);\n    char = text.slice(i, i + l);\n    var rest = text.slice(i + l);\n\n    if (isWord(char, rest)) {\n      started = true;\n      length += l;\n    } else if (!started) {\n      length += l;\n    } else {\n      break;\n    }\n\n    i += l;\n  }\n\n  return length;\n}\n\n/**\n * Get the offset to the end of the word before an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetBackward(text, offset) {\n  text = text.slice(0, offset);\n  text = esrever.reverse(text);\n  var o = getWordOffset(text);\n  return o;\n}\n\n/**\n * Get the offset to the end of the word after an `offset` in `text`.\n *\n * @param {String} text\n * @param {Number} offset\n * @return {Number}\n */\n\nfunction getWordOffsetForward(text, offset) {\n  text = text.slice(offset);\n  var o = getWordOffset(text);\n  return o;\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nvar TextUtils = {\n  getCharLength: getCharLength,\n  getCharOffset: getCharOffset,\n  getCharOffsetBackward: getCharOffsetBackward,\n  getCharOffsetForward: getCharOffsetForward,\n  getWordOffset: getWordOffset,\n  getWordOffsetBackward: getWordOffsetBackward,\n  getWordOffsetForward: getWordOffsetForward,\n  isSurrogate: isSurrogate,\n  isWord: isWord\n};\n\n/**\n * Ensure that an expanded selection is deleted first, and return the updated\n * range to account for the deleted part.\n *\n * @param {Editor}\n */\n\nfunction deleteExpandedAtRange(editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var _range = range,\n      start = _range.start,\n      end = _range.end;\n\n\n  if (document.hasDescendant(start.path)) {\n    range = range.moveToStart();\n  } else {\n    range = range.moveTo(end.path, 0).normalize(document);\n  }\n\n  return range;\n}\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nvar Commands$1 = {};\n\n/**\n * Add a new `mark` to the characters at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Mixed} mark\n */\n\nCommands$1.addMarkAtRange = function (editor, range, mark) {\n  if (range.isCollapsed) return;\n\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start,\n      end = range.end;\n\n  var texts = document.getTextsAtRange(range);\n\n  editor.withoutNormalizing(function () {\n    texts.forEach(function (node) {\n      var key = node.key;\n\n      var index = 0;\n      var length = node.text.length;\n\n      if (key === start.key) index = start.offset;\n      if (key === end.key) length = end.offset;\n      if (key === start.key && key === end.key) length = end.offset - start.offset;\n\n      editor.addMarkByKey(key, index, length, mark);\n    });\n  });\n};\n\n/**\n * Add a list of `marks` to the characters at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Array<Mixed>} mark\n */\n\nCommands$1.addMarksAtRange = function (editor, range, marks) {\n  marks.forEach(function (mark) {\n    return editor.addMarkAtRange(range, mark);\n  });\n};\n\n/**\n * Delete everything in a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands$1.deleteAtRange = function (editor, range) {\n  // Snapshot the selection, which creates an extra undo save point, so that\n  // when you undo a delete, the expanded selection will be retained.\n  editor.snapshotSelection();\n\n  var value = editor.value;\n  var start = range.start,\n      end = range.end;\n\n  var startKey = start.key;\n  var startOffset = start.offset;\n  var endKey = end.key;\n  var endOffset = end.offset;\n  var document = value.document;\n\n  var isStartVoid = document.hasVoidParent(startKey, editor);\n  var isEndVoid = document.hasVoidParent(endKey, editor);\n  var startBlock = document.getClosestBlock(startKey);\n  var endBlock = document.getClosestBlock(endKey);\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  var isHanging = startOffset === 0 && endOffset === 0 && isStartVoid === false && startKey === startBlock.getFirstText().key && endKey === endBlock.getFirstText().key && startKey !== endKey;\n\n  // If it's a hanging selection, nudge it back to end in the previous text.\n  if (isHanging && isEndVoid) {\n    var prevText = document.getPreviousText(endKey);\n    endKey = prevText.key;\n    endOffset = prevText.text.length;\n    isEndVoid = document.hasVoidParent(endKey, editor);\n  }\n\n  editor.withoutNormalizing(function () {\n    // If the start node is inside a void node, remove the void node and update\n    // the starting point to be right after it, continuously until the start point\n    // is not a void, or until the entire range is handled.\n    while (isStartVoid) {\n      var startVoid = document.getClosestVoid(startKey, editor);\n      var nextText = document.getNextText(startKey);\n      editor.removeNodeByKey(startVoid.key);\n\n      // If the start and end keys are the same, we're done.\n      if (startKey === endKey) return;\n\n      // If there is no next text node, we're done.\n      if (!nextText) return;\n\n      // Continue...\n      document = editor.value.document;\n      startKey = nextText.key;\n      startOffset = 0;\n      isStartVoid = document.hasVoidParent(startKey, editor);\n    }\n\n    // If the end node is inside a void node, do the same thing but backwards. But\n    // we don't need any aborting checks because if we've gotten this far there\n    // must be a non-void node that will exit the loop.\n    while (isEndVoid) {\n      var endVoid = document.getClosestVoid(endKey, editor);\n      var _prevText = document.getPreviousText(endKey);\n      editor.removeNodeByKey(endVoid.key);\n\n      // Continue...\n      document = editor.value.document;\n      endKey = _prevText.key;\n      endOffset = _prevText.text.length;\n      isEndVoid = document.hasVoidParent(endKey, editor);\n    }\n\n    // If the start and end key are the same, and it was a hanging selection, we\n    // can just remove the entire block.\n    if (startKey === endKey && isHanging) {\n      editor.removeNodeByKey(startBlock.key);\n      return;\n    } else if (startKey === endKey) {\n      // Otherwise, if it wasn't hanging, we're inside a single text node, so we can\n      // simply remove the text in the range.\n      var index = startOffset;\n      var length = endOffset - startOffset;\n      editor.removeTextByKey(startKey, index, length);\n      return;\n    } else {\n      // Otherwise, we need to recursively remove text and nodes inside the start\n      // block after the start offset and inside the end block before the end\n      // offset. Then remove any blocks that are in between the start and end\n      // blocks. Then finally merge the start and end nodes.\n      startBlock = document.getClosestBlock(startKey);\n      endBlock = document.getClosestBlock(endKey);\n      var startText = document.getNode(startKey);\n      var endText = document.getNode(endKey);\n      var startLength = startText.text.length - startOffset;\n      var endLength = endOffset;\n\n      var ancestor = document.getCommonAncestor(startKey, endKey);\n      var startChild = ancestor.getFurthestChild(startKey);\n      var endChild = ancestor.getFurthestChild(endKey);\n\n      var startParent = document.getParent(startBlock.key);\n      var startParentIndex = startParent.nodes.indexOf(startBlock);\n      var endParentIndex = startParent.nodes.indexOf(endBlock);\n\n      var child = void 0;\n\n      // Iterate through all of the nodes in the tree after the start text node\n      // but inside the end child, and remove them.\n      child = startText;\n\n      while (child.key !== startChild.key) {\n        var parent = document.getParent(child.key);\n        var _index = parent.nodes.indexOf(child);\n        var afters = parent.nodes.slice(_index + 1);\n\n        afters.reverse().forEach(function (node) {\n          editor.removeNodeByKey(node.key);\n        });\n\n        child = parent;\n      }\n\n      // Remove all of the middle children.\n      var startChildIndex = ancestor.nodes.indexOf(startChild);\n      var endChildIndex = ancestor.nodes.indexOf(endChild);\n      var middles = ancestor.nodes.slice(startChildIndex + 1, endChildIndex);\n\n      middles.reverse().forEach(function (node) {\n        editor.removeNodeByKey(node.key);\n      });\n\n      // Remove the nodes before the end text node in the tree.\n      child = endText;\n\n      while (child.key !== endChild.key) {\n        var _parent = document.getParent(child.key);\n        var _index2 = _parent.nodes.indexOf(child);\n        var befores = _parent.nodes.slice(0, _index2);\n\n        befores.reverse().forEach(function (node) {\n          editor.removeNodeByKey(node.key);\n        });\n\n        child = _parent;\n      }\n\n      // Remove any overlapping text content from the leaf text nodes.\n      if (startLength !== 0) {\n        editor.removeTextByKey(startKey, startOffset, startLength);\n      }\n\n      if (endLength !== 0) {\n        editor.removeTextByKey(endKey, 0, endOffset);\n      }\n\n      // If the start and end blocks aren't the same, move and merge the end block\n      // into the start block.\n      if (startBlock.key !== endBlock.key) {\n        document = editor.value.document;\n        var onlyChildAncestor = void 0;\n\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = document.ancestors(endBlock.key)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref = _step.value;\n\n            var _ref2 = slicedToArray(_ref, 1);\n\n            var node = _ref2[0];\n\n            if (node.nodes.size > 1) {\n              break;\n            } else {\n              onlyChildAncestor = node;\n            }\n          }\n\n          // Move the end block to be right after the start block.\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n\n        if (endParentIndex !== startParentIndex + 1) {\n          editor.moveNodeByKey(endBlock.key, startParent.key, startParentIndex + 1);\n        }\n\n        // If the selection is hanging, just remove the start block, otherwise\n        // merge the end block into it.\n        if (isHanging) {\n          editor.removeNodeByKey(startBlock.key);\n        } else {\n          editor.mergeNodeByKey(endBlock.key);\n        }\n\n        // If nested empty blocks are left over above the end block, remove them.\n        if (onlyChildAncestor) {\n          editor.removeNodeByKey(onlyChildAncestor.key);\n        }\n      }\n    }\n  });\n};\n\n/**\n * Delete backward `n` characters at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} n (optional)\n */\n\nCommands$1.deleteBackwardAtRange = function (editor, range) {\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n  if (n === 0) return;\n  var value = editor.value;\n  var document = value.document;\n  var _range2 = range,\n      start = _range2.start,\n      focus = _range2.focus;\n\n  // If the range is expanded, perform a regular delete instead.\n\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var voidParent = document.getClosestVoid(start.path, editor);\n\n  // If there is a void parent, delete it.\n  if (voidParent) {\n    editor.removeNodeByKey(voidParent.key);\n    return;\n  }\n\n  // If the range is at the start of the document, abort.\n  if (start.isAtStartOfNode(document)) {\n    return;\n  }\n\n  var block = document.getClosestBlock(start.path);\n\n  // PERF: If the closest block is empty, remove it. This is just a shortcut,\n  // since merging it would result in the same outcome.\n  if (document.nodes.size !== 1 && block && block.text === '' && block.nodes.size === 1) {\n    editor.removeNodeByKey(block.key);\n    return;\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  var text = document.getDescendant(start.path);\n\n  if (start.isAtStartOfNode(text)) {\n    var prev = document.getPreviousText(text.key);\n    var inline = document.getClosestInline(text.key);\n\n    // If the range is at the start of the inline node, and previous text node\n    // is empty, take the text node before that, or \"prevBlock\" would be the\n    // same node as \"block\"\n    if (inline && prev.text === '') {\n      prev = document.getPreviousText(prev.key);\n    }\n\n    var prevBlock = document.getClosestBlock(prev.key);\n    var prevVoid = document.getClosestVoid(prev.key, editor);\n\n    // If the previous text node has a void parent, remove it.\n    if (prevVoid) {\n      editor.removeNodeByKey(prevVoid.key);\n      return;\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n === 1 && prevBlock !== block) {\n      range = range.moveAnchorTo(prev.key, prev.text.length);\n      editor.deleteAtRange(range);\n      return;\n    }\n  }\n\n  // If the focus offset is farther than the number of characters to delete,\n  // just remove the characters backwards inside the current node.\n  if (n <= focus.offset) {\n    range = range.moveFocusBackward(n);\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  // Otherwise, we need to see how many nodes backwards to go.\n  var node = text;\n  var offset = 0;\n  var traversed = focus.offset;\n\n  while (n > traversed) {\n    node = document.getPreviousText(node.key);\n    var next = traversed + node.text.length;\n\n    if (n <= next) {\n      offset = next - n;\n      break;\n    } else {\n      traversed = next;\n    }\n  }\n\n  range = range.moveAnchorTo(node.key, offset);\n  editor.deleteAtRange(range);\n};\n\n/**\n * Delete backward until the character boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands$1.deleteCharBackwardAtRange = function (editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start;\n\n  var startBlock = document.getClosestBlock(start.path);\n  var offset = startBlock.getOffset(start.key);\n  var o = offset + start.offset;\n  var text = startBlock.text;\n\n  var n = TextUtils.getCharOffsetBackward(text, o);\n  editor.deleteBackwardAtRange(range, n);\n};\n\n/**\n * Delete forward until the character boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands$1.deleteCharForwardAtRange = function (editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start;\n\n  var startBlock = document.getClosestBlock(start.path);\n  var offset = startBlock.getOffset(start.key);\n  var o = offset + start.offset;\n  var text = startBlock.text;\n\n  var n = TextUtils.getCharOffsetForward(text, o);\n  editor.deleteForwardAtRange(range, n);\n};\n\n/**\n * Delete forward `n` characters at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} n (optional)\n */\n\nCommands$1.deleteForwardAtRange = function (editor, range) {\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n  if (n === 0) return;\n  var value = editor.value;\n  var document = value.document;\n  var _range3 = range,\n      start = _range3.start,\n      focus = _range3.focus;\n\n  // If the range is expanded, perform a regular delete instead.\n\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var voidParent = document.getClosestVoid(start.path, editor);\n\n  // If the node has a void parent, delete it.\n  if (voidParent) {\n    editor.removeNodeByKey(voidParent.key);\n    return;\n  }\n\n  var block = document.getClosestBlock(start.path);\n\n  // If the closest is not void, but empty, remove it\n  if (block && !editor.isVoid(block) && block.text === '' && document.nodes.size !== 1) {\n    var nextBlock = document.getNextBlock(block.key);\n    editor.removeNodeByKey(block.key);\n\n    if (nextBlock && nextBlock.key) {\n      editor.moveToStartOfNode(nextBlock);\n    }\n\n    return;\n  }\n\n  // If the range is at the start of the document, abort.\n  if (start.isAtEndOfNode(document)) {\n    return;\n  }\n\n  // If the range is at the start of the text node, we need to figure out what\n  // is behind it to know how to delete...\n  var text = document.getDescendant(start.path);\n\n  if (start.isAtEndOfNode(text)) {\n    var next = document.getNextText(text.key);\n    var _nextBlock = document.getClosestBlock(next.key);\n    var nextVoid = document.getClosestVoid(next.key, editor);\n\n    // If the next text node has a void parent, remove it.\n    if (nextVoid) {\n      editor.removeNodeByKey(nextVoid.key);\n      return;\n    }\n\n    // If we're deleting by one character and the previous text node is not\n    // inside the current block, we need to merge the two blocks together.\n    if (n === 1 && _nextBlock !== block) {\n      range = range.moveFocusTo(next.key, 0);\n      editor.deleteAtRange(range);\n      return;\n    }\n  }\n\n  // If the remaining characters to the end of the node is greater than or equal\n  // to the number of characters to delete, just remove the characters forwards\n  // inside the current node.\n  if (n <= text.text.length - focus.offset) {\n    range = range.moveFocusForward(n);\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  // Otherwise, we need to see how many nodes forwards to go.\n  var node = text;\n  var offset = focus.offset;\n  var traversed = text.text.length - focus.offset;\n\n  while (n > traversed) {\n    node = document.getNextText(node.key);\n    var _next = traversed + node.text.length;\n\n    if (n <= _next) {\n      offset = n - traversed;\n      break;\n    } else {\n      traversed = _next;\n    }\n  }\n\n  range = range.moveFocusTo(node.key, offset);\n  editor.deleteAtRange(range);\n};\n\n/**\n * Delete backward until the line boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands$1.deleteLineBackwardAtRange = function (editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start;\n\n  var startBlock = document.getClosestBlock(start.path);\n  var offset = startBlock.getOffset(start.key);\n  var o = offset + start.offset;\n  editor.deleteBackwardAtRange(range, o);\n};\n\n/**\n * Delete forward until the line boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands$1.deleteLineForwardAtRange = function (editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start;\n\n  var startBlock = document.getClosestBlock(start.path);\n  var offset = startBlock.getOffset(start.key);\n  var o = offset + start.offset;\n  editor.deleteForwardAtRange(range, startBlock.text.length - o);\n};\n\n/**\n * Delete backward until the word boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands$1.deleteWordBackwardAtRange = function (editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start;\n\n  var startBlock = document.getClosestBlock(start.path);\n  var offset = startBlock.getOffset(start.key);\n  var o = offset + start.offset;\n  var text = startBlock.text;\n\n  var n = o === 0 ? 1 : TextUtils.getWordOffsetBackward(text, o);\n  editor.deleteBackwardAtRange(range, n);\n};\n\n/**\n * Delete forward until the word boundary at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nCommands$1.deleteWordForwardAtRange = function (editor, range) {\n  if (range.isExpanded) {\n    editor.deleteAtRange(range);\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start;\n\n  var startBlock = document.getClosestBlock(start.path);\n  var offset = startBlock.getOffset(start.key);\n  var o = offset + start.offset;\n  var text = startBlock.text;\n\n  var wordOffset = TextUtils.getWordOffsetForward(text, o);\n  var n = wordOffset === 0 ? 1 : wordOffset;\n  editor.deleteForwardAtRange(range, n);\n};\n\n/**\n * Insert a `block` node at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Block|String|Object} block\n */\n\nCommands$1.insertBlockAtRange = function (editor, range, block) {\n  range = deleteExpandedAtRange(editor, range);\n  block = Block.create(block);\n\n  var value = editor.value;\n  var document = value.document;\n  var _range4 = range,\n      start = _range4.start;\n\n  var startKey = start.key;\n  var startOffset = start.offset;\n  var startBlock = document.getClosestBlock(startKey);\n  var startInline = document.getClosestInline(startKey);\n  var parent = document.getParent(startBlock.key);\n  var index = parent.nodes.indexOf(startBlock);\n  var insertionMode = getInsertionMode(editor, range);\n\n  if (insertionMode === 'before') {\n    editor.insertNodeByKey(parent.key, index, block);\n  } else if (insertionMode === 'behind') {\n    editor.insertNodeByKey(parent.key, index + 1, block);\n  } else {\n    if (startInline && editor.isVoid(startInline)) {\n      var atEnd = start.isAtEndOfNode(startInline);\n      var siblingText = atEnd ? document.getNextText(startKey) : document.getPreviousText(startKey);\n\n      var splitRange = atEnd ? range.moveToStartOfNode(siblingText) : range.moveToEndOfNode(siblingText);\n\n      startKey = splitRange.start.key;\n      startOffset = splitRange.start.offset;\n    }\n\n    editor.withoutNormalizing(function () {\n      editor.splitDescendantsByKey(startBlock.key, startKey, startOffset);\n      editor.insertNodeByKey(parent.key, index + 1, block);\n    });\n  }\n};\n\n/**\n * Check if current block should be split or new block should be added before or behind it.\n *\n * @param {Editor} editor\n * @param {Range} range\n */\n\nvar getInsertionMode = function getInsertionMode(editor, range) {\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start;\n\n  var startKey = start.key;\n  var startBlock = document.getClosestBlock(startKey);\n  var startInline = document.getClosestInline(startKey);\n\n  if (editor.isVoid(startBlock)) {\n    if (start.isAtEndOfNode(startBlock)) return 'behind';else return 'before';\n  } else if (!startInline && startBlock.text === '') {\n    return 'behind';\n  } else if (start.isAtStartOfNode(startBlock)) {\n    return 'before';\n  } else if (start.isAtEndOfNode(startBlock)) {\n    return 'behind';\n  }\n  return 'split';\n};\n\n/**\n * Insert a `fragment` at a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Document} fragment\n */\n\nCommands$1.insertFragmentAtRange = function (editor, range, fragment) {\n  editor.withoutNormalizing(function () {\n    range = deleteExpandedAtRange(editor, range);\n\n    // If the fragment is empty, there's nothing to do after deleting.\n    if (!fragment.nodes.size) return;\n\n    // Regenerate the keys for all of the fragments nodes, so that they're\n    // guaranteed not to collide with the existing keys in the document. Otherwise\n    // they will be regenerated automatically and we won't have an easy way to\n    // reference them.\n    fragment = fragment.mapDescendants(function (child) {\n      return child.regenerateKey();\n    });\n\n    // Calculate a few things...\n    var _range5 = range,\n        start = _range5.start;\n    var value = editor.value;\n    var document = value.document;\n\n    var startText = document.getDescendant(start.path);\n    var startBlock = document.getClosestBlock(startText.key);\n    var startChild = startBlock.getFurthestChild(startText.key);\n    var isAtStart = start.isAtStartOfNode(startBlock);\n    var parent = document.getParent(startBlock.key);\n    var index = parent.nodes.indexOf(startBlock);\n    var blocks = fragment.getBlocks();\n    var firstChild = fragment.nodes.first();\n    var lastChild = fragment.nodes.last();\n    var firstBlock = blocks.first();\n    var lastBlock = blocks.last();\n    var insertionNode = findInsertionNode(fragment, document, startBlock.key);\n\n    // If the fragment only contains a void block, use `insertBlock` instead.\n    if (firstBlock === lastBlock && editor.isVoid(firstBlock)) {\n      editor.insertBlockAtRange(range, firstBlock);\n      return;\n    }\n\n    // If inserting the entire fragment and it starts or ends with a single\n    // nested block, e.g. a table, we do not merge it with existing blocks.\n    if (insertionNode === fragment && (firstChild.hasBlockChildren() || lastChild.hasBlockChildren())) {\n      // check if reversal is necessary or not\n      var insertionMode = getInsertionMode(editor, range);\n      var nodes = insertionMode === 'before' ? fragment.nodes : fragment.nodes.reverse();\n\n      nodes.forEach(function (node) {\n        editor.insertBlockAtRange(range, node);\n      });\n      return;\n    }\n\n    // If the first and last block aren't the same, we need to insert all of the\n    // nodes after the insertion node's first block at the index.\n    if (firstBlock !== lastBlock) {\n      var lonelyParent = insertionNode.getFurthest(firstBlock.key, function (p) {\n        return p.nodes.size === 1;\n      });\n      var lonelyChild = lonelyParent || firstBlock;\n\n      var startIndex = parent.nodes.indexOf(startBlock);\n      var excludingLonelyChild = insertionNode.removeNode(lonelyChild.key);\n\n      excludingLonelyChild.nodes.forEach(function (node, i) {\n        var newIndex = startIndex + i + 1;\n        editor.insertNodeByKey(parent.key, newIndex, node);\n      });\n    }\n\n    // Check if we need to split the node.\n    if (start.offset !== 0) {\n      editor.splitDescendantsByKey(startChild.key, start.key, start.offset);\n    }\n\n    // Update our variables with the new value.\n    document = editor.value.document;\n    startText = document.getDescendant(start.key);\n    startBlock = document.getClosestBlock(start.key);\n    startChild = startBlock.getFurthestChild(startText.key);\n\n    // If the first and last block aren't the same, we need to move any of the\n    // starting block's children after the split into the last block of the\n    // fragment, which has already been inserted.\n    if (firstBlock !== lastBlock) {\n      var nextChild = isAtStart ? startChild : startBlock.getNextSibling(startChild.key);\n      var nextNodes = nextChild ? startBlock.nodes.skipUntil(function (n) {\n        return n.key === nextChild.key;\n      }) : immutable.List();\n      var lastIndex = lastBlock.nodes.size;\n\n      nextNodes.forEach(function (node, i) {\n        var newIndex = lastIndex + i;\n        editor.moveNodeByKey(node.key, lastBlock.key, newIndex);\n      });\n    }\n\n    // If the starting block is empty, we replace it entirely with the first block\n    // of the fragment, since this leads to a more expected behavior for the user.\n    if (!editor.isVoid(startBlock) && startBlock.text === '' && !startBlock.findDescendant(function (n) {\n      return editor.isVoid(n);\n    })) {\n      editor.removeNodeByKey(startBlock.key);\n      editor.insertNodeByKey(parent.key, index, firstBlock);\n    } else {\n      // Otherwise, we maintain the starting block, and insert all of the first\n      // block's inline nodes into it at the split point.\n      var inlineChild = startBlock.getFurthestChild(startText.key);\n      var inlineIndex = startBlock.nodes.indexOf(inlineChild);\n\n      firstBlock.nodes.forEach(function (inline, i) {\n        var o = start.offset === 0 ? 0 : 1;\n        var newIndex = inlineIndex + i + o;\n        editor.insertNodeByKey(startBlock.key, newIndex, inline);\n      });\n    }\n  });\n};\n\n/**\n * Get the deepest single child block inside `fragment` whose reversed block\n * ancestors match the reversed block ancestors of the `document` starting at\n * the `documentKey`.\n *\n * @param {Document} document\n * @param {string} documentKey\n * @param {Document} fragment\n * @return {Node}\n */\n\nvar findInsertionNode = function findInsertionNode(fragment, document, documentKey) {\n  // Find the deepest block in a doc with no siblings.\n  var deepestSingleBlock = function deepestSingleBlock(doc) {\n    var result = doc;\n\n    while (result.nodes.size === 1 && result.nodes.first().object === 'block') {\n      result = result.nodes.first();\n    }\n\n    return result === doc ? null : result;\n  };\n\n  // Return whether every block in the `fragmentAncestors` list has the\n  // same type as the block in `documentAncestors` with the same index.\n  var ancestorTypesMatch = function ancestorTypesMatch(fragmentAncestors, documentAncestors) {\n    return documentAncestors.size >= fragmentAncestors.size && fragmentAncestors.every(function (fragmentNode, i) {\n      return documentAncestors.get(i).type === fragmentNode.type;\n    });\n  };\n\n  // Given two reverse lists of ancestors, check if all fragment ancestor types\n  // match the doc ancestors at some position.\n  var matchingFragmentAncestor = function matchingFragmentAncestor(documentAncestors, fragmentAncestors) {\n    var depthDifference = documentAncestors.size - fragmentAncestors.size;\n\n    // There is nothing to align if the fragment is deeper than the document.\n    if (depthDifference < 0) {\n      return fragment;\n    }\n\n    for (var fragIdx = 0; fragIdx < fragmentAncestors.size; fragIdx++) {\n      // The docIdx loop relaxes our check in that we can still match if there\n      // are node type differences leaf-side.\n      // This is important for example if our fragment inserts multiple siblings\n      // or inserts another type while the tree structure remains the same.\n      for (var docIdx = 0; docIdx <= depthDifference; docIdx++) {\n        if (ancestorTypesMatch(fragmentAncestors.slice(fragIdx), documentAncestors.slice(docIdx))) {\n          return fragmentAncestors.get(fragIdx);\n        }\n      }\n    }\n    return fragment;\n  };\n\n  // Get the type definitions for all ancestors up from node with key `key`,\n  // except the document object.\n  var getAncestorBlocks = function getAncestorBlocks(doc, key) {\n    return doc.getAncestors(key).slice(1).push(doc.getNode(key)).reverse();\n  };\n\n  var fragmentStartBlock = deepestSingleBlock(fragment);\n\n  if (!fragmentStartBlock) {\n    return fragment;\n  }\n\n  var documentAncestors = getAncestorBlocks(document, documentKey);\n  var fragmentAncestors = getAncestorBlocks(fragment, fragmentStartBlock.key);\n\n  return matchingFragmentAncestor(documentAncestors, fragmentAncestors);\n};\n\n/**\n * Insert an `inline` node at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Inline|String|Object} inline\n */\n\nCommands$1.insertInlineAtRange = function (editor, range, inline) {\n  inline = Inline.create(inline);\n\n  editor.withoutNormalizing(function () {\n    range = deleteExpandedAtRange(editor, range);\n\n    var value = editor.value;\n    var document = value.document;\n    var _range6 = range,\n        start = _range6.start;\n\n    var parent = document.getParent(start.path);\n    var startText = document.assertDescendant(start.path);\n    var index = parent.nodes.indexOf(startText);\n\n    if (editor.isVoid(parent)) {\n      return;\n    }\n\n    editor.splitNodeByPath(start.path, start.offset);\n    editor.insertNodeByKey(parent.key, index + 1, inline);\n  });\n};\n\n/**\n * Insert `text` at a `range`, with optional `marks`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands$1.insertTextAtRange = function (editor, range, text, marks) {\n  editor.withoutNormalizing(function () {\n    range = deleteExpandedAtRange(editor, range);\n\n    var value = editor.value;\n    var document = value.document;\n    var _range7 = range,\n        start = _range7.start;\n\n    var offset = start.offset;\n    var parent = document.getParent(start.path);\n\n    if (editor.isVoid(parent)) {\n      return;\n    }\n\n    editor.insertTextByPath(start.path, offset, text, marks);\n  });\n};\n\n/**\n * Remove an existing `mark` to the characters at `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Mark|String} mark (optional)\n */\n\nCommands$1.removeMarkAtRange = function (editor, range, mark) {\n  if (range.isCollapsed) return;\n\n  var value = editor.value;\n  var document = value.document;\n\n  var texts = document.getTextsAtRange(range);\n  var start = range.start,\n      end = range.end;\n\n\n  editor.withoutNormalizing(function () {\n    texts.forEach(function (node) {\n      var key = node.key;\n\n      var index = 0;\n      var length = node.text.length;\n\n      if (key === start.key) index = start.offset;\n      if (key === end.key) length = end.offset;\n      if (key === start.key && key === end.key) length = end.offset - start.offset;\n\n      editor.removeMarkByKey(key, index, length, mark);\n    });\n  });\n};\n\n/**\n * Set the `properties` of block nodes in a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Object|String} properties\n */\n\nCommands$1.setBlocksAtRange = function (editor, range, properties) {\n  var value = editor.value;\n  var document = value.document;\n\n  var blocks = document.getLeafBlocksAtRange(range);\n\n  var start = range.start,\n      end = range.end,\n      isCollapsed = range.isCollapsed;\n\n  var isStartVoid = document.hasVoidParent(start.path, editor);\n  var startBlock = document.getClosestBlock(start.path);\n  var endBlock = document.getClosestBlock(end.key);\n\n  // Check if we have a \"hanging\" selection case where the even though the\n  // selection extends into the start of the end node, we actually want to\n  // ignore that for UX reasons.\n  var isHanging = isCollapsed === false && start.offset === 0 && end.offset === 0 && isStartVoid === false && start.key === startBlock.getFirstText().key && end.key === endBlock.getFirstText().key;\n\n  // If it's a hanging selection, ignore the last block.\n  var sets = isHanging ? blocks.slice(0, -1) : blocks;\n\n  editor.withoutNormalizing(function () {\n    sets.forEach(function (block) {\n      editor.setNodeByKey(block.key, properties);\n    });\n  });\n};\n\n/**\n * Set the `properties` of inline nodes in a `range`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Object|String} properties\n */\n\nCommands$1.setInlinesAtRange = function (editor, range, properties) {\n  var value = editor.value;\n  var document = value.document;\n\n  var inlines = document.getLeafInlinesAtRange(range);\n\n  editor.withoutNormalizing(function () {\n    inlines.forEach(function (inline) {\n      editor.setNodeByKey(inline.key, properties);\n    });\n  });\n};\n\n/**\n * Split the block nodes at a `range`, to optional `height`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} height (optional)\n */\n\nCommands$1.splitBlockAtRange = function (editor, range) {\n  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n  range = deleteExpandedAtRange(editor, range);\n\n  var _range8 = range,\n      start = _range8.start,\n      end = _range8.end;\n  var value = editor.value;\n  var _value = value,\n      document = _value.document;\n\n  var node = document.assertDescendant(start.path);\n  var parent = document.getClosestBlock(node.key);\n  var h = 0;\n\n  while (parent && parent.object === 'block' && h < height) {\n    node = parent;\n    parent = document.getClosestBlock(parent.key);\n    h++;\n  }\n\n  editor.withoutNormalizing(function () {\n    editor.splitDescendantsByKey(node.key, start.path, start.offset);\n\n    value = editor.value;\n    document = value.document;\n\n    if (range.isExpanded) {\n      if (range.isBackward) range = range.flip();\n      var nextBlock = document.getNextBlock(node.key);\n      range = range.moveAnchorToStartOfNode(nextBlock);\n      range = range.setFocus(range.focus.setPath(null));\n\n      if (start.path.equals(end.path)) {\n        range = range.moveFocusTo(range.anchor.key, end.offset - start.offset);\n      }\n\n      range = document.resolveRange(range);\n      editor.deleteAtRange(range);\n    }\n  });\n};\n\n/**\n * Split the inline nodes at a `range`, to optional `height`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Number} height (optional)\n */\n\nCommands$1.splitInlineAtRange = function (editor, range) {\n  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\n\n  range = deleteExpandedAtRange(editor, range);\n\n  var _range9 = range,\n      start = _range9.start;\n  var value = editor.value;\n  var document = value.document;\n\n  var node = document.assertDescendant(start.path);\n  var parent = document.getClosestInline(node.key);\n  var h = 0;\n\n  while (parent && parent.object === 'inline' && h < height) {\n    node = parent;\n    parent = document.getClosestInline(parent.key);\n    h++;\n  }\n\n  editor.splitDescendantsByKey(node.key, start.path, start.offset);\n};\n\n/**\n * Add or remove a `mark` from the characters at `range`, depending on whether\n * it's already there.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Mixed} mark\n */\n\nCommands$1.toggleMarkAtRange = function (editor, range, mark) {\n  if (range.isCollapsed) return;\n\n  mark = Mark.create(mark);\n\n  var value = editor.value;\n  var document = value.document;\n\n  var marks = document.getActiveMarksAtRange(range);\n  var exists = marks.some(function (m) {\n    return m.equals(mark);\n  });\n\n  if (exists) {\n    editor.removeMarkAtRange(range, mark);\n  } else {\n    editor.addMarkAtRange(range, mark);\n  }\n};\n\n/**\n * Unwrap all of the block nodes in a `range` from a block with `properties`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String|Object} properties\n */\n\nCommands$1.unwrapBlockAtRange = function (editor, range, properties) {\n  properties = Node.createProperties(properties);\n\n  var value = editor.value;\n  var document = value.document;\n\n  var blocks = document.getLeafBlocksAtRange(range);\n  var wrappers = blocks.map(function (block) {\n    return document.getClosest(block.key, function (parent) {\n      if (parent.object !== 'block') return false;\n      if (properties.type != null && parent.type !== properties.type) return false;\n      if (properties.data != null && !parent.data.isSuperset(properties.data)) return false;\n      return true;\n    });\n  }).filter(function (exists) {\n    return exists;\n  }).toOrderedSet().toList();\n\n  editor.withoutNormalizing(function () {\n    wrappers.forEach(function (block) {\n      var first = block.nodes.first();\n      var last = block.nodes.last();\n      var parent = editor.value.document.getParent(block.key);\n      var index = parent.nodes.indexOf(block);\n\n      var children = block.nodes.filter(function (child) {\n        return blocks.some(function (b) {\n          return child === b || child.hasDescendant(b.key);\n        });\n      });\n\n      var firstMatch = children.first();\n      var lastMatch = children.last();\n\n      if (first === firstMatch && last === lastMatch) {\n        block.nodes.forEach(function (child, i) {\n          editor.moveNodeByKey(child.key, parent.key, index + i);\n        });\n\n        editor.removeNodeByKey(block.key);\n      } else if (last === lastMatch) {\n        block.nodes.skipUntil(function (n) {\n          return n === firstMatch;\n        }).forEach(function (child, i) {\n          editor.moveNodeByKey(child.key, parent.key, index + 1 + i);\n        });\n      } else if (first === firstMatch) {\n        block.nodes.takeUntil(function (n) {\n          return n === lastMatch;\n        }).push(lastMatch).forEach(function (child, i) {\n          editor.moveNodeByKey(child.key, parent.key, index + i);\n        });\n      } else {\n        var firstText = firstMatch.getFirstText();\n\n        editor.splitDescendantsByKey(block.key, firstText.key, 0);\n\n        document = editor.value.document;\n\n        children.forEach(function (child, i) {\n          if (i === 0) {\n            var extra = child;\n            child = document.getNextBlock(child.key);\n            editor.removeNodeByKey(extra.key);\n          }\n\n          editor.moveNodeByKey(child.key, parent.key, index + 1 + i);\n        });\n      }\n    });\n  });\n};\n\n/**\n * Unwrap the inline nodes in a `range` from an inline with `properties`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String|Object} properties\n */\n\nCommands$1.unwrapInlineAtRange = function (editor, range, properties) {\n  properties = Node.createProperties(properties);\n\n  var value = editor.value;\n  var document = value.document;\n\n  var texts = document.getTextsAtRange(range);\n  var inlines = texts.map(function (text) {\n    return document.getClosest(text.key, function (parent) {\n      if (parent.object !== 'inline') return false;\n      if (properties.type != null && parent.type !== properties.type) return false;\n      if (properties.data != null && !parent.data.isSuperset(properties.data)) return false;\n      return true;\n    });\n  }).filter(function (exists) {\n    return exists;\n  }).toOrderedSet().toList();\n\n  editor.withoutNormalizing(function () {\n    inlines.forEach(function (inline) {\n      var parent = editor.value.document.getParent(inline.key);\n      var index = parent.nodes.indexOf(inline);\n\n      inline.nodes.forEach(function (child, i) {\n        editor.moveNodeByKey(child.key, parent.key, index + i);\n      });\n\n      editor.removeNodeByKey(inline.key);\n    });\n  });\n};\n\n/**\n * Wrap all of the blocks in a `range` in a new `block`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Block|Object|String} block\n */\n\nCommands$1.wrapBlockAtRange = function (editor, range, block) {\n  block = Block.create(block);\n  block = block.set('nodes', block.nodes.clear());\n\n  var value = editor.value;\n  var document = value.document;\n\n\n  var blocks = document.getLeafBlocksAtRange(range);\n  var firstblock = blocks.first();\n  var lastblock = blocks.last();\n  var parent = void 0,\n      siblings = void 0,\n      index = void 0;\n\n  // If there is only one block in the selection then we know the parent and\n  // siblings.\n  if (blocks.length === 1) {\n    parent = document.getParent(firstblock.key);\n    siblings = blocks;\n  } else {\n    // Determine closest shared parent to all blocks in selection.\n    parent = document.getClosest(firstblock.key, function (p1) {\n      return !!document.getClosest(lastblock.key, function (p2) {\n        return p1 === p2;\n      });\n    });\n  }\n\n  // If no shared parent could be found then the parent is the document.\n  if (parent == null) parent = document;\n\n  // Create a list of direct children siblings of parent that fall in the\n  // selection.\n  if (siblings == null) {\n    var indexes = parent.nodes.reduce(function (ind, node, i) {\n      if (node === firstblock || node.hasDescendant(firstblock.key)) ind[0] = i;\n      if (node === lastblock || node.hasDescendant(lastblock.key)) ind[1] = i;\n      return ind;\n    }, []);\n\n    index = indexes[0];\n    siblings = parent.nodes.slice(indexes[0], indexes[1] + 1);\n  }\n\n  // Get the index to place the new wrapped node at.\n  if (index == null) {\n    index = parent.nodes.indexOf(siblings.first());\n  }\n\n  editor.withoutNormalizing(function () {\n    // Inject the new block node into the parent.\n    editor.insertNodeByKey(parent.key, index, block);\n\n    // Move the sibling nodes into the new block node.\n    siblings.forEach(function (node, i) {\n      editor.moveNodeByKey(node.key, block.key, i);\n    });\n  });\n};\n\n/**\n * Wrap the text and inlines in a `range` in a new `inline`.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {Inline|Object|String} inline\n */\n\nCommands$1.wrapInlineAtRange = function (editor, range, inline) {\n  var value = editor.value;\n  var document = value.document;\n  var start = range.start,\n      end = range.end;\n\n\n  if (range.isCollapsed) {\n    // Wrapping an inline void\n    var inlineParent = document.getClosestInline(start.path);\n\n    if (!inlineParent) {\n      return;\n    }\n\n    if (!editor.isVoid(inlineParent)) {\n      return;\n    }\n\n    return editor.wrapInlineByKey(inlineParent.key, inline);\n  }\n\n  inline = Inline.create(inline);\n  inline = inline.set('nodes', inline.nodes.clear());\n\n  var blocks = document.getLeafBlocksAtRange(range);\n  var startBlock = document.getClosestBlock(start.path);\n  var endBlock = document.getClosestBlock(end.path);\n  var startInline = document.getClosestInline(start.path);\n  var endInline = document.getClosestInline(end.path);\n  var startChild = startBlock.getFurthestChild(start.key);\n  var endChild = endBlock.getFurthestChild(end.key);\n\n  editor.withoutNormalizing(function () {\n    if (!startInline || startInline !== endInline) {\n      editor.splitDescendantsByKey(endChild.key, end.key, end.offset);\n      editor.splitDescendantsByKey(startChild.key, start.key, start.offset);\n    }\n\n    document = editor.value.document;\n    startBlock = document.getDescendant(startBlock.key);\n    endBlock = document.getDescendant(endBlock.key);\n    startChild = startBlock.getFurthestChild(start.key);\n    endChild = endBlock.getFurthestChild(end.key);\n    var startIndex = startBlock.nodes.indexOf(startChild);\n    var endIndex = endBlock.nodes.indexOf(endChild);\n\n    if (startInline && startInline === endInline) {\n      var texts = startBlock.getTextsAtRange(range).map(function (text) {\n        if (start.key === text.key && end.key === text.key) {\n          return text.splitText(start.offset)[1].splitText(end.offset - start.offset)[0].regenerateKey();\n        } else if (start.key === text.key) {\n          return text.splitText(start.offset)[1].regenerateKey();\n        } else if (end.key === text.key) {\n          return text.splitText(end.offset)[0].regenerateKey();\n        } else {\n          return text.regenerateKey();\n        }\n      });\n\n      inline = inline.set('nodes', texts);\n      editor.insertInlineAtRange(range, inline);\n    } else if (startBlock === endBlock) {\n      document = editor.value.document;\n      startBlock = document.getClosestBlock(start.key);\n      startChild = startBlock.getFurthestChild(start.key);\n\n      var startInner = document.getNextSibling(startChild.key);\n      var startInnerIndex = startBlock.nodes.indexOf(startInner);\n      var endInner = start.key === end.key ? startInner : startBlock.getFurthestChild(end.key);\n      var inlines = startBlock.nodes.skipUntil(function (n) {\n        return n === startInner;\n      }).takeUntil(function (n) {\n        return n === endInner;\n      }).push(endInner);\n\n      var node = inline.regenerateKey();\n\n      editor.insertNodeByKey(startBlock.key, startInnerIndex, node);\n\n      inlines.forEach(function (child, i) {\n        editor.moveNodeByKey(child.key, node.key, i);\n      });\n    } else {\n      var startInlines = startBlock.nodes.slice(startIndex + 1);\n      var endInlines = endBlock.nodes.slice(0, endIndex + 1);\n      var startNode = inline.regenerateKey();\n      var endNode = inline.regenerateKey();\n\n      editor.insertNodeByKey(startBlock.key, startIndex + 1, startNode);\n      editor.insertNodeByKey(endBlock.key, endIndex, endNode);\n\n      startInlines.forEach(function (child, i) {\n        editor.moveNodeByKey(child.key, startNode.key, i);\n      });\n\n      endInlines.forEach(function (child, i) {\n        editor.moveNodeByKey(child.key, endNode.key, i);\n      });\n\n      blocks.slice(1, -1).forEach(function (block) {\n        var node = inline.regenerateKey();\n        editor.insertNodeByKey(block.key, 0, node);\n\n        block.nodes.forEach(function (child, i) {\n          editor.moveNodeByKey(child.key, node.key, i);\n        });\n      });\n    }\n  });\n};\n\n/**\n * Wrap the text in a `range` in a prefix/suffix.\n *\n * @param {Editor} editor\n * @param {Range} range\n * @param {String} prefix\n * @param {String} suffix (optional)\n */\n\nCommands$1.wrapTextAtRange = function (editor, range, prefix) {\n  var suffix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : prefix;\n  var start = range.start,\n      end = range.end;\n\n  var startRange = range.moveToStart();\n  var endRange = range.moveToEnd();\n\n  if (start.path.equals(end.path)) {\n    endRange = endRange.moveForward(prefix.length);\n  }\n\n  editor.withoutNormalizing(function () {\n    editor.insertTextAtRange(startRange, prefix);\n    editor.insertTextAtRange(endRange, suffix);\n  });\n};\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nvar Commands$2 = {};\n\n/**\n * Add mark to text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mixed} mark\n */\n\nCommands$2.addMarkByPath = function (editor, path, offset, length, mark) {\n  mark = Mark.create(mark);\n  editor.addMarksByPath(path, offset, length, [mark]);\n};\n\nCommands$2.addMarksByPath = function (editor, path, offset, length, marks) {\n  marks = Mark.createSet(marks);\n\n  if (!marks.size) {\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n\n  var node = document.assertNode(path);\n\n  editor.withoutNormalizing(function () {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length);\n    }\n\n    // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset);\n      path = PathUtils.increment(path);\n      offset = 0;\n    }\n\n    marks.forEach(function (mark) {\n      editor.applyOperation({\n        type: 'add_mark',\n        path: path,\n        mark: Mark.create(mark)\n      });\n    });\n  });\n};\n\n/**\n * Sets specific set of marks on the path\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Array<Object|Mark>} marks\n */\n\nCommands$2.replaceMarksByPath = function (editor, path, offset, length, marks) {\n  var marksSet = Mark.createSet(marks);\n\n  var value = editor.value;\n  var document = value.document;\n\n  var node = document.assertNode(path);\n\n  if (node.marks.equals(marksSet)) {\n    return;\n  }\n\n  editor.withoutNormalizing(function () {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length);\n    }\n\n    // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset);\n      path = PathUtils.increment(path);\n      offset = 0;\n    }\n\n    var marksToApply = marksSet.subtract(node.marks);\n    var marksToRemove = node.marks.subtract(marksSet);\n\n    marksToRemove.forEach(function (mark) {\n      editor.applyOperation({\n        type: 'remove_mark',\n        path: path,\n        mark: Mark.create(mark)\n      });\n    });\n\n    marksToApply.forEach(function (mark) {\n      editor.applyOperation({\n        type: 'add_mark',\n        path: path,\n        mark: Mark.create(mark)\n      });\n    });\n  });\n};\n\n/**\n * Insert a `fragment` at `index` in a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} index\n * @param {Fragment} fragment\n */\n\nCommands$2.insertFragmentByPath = function (editor, path, index, fragment) {\n  fragment.nodes.forEach(function (node, i) {\n    editor.insertNodeByPath(path, index + i, node);\n  });\n};\n\n/**\n * Insert a `node` at `index` in a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} index\n * @param {Node} node\n */\n\nCommands$2.insertNodeByPath = function (editor, path, index, node) {\n  editor.applyOperation({\n    type: 'insert_node',\n    path: path.concat(index),\n    node: node\n  });\n};\n\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands$2.insertTextByPath = function (editor, path, offset, text, marks) {\n  var value = editor.value;\n  var annotations = value.annotations,\n      document = value.document;\n\n  document.assertNode(path);\n\n  editor.withoutNormalizing(function () {\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = annotations.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var annotation = _step.value;\n        var start = annotation.start,\n            end = annotation.end;\n\n        var isAtomic = editor.isAtomic(annotation);\n\n        if (!isAtomic) {\n          continue;\n        }\n\n        if (!start.path.equals(path)) {\n          continue;\n        }\n\n        if (start.offset < offset && (!end.path.equals(path) || end.offset > offset)) {\n          editor.removeAnnotation(annotation);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    editor.applyOperation({\n      type: 'insert_text',\n      path: path,\n      offset: offset,\n      text: text\n    });\n\n    if (marks) {\n      editor.replaceMarksByPath(path, offset, text.length, marks);\n    }\n  });\n};\n\n/**\n * Merge a node by `path` with the previous node.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nCommands$2.mergeNodeByPath = function (editor, path) {\n  var value = editor.value;\n  var document = value.document;\n\n  var original = document.getDescendant(path);\n  var previous = document.getPreviousSibling(path);\n\n  if (!previous) {\n    throw new Error('Unable to merge node with path \"' + path + '\", because it has no previous sibling.');\n  }\n\n  var position = previous.object === 'text' ? previous.text.length : previous.nodes.size;\n\n  editor.applyOperation({\n    type: 'merge_node',\n    path: path,\n    position: position,\n    // for undos to succeed we only need the type and data because\n    // these are the only properties that get changed in the merge operation\n    properties: {\n      type: original.type,\n      data: original.data\n    },\n    target: null\n  });\n};\n\n/**\n * Move a node by `path` to a new parent by `newParentPath` and `newIndex`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {String} newParentPath\n * @param {Number} newIndex\n */\n\nCommands$2.moveNodeByPath = function (editor, path, newParentPath, newIndex) {\n  // If the operation path and newParentPath are the same,\n  // this should be considered a NOOP\n  if (PathUtils.isEqual(path, newParentPath)) {\n    return editor;\n  }\n\n  var newPath = newParentPath.concat(newIndex);\n\n  if (PathUtils.isEqual(path, newPath)) {\n    return editor;\n  }\n\n  editor.applyOperation({\n    type: 'move_node',\n    path: path,\n    newPath: newPath\n  });\n};\n\n/**\n * Remove mark from text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Mark} mark\n */\n\nCommands$2.removeMarkByPath = function (editor, path, offset, length, mark) {\n  mark = Mark.create(mark);\n  editor.removeMarksByPath(path, offset, length, [mark]);\n};\n\nCommands$2.removeMarksByPath = function (editor, path, offset, length, marks) {\n  marks = Mark.createSet(marks);\n\n  if (!marks.size) {\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n\n  var node = document.assertNode(path);\n\n  if (marks.intersect(node.marks).isEmpty()) {\n    return;\n  }\n\n  editor.withoutNormalizing(function () {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length);\n    }\n\n    // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset);\n      path = PathUtils.increment(path);\n      offset = 0;\n    }\n\n    marks.forEach(function (mark) {\n      editor.applyOperation({\n        type: 'remove_mark',\n        path: path,\n        offset: offset,\n        length: length,\n        mark: mark\n      });\n    });\n  });\n};\n\n/**\n * Remove all `marks` from node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nCommands$2.removeAllMarksByPath = function (editor, path) {\n  var state = editor.state;\n  var document = state.document;\n\n  var node = document.assertNode(path);\n\n  editor.withoutNormalizing(function () {\n    if (node.object === 'text') {\n      editor.removeMarksByPath(path, 0, node.text.length, node.marks);\n      return;\n    }\n\n    var _iteratorNormalCompletion2 = true;\n    var _didIteratorError2 = false;\n    var _iteratorError2 = undefined;\n\n    try {\n      for (var _iterator2 = node.texts()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n        var _ref = _step2.value;\n\n        var _ref2 = slicedToArray(_ref, 2);\n\n        var n = _ref2[0];\n        var p = _ref2[1];\n\n        var pth = path.concat(p);\n        editor.removeMarksByPath(pth, 0, n.text.length, n.marks);\n      }\n    } catch (err) {\n      _didIteratorError2 = true;\n      _iteratorError2 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\n          _iterator2.return();\n        }\n      } finally {\n        if (_didIteratorError2) {\n          throw _iteratorError2;\n        }\n      }\n    }\n  });\n};\n\n/**\n * Remove a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nCommands$2.removeNodeByPath = function (editor, path) {\n  var value = editor.value;\n  var document = value.document;\n\n  var node = document.assertNode(path);\n\n  editor.applyOperation({\n    type: 'remove_node',\n    path: path,\n    node: node\n  });\n};\n\n/**\n * Remove text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n */\n\nCommands$2.removeTextByPath = function (editor, path, offset, length) {\n  var value = editor.value;\n  var document = value.document,\n      annotations = value.annotations;\n\n  var node = document.assertNode(path);\n  var text = node.text.slice(offset, offset + length);\n\n  editor.withoutNormalizing(function () {\n    var _iteratorNormalCompletion3 = true;\n    var _didIteratorError3 = false;\n    var _iteratorError3 = undefined;\n\n    try {\n      for (var _iterator3 = annotations.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n        var annotation = _step3.value;\n        var start = annotation.start,\n            end = annotation.end;\n\n        var isAtomic = editor.isAtomic(annotation);\n\n        if (!isAtomic) {\n          continue;\n        }\n\n        if (!start.path.equals(path)) {\n          continue;\n        }\n\n        if (start.offset < offset && (!end.path.equals(path) || end.offset > offset)) {\n          editor.removeAnnotation(annotation);\n        }\n      }\n    } catch (err) {\n      _didIteratorError3 = true;\n      _iteratorError3 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion3 && _iterator3.return) {\n          _iterator3.return();\n        }\n      } finally {\n        if (_didIteratorError3) {\n          throw _iteratorError3;\n        }\n      }\n    }\n\n    editor.applyOperation({\n      type: 'remove_text',\n      path: path,\n      offset: offset,\n      text: text\n    });\n  });\n};\n\n/**\n`* Replace a `node` with another `node`\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|Node} node\n */\n\nCommands$2.replaceNodeByPath = function (editor, path, newNode) {\n  newNode = Node.create(newNode);\n  var index = path.last();\n  var parentPath = PathUtils.lift(path);\n\n  editor.withoutNormalizing(function () {\n    editor.removeNodeByPath(path);\n    editor.insertNodeByPath(parentPath, index, newNode);\n  });\n};\n\n/**\n * Replace a `length` of text at `offset` with new `text` and optional `marks`.\n *\n * @param {Editor} editor\n * @param {String} key\n * @param {Number} offset\n * @param {Number} length\n * @param {string} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands$2.replaceTextByPath = function (editor, path, offset, length, text, marks) {\n  editor.withoutNormalizing(function () {\n    editor.removeTextByPath(path, offset, length);\n    editor.insertTextByPath(path, offset, text, marks);\n  });\n};\n\n/**\n * Set `newProperties` on mark on text at `offset` and `length` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} offset\n * @param {Number} length\n * @param {Object|Mark} properties\n * @param {Object} newProperties\n */\n\nCommands$2.setMarkByPath = function (editor, path, offset, length, properties, newProperties) {\n  properties = Mark.create(properties);\n  newProperties = Mark.createProperties(newProperties);\n\n  var value = editor.value;\n  var document = value.document;\n\n  var node = document.assertNode(path);\n\n  editor.withoutNormalizing(function () {\n    // If it ends before the end of the node, we'll need to split to create a new\n    // text with different marks.\n    if (offset + length < node.text.length) {\n      editor.splitNodeByPath(path, offset + length);\n    }\n\n    // Same thing if it starts after the start. But in that case, we need to\n    // update our path and offset to point to the new start.\n    if (offset > 0) {\n      editor.splitNodeByPath(path, offset);\n      path = PathUtils.increment(path);\n      offset = 0;\n    }\n\n    editor.applyOperation({\n      type: 'set_mark',\n      path: path,\n      properties: properties,\n      newProperties: newProperties\n    });\n  });\n};\n\n/**\n * Set `properties` on a node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|String} newProperties\n */\n\nCommands$2.setNodeByPath = function (editor, path, newProperties) {\n  var value = editor.value;\n  var document = value.document;\n\n  var node = document.assertNode(path);\n  newProperties = Node.createProperties(newProperties);\n  var prevProperties = pick(node, Object.keys(newProperties));\n\n  editor.applyOperation({\n    type: 'set_node',\n    path: path,\n    properties: prevProperties,\n    newProperties: newProperties\n  });\n};\n\n/**\n * Insert `text` at `offset` in node by `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands$2.setTextByPath = function (editor, path, text, marks) {\n  var value = editor.value;\n  var document = value.document;\n\n  var node = document.assertNode(path);\n  var end = node.text.length;\n  editor.replaceTextByPath(path, 0, end, text, marks);\n};\n\n/**\n * Split a node by `path` at `position`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Number} position\n * @param {Object} options\n */\n\nCommands$2.splitNodeByPath = function (editor, path, position) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$target = options.target,\n      target = _options$target === undefined ? null : _options$target;\n  var value = editor.value;\n  var document = value.document;\n\n  var node = document.getDescendant(path);\n\n  editor.applyOperation({\n    type: 'split_node',\n    path: path,\n    position: position,\n    target: target,\n    properties: {\n      type: node.type,\n      data: node.data\n    }\n  });\n};\n\n/**\n * Split a node deeply down the tree by `path`, `textPath` and `textOffset`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Array} textPath\n * @param {Number} textOffset\n */\n\nCommands$2.splitDescendantsByPath = function (editor, path, textPath, textOffset) {\n  if (path.equals(textPath)) {\n    editor.splitNodeByPath(textPath, textOffset);\n    return;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n\n  var index = textOffset;\n  var lastPath = textPath;\n\n  editor.withoutNormalizing(function () {\n    editor.splitNodeByKey(textPath, textOffset);\n\n    var _iteratorNormalCompletion4 = true;\n    var _didIteratorError4 = false;\n    var _iteratorError4 = undefined;\n\n    try {\n      for (var _iterator4 = document.ancestors(textPath)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n        var _ref3 = _step4.value;\n\n        var _ref4 = slicedToArray(_ref3, 2);\n\n        var ancestorPath = _ref4[1];\n\n        var target = index;\n        index = lastPath.last() + 1;\n        lastPath = ancestorPath;\n        editor.splitNodeByPath(ancestorPath, index, { target: target });\n\n        if (ancestorPath.equals(path)) {\n          break;\n        }\n      }\n    } catch (err) {\n      _didIteratorError4 = true;\n      _iteratorError4 = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion4 && _iterator4.return) {\n          _iterator4.return();\n        }\n      } finally {\n        if (_didIteratorError4) {\n          throw _iteratorError4;\n        }\n      }\n    }\n  });\n};\n\n/**\n * Unwrap content from an inline parent with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|String} properties\n */\n\nCommands$2.unwrapInlineByPath = function (editor, path, properties) {\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n\n  var node = document.assertNode(path);\n  var first = node.getFirstText();\n  var last = node.getLastText();\n  var range = selection.moveToRangeOfNode(first, last);\n  editor.unwrapInlineAtRange(range, properties);\n};\n\n/**\n * Unwrap content from a block parent with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Object|String} properties\n */\n\nCommands$2.unwrapBlockByPath = function (editor, path, properties) {\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n\n  var node = document.assertNode(path);\n  var first = node.getFirstText();\n  var last = node.getLastText();\n  var range = selection.moveToRangeOfNode(first, last);\n  editor.unwrapBlockAtRange(range, properties);\n};\n\n/**\n * Unwrap a single node from its parent.\n *\n * If the node is surrounded with siblings, its parent will be\n * split. If the node is the only child, the parent is removed, and\n * simply replaced by the node itself.  Cannot unwrap a root node.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nCommands$2.unwrapNodeByPath = function (editor, path) {\n  var value = editor.value;\n  var document = value.document;\n\n  document.assertNode(path);\n\n  var parentPath = PathUtils.lift(path);\n  var parent = document.assertNode(parentPath);\n  var index = path.last();\n  var parentIndex = parentPath.last();\n  var grandPath = PathUtils.lift(parentPath);\n  var isFirst = index === 0;\n  var isLast = index === parent.nodes.size - 1;\n\n  editor.withoutNormalizing(function () {\n    if (parent.nodes.size === 1) {\n      editor.moveNodeByPath(path, grandPath, parentIndex + 1);\n      editor.removeNodeByPath(parentPath);\n    } else if (isFirst) {\n      editor.moveNodeByPath(path, grandPath, parentIndex);\n    } else if (isLast) {\n      editor.moveNodeByPath(path, grandPath, parentIndex + 1);\n    } else {\n      var updatedPath = PathUtils.increment(path, 1, parentPath.size - 1);\n      updatedPath = updatedPath.set(updatedPath.size - 1, 0);\n      editor.splitNodeByPath(parentPath, index);\n      editor.moveNodeByPath(updatedPath, grandPath, parentIndex + 1);\n    }\n  });\n};\n\n/**\n * Unwrap all of the children of a node, by removing the node and replacing it\n * with the children in the tree.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nCommands$2.unwrapChildrenByPath = function (editor, path) {\n  path = PathUtils.create(path);\n  var value = editor.value;\n  var document = value.document;\n\n  var node = document.assertNode(path);\n  var parentPath = PathUtils.lift(path);\n  var index = path.last();\n  var nodes = node.nodes;\n\n\n  editor.withoutNormalizing(function () {\n    nodes.reverse().forEach(function (child, i) {\n      var childIndex = nodes.size - i - 1;\n      var childPath = path.push(childIndex);\n      editor.moveNodeByPath(childPath, parentPath, index + 1);\n    });\n\n    editor.removeNodeByPath(path);\n  });\n};\n\n/**\n * Wrap a node in a block with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Block|Object|String} block\n */\n\nCommands$2.wrapBlockByPath = function (editor, path, block) {\n  block = Block.create(block);\n  block = block.set('nodes', block.nodes.clear());\n  var parentPath = PathUtils.lift(path);\n  var index = path.last();\n  var newPath = PathUtils.increment(path);\n\n  editor.withoutNormalizing(function () {\n    editor.insertNodeByPath(parentPath, index, block);\n    editor.moveNodeByPath(newPath, path, 0);\n  });\n};\n\n/**\n * Wrap a node in an inline with `properties`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Block|Object|String} inline\n */\n\nCommands$2.wrapInlineByPath = function (editor, path, inline) {\n  inline = Inline.create(inline);\n  inline = inline.set('nodes', inline.nodes.clear());\n  var parentPath = PathUtils.lift(path);\n  var index = path.last();\n  var newPath = PathUtils.increment(path);\n\n  editor.withoutNormalizing(function () {\n    editor.insertNodeByPath(parentPath, index, inline);\n    editor.moveNodeByPath(newPath, path, 0);\n  });\n};\n\n/**\n * Wrap a node by `path` with `node`.\n *\n * @param {Editor} editor\n * @param {Array} path\n * @param {Node|Object} node\n */\n\nCommands$2.wrapNodeByPath = function (editor, path, node) {\n  node = Node.create(node);\n\n  if (node.object === 'block') {\n    editor.wrapBlockByPath(path, node);\n  } else if (node.object === 'inline') {\n    editor.wrapInlineByPath(path, node);\n  }\n};\n\n/**\n * Mix in `*ByKey` variants.\n */\n\nvar COMMANDS = ['addMark', 'insertFragment', 'insertNode', 'insertText', 'mergeNode', 'removeAllMarks', 'removeMark', 'removeNode', 'removeText', 'replaceMarks', 'replaceNode', 'replaceText', 'setMark', 'setNode', 'setText', 'splitNode', 'unwrapBlock', 'unwrapChildren', 'unwrapInline', 'unwrapNode', 'wrapBlock', 'wrapInline', 'wrapNode'];\n\nvar _loop = function _loop(method) {\n  Commands$2[method + 'ByKey'] = function (editor, key) {\n    for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\n      args[_key3 - 2] = arguments[_key3];\n    }\n\n    var value = editor.value;\n    var document = value.document;\n\n    var path = document.assertPath(key);\n    editor[method + 'ByPath'].apply(editor, [path].concat(args));\n  };\n};\n\nvar _iteratorNormalCompletion5 = true;\nvar _didIteratorError5 = false;\nvar _iteratorError5 = undefined;\n\ntry {\n  for (var _iterator5 = COMMANDS[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n    var method = _step5.value;\n\n    _loop(method);\n  }\n\n  // Moving nodes takes two keys, so it's slightly different.\n} catch (err) {\n  _didIteratorError5 = true;\n  _iteratorError5 = err;\n} finally {\n  try {\n    if (!_iteratorNormalCompletion5 && _iterator5.return) {\n      _iterator5.return();\n    }\n  } finally {\n    if (_didIteratorError5) {\n      throw _iteratorError5;\n    }\n  }\n}\n\nCommands$2.moveNodeByKey = function (editor, key, newKey) {\n  for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n    args[_key - 3] = arguments[_key];\n  }\n\n  var value = editor.value;\n  var document = value.document;\n\n  var path = document.assertPath(key);\n  var newPath = document.assertPath(newKey);\n  editor.moveNodeByPath.apply(editor, [path, newPath].concat(args));\n};\n\n// Splitting descendants takes two keys, so it's slightly different.\nCommands$2.splitDescendantsByKey = function (editor, key, textKey) {\n  for (var _len2 = arguments.length, args = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n    args[_key2 - 3] = arguments[_key2];\n  }\n\n  var value = editor.value;\n  var document = value.document;\n\n  var path = document.assertPath(key);\n  var textPath = document.assertPath(textKey);\n  editor.splitDescendantsByPath.apply(editor, [path, textPath].concat(args));\n};\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nvar Commands$3 = {};\n\n/**\n * Save an `operation` into the history.\n *\n * @param {Editor} editor\n * @param {Object} operation\n */\n\nCommands$3.save = function (editor, operation) {\n  var operations = editor.operations,\n      value = editor.value;\n  var data = value.data;\n  var _editor$tmp = editor.tmp,\n      save = _editor$tmp.save,\n      merge = _editor$tmp.merge;\n\n  if (save === false || !isValidOperation(operation)) return;\n\n  var undos = data.get('undos') || immutable.List();\n  var lastBatch = undos.last();\n  var lastOperation = lastBatch && lastBatch.last();\n\n  // If `merge` is non-commital, and this is not the first operation in a new\n  // editor, then merge, otherwise merge based on the last operation.\n  if (merge == null) {\n    if (operations.size !== 0) {\n      merge = true;\n    } else {\n      merge = shouldMerge(operation, lastOperation);\n    }\n  }\n\n  // If the `merge` flag is true, add the operation to the last batch.\n  if (merge && lastBatch) {\n    var batch = lastBatch.push(operation);\n    undos = undos.pop();\n    undos = undos.push(batch);\n  } else {\n    // Otherwise, create a new batch with the operation.\n    var _batch = immutable.List([operation]);\n    undos = undos.push(_batch);\n  }\n\n  // Constrain the history to 100 entries for memory's sake.\n  if (undos.size > 100) {\n    undos = undos.takeLast(100);\n  }\n\n  // Clear the redos and update the history.\n  editor.withoutSaving(function () {\n    var redos = immutable.List();\n    var newData = data.set('undos', undos).set('redos', redos);\n    editor.setData(newData);\n  });\n};\n\n/**\n * Redo to the next value in the history.\n *\n * @param {Editor} editor\n */\n\nCommands$3.redo = function (editor) {\n  var value = editor.value;\n  var data = value.data;\n\n  var redos = data.get('redos') || immutable.List();\n  var undos = data.get('undos') || immutable.List();\n  var batch = redos.last();\n  if (!batch) return;\n\n  editor.withoutSaving(function () {\n    editor.withoutNormalizing(function () {\n      // Replay the batch of operations.\n      batch.forEach(function (op) {\n        var _op = op,\n            type = _op.type,\n            newProperties = _op.newProperties;\n\n        // When the operation mutates the selection, omit its `isFocused` value to\n        // prevent the editor focus from changing during redoing.\n\n        if (type === 'set_selection') {\n          op = op.set('newProperties', omit(newProperties, 'isFocused'));\n        }\n\n        editor.applyOperation(op);\n      });\n\n      // Shift the next value into the undo stack.\n      redos = redos.pop();\n      undos = undos.push(batch);\n      var newData = data.set('undos', undos).set('redos', redos);\n      editor.setData(newData);\n    });\n  });\n};\n\n/**\n * Undo the previous operations in the history.\n *\n * @param {Editor} editor\n */\n\nCommands$3.undo = function (editor) {\n  var value = editor.value;\n  var data = value.data;\n\n  var redos = data.get('redos') || immutable.List();\n  var undos = data.get('undos') || immutable.List();\n  var batch = undos.last();\n  if (!batch) return;\n\n  editor.withoutSaving(function () {\n    editor.withoutNormalizing(function () {\n      // Replay the inverse of the previous operations.\n      batch.slice().reverse().map(function (op) {\n        return op.invert();\n      }).forEach(function (inverse) {\n        var _inverse = inverse,\n            type = _inverse.type,\n            newProperties = _inverse.newProperties;\n\n        // When the operation mutates the selection, omit its `isFocused` value to\n        // prevent the editor focus from changing during undoing.\n\n        if (type === 'set_selection') {\n          inverse = inverse.set('newProperties', omit(newProperties, 'isFocused'));\n        }\n\n        editor.applyOperation(inverse);\n      });\n\n      // Shift the previous operations into the redo stack.\n      redos = redos.push(batch);\n      undos = undos.pop();\n      var newData = data.set('undos', undos).set('redos', redos);\n      editor.setData(newData);\n    });\n  });\n};\n\n/**\n * Apply a series of changes inside a synchronous `fn`, without merging any of\n * the new operations into previous save point in the history.\n *\n * @param {Editor} editor\n * @param {Function} fn\n */\n\nCommands$3.withoutMerging = function (editor, fn) {\n  var value = editor.tmp.merge;\n  editor.tmp.merge = false;\n  fn(editor);\n  editor.tmp.merge = value;\n};\n\n/**\n * Apply a series of changes inside a synchronous `fn`, without saving any of\n * their operations into the history.\n *\n * @param {Editor} editor\n * @param {Function} fn\n */\n\nCommands$3.withoutSaving = function (editor, fn) {\n  var value = editor.tmp.save;\n  editor.tmp.save = false;\n  fn(editor);\n  editor.tmp.save = value;\n};\n\n/**\n * Check whether to merge a new operation `o` into the previous operation `p`.\n *\n * @param {Object} o\n * @param {Object} p\n * @return {Boolean}\n */\n\nfunction shouldMerge(o, p) {\n  if (!p) return false;\n\n  var merge = o.type === 'set_selection' && p.type === 'set_selection' || o.type === 'insert_text' && p.type === 'insert_text' && o.offset === p.offset + p.text.length && o.path.equals(p.path) || o.type === 'remove_text' && p.type === 'remove_text' && o.offset + o.text.length === p.offset && o.path.equals(p.path);\n\n  return merge;\n}\n\n/**\n * Check weather an operation needs to be saved to the history\n * @param {Object} o - operation\n * @returns {Boolean}\n */\n\nfunction isValidOperation(o) {\n  if (o.type === 'set_selection') {\n    var _o$newProperties = o.newProperties,\n        isFocused = _o$newProperties.isFocused,\n        anchor = _o$newProperties.anchor,\n        focus = _o$newProperties.focus;\n\n    // this is blur/focus operation, dont need to store it into the history\n\n    if (isFocused !== undefined && !anchor && !focus) {\n      return false;\n    }\n  }\n  return true;\n}\n\nvar Commands$4 = {};\n\nCommands$4.blur = function (editor) {\n  editor.select({ isFocused: false });\n};\n\nCommands$4.deselect = function (editor) {\n  var range = Selection.create();\n  editor.select(range);\n};\n\nCommands$4.focus = function (editor) {\n  editor.select({ isFocused: true });\n};\n\nCommands$4.flip = function (editor) {\n  editor.command(proxy, 'flip');\n};\n\nCommands$4.moveAnchorBackward = function (editor) {\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  editor.command.apply(editor, [pointBackward, 'anchor'].concat(args));\n};\n\nCommands$4.moveAnchorWordBackward = function (editor) {\n  for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    args[_key2 - 1] = arguments[_key2];\n  }\n\n  editor.command.apply(editor, [pointWordBackward, 'anchor'].concat(args));\n};\n\nCommands$4.moveAnchorForward = function (editor) {\n  for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    args[_key3 - 1] = arguments[_key3];\n  }\n\n  editor.command.apply(editor, [pointForward, 'anchor'].concat(args));\n};\n\nCommands$4.moveAnchorWordForward = function (editor) {\n  for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    args[_key4 - 1] = arguments[_key4];\n  }\n\n  editor.command.apply(editor, [pointWordForward, 'anchor'].concat(args));\n};\n\nCommands$4.moveAnchorTo = function (editor) {\n  for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n    args[_key5 - 1] = arguments[_key5];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveAnchorTo'].concat(args));\n};\n\nCommands$4.moveAnchorToEndOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'anchor', 'end', 'block');\n};\n\nCommands$4.moveAnchorToEndOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'anchor', 'end', 'inline');\n};\n\nCommands$4.moveAnchorToEndOfDocument = function (editor) {\n  editor.moveAnchorToEndOfNode(editor.value.document).moveToAnchor();\n};\n\nCommands$4.moveAnchorToEndOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'next', 'block');\n};\n\nCommands$4.moveAnchorToEndOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'next', 'inline');\n};\n\nCommands$4.moveAnchorToEndOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'next', 'text');\n};\n\nCommands$4.moveAnchorToEndOfNode = function (editor) {\n  for (var _len6 = arguments.length, args = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\n    args[_key6 - 1] = arguments[_key6];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveAnchorToEndOfNode'].concat(args));\n};\n\nCommands$4.moveAnchorToEndOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'previous', 'block');\n};\n\nCommands$4.moveAnchorToEndOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'previous', 'inline');\n};\n\nCommands$4.moveAnchorToEndOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'previous', 'text');\n};\n\nCommands$4.moveAnchorToEndOfText = function (editor) {\n  editor.command(pointEdgeObject, 'anchor', 'end', 'text');\n};\n\nCommands$4.moveAnchorToStartOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'anchor', 'start', 'block');\n};\n\nCommands$4.moveAnchorToStartOfDocument = function (editor) {\n  editor.moveAnchorToStartOfNode(editor.value.document).moveToAnchor();\n};\n\nCommands$4.moveAnchorToStartOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'anchor', 'start', 'inline');\n};\n\nCommands$4.moveAnchorToStartOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'next', 'block');\n};\n\nCommands$4.moveAnchorToStartOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'next', 'inline');\n};\n\nCommands$4.moveAnchorToStartOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'next', 'text');\n};\n\nCommands$4.moveAnchorToStartOfNode = function (editor) {\n  for (var _len7 = arguments.length, args = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n    args[_key7 - 1] = arguments[_key7];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveAnchorToStartOfNode'].concat(args));\n};\n\nCommands$4.moveAnchorToStartOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'previous', 'block');\n};\n\nCommands$4.moveAnchorToStartOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'previous', 'inline');\n};\n\nCommands$4.moveAnchorToStartOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'previous', 'text');\n};\n\nCommands$4.moveAnchorToStartOfText = function (editor) {\n  editor.command(pointEdgeObject, 'anchor', 'start', 'text');\n};\n\nCommands$4.moveBackward = function (editor) {\n  var chars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n  if (chars === 0) return;\n\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var start = selection.start;\n\n  var startBlock = document.getClosestBlock(start.key);\n  var o = startBlock.getOffset(start.key);\n  var offset = o + start.offset;\n  var text = startBlock.text;\n\n  var charsOffset = TextUtils.getCharOffsetBackward(text, offset, chars);\n  editor.moveAnchorBackward(charsOffset).moveFocusBackward(charsOffset);\n};\n\nCommands$4.moveWordBackward = function (editor) {\n  for (var _len8 = arguments.length, args = Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n    args[_key8 - 1] = arguments[_key8];\n  }\n\n  editor.moveFocusWordBackward.apply(editor, args).moveToFocus();\n};\n\nCommands$4.moveEndBackward = function (editor) {\n  for (var _len9 = arguments.length, args = Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n    args[_key9 - 1] = arguments[_key9];\n  }\n\n  editor.command.apply(editor, [pointBackward, 'end'].concat(args));\n};\n\nCommands$4.moveEndWordBackward = function (editor) {\n  for (var _len10 = arguments.length, args = Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {\n    args[_key10 - 1] = arguments[_key10];\n  }\n\n  editor.command.apply(editor, [pointWordBackward, 'end'].concat(args));\n};\n\nCommands$4.moveEndForward = function (editor) {\n  for (var _len11 = arguments.length, args = Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n    args[_key11 - 1] = arguments[_key11];\n  }\n\n  editor.command.apply(editor, [pointForward, 'end'].concat(args));\n};\n\nCommands$4.moveEndWordForward = function (editor) {\n  for (var _len12 = arguments.length, args = Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {\n    args[_key12 - 1] = arguments[_key12];\n  }\n\n  editor.command.apply(editor, [pointWordForward, 'end'].concat(args));\n};\n\nCommands$4.moveEndTo = function (editor) {\n  for (var _len13 = arguments.length, args = Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {\n    args[_key13 - 1] = arguments[_key13];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveEndTo'].concat(args));\n};\n\nCommands$4.moveEndToEndOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'end', 'end', 'block');\n};\n\nCommands$4.moveEndToEndOfDocument = function (editor) {\n  editor.moveEndToEndOfNode(editor.value.document).moveToEnd();\n};\n\nCommands$4.moveEndToEndOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'end', 'end', 'inline');\n};\n\nCommands$4.moveEndToEndOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'next', 'block');\n};\n\nCommands$4.moveEndToEndOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'next', 'inline');\n};\n\nCommands$4.moveEndToEndOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'next', 'text');\n};\n\nCommands$4.moveEndToEndOfNode = function (editor) {\n  for (var _len14 = arguments.length, args = Array(_len14 > 1 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) {\n    args[_key14 - 1] = arguments[_key14];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveEndToEndOfNode'].concat(args));\n};\n\nCommands$4.moveEndToEndOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'previous', 'block');\n};\n\nCommands$4.moveEndToEndOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'previous', 'inline');\n};\n\nCommands$4.moveEndToEndOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'end', 'previous', 'text');\n};\n\nCommands$4.moveEndToEndOfText = function (editor) {\n  editor.command(pointEdgeObject, 'end', 'end', 'text');\n};\n\nCommands$4.moveEndToStartOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'end', 'start', 'block');\n};\n\nCommands$4.moveEndToStartOfDocument = function (editor) {\n  editor.moveEndToStartOfNode(editor.value.document).moveToEnd();\n};\n\nCommands$4.moveEndToStartOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'end', 'start', 'inline');\n};\n\nCommands$4.moveEndToStartOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'next', 'block');\n};\n\nCommands$4.moveEndToStartOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'next', 'inline');\n};\n\nCommands$4.moveEndToStartOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'next', 'text');\n};\n\nCommands$4.moveEndToStartOfNode = function (editor) {\n  for (var _len15 = arguments.length, args = Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {\n    args[_key15 - 1] = arguments[_key15];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveEndToStartOfNode'].concat(args));\n};\n\nCommands$4.moveEndToStartOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'previous', 'block');\n};\n\nCommands$4.moveEndToStartOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'previous', 'inline');\n};\n\nCommands$4.moveEndToStartOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'end', 'start', 'previous', 'text');\n};\n\nCommands$4.moveEndToStartOfText = function (editor) {\n  editor.command(pointEdgeObject, 'end', 'start', 'text');\n};\n\nCommands$4.moveFocusBackward = function (editor) {\n  for (var _len16 = arguments.length, args = Array(_len16 > 1 ? _len16 - 1 : 0), _key16 = 1; _key16 < _len16; _key16++) {\n    args[_key16 - 1] = arguments[_key16];\n  }\n\n  editor.command.apply(editor, [pointBackward, 'focus'].concat(args));\n};\n\nCommands$4.moveFocusWordBackward = function (editor) {\n  for (var _len17 = arguments.length, args = Array(_len17 > 1 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) {\n    args[_key17 - 1] = arguments[_key17];\n  }\n\n  editor.command.apply(editor, [pointWordBackward, 'focus'].concat(args));\n};\n\nCommands$4.moveFocusForward = function (editor) {\n  for (var _len18 = arguments.length, args = Array(_len18 > 1 ? _len18 - 1 : 0), _key18 = 1; _key18 < _len18; _key18++) {\n    args[_key18 - 1] = arguments[_key18];\n  }\n\n  editor.command.apply(editor, [pointForward, 'focus'].concat(args));\n};\n\nCommands$4.moveFocusWordForward = function (editor) {\n  for (var _len19 = arguments.length, args = Array(_len19 > 1 ? _len19 - 1 : 0), _key19 = 1; _key19 < _len19; _key19++) {\n    args[_key19 - 1] = arguments[_key19];\n  }\n\n  editor.command.apply(editor, [pointWordForward, 'focus'].concat(args));\n};\n\nCommands$4.moveFocusTo = function (editor) {\n  for (var _len20 = arguments.length, args = Array(_len20 > 1 ? _len20 - 1 : 0), _key20 = 1; _key20 < _len20; _key20++) {\n    args[_key20 - 1] = arguments[_key20];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveFocusTo'].concat(args));\n};\n\nCommands$4.moveFocusToEndOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'focus', 'end', 'block');\n};\n\nCommands$4.moveFocusToEndOfDocument = function (editor) {\n  editor.moveFocusToEndOfNode(editor.value.document).moveToFocus();\n};\n\nCommands$4.moveFocusToEndOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'focus', 'end', 'inline');\n};\n\nCommands$4.moveFocusToEndOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'next', 'block');\n};\n\nCommands$4.moveFocusToEndOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'next', 'inline');\n};\n\nCommands$4.moveFocusToEndOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'next', 'text');\n};\n\nCommands$4.moveFocusToEndOfNode = function (editor) {\n  for (var _len21 = arguments.length, args = Array(_len21 > 1 ? _len21 - 1 : 0), _key21 = 1; _key21 < _len21; _key21++) {\n    args[_key21 - 1] = arguments[_key21];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveFocusToEndOfNode'].concat(args));\n};\n\nCommands$4.moveFocusToEndOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'previous', 'block');\n};\n\nCommands$4.moveFocusToEndOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'previous', 'inline');\n};\n\nCommands$4.moveFocusToEndOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'previous', 'text');\n};\n\nCommands$4.moveFocusToEndOfText = function (editor) {\n  editor.command(pointEdgeObject, 'focus', 'end', 'text');\n};\n\nCommands$4.moveFocusToStartOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'focus', 'start', 'block');\n};\n\nCommands$4.moveFocusToStartOfDocument = function (editor) {\n  editor.moveFocusToStartOfNode(editor.value.document).moveToFocus();\n};\n\nCommands$4.moveFocusToStartOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'focus', 'start', 'inline');\n};\n\nCommands$4.moveFocusToStartOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'next', 'block');\n};\n\nCommands$4.moveFocusToStartOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'next', 'inline');\n};\n\nCommands$4.moveFocusToStartOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'next', 'text');\n};\n\nCommands$4.moveFocusToStartOfNode = function (editor) {\n  for (var _len22 = arguments.length, args = Array(_len22 > 1 ? _len22 - 1 : 0), _key22 = 1; _key22 < _len22; _key22++) {\n    args[_key22 - 1] = arguments[_key22];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveFocusToStartOfNode'].concat(args));\n};\n\nCommands$4.moveFocusToStartOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'previous', 'block');\n};\n\nCommands$4.moveFocusToStartOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'previous', 'inline');\n};\n\nCommands$4.moveFocusToStartOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'previous', 'text');\n};\n\nCommands$4.moveFocusToStartOfText = function (editor) {\n  editor.command(pointEdgeObject, 'focus', 'start', 'text');\n};\n\nCommands$4.moveForward = function (editor) {\n  var chars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n  if (chars === 0) return;\n\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n  var start = selection.start;\n\n  var startBlock = document.getClosestBlock(start.path);\n  var o = startBlock.getOffset(start.key);\n  var offset = o + start.offset;\n  var text = startBlock.text;\n\n  var charsOffset = TextUtils.getCharOffsetForward(text, offset, chars);\n  editor.moveAnchorForward(charsOffset).moveFocusForward(charsOffset);\n};\n\nCommands$4.moveWordForward = function (editor) {\n  var _editor$moveFocusWord;\n\n  for (var _len23 = arguments.length, args = Array(_len23 > 1 ? _len23 - 1 : 0), _key23 = 1; _key23 < _len23; _key23++) {\n    args[_key23 - 1] = arguments[_key23];\n  }\n\n  (_editor$moveFocusWord = editor.moveFocusWordForward.apply(editor, args)).moveToFocus.apply(_editor$moveFocusWord, args);\n};\n\nCommands$4.moveStartBackward = function (editor) {\n  for (var _len24 = arguments.length, args = Array(_len24 > 1 ? _len24 - 1 : 0), _key24 = 1; _key24 < _len24; _key24++) {\n    args[_key24 - 1] = arguments[_key24];\n  }\n\n  editor.command.apply(editor, [pointBackward, 'start'].concat(args));\n};\n\nCommands$4.moveStartWordBackward = function (editor) {\n  for (var _len25 = arguments.length, args = Array(_len25 > 1 ? _len25 - 1 : 0), _key25 = 1; _key25 < _len25; _key25++) {\n    args[_key25 - 1] = arguments[_key25];\n  }\n\n  editor.command.apply(editor, [pointWordBackward, 'start'].concat(args));\n};\n\nCommands$4.moveStartForward = function (editor) {\n  for (var _len26 = arguments.length, args = Array(_len26 > 1 ? _len26 - 1 : 0), _key26 = 1; _key26 < _len26; _key26++) {\n    args[_key26 - 1] = arguments[_key26];\n  }\n\n  editor.command.apply(editor, [pointForward, 'start'].concat(args));\n};\n\nCommands$4.moveStartWordForward = function (editor) {\n  for (var _len27 = arguments.length, args = Array(_len27 > 1 ? _len27 - 1 : 0), _key27 = 1; _key27 < _len27; _key27++) {\n    args[_key27 - 1] = arguments[_key27];\n  }\n\n  editor.command.apply(editor, [pointWordForward, 'start'].concat(args));\n};\n\nCommands$4.moveStartTo = function (editor) {\n  for (var _len28 = arguments.length, args = Array(_len28 > 1 ? _len28 - 1 : 0), _key28 = 1; _key28 < _len28; _key28++) {\n    args[_key28 - 1] = arguments[_key28];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveStartTo'].concat(args));\n};\n\nCommands$4.moveStartToEndOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'start', 'end', 'block');\n};\n\nCommands$4.moveStartToEndOfDocument = function (editor) {\n  editor.moveStartToEndOfNode(editor.value.document).moveToStart();\n};\n\nCommands$4.moveStartToEndOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'start', 'end', 'inline');\n};\n\nCommands$4.moveStartToEndOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'next', 'block');\n};\n\nCommands$4.moveStartToEndOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'next', 'inline');\n};\n\nCommands$4.moveStartToEndOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'next', 'text');\n};\n\nCommands$4.moveStartToEndOfNode = function (editor) {\n  for (var _len29 = arguments.length, args = Array(_len29 > 1 ? _len29 - 1 : 0), _key29 = 1; _key29 < _len29; _key29++) {\n    args[_key29 - 1] = arguments[_key29];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveStartToEndOfNode'].concat(args));\n};\n\nCommands$4.moveStartToEndOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'previous', 'block');\n};\n\nCommands$4.moveStartToEndOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'previous', 'inline');\n};\n\nCommands$4.moveStartToEndOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'end', 'previous', 'text');\n};\n\nCommands$4.moveStartToEndOfText = function (editor) {\n  editor.command(pointEdgeObject, 'start', 'end', 'text');\n};\n\nCommands$4.moveStartToStartOfBlock = function (editor) {\n  editor.command(pointEdgeObject, 'start', 'start', 'block');\n};\n\nCommands$4.moveStartToStartOfDocument = function (editor) {\n  editor.moveStartToStartOfNode(editor.value.document).moveToStart();\n};\n\nCommands$4.moveStartToStartOfInline = function (editor) {\n  editor.command(pointEdgeObject, 'start', 'start', 'inline');\n};\n\nCommands$4.moveStartToStartOfNextBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'next', 'block');\n};\n\nCommands$4.moveStartToStartOfNextInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'next', 'inline');\n};\n\nCommands$4.moveStartToStartOfNextText = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'next', 'text');\n};\n\nCommands$4.moveStartToStartOfNode = function (editor) {\n  for (var _len30 = arguments.length, args = Array(_len30 > 1 ? _len30 - 1 : 0), _key30 = 1; _key30 < _len30; _key30++) {\n    args[_key30 - 1] = arguments[_key30];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveStartToStartOfNode'].concat(args));\n};\n\nCommands$4.moveStartToStartOfPreviousBlock = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'previous', 'block');\n};\n\nCommands$4.moveStartToStartOfPreviousInline = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'previous', 'inline');\n};\n\nCommands$4.moveStartToStartOfPreviousText = function (editor) {\n  editor.command(pointEdgeSideObject, 'start', 'start', 'previous', 'text');\n};\n\nCommands$4.moveStartToStartOfText = function (editor) {\n  editor.command(pointEdgeObject, 'start', 'start', 'text');\n};\n\nCommands$4.moveTo = function (editor) {\n  for (var _len31 = arguments.length, args = Array(_len31 > 1 ? _len31 - 1 : 0), _key31 = 1; _key31 < _len31; _key31++) {\n    args[_key31 - 1] = arguments[_key31];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveTo'].concat(args));\n};\n\nCommands$4.moveToAnchor = function (editor) {\n  editor.command(proxy, 'moveToAnchor');\n};\n\nCommands$4.moveToEnd = function (editor) {\n  editor.command(proxy, 'moveToEnd');\n};\n\nCommands$4.moveToEndOfBlock = function (editor) {\n  editor.moveEndToEndOfBlock().moveToEnd();\n};\n\nCommands$4.moveToEndOfDocument = function (editor) {\n  editor.moveEndToEndOfNode(editor.value.document).moveToEnd();\n};\n\nCommands$4.moveToEndOfInline = function (editor) {\n  editor.moveEndToEndOfInline().moveToEnd();\n};\n\nCommands$4.moveToEndOfNextBlock = function (editor) {\n  editor.moveEndToEndOfNextBlock().moveToEnd();\n};\n\nCommands$4.moveToEndOfNextInline = function (editor) {\n  editor.moveEndToEndOfNextInline().moveToEnd();\n};\n\nCommands$4.moveToEndOfNextText = function (editor) {\n  editor.moveEndToEndOfNextText().moveToEnd();\n};\n\nCommands$4.moveToEndOfNode = function (editor) {\n  for (var _len32 = arguments.length, args = Array(_len32 > 1 ? _len32 - 1 : 0), _key32 = 1; _key32 < _len32; _key32++) {\n    args[_key32 - 1] = arguments[_key32];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveToEndOfNode'].concat(args));\n};\n\nCommands$4.moveToEndOfPreviousBlock = function (editor) {\n  editor.moveStartToEndOfPreviousBlock().moveToStart();\n};\n\nCommands$4.moveToEndOfPreviousInline = function (editor) {\n  editor.moveStartToEndOfPreviousInline().moveToStart();\n};\n\nCommands$4.moveToEndOfPreviousText = function (editor) {\n  editor.moveStartToEndOfPreviousText().moveToStart();\n};\n\nCommands$4.moveToEndOfText = function (editor) {\n  editor.moveEndToEndOfText().moveToEnd();\n};\n\nCommands$4.moveToFocus = function (editor) {\n  editor.command(proxy, 'moveToFocus');\n};\n\nCommands$4.moveToRangeOfDocument = function (editor) {\n  editor.moveToRangeOfNode(editor.value.document);\n};\n\nCommands$4.moveToRangeOfNode = function (editor) {\n  for (var _len33 = arguments.length, args = Array(_len33 > 1 ? _len33 - 1 : 0), _key33 = 1; _key33 < _len33; _key33++) {\n    args[_key33 - 1] = arguments[_key33];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveToRangeOfNode'].concat(args));\n};\n\nCommands$4.moveToStart = function (editor) {\n  editor.command(proxy, 'moveToStart');\n};\n\nCommands$4.moveToStartOfBlock = function (editor) {\n  editor.moveStartToStartOfBlock().moveToStart();\n};\n\nCommands$4.moveToStartOfDocument = function (editor) {\n  editor.moveStartToStartOfNode(editor.value.document).moveToStart();\n};\n\nCommands$4.moveToStartOfInline = function (editor) {\n  editor.moveStartToStartOfInline().moveToStart();\n};\n\nCommands$4.moveToStartOfNextBlock = function (editor) {\n  editor.moveEndToStartOfNextBlock().moveToEnd();\n};\n\nCommands$4.moveToStartOfNextInline = function (editor) {\n  editor.moveEndToStartOfNextInline().moveToEnd();\n};\n\nCommands$4.moveToStartOfNextText = function (editor) {\n  editor.moveEndToStartOfNextText().moveToEnd();\n};\n\nCommands$4.moveToStartOfNode = function (editor) {\n  for (var _len34 = arguments.length, args = Array(_len34 > 1 ? _len34 - 1 : 0), _key34 = 1; _key34 < _len34; _key34++) {\n    args[_key34 - 1] = arguments[_key34];\n  }\n\n  editor.command.apply(editor, [proxy, 'moveToStartOfNode'].concat(args));\n};\n\nCommands$4.moveToStartOfPreviousBlock = function (editor) {\n  editor.moveStartToStartOfPreviousBlock().moveToStart();\n};\n\nCommands$4.moveToStartOfPreviousInline = function (editor) {\n  editor.moveStartToStartOfPreviousInline().moveToStart();\n};\n\nCommands$4.moveToStartOfPreviousText = function (editor) {\n  editor.moveStartToStartOfPreviousText().moveToStart();\n};\n\nCommands$4.moveToStartOfText = function (editor) {\n  editor.moveStartToStartOfText().moveToStart();\n};\n\nCommands$4.select = function (editor, properties) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  properties = Selection.createProperties(properties);\n  var _options$snapshot = options.snapshot,\n      snapshot = _options$snapshot === undefined ? false : _options$snapshot;\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n\n  var newProperties = {};\n  var next = selection.setProperties(properties);\n  next = document.resolveSelection(next);\n\n  // Re-compute the properties, to ensure that we get their normalized values.\n  properties = pick(next, Object.keys(properties));\n\n  // Remove any properties that are already equal to the current selection. And\n  // create a dictionary of the previous values for all of the properties that\n  // are being changed, for the inverse operation.\n  for (var k in properties) {\n    if (snapshot === true || !immutable.is(properties[k], selection[k])) {\n      newProperties[k] = properties[k];\n    }\n  }\n\n  // If the selection moves, clear any marks, unless the new selection\n  // properties change the marks in some way.\n  if (selection.marks && !newProperties.marks && (newProperties.anchor || newProperties.focus)) {\n    newProperties.marks = null;\n  }\n\n  // If there are no new properties to set, abort to avoid extra operations.\n  if (Object.keys(newProperties).length === 0) {\n    return;\n  }\n\n  // TODO: for some reason toJSON() is required here (it breaks selections between blocks)? - 2018-10-10\n  var prevProperties = pick(selection.toJSON(), Object.keys(newProperties));\n\n  editor.applyOperation({\n    type: 'set_selection',\n    value: value,\n    properties: prevProperties,\n    newProperties: newProperties\n  }, snapshot ? { skip: false, merge: false } : {});\n};\n\nCommands$4.setAnchor = function (editor) {\n  for (var _len35 = arguments.length, args = Array(_len35 > 1 ? _len35 - 1 : 0), _key35 = 1; _key35 < _len35; _key35++) {\n    args[_key35 - 1] = arguments[_key35];\n  }\n\n  editor.command.apply(editor, [proxy, 'setAnchor'].concat(args));\n};\n\nCommands$4.setEnd = function (editor) {\n  for (var _len36 = arguments.length, args = Array(_len36 > 1 ? _len36 - 1 : 0), _key36 = 1; _key36 < _len36; _key36++) {\n    args[_key36 - 1] = arguments[_key36];\n  }\n\n  editor.command.apply(editor, [proxy, 'setEnd'].concat(args));\n};\n\nCommands$4.setFocus = function (editor) {\n  for (var _len37 = arguments.length, args = Array(_len37 > 1 ? _len37 - 1 : 0), _key37 = 1; _key37 < _len37; _key37++) {\n    args[_key37 - 1] = arguments[_key37];\n  }\n\n  editor.command.apply(editor, [proxy, 'setFocus'].concat(args));\n};\n\nCommands$4.setStart = function (editor) {\n  for (var _len38 = arguments.length, args = Array(_len38 > 1 ? _len38 - 1 : 0), _key38 = 1; _key38 < _len38; _key38++) {\n    args[_key38 - 1] = arguments[_key38];\n  }\n\n  editor.command.apply(editor, [proxy, 'setStart'].concat(args));\n};\n\nCommands$4.snapshotSelection = function (editor) {\n  editor.withoutMerging(function () {\n    editor.select(editor.value.selection, { snapshot: true });\n  });\n};\n\n/**\n * Helpers.\n */\n\nfunction proxy(editor, method) {\n  var _editor$value$selecti;\n\n  for (var _len39 = arguments.length, args = Array(_len39 > 2 ? _len39 - 2 : 0), _key39 = 2; _key39 < _len39; _key39++) {\n    args[_key39 - 2] = arguments[_key39];\n  }\n\n  var range = (_editor$value$selecti = editor.value.selection)[method].apply(_editor$value$selecti, args);\n  editor.select(range);\n}\n\nfunction pointEdgeObject(editor, point, edge, object) {\n  var Point = point.slice(0, 1).toUpperCase() + point.slice(1);\n  var Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1);\n  var Object = object.slice(0, 1).toUpperCase() + object.slice(1);\n  var method = 'move' + Point + 'To' + Edge + 'OfNode';\n  var getNode = object === 'text' ? 'getNode' : 'getClosest' + Object;\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n\n  var p = selection[point];\n  var node = document[getNode](p.key);\n  if (!node) return;\n  editor[method](node);\n}\n\nfunction pointEdgeSideObject(editor, point, edge, side, object) {\n  var Point = point.slice(0, 1).toUpperCase() + point.slice(1);\n  var Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1);\n  var Side = side.slice(0, 1).toUpperCase() + side.slice(1);\n  var Object = object.slice(0, 1).toUpperCase() + object.slice(1);\n  var method = 'move' + Point + 'To' + Edge + 'OfNode';\n  var getNode = object === 'text' ? 'getNode' : 'getClosest' + Object;\n  var getDirectionNode = 'get' + Side + Object;\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n\n  var p = selection[point];\n  var node = document[getNode](p.key);\n  if (!node) return;\n  var target = document[getDirectionNode](node.key);\n  if (!target) return;\n  editor[method](target);\n}\n\nfunction pointBackward(editor, point) {\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n  if (n === 0) return;\n  if (n < 0) return pointForward(editor, point, -n);\n\n  var Point = point.slice(0, 1).toUpperCase() + point.slice(1);\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n\n  var p = selection[point];\n  var hasVoidParent = document.hasVoidParent(p.path, editor);\n\n  // what is this?\n  if (!hasVoidParent && p.offset - n >= 0) {\n    var range = selection['move' + Point + 'Backward'](n);\n    editor.select(range);\n    return;\n  }\n\n  var previous = document.getPreviousText(p.path);\n  if (!previous) return;\n\n  var block = document.getClosestBlock(p.path);\n  var isInBlock = block.hasNode(previous.key);\n  var isPreviousInVoid = previous && document.hasVoidParent(previous.key, editor);\n  editor['move' + Point + 'ToEndOfNode'](previous);\n\n  // when is this called?\n  if (!hasVoidParent && !isPreviousInVoid && isInBlock) {\n    var _range = editor.value.selection['move' + Point + 'Backward'](n);\n    editor.select(_range);\n  }\n}\n\nfunction pointForward(editor, point) {\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n  if (n === 0) return;\n  if (n < 0) return pointBackward(editor, point, -n);\n\n  var Point = point.slice(0, 1).toUpperCase() + point.slice(1);\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n\n  var p = selection[point];\n  var text = document.getNode(p.path);\n  var hasVoidParent = document.hasVoidParent(p.path, editor);\n\n  // what is this?\n  if (!hasVoidParent && p.offset + n <= text.text.length) {\n    var range = selection['move' + Point + 'Forward'](n);\n    editor.select(range);\n    return;\n  }\n\n  var next = document.getNextText(p.path);\n  if (!next) return;\n\n  var block = document.getClosestBlock(p.path);\n  var isInBlock = block.hasNode(next.key);\n  var isNextInVoid = document.hasVoidParent(next.key, editor);\n  editor['move' + Point + 'ToStartOfNode'](next);\n\n  // when is this called?\n  if (!hasVoidParent && !isNextInVoid && isInBlock) {\n    var _range2 = editor.value.selection['move' + Point + 'Forward'](n);\n    editor.select(_range2);\n  }\n}\n\nfunction pointWordBackward(editor, pointName) {\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n\n  var point = selection[pointName];\n  var block = document.getClosestBlock(point.key);\n  var offset = block.getOffset(point.key);\n  var o = offset + point.offset;\n  var text = block.text;\n\n  var n = TextUtils.getWordOffsetBackward(text, o);\n  editor.command(pointBackward, pointName, n > 0 ? n : 1);\n}\n\nfunction pointWordForward(editor, pointName) {\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n\n  var point = selection[pointName];\n  var block = document.getClosestBlock(point.key);\n  var offset = block.getOffset(point.key);\n  var o = offset + point.offset;\n  var text = block.text;\n\n  var n = TextUtils.getWordOffsetForward(text, o);\n  editor.command(pointForward, pointName, n > 0 ? n : 1);\n}\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nvar Commands$5 = {};\n\n/**\n * Set `properties` on the value.\n *\n * @param {Editor} editor\n * @param {Object|Value} properties\n */\n\nCommands$5.setData = function (editor) {\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var value = editor.value;\n\n  var newProperties = Value.createProperties({ data: data });\n  var prevProperties = pick(value, Object.keys(newProperties));\n\n  editor.applyOperation({\n    type: 'set_value',\n    properties: prevProperties,\n    newProperties: newProperties\n  });\n};\n\nCommands$5.addAnnotation = function (editor, annotation) {\n  annotation = Annotation.create(annotation);\n\n  editor.applyOperation({\n    type: 'add_annotation',\n    annotation: annotation\n  });\n};\n\nCommands$5.removeAnnotation = function (editor, annotation) {\n  annotation = Annotation.create(annotation);\n\n  editor.applyOperation({\n    type: 'remove_annotation',\n    annotation: annotation\n  });\n};\n\nCommands$5.setAnnotation = function (editor, annotation, newProperties) {\n  annotation = Annotation.create(annotation);\n  newProperties = Annotation.createProperties(newProperties);\n\n  editor.applyOperation({\n    type: 'set_annotation',\n    properties: annotation,\n    newProperties: newProperties\n  });\n};\n\nCommands$5.setAnnotations = function (editor) {\n  var annotations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var value = editor.value;\n\n  var newProperties = Value.createProperties({ annotations: annotations });\n  var prevProperties = pick(value, Object.keys(newProperties));\n\n  editor.applyOperation({\n    type: 'set_value',\n    properties: prevProperties,\n    newProperties: newProperties\n  });\n};\n\n/**\n * A plugin that adds a set of queries to the editor.\n *\n * @param {Object} queries\n * @return {Object}\n */\n\nfunction QueriesPlugin() {\n  var queries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  /**\n   * On construct, register all the queries.\n   *\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onConstruct(editor, next) {\n    for (var query in queries) {\n      editor.registerQuery(query);\n    }\n\n    return next();\n  }\n\n  /**\n   * On query, if it exists in our list of queries, call it.\n   *\n   * @param {Object} query\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onQuery(query, editor, next) {\n    var type = query.type,\n        args = query.args;\n\n    var fn = queries[type];\n    if (!fn) return next();\n    var ret = fn.apply(undefined, [editor].concat(toConsumableArray(args)));\n    return ret === undefined ? next() : ret;\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onConstruct: onConstruct,\n    onQuery: onQuery\n  };\n}\n\n/**\n * Define a Slate error.\n *\n * @type {SlateError}\n */\n\nvar SlateError = function (_Error) {\n  inherits(SlateError, _Error);\n\n  function SlateError(code) {\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, SlateError);\n\n    var _this = possibleConstructorReturn(this, (SlateError.__proto__ || Object.getPrototypeOf(SlateError)).call(this, code));\n\n    _this.code = code;\n\n    for (var key in attrs) {\n      _this[key] = attrs[key];\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(_this, _this.constructor);\n    } else {\n      _this.stack = new Error().stack;\n    }\n    return _this;\n  }\n\n  return SlateError;\n}(Error);\n\n/**\n * Create a plugin from a `schema` definition.\n *\n * @param {Object} schema\n * @return {Object}\n */\n\nfunction SchemaPlugin(schema) {\n  var rules = schema.rules,\n      document = schema.document,\n      blocks = schema.blocks,\n      inlines = schema.inlines,\n      marks = schema.marks,\n      annotations = schema.annotations,\n      decorations = schema.decorations;\n\n  var schemaRules = [];\n\n  if (rules) {\n    schemaRules = schemaRules.concat(rules);\n  }\n\n  if (document) {\n    schemaRules.push(_extends({\n      match: [{ object: 'document' }]\n    }, document));\n  }\n\n  if (blocks) {\n    for (var key in blocks) {\n      schemaRules.push(_extends({\n        match: [{ object: 'block', type: key }]\n      }, blocks[key]));\n    }\n  }\n\n  if (inlines) {\n    for (var _key in inlines) {\n      schemaRules.push(_extends({\n        match: [{ object: 'inline', type: _key }]\n      }, inlines[_key]));\n    }\n  }\n\n  if (marks) {\n    for (var _key2 in marks) {\n      schemaRules.push(_extends({\n        match: [{ object: 'mark', type: _key2 }]\n      }, marks[_key2]));\n    }\n  }\n\n  if (annotations) {\n    for (var _key3 in annotations) {\n      schemaRules.push(_extends({\n        match: [{ object: 'annotation', type: _key3 }]\n      }, annotations[_key3]));\n    }\n  }\n\n  if (decorations) {\n    for (var _key4 in decorations) {\n      schemaRules.push(_extends({\n        match: [{ object: 'decoration', type: _key4 }]\n      }, decorations[_key4]));\n    }\n  }\n\n  /**\n   * Check if a `format` is atomic based on the schema rules.\n   *\n   * @param {Editor} editor\n   * @param {Format} format\n   * @return {Boolean}\n   */\n\n  function isAtomic(editor, format) {\n    var rule = schemaRules.find(function (r) {\n      return 'isAtomic' in r && testRules(format, r.match);\n    });\n\n    return rule && rule.isAtomic;\n  }\n\n  /**\n   * Check if a `node` is void based on the schema rules.\n   *\n   * @param {Editor} editor\n   * @param {Node} node\n   * @return {Boolean}\n   */\n\n  function isVoid(editor, node) {\n    var rule = schemaRules.find(function (r) {\n      return 'isVoid' in r && testRules(node, r.match);\n    });\n\n    return rule && rule.isVoid;\n  }\n\n  /**\n   * Normalize a `node` with the schema rules, returning a function that will\n   * fix the invalid node, or void if the node is valid.\n   *\n   * @param {Node} node\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Function|Void}\n   */\n\n  function normalizeNode(node, editor, next) {\n    var error = validateNode(node, editor, function () {});\n    if (!error) return next();\n\n    return function () {\n      var rule = error.rule;\n      var size = editor.operations.size;\n\n      // First run the user-provided `normalize` function if one exists...\n\n      if (rule.normalize) {\n        rule.normalize(editor, error);\n      }\n\n      // If the `normalize` function did not add any operations to the editor\n      // object, it can't have normalized, so run the default one.\n      if (editor.operations.size === size) {\n        defaultNormalize(editor, error);\n      }\n    };\n  }\n\n  /**\n   * Validate a `node` with the schema rules, returning a `SlateError` if it's\n   * invalid.\n   *\n   * @param {Node} node\n   * @param {Editor} editor\n   * @param {Function} next\n   * @return {Error|Void}\n   */\n\n  function validateNode(node, editor, next) {\n    var matches = schemaRules.filter(function (r) {\n      return testRules(node, r.match);\n    });\n    var failure = validateRules(node, matches, schemaRules, { every: true });\n    if (!failure) return next();\n    var error = new SlateError(failure.code, failure);\n    return error;\n  }\n\n  /**\n   * On schema-related queries, respond if we can.\n   *\n   * @param {Object} query\n   * @param {Function} next\n   */\n\n  var queries = QueriesPlugin({ isAtomic: isAtomic, isVoid: isVoid });\n\n  /**\n   * Return the plugins.\n   *\n   * @type {Object}\n   */\n\n  return [{ normalizeNode: normalizeNode, validateNode: validateNode }, queries];\n}\n\n/**\n * Normalize an invalid value with `error` with default remedies.\n *\n * @param {Editor} editor\n * @param {SlateError} error\n */\n\nfunction defaultNormalize(editor, error) {\n  var code = error.code,\n      node = error.node,\n      child = error.child,\n      next = error.next,\n      previous = error.previous,\n      key = error.key,\n      mark = error.mark;\n\n\n  switch (code) {\n    case 'child_max_invalid':\n    case 'child_object_invalid':\n    case 'child_type_invalid':\n    case 'child_unknown':\n    case 'first_child_object_invalid':\n    case 'first_child_type_invalid':\n    case 'last_child_object_invalid':\n    case 'last_child_type_invalid':\n      {\n        return child.object === 'text' && node.object === 'block' && node.nodes.size === 1 ? editor.removeNodeByKey(node.key) : editor.removeNodeByKey(child.key);\n      }\n\n    case 'previous_sibling_object_invalid':\n    case 'previous_sibling_type_invalid':\n      {\n        return previous.object === 'text' && node.object === 'block' && node.nodes.size === 1 ? editor.removeNodeByKey(node.key) : editor.removeNodeByKey(previous.key);\n      }\n\n    case 'next_sibling_object_invalid':\n    case 'next_sibling_type_invalid':\n      {\n        return next.object === 'text' && node.object === 'block' && node.nodes.size === 1 ? editor.removeNodeByKey(node.key) : editor.removeNodeByKey(next.key);\n      }\n\n    case 'child_min_invalid':\n    case 'node_text_invalid':\n    case 'parent_object_invalid':\n    case 'parent_type_invalid':\n      {\n        return node.object === 'document' ? node.nodes.forEach(function (n) {\n          return editor.removeNodeByKey(n.key);\n        }) : editor.removeNodeByKey(node.key);\n      }\n\n    case 'node_data_invalid':\n      {\n        return node.data.get(key) === undefined && node.object !== 'document' ? editor.removeNodeByKey(node.key) : editor.setNodeByKey(node.key, { data: node.data.delete(key) });\n      }\n\n    case 'node_mark_invalid':\n      {\n        return node.getTexts().forEach(function (t) {\n          return editor.removeMarkByKey(t.key, 0, t.text.length, mark);\n        });\n      }\n\n    default:\n      {\n        return editor.removeNodeByKey(node.key);\n      }\n  }\n}\n\n/**\n * Check that an `object` matches one of a set of `rules`.\n *\n * @param {Mixed} object\n * @param {Object|Array} rules\n * @return {Boolean}\n */\n\nfunction testRules(object, rules) {\n  var error = validateRules(object, rules);\n  return !error;\n}\n\n/**\n * Validate that a `object` matches a `rule` object or array.\n *\n * @param {Mixed} object\n * @param {Object|Array} rule\n * @param {Array|Void} rules\n * @return {Error|Void}\n */\n\nfunction validateRules(object, rule, rules) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var _options$every = options.every,\n      every = _options$every === undefined ? false : _options$every,\n      _options$match = options.match,\n      match = _options$match === undefined ? null : _options$match;\n\n\n  if (typeof rule === 'function') {\n    var valid = rule(object, match);\n    return valid ? null : fail('node_invalid', { rule: rule, node: object });\n  }\n\n  if (Array.isArray(rule)) {\n    var array = rule.length ? rule : [{}];\n    var first = void 0;\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = array[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var r = _step.value;\n\n        var _error = validateRules(object, r, rules);\n        first = first || _error;\n        if (every && _error) return _error;\n        if (!every && !_error) return;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return first;\n  }\n\n  var error = validateObject(object, rule) || validateType(object, rule) || validateData(object, rule) || validateMarks(object, rule) || validateText(object, rule) || validateFirst(object, rule) || validateLast(object, rule) || validateNodes(object, rule, rules);\n\n  return error;\n}\n\nfunction validateObject(node, rule) {\n  if (rule.object == null) return;\n  if (rule.object === node.object) return;\n  if (typeof rule.object === 'function' && rule.object(node.object)) return;\n  return fail('node_object_invalid', { rule: rule, node: node });\n}\n\nfunction validateType(node, rule) {\n  if (rule.type == null) return;\n  if (rule.type === node.type) return;\n  if (typeof rule.type === 'function' && rule.type(node.type)) return;\n  return fail('node_type_invalid', { rule: rule, node: node });\n}\n\nfunction validateData(node, rule) {\n  if (rule.data == null) return;\n  if (node.data == null) return;\n\n  if (typeof rule.data === 'function') {\n    if (rule.data(node.data)) return;\n    return fail('node_data_invalid', { rule: rule, node: node });\n  }\n\n  for (var key in rule.data) {\n    var fn = rule.data[key];\n    var value = node.data && node.data.get(key);\n    var valid = typeof fn === 'function' ? fn(value) : fn === value;\n    if (valid) continue;\n    return fail('node_data_invalid', { rule: rule, node: node, key: key, value: value });\n  }\n}\n\nfunction validateMarks(node, rule) {\n  if (rule.marks == null) return;\n\n  var marks = node.object === 'text' ? node.marks.toArray() : node.getMarks().toArray();\n\n  var _loop = function _loop(mark) {\n    var valid = rule.marks.some(function (def) {\n      return typeof def.type === 'function' ? def.type(mark.type) : def.type === mark.type;\n    });\n    if (valid) return 'continue';\n    return {\n      v: fail('node_mark_invalid', { rule: rule, node: node, mark: mark })\n    };\n  };\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = marks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var mark = _step2.value;\n\n      var _ret = _loop(mark);\n\n      switch (_ret) {\n        case 'continue':\n          continue;\n\n        default:\n          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n}\n\nfunction validateText(node, rule) {\n  if (rule.text == null) return;\n  var text = node.text;\n\n  var valid = typeof rule.text === 'function' ? rule.text(text) : rule.text.test(text);\n  if (valid) return;\n  return fail('node_text_invalid', { rule: rule, node: node, text: text });\n}\n\nfunction validateFirst(node, rule) {\n  if (rule.first == null) return;\n  var first = node.nodes.first();\n  if (!first) return;\n  var error = validateRules(first, rule.first);\n  if (!error) return;\n  error.rule = rule;\n  error.node = node;\n  error.child = first;\n  error.code = error.code.replace('node_', 'first_child_');\n  return error;\n}\n\nfunction validateLast(node, rule) {\n  if (rule.last == null) return;\n  var last = node.nodes.last();\n  if (!last) return;\n  var error = validateRules(last, rule.last);\n  if (!error) return;\n  error.rule = rule;\n  error.node = node;\n  error.child = last;\n  error.code = error.code.replace('node_', 'last_child_');\n  return error;\n}\n\nfunction validateNodes(node, rule) {\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n  if (node.nodes == null) return;\n\n  var children = node.nodes;\n  var defs = rule.nodes != null ? rule.nodes.slice() : [];\n  var count = 0;\n  var lastCount = 0;\n  var min = null;\n  var index = -1;\n  var def = null;\n  var max = null;\n  var child = null;\n  var previous = null;\n  var next = null;\n\n  function nextDef() {\n    if (defs.length === 0) return false;\n    def = defs.shift();\n    lastCount = count;\n    count = 0;\n    min = def.min || null;\n    max = def.max || null;\n    return true;\n  }\n\n  function nextChild() {\n    index += 1;\n    previous = index ? children.get(index - 1) : null;\n    child = children.get(index);\n    next = children.get(index + 1);\n    if (!child) return false;\n    lastCount = count;\n    count += 1;\n    return true;\n  }\n\n  function rewind() {\n    if (index > 0) {\n      index -= 1;\n      count = lastCount;\n    }\n  }\n\n  if (rule.nodes != null) {\n    nextDef();\n  }\n\n  while (nextChild()) {\n    var err = validateParent(node, child, rules) || validatePrevious(node, child, previous, index, rules) || validateNext(node, child, next, index, rules);\n\n    if (err) return err;\n\n    if (rule.nodes != null) {\n      if (!def) {\n        return fail('child_unknown', { rule: rule, node: node, child: child, index: index });\n      }\n\n      if (def.match) {\n        var error = validateRules(child, def.match);\n\n        if (error) {\n          // Since we want to report overflow on last matching child we don't\n          // immediately check for count > max, but instead do so once we find\n          // a child that doesn't match.\n          if (max != null && count - 1 > max) {\n            rewind();\n            return fail('child_max_invalid', {\n              rule: rule,\n              node: node,\n              index: index,\n              child: children.get(index),\n              count: count,\n              limit: max\n            });\n          }\n\n          var lastMin = min;\n\n          // If there are more groups after this one then child might actually\n          // be valid.\n          if (nextDef()) {\n            // If we've already satisfied the minimum for the current group,\n            // then we can rewind and proceed to the next group.\n            if (lastCount - 1 >= lastMin) {\n              index -= 1;\n              continue;\n            }\n\n            // Otherwise we know that current value is underflowing. There are\n            // three possible causes for this...\n\n            // 1. There might just not be enough elements for current group, and\n            // current child is in fact the first of the next group. If so, the\n            // next def will not report errors, in which case we can rewind and\n            // report an minimum error.\n            if (validateRules(child, def.match) == null) {\n              rewind();\n              return fail('child_min_invalid', {\n                rule: rule,\n                node: node,\n                index: index,\n                count: lastCount - 1,\n                limit: lastMin\n              });\n            }\n\n            // 2. The current group is underflowing, but there is also an\n            // invalid child before the next group.\n            // 3. Or the current group is not underflowing but it appears so\n            // because there's an invalid child between its members.\n            // It's either the second or third case. If it's the second then\n            // we could report an underflow, but presence of an invalid child\n            // is arguably more important, so we report it first. It also lets\n            // us avoid checking for which case exactly is it.\n            error.rule = rule;\n            error.node = node;\n            error.child = child;\n            error.index = index;\n            error.code = error.code.replace('node_', 'child_');\n            return error;\n          }\n\n          // Otherwise either we exhausted the last group, in which case it's\n          // an unknown child, ...\n          if (max != null && count > max) {\n            return fail('child_unknown', { rule: rule, node: node, child: child, index: index });\n          }\n\n          // ... or it's an invalid child for the last group.\n          error.rule = rule;\n          error.node = node;\n          error.child = child;\n          error.index = index;\n          error.code = error.code.replace('node_', 'child_');\n          return error;\n        }\n      }\n    }\n  }\n\n  // Since we want to report overflow on last matching child we don't\n  // immediately check for count > max, but do so after processing all nodes.\n  if (max != null && count > max) {\n    return fail('child_max_invalid', {\n      rule: rule,\n      node: node,\n      index: index - 1,\n      count: count,\n      child: children.get(index - 1),\n      limit: max\n    });\n  }\n\n  if (rule.nodes != null) {\n    do {\n      if (count < min) {\n        return fail('child_min_invalid', {\n          rule: rule,\n          node: node,\n          index: index,\n          count: count,\n          limit: min\n        });\n      }\n    } while (nextDef());\n  }\n}\n\nfunction validateParent(node, child, rules) {\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = rules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var rule = _step3.value;\n\n      if (rule.parent == null) continue;\n      if (!testRules(child, rule.match)) continue;\n\n      var error = validateRules(node, rule.parent);\n      if (!error) continue;\n\n      error.rule = rule;\n      error.parent = node;\n      error.node = child;\n      error.code = error.code.replace('node_', 'parent_');\n      return error;\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n}\n\nfunction validatePrevious(node, child, previous, index, rules) {\n  if (!previous) return;\n\n  var _iteratorNormalCompletion4 = true;\n  var _didIteratorError4 = false;\n  var _iteratorError4 = undefined;\n\n  try {\n    for (var _iterator4 = rules[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n      var rule = _step4.value;\n\n      if (rule.previous == null) continue;\n      if (!testRules(child, rule.match)) continue;\n\n      var error = validateRules(previous, rule.previous);\n      if (!error) continue;\n\n      error.rule = rule;\n      error.node = node;\n      error.child = child;\n      error.index = index;\n      error.previous = previous;\n      error.code = error.code.replace('node_', 'previous_sibling_');\n      return error;\n    }\n  } catch (err) {\n    _didIteratorError4 = true;\n    _iteratorError4 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion4 && _iterator4.return) {\n        _iterator4.return();\n      }\n    } finally {\n      if (_didIteratorError4) {\n        throw _iteratorError4;\n      }\n    }\n  }\n}\n\nfunction validateNext(node, child, next, index, rules) {\n  if (!next) return;\n\n  var _iteratorNormalCompletion5 = true;\n  var _didIteratorError5 = false;\n  var _iteratorError5 = undefined;\n\n  try {\n    for (var _iterator5 = rules[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n      var rule = _step5.value;\n\n      if (rule.next == null) continue;\n      if (!testRules(child, rule.match)) continue;\n\n      var error = validateRules(next, rule.next, [], { match: child });\n      if (!error) continue;\n\n      error.rule = rule;\n      error.node = node;\n      error.child = child;\n      error.index = index;\n      error.next = next;\n      error.code = error.code.replace('node_', 'next_sibling_');\n      return error;\n    }\n  } catch (err) {\n    _didIteratorError5 = true;\n    _iteratorError5 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion5 && _iterator5.return) {\n        _iterator5.return();\n      }\n    } finally {\n      if (_didIteratorError5) {\n        throw _iteratorError5;\n      }\n    }\n  }\n}\n\n/**\n * Create an interim failure object with `code` and `attrs`.\n *\n * @param {String} code\n * @param {Object} attrs\n * @return {Object}\n */\n\nfunction fail(code, attrs) {\n  return _extends({ code: code }, attrs);\n}\n\n/**\n * Ensure that an expanded selection is deleted first using the `editor.delete`\n * command. This guarantees that it uses the proper semantic \"intent\" instead of\n * using `deleteAtRange` under the covers and skipping `delete`.\n *\n * @param {Editor}\n */\n\nfunction deleteExpanded(editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n\n  if (selection.isExpanded) {\n    editor.delete();\n  }\n}\n\n/**\n * Commands.\n *\n * @type {Object}\n */\n\nvar Commands$6 = {};\n\n/**\n * Add a `mark` to the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Mark} mark\n */\n\nCommands$6.addMark = function (editor, mark) {\n  mark = Mark.create(mark);\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n\n\n  if (selection.isExpanded) {\n    editor.addMarkAtRange(selection, mark);\n  } else if (selection.marks) {\n    var marks = selection.marks.add(mark);\n    var sel = selection.set('marks', marks);\n    editor.select(sel);\n  } else {\n    var _marks = document.getActiveMarksAtRange(selection).add(mark);\n    var _sel = selection.set('marks', _marks);\n    editor.select(_sel);\n  }\n};\n\n/**\n * Add a list of `marks` to the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Set<Mark>|Array<Object>} marks\n */\n\nCommands$6.addMarks = function (editor, marks) {\n  marks.forEach(function (mark) {\n    return editor.addMark(mark);\n  });\n};\n\n/**\n * Delete at the current selection.\n *\n * @param {Editor} editor\n */\n\nCommands$6.delete = function (editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n  editor.deleteAtRange(selection);\n\n  // COMPAT: Ensure that the selection is collapsed, because in certain cases\n  // when deleting across inline nodes, when splitting the inline node the end\n  // point of the selection will end up after the split point.\n  editor.moveToFocus();\n};\n\n/**\n * Delete backward `n` characters.\n *\n * @param {Editor} editor\n * @param {Number} n (optional)\n */\n\nCommands$6.deleteBackward = function (editor) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var value = editor.value;\n  var selection = value.selection;\n\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteBackwardAtRange(selection, n);\n  }\n};\n\n/**\n * Delete backward one character.\n *\n * @param {Editor} editor\n */\n\nCommands$6.deleteCharBackward = function (editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteCharBackwardAtRange(selection);\n  }\n};\n\n/**\n * Delete backward one line.\n *\n * @param {Editor} editor\n */\n\nCommands$6.deleteLineBackward = function (editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteLineBackwardAtRange(selection);\n  }\n};\n\n/**\n * Delete backward one word.\n *\n * @param {Editor} editor\n */\n\nCommands$6.deleteWordBackward = function (editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteWordBackwardAtRange(selection);\n  }\n};\n\n/**\n * Delete backward `n` characters.\n *\n * @param {Editor} editor\n * @param {Number} n (optional)\n */\n\nCommands$6.deleteForward = function (editor) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var value = editor.value;\n  var selection = value.selection;\n\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteForwardAtRange(selection, n);\n  }\n};\n\n/**\n * Delete backward one character.\n *\n * @param {Editor} editor\n */\n\nCommands$6.deleteCharForward = function (editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteCharForwardAtRange(selection);\n  }\n};\n\n/**\n * Delete backward one line.\n *\n * @param {Editor} editor\n */\n\nCommands$6.deleteLineForward = function (editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteLineForwardAtRange(selection);\n  }\n};\n\n/**\n * Delete backward one word.\n *\n * @param {Editor} editor\n */\n\nCommands$6.deleteWordForward = function (editor) {\n  var value = editor.value;\n  var selection = value.selection;\n\n\n  if (selection.isExpanded) {\n    editor.delete();\n  } else {\n    editor.deleteWordForwardAtRange(selection);\n  }\n};\n\n/**\n * Insert a `block` at the current selection.\n *\n * @param {Editor} editor\n * @param {String|Object|Block} block\n */\n\nCommands$6.insertBlock = function (editor, block) {\n  deleteExpanded(editor);\n\n  block = Block.create(block);\n  var value = editor.value;\n  var selection = value.selection;\n\n  editor.insertBlockAtRange(selection, block);\n\n  // If the node was successfully inserted, update the selection.\n  var node = editor.value.document.getNode(block.key);\n  if (node) editor.moveToEndOfNode(node);\n};\n\n/**\n * Insert a `fragment` at the current selection.\n *\n * @param {Editor} editor\n * @param {Document} fragment\n */\n\nCommands$6.insertFragment = function (editor, fragment) {\n  if (!fragment.nodes.size) return;\n\n  deleteExpanded(editor);\n\n  var value = editor.value;\n  var _value = value,\n      document = _value.document,\n      selection = _value.selection;\n  var start = selection.start;\n\n  var keys = Array.from(document.texts(), function (_ref) {\n    var _ref2 = slicedToArray(_ref, 1),\n        text = _ref2[0];\n\n    return text.key;\n  });\n\n  editor.insertFragmentAtRange(selection, fragment);\n  value = editor.value;\n  document = value.document;\n\n  var newTexts = document.getTexts().filter(function (n) {\n    return !keys.includes(n.key);\n  });\n  if (newTexts.size === 0) return;\n  var fragmentLength = fragment.text.length;\n\n  // Either startText is still here, or we want the first un-previously known text\n  var startText = document.getNode(start.key) || newTexts.first();\n  // We want the last un-previously known text\n  var endText = newTexts.last() || startText;\n\n  if (startText === endText) {\n    editor.moveTo(endText.key, fragmentLength);\n    return;\n  }\n\n  // Everything will be calculated relative to the first common ancestor to optimize speed\n  var parent = document.getCommonAncestor(startText.key, endText.key);\n\n  var startOffset = parent.getOffset(startText.key) + (start.key === startText.key ? start.offset : 0);\n\n  // endText might not be the last un-previously known text node, so we precisely pick it by offset\n  endText = parent.getTextAtOffset(startOffset + fragmentLength - 1) || endText;\n\n  editor.moveTo(endText.key, startOffset + fragmentLength - parent.getOffset(endText.key));\n};\n\n/**\n * Insert an `inline` at the current selection.\n *\n * @param {Editor} editor\n * @param {String|Object|Inline} inline\n */\n\nCommands$6.insertInline = function (editor, inline) {\n  deleteExpanded(editor);\n\n  inline = Inline.create(inline);\n  var value = editor.value;\n  var selection = value.selection;\n\n  editor.insertInlineAtRange(selection, inline);\n\n  // If the node was successfully inserted, update the selection.\n  var node = editor.value.document.getNode(inline.key);\n  if (node) editor.moveToEndOfNode(node);\n};\n\n/**\n * Insert a string of `text` with optional `marks` at the current selection.\n *\n * @param {Editor} editor\n * @param {String} text\n * @param {Set<Mark>} marks (optional)\n */\n\nCommands$6.insertText = function (editor, text, marks) {\n  deleteExpanded(editor);\n\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n\n  marks = marks || selection.marks || document.getInsertMarksAtRange(selection);\n\n  editor.withoutNormalizing(function () {\n    editor.insertTextAtRange(selection, text, marks);\n\n    // If the text was successfully inserted, and the selection had marks on it,\n    // unset the selection's marks.\n    if (selection.marks && document !== editor.value.document) {\n      editor.select({ marks: null });\n    }\n  });\n};\n\n/**\n * Remove a `mark` from the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Mark} mark\n */\n\nCommands$6.removeMark = function (editor, mark) {\n  mark = Mark.create(mark);\n  var value = editor.value;\n  var document = value.document,\n      selection = value.selection;\n\n\n  if (selection.isExpanded) {\n    editor.removeMarkAtRange(selection, mark);\n  } else if (selection.marks) {\n    var marks = selection.marks.remove(mark);\n    var sel = selection.set('marks', marks);\n    editor.select(sel);\n  } else {\n    var _marks2 = document.getActiveMarksAtRange(selection).remove(mark);\n    var _sel2 = selection.set('marks', _marks2);\n    editor.select(_sel2);\n  }\n};\n\n/**\n * Replace an `oldMark` with a `newMark` in the characters in the current selection.\n *\n * @param {Editor} editor\n * @param {Mark} oldMark\n * @param {Mark} newMark\n */\n\nCommands$6.replaceMark = function (editor, oldMark, newMark) {\n  editor.removeMark(oldMark);\n  editor.addMark(newMark);\n};\n\n/**\n * Set the `properties` of block nodes.\n *\n * @param {Editor} editor\n * @param {Object|String} properties\n */\n\nCommands$6.setBlocks = function (editor, properties) {\n  var value = editor.value;\n  var selection = value.selection;\n\n  editor.setBlocksAtRange(selection, properties);\n};\n\n/**\n * Set the `properties` of inline nodes.\n *\n * @param {Editor} editor\n * @param {Object|String} properties\n */\n\nCommands$6.setInlines = function (editor, properties) {\n  var value = editor.value;\n  var selection = value.selection;\n\n  editor.setInlinesAtRange(selection, properties);\n};\n\n/**\n * Split the block node at the current selection, to optional `depth`.\n *\n * @param {Editor} editor\n * @param {Number} depth (optional)\n */\n\nCommands$6.splitBlock = function (editor) {\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n  deleteExpanded(editor);\n\n  var value = editor.value;\n  var selection = value.selection,\n      document = value.document;\n\n  var marks = selection.marks || document.getInsertMarksAtRange(selection);\n  editor.splitBlockAtRange(selection, depth).moveToEnd();\n\n  if (marks && marks.size !== 0) {\n    editor.select({ marks: marks });\n  }\n};\n\n/**\n * Split the inline nodes to optional `height`.\n *\n * @param {Editor} editor\n * @param {Number} height (optional)\n */\n\nCommands$6.splitInline = function (editor, height) {\n  deleteExpanded(editor);\n  var value = editor.value;\n  var selection = value.selection;\n\n  editor.splitInlineAtRange(selection, height);\n};\n\n/**\n * Add or remove a `mark` from the characters in the current selection,\n * depending on whether it's already there.\n *\n * @param {Editor} editor\n * @param {Mark} mark\n */\n\nCommands$6.toggleMark = function (editor, mark) {\n  mark = Mark.create(mark);\n  var value = editor.value;\n\n  var exists = value.activeMarks.has(mark);\n\n  if (exists) {\n    editor.removeMark(mark);\n  } else {\n    editor.addMark(mark);\n  }\n};\n\n/**\n * Unwrap nodes from a block with `properties`.\n *\n * @param {Editor} editor\n * @param {String|Object} properties\n */\n\nCommands$6.unwrapBlock = function (editor, properties) {\n  var value = editor.value;\n  var selection = value.selection;\n\n  editor.unwrapBlockAtRange(selection, properties);\n};\n\n/**\n * Unwrap nodes from an inline with `properties`.\n *\n * @param {Editor} editor\n * @param {String|Object} properties\n */\n\nCommands$6.unwrapInline = function (editor, properties) {\n  var value = editor.value;\n  var selection = value.selection;\n\n  editor.unwrapInlineAtRange(selection, properties);\n};\n\n/**\n * Wrap nodes in a new `block`.\n *\n * @param {Editor} editor\n * @param {Block|Object|String} block\n */\n\nCommands$6.wrapBlock = function (editor, block) {\n  var value = editor.value;\n  var selection = value.selection;\n\n  editor.wrapBlockAtRange(selection, block);\n};\n\n/**\n * Wrap nodes in a new `inline`.\n *\n * @param {Editor} editor\n * @param {Inline|Object|String} inline\n */\n\nCommands$6.wrapInline = function (editor, inline) {\n  var value = editor.value;\n  var selection = value.selection;\n\n  editor.wrapInlineAtRange(selection, inline);\n};\n\n/**\n * Wrap the current selection with prefix/suffix.\n *\n * @param {Editor} editor\n * @param {String} prefix\n * @param {String} suffix\n */\n\nCommands$6.wrapText = function (editor, prefix) {\n  var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : prefix;\n  var value = editor.value;\n  var selection = value.selection;\n\n  editor.wrapTextAtRange(selection, prefix, suffix);\n\n  // If the selection was collapsed, it will have moved the start offset too.\n  if (selection.isCollapsed) {\n    editor.moveStartBackward(prefix.length);\n  }\n\n  // Adding the suffix will have pushed the end of the selection further on, so\n  // we need to move it back to account for this.\n  editor.moveEndBackward(suffix.length);\n\n  // There's a chance that the selection points moved \"through\" each other,\n  // resulting in a now-incorrect selection direction.\n  if (selection.isForward !== editor.value.selection.isForward) {\n    editor.flip();\n  }\n};\n\n/**\n * A plugin that defines the core Slate logic.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction CorePlugin() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _options$plugins = options.plugins,\n      plugins = _options$plugins === undefined ? [] : _options$plugins;\n\n  /**\n   * The core Slate commands.\n   *\n   * @type {Object}\n   */\n\n  var commands = CommandsPlugin(_extends({}, Commands$1, Commands$2, Commands$3, Commands$4, Commands$5, Commands$6));\n\n  /**\n   * The core Slate queries.\n   *\n   * @type {Object}\n   */\n\n  var queries = QueriesPlugin({\n    isAtomic: function isAtomic() {\n      return false;\n    },\n    isVoid: function isVoid() {\n      return false;\n    }\n  });\n\n  /**\n   * The core Slate schema.\n   *\n   * @type {Object}\n   */\n\n  var schema = SchemaPlugin({\n    rules: [\n    // Only allow block nodes in documents.\n    {\n      match: { object: 'document' },\n      nodes: [{\n        match: { object: 'block' }\n      }]\n    },\n\n    // Only allow block nodes or inline and text nodes in blocks.\n    {\n      match: {\n        object: 'block',\n        first: { object: 'block' }\n      },\n      nodes: [{\n        match: { object: 'block' }\n      }]\n    }, {\n      match: {\n        object: 'block',\n        first: [{ object: 'inline' }, { object: 'text' }]\n      },\n      nodes: [{\n        match: [{ object: 'inline' }, { object: 'text' }]\n      }]\n    },\n\n    // Only allow inline and text nodes in inlines.\n    {\n      match: { object: 'inline' },\n      nodes: [{ match: [{ object: 'inline' }, { object: 'text' }] }]\n    },\n\n    // Ensure that block and inline nodes have at least one text child.\n    {\n      match: [{ object: 'block' }, { object: 'inline' }],\n      nodes: [{ min: 1 }],\n      normalize: function normalize(editor, error) {\n        var code = error.code,\n            node = error.node;\n\n\n        if (code === 'child_min_invalid' && node.nodes.isEmpty()) {\n          editor.insertNodeByKey(node.key, 0, Text.create());\n        }\n      }\n    },\n\n    // Ensure that inline nodes are surrounded by text nodes.\n    {\n      match: { object: 'block' },\n      first: [{ object: 'block' }, { object: 'text' }],\n      last: [{ object: 'block' }, { object: 'text' }],\n      normalize: function normalize(editor, error) {\n        var code = error.code,\n            node = error.node;\n\n        var text = Text.create();\n        var i = void 0;\n\n        if (code === 'first_child_object_invalid') {\n          i = 0;\n        } else if (code === 'last_child_object_invalid') {\n          i = node.nodes.size;\n        } else {\n          return;\n        }\n\n        editor.insertNodeByKey(node.key, i, text);\n      }\n    }, {\n      match: { object: 'inline' },\n      first: [{ object: 'block' }, { object: 'text' }],\n      last: [{ object: 'block' }, { object: 'text' }],\n      previous: [{ object: 'block' }, { object: 'text' }],\n      next: [{ object: 'block' }, { object: 'text' }],\n      normalize: function normalize(editor, error) {\n        var code = error.code,\n            node = error.node,\n            index = error.index;\n\n        var text = Text.create();\n        var i = void 0;\n\n        if (code === 'first_child_object_invalid') {\n          i = 0;\n        } else if (code === 'last_child_object_invalid') {\n          i = node.nodes.size;\n        } else if (code === 'previous_sibling_object_invalid') {\n          i = index;\n        } else if (code === 'next_sibling_object_invalid') {\n          i = index + 1;\n        } else {\n          return;\n        }\n\n        editor.insertNodeByKey(node.key, i, text);\n      }\n    },\n\n    // Merge adjacent text nodes with the same marks.\n    {\n      match: { object: 'text' },\n      next: function next(_next, match) {\n        return _next.object !== 'text' || !match.marks.equals(_next.marks);\n      },\n      normalize: function normalize(editor, error) {\n        var code = error.code,\n            next = error.next;\n\n\n        if (code === 'next_sibling_invalid') {\n          editor.mergeNodeByKey(next.key);\n        }\n      }\n    },\n\n    // Remove extra adjacent empty text nodes.\n    {\n      match: { object: 'text' },\n      previous: function previous(prev) {\n        return prev.object !== 'text' || prev.text !== '';\n      },\n      next: function next(_next2) {\n        return _next2.object !== 'text' || _next2.text !== '';\n      },\n      normalize: function normalize(editor, error) {\n        var code = error.code,\n            next = error.next,\n            previous = error.previous;\n\n\n        if (code === 'next_sibling_invalid') {\n          editor.removeNodeByKey(next.key);\n        } else if (code === 'previous_sibling_invalid') {\n          editor.removeNodeByKey(previous.key);\n        }\n      }\n    }]\n  });\n\n  /**\n   * Return the plugins.\n   *\n   * @type {Array}\n   */\n\n  return [schema].concat(toConsumableArray(plugins), [commands, queries]);\n}\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug$2 = Debug('slate:editor');\n\n/**\n * Editor.\n *\n * @type {Editor}\n */\n\nvar Editor = function () {\n  /**\n   * Create a new `Editor` with `attrs`.\n   *\n   * @param {Object} attrs\n   * @param {Object} options\n   */\n\n  function Editor() {\n    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    classCallCheck(this, Editor);\n    var _options$controller = options.controller,\n        controller = _options$controller === undefined ? this : _options$controller,\n        _options$construct = options.construct,\n        construct = _options$construct === undefined ? true : _options$construct;\n    var _attrs$onChange = attrs.onChange,\n        onChange = _attrs$onChange === undefined ? function () {} : _attrs$onChange,\n        _attrs$plugins = attrs.plugins,\n        plugins = _attrs$plugins === undefined ? [] : _attrs$plugins,\n        _attrs$readOnly = attrs.readOnly,\n        readOnly = _attrs$readOnly === undefined ? false : _attrs$readOnly,\n        _attrs$value = attrs.value,\n        value = _attrs$value === undefined ? Value.create() : _attrs$value;\n\n\n    this.controller = controller;\n    this.middleware = {};\n    this.onChange = onChange;\n    this.operations = immutable.List();\n    this.readOnly = null;\n    this.value = null;\n\n    this.tmp = {\n      dirty: [],\n      flushing: false,\n      merge: null,\n      normalize: true,\n      save: true\n    };\n\n    var core = CorePlugin({ plugins: plugins });\n    registerPlugin(this, core);\n\n    if (construct) {\n      this.run('onConstruct');\n      this.setReadOnly(readOnly);\n      this.setValue(value, options);\n    }\n  }\n\n  /**\n   * Apply an `operation` to the editor, updating its value.\n   *\n   * @param {Operation|Object} operation\n   * @return {Editor}\n   */\n\n  createClass(Editor, [{\n    key: 'applyOperation',\n    value: function applyOperation(operation) {\n      var _this = this;\n\n      var operations = this.operations,\n          controller = this.controller;\n\n      var value = this.value;\n\n      // Add in the current `value` in case the operation was serialized.\n      if (isPlainObject(operation)) {\n        operation = _extends({}, operation, { value: value });\n      }\n\n      operation = Operation.create(operation);\n\n      // Save the operation into the history. Since `save` is a command, we need\n      // to do it without normalizing, since it would have side effects.\n      this.withoutNormalizing(function () {\n        controller.save(operation);\n        value = _this.value;\n      });\n\n      // Apply the operation to the value.\n      debug$2('apply', { operation: operation });\n      this.value = operation.apply(value);\n      this.operations = operations.push(operation);\n\n      // Get the paths of the affected nodes, and mark them as dirty.\n      var newDirtyPaths = getDirtyPaths(operation);\n\n      var dirty = this.tmp.dirty.map(function (path) {\n        path = PathUtils.create(path);\n        var transformed = PathUtils.transform(path, operation);\n        return transformed.toArray();\n      });\n\n      var pathIndex = {};\n      var dirtyPaths = Array.prototype.concat.apply(newDirtyPaths, dirty);\n      this.tmp.dirty = [];\n\n      // PERF: De-dupe the paths so we don't do extra normalization.\n      dirtyPaths.forEach(function (dirtyPath) {\n        var key = dirtyPath.join(',');\n\n        if (!pathIndex[key]) {\n          _this.tmp.dirty.push(dirtyPath);\n        }\n\n        pathIndex[key] = true;\n      });\n\n      // If we're not already, queue the flushing process on the next tick.\n      if (!this.tmp.flushing) {\n        this.tmp.flushing = true;\n        Promise.resolve().then(function () {\n          return _this.flush();\n        });\n      }\n\n      return controller;\n    }\n\n    /**\n     * Flush the editor's current change.\n     *\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'flush',\n    value: function flush() {\n      this.run('onChange');\n      var value = this.value,\n          operations = this.operations,\n          controller = this.controller;\n\n      var change = { value: value, operations: operations };\n      this.operations = immutable.List();\n      this.tmp.flushing = false;\n      this.onChange(change);\n      return controller;\n    }\n\n    /**\n     * Trigger a command by `type` with `...args`.\n     *\n     * @param {String|Function} type\n     * @param {Any} ...args\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'command',\n    value: function command(type) {\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      var controller = this.controller;\n\n\n      if (typeof type === 'function') {\n        type.apply(undefined, [controller].concat(args));\n        normalizeDirtyPaths(this);\n        return controller;\n      }\n\n      debug$2('command', { type: type, args: args });\n      var obj = { type: type, args: args };\n      this.run('onCommand', obj);\n      normalizeDirtyPaths(this);\n      return controller;\n    }\n\n    /**\n     * Checks if a command by `type` has been registered.\n     *\n     * @param {String} type\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasCommand',\n    value: function hasCommand(type) {\n      var controller = this.controller;\n\n      var has = type in controller && controller[type].__command;\n\n      return has;\n    }\n\n    /**\n     * Checks if a query by `type` has been registered.\n     *\n     * @param {String} type\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasQuery',\n    value: function hasQuery(type) {\n      var controller = this.controller;\n\n      var has = type in controller && controller[type].__query;\n\n      return has;\n    }\n\n    /**\n     * Normalize all of the nodes in the document from scratch.\n     *\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize() {\n      var value = this.value,\n          controller = this.controller;\n      var document = value.document;\n\n      var table = document.getKeysToPathsTable();\n      var paths = Object.values(table).map(PathUtils.create);\n      this.tmp.dirty = this.tmp.dirty.concat(paths);\n      normalizeDirtyPaths(this);\n\n      var selection = value.selection;\n\n      document = value.document;\n\n      if (selection.isUnset && document.nodes.size) {\n        controller.moveToStartOfDocument();\n      }\n\n      return controller;\n    }\n\n    /**\n     * Ask a query by `type` with `...args`.\n     *\n     * @param {String|Function} type\n     * @param {Any} ...args\n     * @return {Any}\n     */\n\n  }, {\n    key: 'query',\n    value: function query(type) {\n      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      var controller = this.controller;\n\n\n      if (typeof type === 'function') {\n        return type.apply(undefined, [controller].concat(args));\n      }\n\n      debug$2('query', { type: type, args: args });\n      var obj = { type: type, args: args };\n      return this.run('onQuery', obj);\n    }\n\n    /**\n     * Register a command `type` with the editor.\n     *\n     * @param {String} type\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'registerCommand',\n    value: function registerCommand(type) {\n      var _this2 = this;\n\n      var controller = this.controller;\n\n\n      if (type in controller && controller[type].__command) {\n        return controller;\n      }\n\n      invariant(!(type in controller), 'You cannot register a `' + type + '` command because it would overwrite an existing property of the `Editor`.');\n\n      var method = function method() {\n        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n          args[_key3] = arguments[_key3];\n        }\n\n        return _this2.command.apply(_this2, [type].concat(args));\n      };\n      controller[type] = method;\n      method.__command = true;\n      return controller;\n    }\n\n    /**\n     * Register a query `type` with the editor.\n     *\n     * @param {String} type\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'registerQuery',\n    value: function registerQuery(type) {\n      var _this3 = this;\n\n      var controller = this.controller;\n\n\n      if (type in controller && controller[type].__query) {\n        return controller;\n      }\n\n      invariant(!(type in controller), 'You cannot register a `' + type + '` query because it would overwrite an existing property of the `Editor`.');\n\n      var method = function method() {\n        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n          args[_key4] = arguments[_key4];\n        }\n\n        return _this3.query.apply(_this3, [type].concat(args));\n      };\n      controller[type] = method;\n      method.__query = true;\n      return controller;\n    }\n\n    /**\n     * Run through the middleware stack by `key` with `args`.\n     *\n     * @param {String} key\n     * @param {Any} ...args\n     * @return {Any}\n     */\n\n  }, {\n    key: 'run',\n    value: function run(key) {\n      for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\n        args[_key5 - 1] = arguments[_key5];\n      }\n\n      var controller = this.controller,\n          middleware = this.middleware;\n\n      var fns = middleware[key] || [];\n      var i = 0;\n\n      function next() {\n        var fn = fns[i++];\n        if (!fn) return;\n\n        for (var _len6 = arguments.length, overrides = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n          overrides[_key6] = arguments[_key6];\n        }\n\n        if (overrides.length) {\n          args = overrides;\n        }\n\n        var ret = fn.apply(undefined, toConsumableArray(args).concat([controller, next]));\n        return ret;\n      }\n\n      Object.defineProperty(next, 'change', {\n        get: function get$$1() {\n          invariant(false, 'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.');\n        }\n      });\n\n      Object.defineProperty(next, 'onChange', {\n        get: function get$$1() {\n          invariant(false, 'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.');\n        }\n      });\n\n      Object.defineProperty(next, 'props', {\n        get: function get$$1() {\n          invariant(false, 'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.');\n        }\n      });\n\n      Object.defineProperty(next, 'schema', {\n        get: function get$$1() {\n          invariant(false, 'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.');\n        }\n      });\n\n      Object.defineProperty(next, 'stack', {\n        get: function get$$1() {\n          invariant(false, 'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.');\n        }\n      });\n\n      return next();\n    }\n\n    /**\n     * Set the `readOnly` flag.\n     *\n     * @param {Boolean} readOnly\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'setReadOnly',\n    value: function setReadOnly(readOnly) {\n      this.readOnly = readOnly;\n      return this;\n    }\n\n    /**\n     * Set the editor's `value`.\n     *\n     * @param {Value} value\n     * @param {Options} options\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'setValue',\n    value: function setValue(value) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _options$normalize = options.normalize,\n          normalize = _options$normalize === undefined ? value !== this.value : _options$normalize;\n\n      this.value = value;\n\n      if (normalize) {\n        this.normalize();\n      }\n\n      return this;\n    }\n\n    /**\n     * Apply a series of changes inside a synchronous `fn`, deferring\n     * normalization until after the function has finished executing.\n     *\n     * @param {Function} fn\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'withoutNormalizing',\n    value: function withoutNormalizing(fn) {\n      var controller = this.controller;\n\n      var value = this.tmp.normalize;\n      this.tmp.normalize = false;\n      fn(controller);\n      this.tmp.normalize = value;\n      normalizeDirtyPaths(this);\n      return controller;\n    }\n\n    /**\n     * Deprecated.\n     */\n\n  }, {\n    key: 'change',\n    value: function change(fn) {\n      warning(false, 'As of Slate 0.43 the `change` object has been replaced with `editor`, so the `editor.change()` method is deprecated.`');\n\n      for (var _len7 = arguments.length, args = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\n        args[_key7 - 1] = arguments[_key7];\n      }\n\n      fn.apply(undefined, [this.controller].concat(args));\n    }\n  }, {\n    key: 'call',\n    value: function call(fn) {\n      warning(false, 'As of Slate 0.43 the `editor.call(fn)` method has been deprecated, please use `editor.command(fn)` instead.');\n\n      for (var _len8 = arguments.length, args = Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\n        args[_key8 - 1] = arguments[_key8];\n      }\n\n      fn.apply(undefined, [this.controller].concat(args));\n      return this.controller;\n    }\n  }, {\n    key: 'applyOperations',\n    value: function applyOperations(operations) {\n      var _this4 = this;\n\n      warning(false, 'As of Slate 0.43 the `applyOperations` method is deprecated, please apply each operation in a loop instead.');\n\n      operations.forEach(function (op) {\n        return _this4.applyOperation(op);\n      });\n      return this.controller;\n    }\n  }, {\n    key: 'setOperationFlag',\n    value: function setOperationFlag(key, value) {\n      warning(false, 'As of slate@0.41 the `change.setOperationFlag` method has been deprecated.');\n\n      this.tmp[key] = value;\n      return this;\n    }\n  }, {\n    key: 'getFlag',\n    value: function getFlag(key) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      warning(false, 'As of slate@0.41 the `change.getFlag` method has been deprecated.');\n\n      return options[key] !== undefined ? options[key] : this.tmp[key];\n    }\n  }, {\n    key: 'unsetOperationFlag',\n    value: function unsetOperationFlag(key) {\n      warning(false, 'As of slate@0.41 the `change.unsetOperationFlag` method has been deprecated.');\n\n      delete this.tmp[key];\n      return this;\n    }\n  }, {\n    key: 'withoutNormalization',\n    value: function withoutNormalization(fn) {\n      warning(false, 'As of slate@0.41 the `change.withoutNormalization` helper has been renamed to `change.withoutNormalizing`.');\n\n      return this.withoutNormalizing(fn);\n    }\n  }, {\n    key: 'editor',\n    get: function get$$1() {\n      warning(false, \"As of Slate 0.43 the `change` object has been replaced with `editor`, so you don't need to access `change.editor`.\");\n\n      return this.controller;\n    }\n  }]);\n  return Editor;\n}();\n\n/**\n * Get the \"dirty\" paths for a given `operation`.\n *\n * @param {Operation} operation\n * @return {Array}\n */\n\nfunction getDirtyPaths(operation) {\n  var type = operation.type,\n      node = operation.node,\n      path = operation.path,\n      newPath = operation.newPath;\n\n\n  switch (type) {\n    case 'add_mark':\n    case 'insert_text':\n    case 'remove_mark':\n    case 'remove_text':\n    case 'set_mark':\n    case 'set_node':\n      {\n        var ancestors = PathUtils.getAncestors(path).toArray();\n        return [].concat(toConsumableArray(ancestors), [path]);\n      }\n\n    case 'insert_node':\n      {\n        var table = node.getKeysToPathsTable();\n        var paths = Object.values(table).map(function (p) {\n          return path.concat(p);\n        });\n        var _ancestors = PathUtils.getAncestors(path).toArray();\n        return [].concat(toConsumableArray(_ancestors), [path], toConsumableArray(paths));\n      }\n\n    case 'split_node':\n      {\n        var _ancestors2 = PathUtils.getAncestors(path).toArray();\n        var nextPath = PathUtils.increment(path);\n        return [].concat(toConsumableArray(_ancestors2), [path, nextPath]);\n      }\n\n    case 'merge_node':\n      {\n        var _ancestors3 = PathUtils.getAncestors(path).toArray();\n        var previousPath = PathUtils.decrement(path);\n        return [].concat(toConsumableArray(_ancestors3), [previousPath]);\n      }\n\n    case 'move_node':\n      {\n        if (PathUtils.isEqual(path, newPath)) {\n          return [];\n        }\n\n        var oldAncestors = PathUtils.getAncestors(path).reduce(function (arr, p) {\n          arr.push.apply(arr, toConsumableArray(PathUtils.transform(p, operation).toArray()));\n          return arr;\n        }, []);\n\n        var newAncestors = PathUtils.getAncestors(newPath).reduce(function (arr, p) {\n          arr.push.apply(arr, toConsumableArray(PathUtils.transform(p, operation).toArray()));\n          return arr;\n        }, []);\n\n        return [].concat(toConsumableArray(oldAncestors), toConsumableArray(newAncestors));\n      }\n\n    case 'remove_node':\n      {\n        var _ancestors4 = PathUtils.getAncestors(path).toArray();\n        return [].concat(toConsumableArray(_ancestors4));\n      }\n\n    default:\n      {\n        return [];\n      }\n  }\n}\n\n/**\n * Normalize any new \"dirty\" paths that have been added to the change.\n *\n * @param {Editor}\n */\n\nfunction normalizeDirtyPaths(editor) {\n  if (!editor.tmp.normalize) {\n    return;\n  }\n\n  if (!editor.tmp.dirty.length) {\n    return;\n  }\n\n  editor.withoutNormalizing(function () {\n    while (editor.tmp.dirty.length) {\n      var path = editor.tmp.dirty.pop();\n      normalizeNodeByPath(editor, path);\n    }\n  });\n}\n\n/**\n * Normalize the node at a specific `path`.\n *\n * @param {Editor} editor\n * @param {Array} path\n */\n\nfunction normalizeNodeByPath(editor, path) {\n  var controller = editor.controller;\n  var value = editor.value;\n  var _value = value,\n      document = _value.document;\n\n  var node = document.assertNode(path);\n  var iterations = 0;\n  var max = 100 + (node.object === 'text' ? 1 : node.nodes.size);\n\n  while (node) {\n    var fn = node.normalize(controller);\n\n    if (!fn) {\n      break;\n    }\n\n    // Run the normalize `fn` to fix the node.\n    fn(controller);\n\n    // Attempt to re-find the node by path, or by key if it has changed\n    // locations in the tree continue iterating.\n    value = editor.value;\n    document = value.document;\n    var _node = node,\n        key = _node.key;\n\n    var found = document.getDescendant(path);\n\n    if (found && found.key === key) {\n      node = found;\n    } else {\n      found = document.getDescendant(key);\n\n      if (found) {\n        node = found;\n        path = document.getPath(key);\n      } else {\n        // If it no longer exists by key, it was removed, so we're done.\n        break;\n      }\n    }\n\n    // Increment the iterations counter, and check to make sure that we haven't\n    // exceeded the max. Without this check, it's easy for the `normalize`\n    // function of a schema rule to be written incorrectly and for an infinite\n    // invalid loop to occur.\n    iterations++;\n\n    if (iterations > max) {\n      throw new Error('A schema rule could not be normalized after sufficient iterations. This is usually due to a `rule.normalize` or `plugin.normalizeNode` function of a schema being incorrectly written, causing an infinite loop.');\n    }\n  }\n}\n\n/**\n * Register a `plugin` with the editor.\n *\n * @param {Editor} editor\n * @param {Object|Array|Null} plugin\n */\n\nfunction registerPlugin(editor, plugin) {\n  if (Array.isArray(plugin)) {\n    plugin.forEach(function (p) {\n      return registerPlugin(editor, p);\n    });\n    return;\n  }\n\n  if (plugin == null) {\n    return;\n  }\n\n  var commands = plugin.commands,\n      queries = plugin.queries,\n      schema = plugin.schema,\n      rest = objectWithoutProperties(plugin, ['commands', 'queries', 'schema']);\n\n\n  if (commands) {\n    var commandsPlugin = CommandsPlugin(commands);\n    registerPlugin(editor, commandsPlugin);\n  }\n\n  if (queries) {\n    var queriesPlugin = QueriesPlugin(queries);\n    registerPlugin(editor, queriesPlugin);\n  }\n\n  if (schema) {\n    var schemaPlugin = SchemaPlugin(schema);\n    registerPlugin(editor, schemaPlugin);\n  }\n\n  for (var key in rest) {\n    var fn = rest[key];\n    var middleware = editor.middleware[key] = editor.middleware[key] || [];\n    middleware.push(fn);\n  }\n}\n\n/**\n * Default properties.\n *\n * @type {Object}\n */\n\nvar DEFAULTS$13 = {\n  marks: undefined,\n  text: undefined\n\n  /**\n   * Leaf.\n   *\n   * @type {Leaf}\n   */\n\n};\nvar Leaf$1 = function (_Record) {\n  inherits(Leaf, _Record);\n\n  function Leaf() {\n    classCallCheck(this, Leaf);\n    return possibleConstructorReturn(this, (Leaf.__proto__ || Object.getPrototypeOf(Leaf)).apply(this, arguments));\n  }\n\n  createClass(Leaf, [{\n    key: 'updateMark',\n\n\n    /**\n     * Update a `mark` at leaf, replace with newMark\n     *\n     * @param {Mark} mark\n     * @param {Mark} newMark\n     * @returns {Leaf}\n     */\n\n    value: function updateMark(mark, newMark) {\n      var marks = this.marks;\n\n      if (newMark.equals(mark)) return this;\n      if (!marks.has(mark)) return this;\n      var newMarks = marks.withMutations(function (collection) {\n        collection.remove(mark).add(newMark);\n      });\n      return this.set('marks', newMarks);\n    }\n\n    /**\n     * Add a `mark` to the leaf.\n     *\n     * @param {Mark} mark\n     * @returns {Text}\n     */\n\n  }, {\n    key: 'addMark',\n    value: function addMark(mark) {\n      var marks = this.marks;\n\n      return this.set('marks', marks.add(mark));\n    }\n\n    /**\n     * Add a `set` of marks to the leaf.\n     *\n     * @param {Set<Mark>} set\n     * @returns {Text}\n     */\n\n  }, {\n    key: 'addMarks',\n    value: function addMarks(set$$1) {\n      var marks = this.marks;\n\n      return this.set('marks', marks.union(set$$1));\n    }\n\n    /**\n     * Insert a text `string` into the leaf at `offset`.\n     *\n     * @param {Number} offset\n     * @param {String} string\n     * @return {Leaf}\n     */\n\n  }, {\n    key: 'insertText',\n    value: function insertText(offset, string) {\n      var text = this.text;\n\n      var next = text.slice(0, offset) + string + text.slice(offset);\n      return this.set('text', next);\n    }\n\n    /**\n     * Remove a `mark` from the leaf.\n     *\n     * @param {Mark} mark\n     * @returns {Text}\n     */\n\n  }, {\n    key: 'removeMark',\n    value: function removeMark(mark) {\n      var marks = this.marks;\n\n      return this.set('marks', marks.remove(mark));\n    }\n\n    /**\n     * Return a JSON representation of the leaf.\n     *\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var object = {\n        object: this.object,\n        text: this.text,\n        marks: this.marks.toArray().map(function (m) {\n          return m.toJSON();\n        })\n      };\n\n      return object;\n    }\n  }], [{\n    key: 'create',\n\n    /**\n     * Create a new `Leaf` with `attrs`.\n     *\n     * @param {Object|Leaf} attrs\n     * @return {Leaf}\n     */\n\n    value: function create() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      warning(false, 'As of slate@0.47 the `Leaf` model is deprecated.');\n\n      if (Leaf.isLeaf(attrs)) {\n        return attrs;\n      }\n\n      if (typeof attrs === 'string') {\n        attrs = { text: attrs };\n      }\n\n      if (isPlainObject(attrs)) {\n        return Leaf.fromJSON(attrs);\n      }\n\n      throw new Error('`Leaf.create` only accepts objects, strings or leaves, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a valid List of `Leaf` from `leaves`\n     *\n     * @param {List<Leaf>} leaves\n     * @return {List<Leaf>}\n     */\n\n  }, {\n    key: 'createLeaves',\n    value: function createLeaves(leaves) {\n      if (leaves.size <= 1) return leaves;\n\n      var invalid = false;\n\n      // TODO: we can make this faster with [List] and then flatten\n      var result = immutable.List().withMutations(function (cache) {\n        // Search from the leaves left end to find invalid node;\n        leaves.findLast(function (leaf, index) {\n          var firstLeaf = cache.first();\n\n          // If the first leaf of cache exist, check whether the first leaf is connectable with the current leaf\n          if (firstLeaf) {\n            // If marks equals, then the two leaves can be connected\n            if (firstLeaf.marks.equals(leaf.marks)) {\n              invalid = true;\n              cache.set(0, firstLeaf.set('text', '' + leaf.text + firstLeaf.text));\n              return;\n            }\n\n            // If the cached leaf is empty, drop the empty leaf with the upcoming leaf\n            if (firstLeaf.text === '') {\n              invalid = true;\n              cache.set(0, leaf);\n              return;\n            }\n\n            // If the current leaf is empty, drop the leaf\n            if (leaf.text === '') {\n              invalid = true;\n              return;\n            }\n          }\n\n          cache.unshift(leaf);\n        });\n      });\n\n      if (!invalid) return leaves;\n      return result;\n    }\n\n    /**\n     * Split a list of leaves to two lists; if the leaves are valid leaves, the returned leaves are also valid\n     * Corner Cases:\n     *   1. if offset is smaller than 0, then return [List(), leaves]\n     *   2. if offset is bigger than the text length, then return [leaves, List()]\n     *\n     * @param {List<Leaf> leaves\n     * @return {Array<List<Leaf>>}\n     */\n\n  }, {\n    key: 'splitLeaves',\n    value: function splitLeaves(leaves, offset) {\n      if (offset < 0) return [immutable.List(), leaves];\n\n      if (leaves.size === 0) {\n        return [immutable.List(), immutable.List()];\n      }\n\n      var endOffset = 0;\n      var index = -1;\n      var left = void 0,\n          right = void 0;\n\n      leaves.find(function (leaf) {\n        index++;\n        var startOffset = endOffset;\n        var text = leaf.text;\n\n        endOffset += text.length;\n\n        if (endOffset < offset) return false;\n        if (startOffset > offset) return false;\n\n        var length = offset - startOffset;\n        left = leaf.set('text', text.slice(0, length));\n        right = leaf.set('text', text.slice(length));\n        return true;\n      });\n\n      if (!left) return [leaves, immutable.List()];\n\n      if (left.text === '') {\n        if (index === 0) {\n          return [immutable.List.of(left), leaves];\n        }\n\n        return [leaves.take(index), leaves.skip(index)];\n      }\n\n      if (right.text === '') {\n        if (index === leaves.size - 1) {\n          return [leaves, immutable.List.of(right)];\n        }\n\n        return [leaves.take(index + 1), leaves.skip(index + 1)];\n      }\n\n      return [leaves.take(index).push(left), leaves.skip(index + 1).unshift(right)];\n    }\n\n    /**\n     * Create a `Leaf` list from `attrs`.\n     *\n     * @param {Array<Leaf|Object>|List<Leaf|Object>} attrs\n     * @return {List<Leaf>}\n     */\n\n  }, {\n    key: 'createList',\n    value: function createList() {\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n      if (immutable.List.isList(attrs) || Array.isArray(attrs)) {\n        var list = new immutable.List(attrs.map(Leaf.create));\n        return list;\n      }\n\n      throw new Error('`Leaf.createList` only accepts arrays or lists, but you passed it: ' + attrs);\n    }\n\n    /**\n     * Create a `Leaf` from a JSON `object`.\n     *\n     * @param {Object} object\n     * @return {Leaf}\n     */\n\n  }, {\n    key: 'fromJSON',\n    value: function fromJSON(object) {\n      var _object$text = object.text,\n          text = _object$text === undefined ? '' : _object$text,\n          _object$marks = object.marks,\n          marks = _object$marks === undefined ? [] : _object$marks;\n\n\n      var leaf = new Leaf({\n        text: text,\n        marks: immutable.Set(marks.map(Mark.fromJSON))\n      });\n\n      return leaf;\n    }\n\n    /**\n     * Check if `any` is a list of leaves.\n     *\n     * @param {Any} any\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isLeafList',\n    value: function isLeafList(any) {\n      return immutable.List.isList(any) && any.every(function (item) {\n        return Leaf.isLeaf(item);\n      });\n    }\n  }]);\n  return Leaf;\n}(immutable.Record(DEFAULTS$13));\n\n/**\n * Mix in an `Interface` to a `Class`.\n *\n * @param {Class} Interface\n * @param {Class} Class\n */\n\nfunction mixin(Interface, Classes) {\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = Classes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var Class = _step.value;\n\n      // Copy static properties from the interface.\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = Object.getOwnPropertyNames(Interface)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var name = _step2.value;\n\n          if (Class.hasOwnProperty(name)) continue;\n          var desc = Object.getOwnPropertyDescriptor(Interface, name);\n          Object.defineProperty(Class, name, desc);\n        }\n\n        // Copy instance properties from the interface.\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = Object.getOwnPropertyNames(Interface.prototype)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _name = _step3.value;\n\n          if (Class.prototype.hasOwnProperty(_name)) continue;\n          var desc = Object.getOwnPropertyDescriptor(Interface.prototype, _name);\n          Object.defineProperty(Class.prototype, _name, desc);\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n\n/**\n * A factory for the interface that all Slate objects implement.\n *\n * @type {Function}\n */\n\nfunction create$2(type) {\n  var TYPE = TYPES[type];\n  var camel = '' + type.charAt(0).toUpperCase() + type.slice(1);\n  var is = 'is' + camel;\n\n  var ObjectInterface = function () {\n    function ObjectInterface() {\n      classCallCheck(this, ObjectInterface);\n    }\n\n    createClass(ObjectInterface, [{\n      key: 'object',\n\n      /**\n       * Return the type of the object.\n       *\n       * @return {String}\n       */\n\n      get: function get$$1() {\n        return type;\n      }\n    }]);\n    return ObjectInterface;\n  }();\n\n  ObjectInterface[is] = isObject.bind(null, type);\n  ObjectInterface.prototype[TYPE] = true;\n  return ObjectInterface;\n}\n\n/**\n * Mix in the object interfaces.\n */\n\nObject.entries({\n  Annotation: Annotation,\n  Block: Block,\n  Change: Change,\n  Decoration: Decoration,\n  Document: Document,\n  Editor: Editor,\n  Inline: Inline,\n  Leaf: Leaf$1,\n  Mark: Mark,\n  Node: Node,\n  Operation: Operation,\n  Point: Point,\n  Range: Range,\n  Selection: Selection,\n  Text: Text,\n  Value: Value\n}).forEach(function (_ref) {\n  var _ref2 = slicedToArray(_ref, 2),\n      camel = _ref2[0],\n      obj = _ref2[1];\n\n  return mixin(create$2(camel.toLowerCase()), [obj]);\n});\n\n/**\n * The interface that all Slate models implement.\n *\n * @type {Class}\n */\n\nvar ModelInterface = function () {\n  function ModelInterface() {\n    classCallCheck(this, ModelInterface);\n  }\n\n  createClass(ModelInterface, [{\n    key: 'toJS',\n\n\n    /**\n     * Alias `toJS`.\n     */\n\n    value: function toJS() {\n      return this.toJSON.apply(this, arguments);\n    }\n  }], [{\n    key: 'fromJS',\n\n    /**\n     * Alias `fromJS`.\n     */\n\n    value: function fromJS() {\n      return this.fromJSON.apply(this, arguments);\n    }\n  }]);\n  return ModelInterface;\n}();\n\n/**\n * Mix in the common interface.\n *\n * @param {Record}\n */\n\nmixin(ModelInterface, [Annotation, Block, Decoration, Document, Inline, Leaf$1, Mark, Node, Operation, Point, Range, Selection, Text, Value]);\n\n/* global WeakMap, Map, Symbol */\n\n/**\n * GLOBAL: True if memoization should is enabled.\n *\n * @type {Boolean}\n */\n\nvar ENABLED = true;\n\n/**\n * The leaf node of a cache tree. Used to support variable argument length. A\n * unique object, so that native Maps will key it by reference.\n *\n * @type {Symbol}\n */\n\nvar LEAF = Symbol('LEAF');\n\n/**\n * The node of a cache tree for a WeakMap to store cache visited by objects\n *\n * @type {Symbol}\n */\n\nvar STORE_KEY = Symbol('STORE_KEY');\n\n/**\n * Values to represent a memoized undefined and null value. Allows efficient value\n * retrieval using Map.get only.\n *\n * @type {Symbol}\n */\n\nvar UNDEFINED = Symbol('undefined');\nvar NULL = Symbol('null');\n\n/**\n * Default value for unset keys in native Maps\n *\n * @type {Undefined}\n */\n\nvar UNSET = undefined;\n\n/**\n * Global Store for all cached values\n *\n * @type {WeakMap}\n */\n\nvar memoizeStore = new WeakMap();\n\n/**\n * Memoize all of the `properties` on a `object`.\n *\n * @param {Object} object\n * @param {Array} properties\n * @return {Record}\n */\n\nfunction memoize(object, properties) {\n  var _loop = function _loop(property) {\n    var original = object[property];\n\n    if (!original) {\n      throw new Error('Object does not have a property named \"' + property + '\".');\n    }\n\n    object[property] = function () {\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      // If memoization is disabled, call into the original method.\n      if (!ENABLED) return original.apply(this, args);\n\n      if (!memoizeStore.has(this)) {\n        memoizeStore.set(this, {\n          noArgs: {},\n          hasArgs: {}\n        });\n      }\n\n      var _memoizeStore$get = memoizeStore.get(this),\n          noArgs = _memoizeStore$get.noArgs,\n          hasArgs = _memoizeStore$get.hasArgs;\n\n      var takesArguments = args.length !== 0;\n\n      var cachedValue = void 0;\n      var keys = void 0;\n\n      if (takesArguments) {\n        keys = [property].concat(args);\n        cachedValue = getIn(hasArgs, keys);\n      } else {\n        cachedValue = noArgs[property];\n      }\n\n      // If we've got a result already, return it.\n      if (cachedValue !== UNSET) {\n        return cachedValue === UNDEFINED ? undefined : cachedValue;\n      }\n\n      // Otherwise calculate what it should be once and cache it.\n      var value = original.apply(this, args);\n      var v = value === undefined ? UNDEFINED : value;\n\n      if (takesArguments) {\n        setIn(hasArgs, keys, v);\n      } else {\n        noArgs[property] = v;\n      }\n\n      return value;\n    };\n  };\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var property = _step.value;\n\n      _loop(property);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n}\n\n/**\n * Get a value at a key path in a tree of Map.\n *\n * If not set, returns UNSET.\n * If the set value is undefined, returns UNDEFINED.\n *\n * @param {Map} map\n * @param {Array} keys\n * @return {Any|UNSET|UNDEFINED}\n */\n\nfunction getIn(map, keys) {\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var key = _step2.value;\n\n      if (key === undefined) {\n        key = UNDEFINED;\n      } else if (key == null) {\n        key = NULL;\n      }\n\n      if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {\n        map = map[STORE_KEY] && map[STORE_KEY].get(key);\n      } else {\n        map = map[key];\n      }\n\n      if (map === UNSET) return UNSET;\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  return map[LEAF];\n}\n\n/**\n * Set a value at a key path in a tree of Map, creating Maps on the go.\n *\n * @param {Map} map\n * @param {Array} keys\n * @param {Any} value\n * @return {Map}\n */\n\nfunction setIn(map, keys, value) {\n  var child = map;\n\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var key = _step3.value;\n\n      if (key === undefined) {\n        key = UNDEFINED;\n      } else if (key == null) {\n        key = NULL;\n      }\n\n      if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) !== 'object') {\n        if (!child[key]) {\n          child[key] = {};\n        }\n\n        child = child[key];\n        continue;\n      }\n\n      if (!child[STORE_KEY]) {\n        child[STORE_KEY] = new WeakMap();\n      }\n\n      if (!child[STORE_KEY].has(key)) {\n        var newChild = {};\n        child[STORE_KEY].set(key, newChild);\n        child = newChild;\n        continue;\n      }\n\n      child = child[STORE_KEY].get(key);\n    }\n\n    // The whole path has been created, so set the value to the bottom most map.\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  child[LEAF] = value;\n  return map;\n}\n\n/**\n * In DEV mode, clears the previously memoized values, globally.\n *\n * @return {Void}\n */\n\nfunction resetMemoization() {\n  memoizeStore = new WeakMap();\n}\n\n/**\n * In DEV mode, enable or disable the use of memoize values, globally.\n *\n * @param {Boolean} enabled\n * @return {Void}\n */\n\nfunction useMemoization(enabled) {\n  ENABLED = enabled;\n}\n\n/**\n * The interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Class}\n */\n\nvar NodeInterface = function () {\n  function NodeInterface() {\n    classCallCheck(this, NodeInterface);\n  }\n\n  createClass(NodeInterface, [{\n    key: 'getFirstText',\n\n    /**\n     * Get the first text node of a node, or the node itself.\n     *\n     * @return {Node|Null}\n     */\n\n    value: function getFirstText() {\n      if (this.object === 'text') {\n        return this;\n      }\n\n      var descendant = null;\n\n      var found = this.nodes.find(function (node) {\n        if (node.object === 'text') return true;\n        descendant = node.getFirstText();\n        return !!descendant;\n      });\n\n      return descendant || found;\n    }\n\n    /**\n     * Get an object mapping all the keys in the node to their paths.\n     *\n     * @return {Object}\n     */\n\n  }, {\n    key: 'getKeysToPathsTable',\n    value: function getKeysToPathsTable() {\n      var ret = defineProperty({}, this.key, []);\n\n      if (this.nodes) {\n        this.nodes.forEach(function (node, i) {\n          var nested = node.getKeysToPathsTable();\n\n          for (var key in nested) {\n            var path = nested[key];\n\n            warning(!(key in ret), 'A node with a duplicate key of \"' + key + '\" was found! Duplicate keys are not allowed, you should use `node.regenerateKey` before inserting if you are reusing an existing node.');\n\n            ret[key] = [i].concat(toConsumableArray(path));\n          }\n        });\n      }\n\n      return ret;\n    }\n\n    /**\n     * Get the last text node of a node, or the node itself.\n     *\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getLastText',\n    value: function getLastText() {\n      if (this.object === 'text') {\n        return this;\n      }\n\n      var descendant = null;\n\n      var found = this.nodes.findLast(function (node) {\n        if (node.object === 'text') return true;\n        descendant = node.getLastText();\n        return descendant;\n      });\n\n      return descendant || found;\n    }\n\n    /**\n     * Get a node in the tree, or the node itself.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNode',\n    value: function getNode(path) {\n      path = this.resolvePath(path);\n      if (!path) return null;\n      if (this.object === 'text' && path.size) return null;\n      var node = path.size ? this.getDescendant(path) : this;\n      return node;\n    }\n\n    /**\n     * Find the path to a node.\n     *\n     * @param {String|List} key\n     * @return {List}\n     */\n\n  }, {\n    key: 'getPath',\n    value: function getPath(key) {\n      // COMPAT: Handle passing in a path, to match other methods.\n      if (immutable.List.isList(key)) {\n        return key;\n      }\n\n      // COMPAT: Handle a node object by iterating the descendants tree, so that\n      // we avoid using keys for the future.\n      if (Node.isNode(key) && this.descendants) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = this.descendants()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref = _step.value;\n\n            var _ref2 = slicedToArray(_ref, 2);\n\n            var node = _ref2[0];\n            var _path = _ref2[1];\n\n            if (key === node) return _path;\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      var dict = this.getKeysToPathsTable();\n      var path = dict[key];\n      return path ? immutable.List(path) : null;\n    }\n\n    /**\n     * Get the concatenated text string of a node.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'getText',\n    value: function getText() {\n      if (this.object === 'text') {\n        return this.text;\n      }\n\n      var text = this.nodes.reduce(function (memo, c) {\n        return memo + c.text;\n      }, '');\n      return text;\n    }\n\n    /**\n     * Check if a node exists.\n     *\n     * @param {List|String} path\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasNode',\n    value: function hasNode(path) {\n      var node = this.getNode(path);\n      return !!node;\n    }\n\n    /**\n     * Normalize the text node with an `editor`.\n     *\n     * @param {Editor} editor\n     * @return {Function|Void}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(editor) {\n      var normalizer = editor.run('normalizeNode', this);\n      return normalizer;\n    }\n\n    /**\n     * Regenerate the node's key.\n     *\n     * @return {Node}\n     */\n\n  }, {\n    key: 'regenerateKey',\n    value: function regenerateKey() {\n      var key = KeyUtils.create();\n      var node = this.set('key', key);\n      return node;\n    }\n\n    /**\n     * Resolve a path from a path list or key string.\n     *\n     * An `index` can be provided, in which case paths created from a key string\n     * will have the index pushed onto them. This is helpful in cases where you\n     * want to accept either a `path` or a `key, index` combination for targeting\n     * a location in the tree that doesn't exist yet, like when inserting.\n     *\n     * @param {List|String} value\n     * @param {Number} index\n     * @return {List}\n     */\n\n  }, {\n    key: 'resolvePath',\n    value: function resolvePath(path, index) {\n      if (typeof path === 'string') {\n        path = this.getPath(path);\n\n        if (index != null) {\n          path = path.concat(index);\n        }\n      } else {\n        path = PathUtils.create(path);\n      }\n\n      return path;\n    }\n\n    /**\n     * Validate the node with an `editor`.\n     *\n     * @param {Editor} editor\n     * @return {Error|Void}\n     */\n\n  }, {\n    key: 'validate',\n    value: function validate(editor) {\n      var error = editor.run('validateNode', this);\n      return error;\n    }\n  }]);\n  return NodeInterface;\n}();\n\n/**\n * Memoize read methods.\n */\n\nmemoize(NodeInterface.prototype, ['getFirstText', 'getKeysToPathsTable', 'getLastText', 'getText', 'normalize', 'validate']);\n\n/**\n * Mix in the node interface.\n */\n\nmixin(NodeInterface, [Block, Document, Inline, Text]);\n\nvar global$1 = typeof global !== \"undefined\" ? global :\n            typeof self !== \"undefined\" ? self :\n            typeof window !== \"undefined\" ? window : {}\n\nfunction identity() {\n  return true;\n}\n\n/**\n * The interface that `Document`, `Block` and `Inline` all implement, to make\n * working with the recursive node tree easier.\n *\n * @type {Class}\n */\n\nvar ElementInterface = function () {\n  function ElementInterface() {\n    classCallCheck(this, ElementInterface);\n  }\n\n  createClass(ElementInterface, [{\n    key: 'addMark',\n\n\n    /**\n     * Add `mark` to text at `path`.\n     *\n     * @param {List|String} path\n     * @param {Mark} mark\n     * @return {Node}\n     */\n\n    value: function addMark(path, mark) {\n      path = this.resolvePath(path);\n      var node = this.assertDescendant(path);\n      node = node.addMark(mark);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n\n    /**\n     * Create an iteratable for all of the ancestors of the node.\n     *\n     * @return {Iterable}\n     */\n\n  }, {\n    key: 'ancestors',\n    value: function ancestors(path) {\n      var iterable = this.createIterable({\n        path: path,\n        direction: null,\n        downward: false,\n        includeTargetAncestors: true,\n        includeRoot: true\n      });\n\n      return iterable;\n    }\n\n    /**\n     * Create an iteratable for all of the blocks of a node with `options`.\n     *\n     * @param {Options}\n     * @return {Iterable}\n     */\n\n  }, {\n    key: 'blocks',\n    value: function blocks() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var onlyLeaves = options.onlyLeaves,\n          onlyRoots = options.onlyRoots,\n          onlyTypes = options.onlyTypes,\n          _match = options.match,\n          rest = objectWithoutProperties(options, ['onlyLeaves', 'onlyRoots', 'onlyTypes', 'match']);\n\n      var iterable = this.descendants(_extends({\n        includeDocument: false,\n        includeInlines: false,\n        includeTexts: false\n      }, rest, {\n        match: function match(node, path) {\n          if (onlyTypes && !onlyTypes.includes(node.type)) {\n            return false;\n          } else if (onlyRoots && path.size !== 1) {\n            return false;\n          } else if (onlyLeaves && !node.isLeafBlock()) {\n            return false;\n          } else if (_match && !_match(node, path)) {\n            return false;\n          } else {\n            return true;\n          }\n        }\n      }));\n\n      return iterable;\n    }\n\n    /**\n     * Create an annotation with `properties` relative to the node.\n     *\n     * @param {Object|Annotation} properties\n     * @return {Annotation}\n     */\n\n  }, {\n    key: 'createAnnotation',\n    value: function createAnnotation(properties) {\n      properties = Annotation.createProperties(properties);\n      var annotation = this.resolveAnnotation(properties);\n      return annotation;\n    }\n\n    /**\n     * Create a decoration with `properties` relative to the node.\n     *\n     * @param {Object|Decoration} properties\n     * @return {Decoration}\n     */\n\n  }, {\n    key: 'createDecoration',\n    value: function createDecoration(properties) {\n      properties = Decoration.createProperties(properties);\n      var decoration = this.resolveDecoration(properties);\n      return decoration;\n    }\n\n    /**\n     * Create an iteratable function starting at `target` path with `options`.\n     *\n     * @param {Object} options (optional)\n     * @return {Function}\n     */\n\n  }, {\n    key: 'createIterable',\n    value: function createIterable() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _options$direction = options.direction,\n          direction = _options$direction === undefined ? 'forward' : _options$direction,\n          _options$downward = options.downward,\n          downward = _options$downward === undefined ? true : _options$downward,\n          _options$upward = options.upward,\n          upward = _options$upward === undefined ? true : _options$upward,\n          _options$includeBlock = options.includeBlocks,\n          includeBlocks = _options$includeBlock === undefined ? true : _options$includeBlock,\n          _options$includeDocum = options.includeDocument,\n          includeDocument = _options$includeDocum === undefined ? true : _options$includeDocum,\n          _options$includeInlin = options.includeInlines,\n          includeInlines = _options$includeInlin === undefined ? true : _options$includeInlin,\n          _options$includeRoot = options.includeRoot,\n          includeRoot = _options$includeRoot === undefined ? false : _options$includeRoot,\n          _options$includeTarge = options.includeTarget,\n          includeTarget = _options$includeTarge === undefined ? !!options.range : _options$includeTarge,\n          _options$includeTarge2 = options.includeTargetAncestors,\n          includeTargetAncestors = _options$includeTarge2 === undefined ? false : _options$includeTarge2,\n          _options$includeTexts = options.includeTexts,\n          includeTexts = _options$includeTexts === undefined ? true : _options$includeTexts,\n          _options$match = options.match,\n          match = _options$match === undefined ? null : _options$match;\n\n\n      var root = this;\n      var targetPath = null;\n      var targetRange = null;\n\n      // You can iterate over either a range or a path, but not both.\n      if (options.range) {\n        targetRange = root.resolveRange(options.range);\n        targetPath = root.resolvePath(targetRange.start.path);\n      } else if (options.path) {\n        targetPath = root.resolvePath(options.path);\n      }\n\n      var targetNode = targetPath && root.assertNode(targetPath);\n      var NativeSet = typeof window === 'undefined' ? global$1.Set : window.Set;\n\n      // Return an object that implements the iterable interface.\n      return defineProperty({}, Symbol.iterator, function () {\n        var visited = new NativeSet();\n        var startPath = targetRange && targetRange.start.path;\n        var endPath = targetRange && targetRange.end.path;\n        var path = targetPath;\n        var node = targetNode;\n        var includedTarget = false;\n        var includedStart = false;\n        var includingStart = false;\n\n        var result = function result() {\n          // When these are nulled out we've finished iterating.\n          if (!path || !node) {\n            return { done: true };\n          }\n\n          // We often don't want to include the root node itself.\n          if (!includeRoot && node === root) {\n            return next();\n          }\n\n          if (!includeBlocks && node.object === 'block') {\n            return next();\n          }\n\n          if (!includeDocument && node.object === 'document') {\n            return next();\n          }\n\n          if (!includeInlines && node.object === 'inline') {\n            return next();\n          }\n\n          if (!includeTexts && node.object === 'text') {\n            return next();\n          }\n\n          if (match && !match(node, path)) {\n            return next();\n          }\n\n          return { value: [node, path], done: false };\n        };\n\n        var next = function next() {\n          if (!path || !node) {\n            return result();\n          }\n\n          // When iterating over a range, we need to include the specific\n          // ancestors in the start path of the range manually.\n          if (startPath && !includedStart) {\n            if (!includingStart) {\n              includingStart = true;\n              path = PathUtils.create([]);\n              node = root;\n              return result();\n            }\n\n            if (path.size === startPath.size - 1) {\n              includedStart = true;\n              path = targetPath;\n              node = targetNode;\n              return next();\n            }\n\n            path = startPath.slice(0, path.size + 1);\n            node = root.assertNode(path);\n            return result();\n          }\n\n          // Sometimes we want to include the target itself.\n          if (includeTarget && !includedTarget) {\n            includedTarget = true;\n            return result();\n          }\n\n          // When iterating over a range, if we get to the end path then exit.\n          if (endPath && path.equals(endPath)) {\n            node = null;\n            path = null;\n            return next();\n          }\n\n          // If we're allowed to go downward, and we haven't decsended yet, do so.\n          if (downward && node.nodes && node.nodes.size && !visited.has(node)) {\n            visited.add(node);\n            var nextIndex = direction === 'forward' ? 0 : node.nodes.size - 1;\n            path = path.push(nextIndex);\n            node = root.assertNode(path);\n            return result();\n          }\n\n          // If we're going forward...\n          if (direction === 'forward') {\n            var newPath = PathUtils.increment(path);\n            var newNode = root.getNode(newPath);\n\n            if (newNode) {\n              path = newPath;\n              node = newNode;\n              return result();\n            }\n          }\n\n          // If we're going backward...\n          if (direction === 'backward' && path.last() !== 0) {\n            var _newPath = PathUtils.decrement(path);\n            var _newNode = root.getNode(_newPath);\n\n            if (_newNode) {\n              path = _newPath;\n              node = _newNode;\n              return result();\n            }\n          }\n\n          // If we're going upward...\n          if (upward && path.size) {\n            path = PathUtils.lift(path);\n            node = root.assertNode(path);\n\n            // Sometimes we'll have already visited the node on the way down\n            // so we don't want to double count it.\n            if (visited.has(node)) {\n              return next();\n            }\n\n            visited.add(node);\n\n            // If ancestors of the target node shouldn't be included, skip them.\n            if (!includeTargetAncestors) {\n              return next();\n            } else {\n              return result();\n            }\n          }\n\n          path = null;\n          node = null;\n          return next();\n        };\n\n        return { next: next };\n      });\n    }\n\n    /**\n     * Create a point with `properties` relative to the node.\n     *\n     * @param {Object|Point} properties\n     * @return {Range}\n     */\n\n  }, {\n    key: 'createPoint',\n    value: function createPoint(properties) {\n      properties = Point.createProperties(properties);\n      var point = this.resolvePoint(properties);\n      return point;\n    }\n\n    /**\n     * Create a range with `properties` relative to the node.\n     *\n     * @param {Object|Range} properties\n     * @return {Range}\n     */\n\n  }, {\n    key: 'createRange',\n    value: function createRange(properties) {\n      properties = Range.createProperties(properties);\n      var range = this.resolveRange(properties);\n      return range;\n    }\n\n    /**\n     * Create a selection with `properties` relative to the node.\n     *\n     * @param {Object|Selection} properties\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'createSelection',\n    value: function createSelection(properties) {\n      properties = Selection.createProperties(properties);\n      var selection = this.resolveSelection(properties);\n      return selection;\n    }\n\n    /**\n     * Create an iteratable for all of the descendants of the node.\n     *\n     * @param {Object} options\n     * @return {Iterable}\n     */\n\n  }, {\n    key: 'descendants',\n    value: function descendants(options) {\n      var iterable = this.createIterable(_extends({ path: [] }, options));\n      return iterable;\n    }\n\n    /**\n     * Find all of the descendants that match a `predicate`.\n     *\n     * @param {Function} predicate\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'filterDescendants',\n    value: function filterDescendants() {\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\n\n      var matches = [];\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = this.descendants()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _ref2 = _step.value;\n\n          var _ref3 = slicedToArray(_ref2, 2);\n\n          var node = _ref3[0];\n          var path = _ref3[1];\n\n          if (predicate(node, path)) {\n            matches.push(node);\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      return immutable.List(matches);\n    }\n\n    /**\n     * Find the first descendant that matches a `predicate`.\n     *\n     * @param {Function} predicate\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'findDescendant',\n    value: function findDescendant() {\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = this.descendants()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _ref4 = _step2.value;\n\n          var _ref5 = slicedToArray(_ref4, 2);\n\n          var node = _ref5[0];\n          var path = _ref5[1];\n\n          if (predicate(node, path)) {\n            return node;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return null;\n    }\n\n    /**\n     * Iterate over all descendants, breaking if `predicate` returns false.\n     *\n     * @param {Function} predicate\n     */\n\n  }, {\n    key: 'forEachDescendant',\n    value: function forEachDescendant() {\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = this.descendants()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var _next = _step3.value;\n\n          var ret = predicate.apply(undefined, toConsumableArray(_next));\n\n          if (ret === false) {\n            return;\n          }\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\n            _iterator3.return();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n    }\n\n    /**\n     * Get a set of the active marks in a `range`. Active marks are marks that are\n     * on every text node in a given range. This is a common distinction for\n     * highlighting toolbar buttons for example.\n     *\n     * TODO: this method needs to be cleaned up, it's very hard to follow and\n     * probably doing unnecessary work.\n     *\n     * @param {Range} range\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getActiveMarksAtRange',\n    value: function getActiveMarksAtRange(range) {\n      range = this.resolveRange(range);\n\n      if (range.isUnset) {\n        return immutable.Set();\n      }\n\n      if (range.isCollapsed) {\n        var _range = range,\n            _start = _range.start;\n\n        return this.getInsertMarksAtPoint(_start);\n      }\n\n      var _range2 = range,\n          start = _range2.start,\n          end = _range2.end;\n\n      var startPath = start.path;\n      var startOffset = start.offset;\n      var endPath = end.path;\n      var endOffset = end.offset;\n      var startText = this.getDescendant(startPath);\n      var endText = this.getDescendant(endPath);\n\n      if (!startPath.equals(endPath)) {\n        while (!startPath.equals(endPath) && endOffset === 0) {\n          \n          var _texts = this.texts({\n            path: endPath,\n            direction: 'backward'\n          });\n\n          var _texts2 = slicedToArray(_texts, 1);\n\n          var _texts2$ = slicedToArray(_texts2[0], 2);\n\n          endText = _texts2$[0];\n          endPath = _texts2$[1];\n\n\n          endOffset = endText.text.length;\n        }\n\n        while (!startPath.equals(endPath) && startOffset === startText.text.length) {\n          \n          var _texts3 = this.texts({ path: startPath });\n\n          var _texts4 = slicedToArray(_texts3, 1);\n\n          var _texts4$ = slicedToArray(_texts4[0], 2);\n\n          startText = _texts4$[0];\n          startPath = _texts4$[1];\n\n          startOffset = 0;\n        }\n      }\n\n      if (startPath.equals(endPath)) {\n        return startText.marks;\n      }\n\n      var startMarks = startText.marks;\n\n      // PERF: if start marks is empty we can return early.\n      if (startMarks.size === 0) {\n        return immutable.Set();\n      }\n\n      var endMarks = endText.marks;\n      var marks = startMarks.intersect(endMarks);\n\n      // If marks is already empty, the active marks is empty\n      if (marks.size === 0) {\n        return marks;\n      }\n\n      \n      var _texts5 = this.texts({ path: startPath });\n\n      var _texts6 = slicedToArray(_texts5, 1);\n\n      var _texts6$ = slicedToArray(_texts6[0], 2);\n\n      startText = _texts6$[0];\n      startPath = _texts6$[1];\n\n\n      while (!startPath.equals(endPath)) {\n        if (startText.text.length !== 0) {\n          marks = marks.intersect(startText.marks);\n\n          if (marks.size === 0) {\n            return immutable.Set();\n          }\n        }\n\n        \n        var _texts7 = this.texts({ path: startPath });\n\n        var _texts8 = slicedToArray(_texts7, 1);\n\n        var _texts8$ = slicedToArray(_texts8[0], 2);\n\n        startText = _texts8$[0];\n        startPath = _texts8$[1];\n      }\n\n      return marks;\n    }\n\n    /**\n     * Get a list of the ancestors of a descendant.\n     *\n     * @param {List|String} path\n     * @return {List<Node>|Null}\n     */\n\n  }, {\n    key: 'getAncestors',\n    value: function getAncestors(path) {\n      var iterable = this.ancestors(path);\n      var array = Array.from(iterable, function (_ref6) {\n        var _ref7 = slicedToArray(_ref6, 1),\n            node = _ref7[0];\n\n        return node;\n      }).reverse();\n      var list = immutable.List(array);\n      return list;\n    }\n\n    /**\n     * Get the leaf block descendants of the node.\n     *\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getBlocks',\n    value: function getBlocks() {\n      var iterable = this.blocks({ onlyLeaves: true });\n      var array = Array.from(iterable, function (_ref8) {\n        var _ref9 = slicedToArray(_ref8, 1),\n            node = _ref9[0];\n\n        return node;\n      });\n      var list = immutable.List(array);\n      return list;\n    }\n\n    /**\n     * Get all of the leaf blocks that match a `type`.\n     *\n     * @param {String} type\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getBlocksByType',\n    value: function getBlocksByType(type) {\n      var iterable = this.blocks({ onlyLeaves: true, onlyTypes: [type] });\n      var array = Array.from(iterable, function (_ref10) {\n        var _ref11 = slicedToArray(_ref10, 1),\n            node = _ref11[0];\n\n        return node;\n      });\n      var list = immutable.List(array);\n      return list;\n    }\n\n    /**\n     * Get a child node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getChild',\n    value: function getChild(path) {\n      path = this.resolvePath(path);\n\n      if (!path || path.size > 1) {\n        return null;\n      }\n\n      var child = this.nodes.get(path.first());\n      return child;\n    }\n\n    /**\n     * Get closest parent of node that matches a `predicate`.\n     *\n     * @param {List|String} path\n     * @param {Function} predicate\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getClosest',\n    value: function getClosest(path, predicate) {\n      var _iteratorNormalCompletion4 = true;\n      var _didIteratorError4 = false;\n      var _iteratorError4 = undefined;\n\n      try {\n        for (var _iterator4 = this.ancestors(path)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\n          var _ref12 = _step4.value;\n\n          var _ref13 = slicedToArray(_ref12, 2);\n\n          var n = _ref13[0];\n          var p = _ref13[1];\n\n          if (predicate(n, p)) {\n            return n;\n          }\n        }\n      } catch (err) {\n        _didIteratorError4 = true;\n        _iteratorError4 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\n            _iterator4.return();\n          }\n        } finally {\n          if (_didIteratorError4) {\n            throw _iteratorError4;\n          }\n        }\n      }\n\n      return null;\n    }\n\n    /**\n     * Get the closest block parent of a node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getClosestBlock',\n    value: function getClosestBlock(path) {\n      var closest = this.getClosest(path, function (n) {\n        return n.object === 'block';\n      });\n      return closest;\n    }\n\n    /**\n     * Get the closest inline parent of a node by `path`.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getClosestInline',\n    value: function getClosestInline(path) {\n      var closest = this.getClosest(path, function (n) {\n        return n.object === 'inline';\n      });\n      return closest;\n    }\n\n    /**\n     * Get the closest void parent of a node by `path`.\n     *\n     * @param {List|String} path\n     * @param {Editor} editor\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getClosestVoid',\n    value: function getClosestVoid(path, editor) {\n      invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `node.getClosestVoid` method takes an `editor` instead of a `value`.');\n\n      var closest = this.getClosest(path, function (n) {\n        return editor.isVoid(n);\n      });\n      return closest;\n    }\n\n    /**\n     * Get the common ancestor of nodes `a` and `b`.\n     *\n     * @param {List} a\n     * @param {List} b\n     * @return {Node}\n     */\n\n  }, {\n    key: 'getCommonAncestor',\n    value: function getCommonAncestor(a, b) {\n      a = this.resolvePath(a);\n      b = this.resolvePath(b);\n\n      if (!a || !b) {\n        return null;\n      }\n\n      var path = PathUtils.relate(a, b);\n      var node = this.getNode(path);\n      return node;\n    }\n\n    /**\n     * Get the decorations for the node from an `editor`.\n     *\n     * @param {Editor} editor\n     * @return {List}\n     */\n\n  }, {\n    key: 'getDecorations',\n    value: function getDecorations(editor) {\n      var decorations = editor.run('decorateNode', this);\n      decorations = Decoration.createList(decorations);\n      return decorations;\n    }\n\n    /**\n     * Get the depth of a descendant, with optional `startAt`.\n     *\n     * @param {List|String} path\n     * @param {Number} startAt\n     * @return {Number|Null}\n     */\n\n  }, {\n    key: 'getDepth',\n    value: function getDepth(path) {\n      var startAt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n\n      path = this.resolvePath(path);\n\n      if (!path) {\n        return null;\n      }\n\n      var node = this.getNode(path);\n      var depth = node ? path.size - 1 + startAt : null;\n      return depth;\n    }\n\n    /**\n     * Get a descendant node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getDescendant',\n    value: function getDescendant(path) {\n      path = this.resolvePath(path);\n\n      if (!path || !path.size) {\n        return null;\n      }\n\n      var node = this;\n\n      path.forEach(function (index) {\n        node = node.getIn(['nodes', index]);\n        return !!node;\n      });\n\n      return node;\n    }\n\n    /**\n     * Get all of the descendant nodes in a `range`.\n     *\n     * @param {Range} range\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getDescendantsAtRange',\n    value: function getDescendantsAtRange(range) {\n      var iterable = this.descendants({ range: range });\n      var array = Array.from(iterable, function (_ref14) {\n        var _ref15 = slicedToArray(_ref14, 1),\n            node = _ref15[0];\n\n        return node;\n      });\n      var list = immutable.List(array);\n      return list;\n    }\n\n    /**\n     * Get a fragment of the node at a `range`.\n     *\n     * @param {Range} range\n     * @return {Document}\n     */\n\n  }, {\n    key: 'getFragmentAtRange',\n    value: function getFragmentAtRange(range) {\n      range = this.resolveRange(range);\n\n      if (range.isUnset) {\n        return Document.create();\n      }\n\n      var _range3 = range,\n          start = _range3.start,\n          end = _range3.end;\n\n      var node = this;\n      var targetPath = end.path;\n      var targetPosition = end.offset;\n      var side = 'end';\n\n      while (targetPath.size) {\n        var index = targetPath.last();\n        node = node.splitNode(targetPath, targetPosition);\n        targetPosition = index + 1;\n        targetPath = PathUtils.lift(targetPath);\n\n        if (!targetPath.size && side === 'end') {\n          targetPath = start.path;\n          targetPosition = start.offset;\n          side = 'start';\n        }\n      }\n\n      var startIndex = start.path.first() + 1;\n      var endIndex = end.path.first() + 2;\n      var nodes = node.nodes.slice(startIndex, endIndex);\n      var fragment = Document.create({ nodes: nodes });\n      return fragment;\n    }\n\n    /**\n     * Get the furthest ancestors of a node that matches a `predicate`.\n     *\n     * @param {Path} path\n     * @param {Function} predicate\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthest',\n    value: function getFurthest(path) {\n      var predicate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;\n\n      var iterable = this.ancestors(path);\n      var results = Array.from(iterable).reverse();\n\n      var _iteratorNormalCompletion5 = true;\n      var _didIteratorError5 = false;\n      var _iteratorError5 = undefined;\n\n      try {\n        for (var _iterator5 = results[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\n          var _ref16 = _step5.value;\n\n          var _ref17 = slicedToArray(_ref16, 2);\n\n          var n = _ref17[0];\n          var p = _ref17[1];\n\n          if (predicate(n, p)) {\n            return n;\n          }\n        }\n      } catch (err) {\n        _didIteratorError5 = true;\n        _iteratorError5 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\n            _iterator5.return();\n          }\n        } finally {\n          if (_didIteratorError5) {\n            throw _iteratorError5;\n          }\n        }\n      }\n\n      return null;\n    }\n\n    /**\n     * Get the furthest block parent of a node.\n     *\n     * @param {Path} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthestBlock',\n    value: function getFurthestBlock(path) {\n      var furthest = this.getFurthest(path, function (n) {\n        return n.object === 'block';\n      });\n      return furthest;\n    }\n\n    /**\n     * Get the furthest child ancestor of a node at `path`.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthestChild',\n    value: function getFurthestChild(path) {\n      path = this.resolvePath(path);\n\n      if (!path || !path.size) {\n        return null;\n      }\n\n      var furthest = this.nodes.get(path.first());\n      return furthest;\n    }\n\n    /**\n     * Get the furthest inline parent of a node.\n     *\n     * @param {Path} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getFurthestInline',\n    value: function getFurthestInline(path) {\n      var furthest = this.getFurthest(path, function (n) {\n        return n.object === 'inline';\n      });\n      return furthest;\n    }\n\n    /**\n     * Get the closest inline nodes for each text node in the node.\n     *\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getInlines',\n    value: function getInlines() {\n      var iterable = this.inlines({ onlyLeaves: true });\n      var array = Array.from(iterable, function (_ref18) {\n        var _ref19 = slicedToArray(_ref18, 1),\n            node = _ref19[0];\n\n        return node;\n      });\n      var list = immutable.List(array);\n      return list;\n    }\n\n    /**\n     * Get all of the leaf inline nodes that match a `type`.\n     *\n     * @param {String} type\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getInlinesByType',\n    value: function getInlinesByType(type) {\n      var iterable = this.inlines({ onlyLeaves: true, onlyTypes: [type] });\n      var array = Array.from(iterable, function (_ref20) {\n        var _ref21 = slicedToArray(_ref20, 1),\n            node = _ref21[0];\n\n        return node;\n      });\n      var list = immutable.List(array);\n      return list;\n    }\n\n    /**\n     * Get a set of marks that would occur on the next insert at a `point` in the\n     * node. This mimics expected rich text editing behaviors of mark contiuation.\n     *\n     * @param {Point} point\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getInsertMarksAtPoint',\n    value: function getInsertMarksAtPoint(point) {\n      point = this.resolvePoint(point);\n      var _point = point,\n          path = _point.path,\n          offset = _point.offset;\n\n      var text = this.getDescendant(path);\n\n      // PERF: we can exit early if the offset isn't at the start of the node.\n      if (offset !== 0) {\n        return text.marks;\n      }\n\n      var blockNode = void 0;\n      var blockPath = void 0;\n\n      var _iteratorNormalCompletion6 = true;\n      var _didIteratorError6 = false;\n      var _iteratorError6 = undefined;\n\n      try {\n        for (var _iterator6 = this.ancestors(path)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\n          var entry = _step6.value;\n\n          var _entry = slicedToArray(entry, 2),\n              n = _entry[0],\n              p = _entry[1];\n\n          if (n.object === 'block') {\n            blockNode = n;\n            blockPath = p;\n          }\n        }\n      } catch (err) {\n        _didIteratorError6 = true;\n        _iteratorError6 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\n            _iterator6.return();\n          }\n        } finally {\n          if (_didIteratorError6) {\n            throw _iteratorError6;\n          }\n        }\n      }\n\n      var relativePath = PathUtils.drop(path, blockPath.size);\n\n      var _blockNode$texts = blockNode.texts({\n        path: relativePath,\n        direction: 'backward'\n      }),\n          _blockNode$texts2 = slicedToArray(_blockNode$texts, 1),\n          previous = _blockNode$texts2[0];\n\n      // If there's no previous text, we're at the start of the block, so use\n      // the current text nodes marks.\n\n\n      if (!previous) {\n        return text.marks;\n      }\n\n      // Otherwise, continue with the previous text node's marks instead.\n\n      var _previous = slicedToArray(previous, 1),\n          previousText = _previous[0];\n\n      return previousText.marks;\n    }\n\n    /**\n     * Get a set of marks that would occur on the next insert at a `range`.\n     * This mimics expected rich text editing behaviors of mark contiuation.\n     *\n     * @param {Range} range\n     * @return {Set<Mark>}\n     */\n\n  }, {\n    key: 'getInsertMarksAtRange',\n    value: function getInsertMarksAtRange(range) {\n      range = this.resolveRange(range);\n      var _range4 = range,\n          start = _range4.start;\n\n\n      if (range.isUnset) {\n        return immutable.Set();\n      }\n\n      if (range.isCollapsed) {\n        return this.getInsertMarksAtPoint(start);\n      }\n\n      var text = this.getDescendant(start.path);\n      return text.marks;\n    }\n\n    /**\n     * Get the bottom-most block descendants in a `range`.\n     *\n     * @param {Range} range\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getLeafBlocksAtRange',\n    value: function getLeafBlocksAtRange(range) {\n      var iterable = this.blocks({ range: range, onlyLeaves: true });\n      var array = Array.from(iterable, function (_ref22) {\n        var _ref23 = slicedToArray(_ref22, 1),\n            node = _ref23[0];\n\n        return node;\n      });\n      var list = immutable.List(array);\n      return list;\n    }\n\n    /**\n     * Get the bottom-most inline nodes for each text node in a `range`.\n     *\n     * @param {Range} range\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getLeafInlinesAtRange',\n    value: function getLeafInlinesAtRange(range) {\n      var iterable = this.inlines({ range: range, onlyLeaves: true });\n      var array = Array.from(iterable, function (_ref24) {\n        var _ref25 = slicedToArray(_ref24, 1),\n            node = _ref25[0];\n\n        return node;\n      });\n      var list = immutable.List(array);\n      return list;\n    }\n\n    /**\n     * Get an object mapping all the keys in the node to their paths.\n     *\n     * @return {Map}\n     */\n\n  }, {\n    key: 'getNodesToPathsMap',\n    value: function getNodesToPathsMap() {\n      var root = this;\n      var map = typeof window === 'undefined' ? new global$1.Map() : new window.Map();\n\n      map.set(root, PathUtils.create([]));\n\n      root.forEachDescendant(function (node, path) {\n        map.set(node, path);\n      });\n\n      return map;\n    }\n\n    /**\n     * Get all of the marks for all of the characters of every text node.\n     *\n     * @return {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getMarks',\n    value: function getMarks() {\n      var iterable = this.marks();\n      var array = Array.from(iterable, function (_ref26) {\n        var _ref27 = slicedToArray(_ref26, 1),\n            mark = _ref27[0];\n\n        return mark;\n      });\n      return immutable.OrderedSet(array);\n    }\n\n    /**\n     * Get a set of the marks in a `range`.\n     *\n     * @param {Range} range\n     * @return {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getMarksAtRange',\n    value: function getMarksAtRange(range) {\n      var iterable = this.marks({ range: range });\n      var array = Array.from(iterable, function (_ref28) {\n        var _ref29 = slicedToArray(_ref28, 1),\n            mark = _ref29[0];\n\n        return mark;\n      });\n      return immutable.OrderedSet(array);\n    }\n\n    /**\n     * Get all of the marks that match a `type`.\n     *\n     * @param {String} type\n     * @return {OrderedSet<Mark>}\n     */\n\n  }, {\n    key: 'getMarksByType',\n    value: function getMarksByType(type) {\n      var iterable = this.marks({ onlyTypes: [type] });\n      var array = Array.from(iterable, function (_ref30) {\n        var _ref31 = slicedToArray(_ref30, 1),\n            mark = _ref31[0];\n\n        return mark;\n      });\n      return immutable.OrderedSet(array);\n    }\n\n    /**\n     * Get the block node after a descendant text node by `path`.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNextBlock',\n    value: function getNextBlock(path) {\n      var _blocks = this.blocks({ path: path, onlyLeaves: true }),\n          _blocks2 = slicedToArray(_blocks, 1),\n          entry = _blocks2[0];\n\n      var block = entry ? entry[0] : null;\n      return block;\n    }\n\n    /**\n     * Get the next node in the tree, returning siblings or ancestor siblings.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNextNode',\n    value: function getNextNode(path) {\n      var iterable = this.createIterable({ path: path, downward: false });\n\n      var _iterable = slicedToArray(iterable, 1),\n          entry = _iterable[0];\n\n      var node = entry ? entry[0] : null;\n      return node;\n    }\n\n    /**\n     * Get the next sibling of a node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNextSibling',\n    value: function getNextSibling(path) {\n      var _siblings = this.siblings(path),\n          _siblings2 = slicedToArray(_siblings, 1),\n          entry = _siblings2[0];\n\n      var node = entry ? entry[0] : null;\n      return node;\n    }\n\n    /**\n     * Get the text node after a descendant text node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getNextText',\n    value: function getNextText(path) {\n      var _texts9 = this.texts({ path: path }),\n          _texts10 = slicedToArray(_texts9, 1),\n          entry = _texts10[0];\n\n      var node = entry ? entry[0] : null;\n      return node;\n    }\n\n    /**\n     * Get the offset for a descendant text node by `path` or `key`.\n     *\n     * @param {List|string} path\n     * @return {Number}\n     */\n\n  }, {\n    key: 'getOffset',\n    value: function getOffset(path) {\n      path = this.resolvePath(path);\n      this.assertDescendant(path);\n\n      // Calculate the offset of the nodes before the highest child.\n      var index = path.first();\n\n      var offset = this.nodes.slice(0, index).reduce(function (memo, n) {\n        return memo + n.text.length;\n      }, 0);\n\n      // Recurse if need be.\n      var ret = path.size === 1 ? offset : offset + this.nodes.get(index).getOffset(PathUtils.drop(path));\n\n      return ret;\n    }\n\n    /**\n     * Get the offset from a `range`.\n     *\n     * @param {Range} range\n     * @return {Number}\n     */\n\n  }, {\n    key: 'getOffsetAtRange',\n    value: function getOffsetAtRange(range) {\n      range = this.resolveRange(range);\n\n      if (range.isUnset) {\n        throw new Error('The range cannot be unset to calculcate its offset.');\n      }\n\n      if (range.isExpanded) {\n        throw new Error('The range must be collapsed to calculcate its offset.');\n      }\n\n      var _range5 = range,\n          start = _range5.start;\n\n      var offset = this.getOffset(start.path) + start.offset;\n      return offset;\n    }\n\n    /**\n     * Get the parent of a descendant node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getParent',\n    value: function getParent(path) {\n      path = this.resolvePath(path);\n      if (!path) return null;\n      if (!path.size) return null;\n      var parentPath = PathUtils.lift(path);\n      var parent = this.getNode(parentPath);\n      return parent;\n    }\n\n    /**\n     * Get the block node before a descendant text node by `path`.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getPreviousBlock',\n    value: function getPreviousBlock(path) {\n      var _blocks3 = this.blocks({\n        path: path,\n        onlyLeaves: true,\n        direction: 'backward'\n      }),\n          _blocks4 = slicedToArray(_blocks3, 1),\n          entry = _blocks4[0];\n\n      var block = entry ? entry[0] : null;\n      return block;\n    }\n\n    /**\n     * Get the previous node from a node in the tree.\n     *\n     * This will not only check for siblings but instead move up the tree\n     * returning the previous ancestor if no sibling is found.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getPreviousNode',\n    value: function getPreviousNode(path) {\n      var iterable = this.createIterable({\n        path: path,\n        downward: false,\n        direction: 'backward'\n      });\n\n      var _iterable2 = slicedToArray(iterable, 1),\n          entry = _iterable2[0];\n\n      var node = entry ? entry[0] : null;\n      return node;\n    }\n\n    /**\n     * Get the previous sibling of a node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getPreviousSibling',\n    value: function getPreviousSibling(path) {\n      var _siblings3 = this.siblings(path, { direction: 'backward' }),\n          _siblings4 = slicedToArray(_siblings3, 1),\n          entry = _siblings4[0];\n\n      var node = entry ? entry[0] : null;\n      return node;\n    }\n\n    /**\n     * Get the text node before a descendant text node.\n     *\n     * @param {List|String} path\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getPreviousText',\n    value: function getPreviousText(path) {\n      var _texts11 = this.texts({ path: path, direction: 'backward' }),\n          _texts12 = slicedToArray(_texts11, 1),\n          entry = _texts12[0];\n\n      var node = entry ? entry[0] : null;\n      return node;\n    }\n\n    /**\n     * Get only the root block nodes in a `range`.\n     *\n     * @param {Range} range\n     * @return {List}\n     */\n\n  }, {\n    key: 'getRootBlocksAtRange',\n    value: function getRootBlocksAtRange(range) {\n      var iterable = this.blocks({ range: range, onlyRoots: true });\n      var array = Array.from(iterable, function (_ref32) {\n        var _ref33 = slicedToArray(_ref32, 1),\n            node = _ref33[0];\n\n        return node;\n      });\n      var list = immutable.List(array);\n      return list;\n    }\n\n    /**\n     * Get only the root inline nodes in a `range`.\n     *\n     * @param {Range} range\n     * @return {List}\n     */\n\n  }, {\n    key: 'getRootInlinesAtRange',\n    value: function getRootInlinesAtRange(range) {\n      var iterable = this.inlines({ range: range, onlyRoots: true });\n      var array = Array.from(iterable, function (_ref34) {\n        var _ref35 = slicedToArray(_ref34, 1),\n            node = _ref35[0];\n\n        return node;\n      });\n      var list = immutable.List(array);\n      return list;\n    }\n\n    /**\n     * Get the descendent text node at an `offset`.\n     *\n     * @param {String} offset\n     * @return {Node|Null}\n     */\n\n  }, {\n    key: 'getTextAtOffset',\n    value: function getTextAtOffset(offset) {\n      // PERF: Add a few shortcuts for the obvious cases.\n      if (offset === 0) return this.getFirstText();\n      if (offset === this.text.length) return this.getLastText();\n      if (offset < 0 || offset > this.text.length) return null;\n\n      var length = 0;\n\n      var _iteratorNormalCompletion7 = true;\n      var _didIteratorError7 = false;\n      var _iteratorError7 = undefined;\n\n      try {\n        for (var _iterator7 = this.texts()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\n          var _ref36 = _step7.value;\n\n          var _ref37 = slicedToArray(_ref36, 1);\n\n          var node = _ref37[0];\n\n          length += node.text.length;\n\n          if (length > offset) {\n            return node;\n          }\n        }\n      } catch (err) {\n        _didIteratorError7 = true;\n        _iteratorError7 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion7 && _iterator7.return) {\n            _iterator7.return();\n          }\n        } finally {\n          if (_didIteratorError7) {\n            throw _iteratorError7;\n          }\n        }\n      }\n\n      return null;\n    }\n\n    /**\n     * Get the direction of the node's text.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'getTextDirection',\n    value: function getTextDirection() {\n      var dir = getDirection(this.text);\n      return dir === 'neutral' ? null : dir;\n    }\n\n    /**\n     * Recursively get all of the child text nodes in order of appearance.\n     *\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getTexts',\n    value: function getTexts() {\n      var iterable = this.texts();\n      var array = Array.from(iterable, function (_ref38) {\n        var _ref39 = slicedToArray(_ref38, 1),\n            node = _ref39[0];\n\n        return node;\n      });\n      var list = immutable.List(array);\n      return list;\n    }\n\n    /**\n     * Get all of the text nodes in a `range` as a List.\n     *\n     * @param {Range} range\n     * @return {List<Node>}\n     */\n\n  }, {\n    key: 'getTextsAtRange',\n    value: function getTextsAtRange(range) {\n      var iterable = this.texts({ range: range });\n      var array = Array.from(iterable, function (_ref40) {\n        var _ref41 = slicedToArray(_ref40, 1),\n            node = _ref41[0];\n\n        return node;\n      });\n      var list = immutable.List(array);\n      return list;\n    }\n\n    /**\n     * Check if the node has block children.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasBlockChildren',\n    value: function hasBlockChildren() {\n      return !!(this.nodes && this.nodes.find(function (n) {\n        return n.object === 'block';\n      }));\n    }\n\n    /**\n     * Check if a child node exists.\n     *\n     * @param {List|String} path\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasChild',\n    value: function hasChild(path) {\n      var child = this.getChild(path);\n      return !!child;\n    }\n\n    /**\n     * Check if a node has inline children.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasInlineChildren',\n    value: function hasInlineChildren() {\n      return !!(this.nodes && this.nodes.find(function (n) {\n        return n.object === 'inline' || n.object === 'text';\n      }));\n    }\n\n    /**\n     * Recursively check if a child node exists.\n     *\n     * @param {List|String} path\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasDescendant',\n    value: function hasDescendant(path) {\n      var descendant = this.getDescendant(path);\n      return !!descendant;\n    }\n\n    /**\n     * Check if a node has a void parent.\n     *\n     * @param {List|String} path\n     * @param {Editor} editor\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'hasVoidParent',\n    value: function hasVoidParent(path, editor) {\n      invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `node.hasVoidParent` method takes an `editor` instead of a `value`.');\n\n      var closest = this.getClosestVoid(path, editor);\n      return !!closest;\n    }\n\n    /**\n     * Create an iteratable for all of the inlines of a node with `options`.\n     *\n     * @param {Options}\n     * @return {Iterable}\n     */\n\n  }, {\n    key: 'inlines',\n    value: function inlines() {\n      var _this = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var onlyLeaves = options.onlyLeaves,\n          onlyRoots = options.onlyRoots,\n          onlyTypes = options.onlyTypes,\n          _match2 = options.match,\n          rest = objectWithoutProperties(options, ['onlyLeaves', 'onlyRoots', 'onlyTypes', 'match']);\n\n      var iterable = this.descendants(_extends({\n        includeBlocks: false,\n        includeTexts: false,\n        includeDocument: false\n      }, rest, {\n        match: function match(node, path) {\n          if (onlyTypes && !onlyTypes.includes(node.type)) {\n            return false;\n          } else if (onlyLeaves && !node.isLeafInline()) {\n            return false;\n          } else if (onlyRoots && _this.getParent(path).object !== 'block') {\n            return false;\n          } else if (_match2 && !_match2(node, path)) {\n            return false;\n          } else {\n            return true;\n          }\n        }\n      }));\n\n      return iterable;\n    }\n\n    /**\n     * Insert a `node`.\n     *\n     * @param {List|String} path\n     * @param {Node} node\n     * @return {Node}\n     */\n\n  }, {\n    key: 'insertNode',\n    value: function insertNode(path, node) {\n      path = this.resolvePath(path);\n      var index = path.last();\n      var parentPath = PathUtils.lift(path);\n      var parent = this.assertNode(parentPath);\n      var nodes = parent.nodes.splice(index, 0, node);\n      parent = parent.set('nodes', nodes);\n      var ret = this.replaceNode(parentPath, parent);\n      return ret;\n    }\n\n    /**\n     * Insert `text` at `offset` in node by `path`.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @param {String} text\n     * @return {Node}\n     */\n\n  }, {\n    key: 'insertText',\n    value: function insertText(path, offset, text) {\n      path = this.resolvePath(path);\n      var node = this.assertDescendant(path);\n      node = node.insertText(offset, text);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n\n    /**\n     * Check whether the node is a leaf block.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isLeafBlock',\n    value: function isLeafBlock() {\n      if (this.object !== 'block') {\n        return false;\n      }\n\n      if (this.nodes.some(function (n) {\n        return n.object === 'block';\n      })) {\n        return false;\n      }\n\n      return true;\n    }\n\n    /**\n     * Check whether the node is a leaf inline.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isLeafInline',\n    value: function isLeafInline() {\n      if (this.object !== 'inline') {\n        return false;\n      }\n\n      if (this.nodes.some(function (n) {\n        return n.object === 'inline';\n      })) {\n        return false;\n      }\n\n      return true;\n    }\n\n    /**\n     * Check whether a descendant node is inside a `range` by `path`.\n     *\n     * @param {List|String} path\n     * @param {Range} range\n     * @return {Node}\n     */\n\n  }, {\n    key: 'isInRange',\n    value: function isInRange(path, range) {\n      path = this.resolvePath(path);\n      range = this.resolveRange(range);\n\n      if (range.isUnset) {\n        return false;\n      }\n\n      var toStart = PathUtils.compare(path, range.start.path);\n      var toEnd = PathUtils.compare(path, range.end.path);\n      var isInRange = toStart !== -1 && toEnd !== 1;\n      return isInRange;\n    }\n\n    /**\n     * Map all child nodes, updating them in their parents. This method is\n     * optimized to not return a new node if no changes are made.\n     *\n     * @param {Function} predicate\n     * @return {Node}\n     */\n\n  }, {\n    key: 'mapChildren',\n    value: function mapChildren() {\n      var _this2 = this;\n\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\n      var nodes = this.nodes;\n\n\n      nodes.forEach(function (node, i) {\n        var ret = predicate(node, i, _this2.nodes);\n        if (ret !== node) nodes = nodes.set(ret.key, ret);\n      });\n\n      var ret = this.set('nodes', nodes);\n      return ret;\n    }\n\n    /**\n     * Map all descendant nodes, updating them in their parents. This method is\n     * optimized to not return a new node if no changes are made.\n     *\n     * @param {Function} predicate\n     * @return {Node}\n     */\n\n  }, {\n    key: 'mapDescendants',\n    value: function mapDescendants() {\n      var _this3 = this;\n\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\n      var nodes = this.nodes;\n\n\n      nodes.forEach(function (node, index) {\n        var ret = node;\n        if (ret.object !== 'text') ret = ret.mapDescendants(predicate);\n        ret = predicate(ret, index, _this3.nodes);\n        if (ret === node) return;\n\n        nodes = nodes.set(index, ret);\n      });\n\n      var ret = this.set('nodes', nodes);\n      return ret;\n    }\n\n    /**\n     * Create an iteratable for all the marks in text nodes with `options`.\n     *\n     * @param {Options}\n     * @return {Iterable}\n     */\n\n  }, {\n    key: 'marks',\n    value: function marks() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var _options$onlyTypes = options.onlyTypes,\n          onlyTypes = _options$onlyTypes === undefined ? null : _options$onlyTypes,\n          match = options.match,\n          rest = objectWithoutProperties(options, ['onlyTypes', 'match']);\n\n      var texts = this.texts(rest);\n\n      return defineProperty({}, Symbol.iterator, function () {\n        var iterator = texts[Symbol.iterator]();\n        var node = null;\n        var path = null;\n        var remaining = [];\n\n        var next = function next() {\n          if (remaining.length) {\n            var mark = remaining.shift();\n\n            if (onlyTypes && !onlyTypes.includes(mark.type)) {\n              return next();\n            } else if (match && !match(mark, node, path)) {\n              return next();\n            }\n\n            return { value: [mark, node, path], done: false };\n          }\n\n          var _iterator$next = iterator.next(),\n              value = _iterator$next.value,\n              done = _iterator$next.done;\n\n          if (done) {\n            return { done: true };\n          }\n\n          \n          var _value = slicedToArray(value, 2);\n\n          node = _value[0];\n          path = _value[1];\n\n          remaining = node.marks.toArray();\n          return next();\n        };\n\n        return { next: next };\n      });\n    }\n\n    /**\n     * Merge a node backwards its previous sibling.\n     *\n     * @param {List|Key} path\n     * @return {Node}\n     */\n\n  }, {\n    key: 'mergeNode',\n    value: function mergeNode(path) {\n      var b = this.assertNode(path);\n      path = this.resolvePath(path);\n\n      if (path.last() === 0) {\n        throw new Error('Unable to merge node because it has no previous sibling: ' + b);\n      }\n\n      var withPath = PathUtils.decrement(path);\n      var a = this.assertNode(withPath);\n\n      if (a.object !== b.object) {\n        throw new Error('Unable to merge two different kinds of nodes: ' + a + ' and ' + b);\n      }\n\n      var newNode = a.object === 'text' ? a.mergeText(b) : a.set('nodes', a.nodes.concat(b.nodes));\n\n      var ret = this;\n      ret = ret.removeNode(path);\n      ret = ret.removeNode(withPath);\n      ret = ret.insertNode(withPath, newNode);\n      return ret;\n    }\n\n    /**\n     * Move a node by `path` to `newPath`.\n     *\n     * A `newIndex` can be provided when move nodes by `key`, to account for not\n     * being able to have a key for a location in the tree that doesn't exist yet.\n     *\n     * @param {List|Key} path\n     * @param {List|Key} newPath\n     * @param {Number} newIndex\n     * @return {Node}\n     */\n\n  }, {\n    key: 'moveNode',\n    value: function moveNode(path, newPath) {\n      var newIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n      var node = this.assertNode(path);\n      path = this.resolvePath(path);\n      newPath = this.resolvePath(newPath, newIndex);\n\n      var newParentPath = PathUtils.lift(newPath);\n      this.assertNode(newParentPath);\n\n      // TODO: this is a bit hacky, re-creating the operation that led to this method being called\n      // Alternative 1: pass the operation through from apply -> value.moveNode\n      // Alternative 2: add a third property to the operation called \"transformedNewPath\", pass that through\n      var op = Operation.create({\n        type: 'move_node',\n        path: path,\n        newPath: newPath\n      });\n      newPath = PathUtils.transform(path, op).first();\n\n      var ret = this;\n      ret = ret.removeNode(path);\n      ret = ret.insertNode(newPath, node);\n      return ret;\n    }\n\n    /**\n     * Remove `mark` from text at `path`.\n     *\n     * @param {List} path\n     * @param {Mark} mark\n     * @return {Node}\n     */\n\n  }, {\n    key: 'removeMark',\n    value: function removeMark(path, mark) {\n      path = this.resolvePath(path);\n      var node = this.assertDescendant(path);\n      node = node.removeMark(mark);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n\n    /**\n     * Remove a node.\n     *\n     * @param {List|String} path\n     * @return {Node}\n     */\n\n  }, {\n    key: 'removeNode',\n    value: function removeNode(path) {\n      this.assertDescendant(path);\n      path = this.resolvePath(path);\n      var deep = path.flatMap(function (x) {\n        return ['nodes', x];\n      });\n      var ret = this.deleteIn(deep);\n      return ret;\n    }\n\n    /**\n     * Remove `text` at `offset` in node.\n     *\n     * @param {List|Key} path\n     * @param {Number} offset\n     * @param {String} text\n     * @return {Node}\n     */\n\n  }, {\n    key: 'removeText',\n    value: function removeText(path, offset, text) {\n      var node = this.assertDescendant(path);\n      node = node.removeText(offset, text.length);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n\n    /**\n     * Replace a `node` in the tree.\n     *\n     * @param {List|Key} path\n     * @param {Node} node\n     * @return {Node}\n     */\n\n  }, {\n    key: 'replaceNode',\n    value: function replaceNode(path, node) {\n      path = this.resolvePath(path);\n\n      if (!path) {\n        throw new Error('Unable to replace a node because it could not be found in the first place: ' + path);\n      }\n\n      if (!path.size) return node;\n      this.assertNode(path);\n      var deep = path.flatMap(function (x) {\n        return ['nodes', x];\n      });\n      var ret = this.setIn(deep, node);\n      return ret;\n    }\n\n    /**\n     * Resolve a `annotation`, relative to the node, ensuring that the keys and\n     * offsets in the annotation exist and that they are synced with the paths.\n     *\n     * @param {Annotation|Object} annotation\n     * @return {Annotation}\n     */\n\n  }, {\n    key: 'resolveAnnotation',\n    value: function resolveAnnotation(annotation) {\n      annotation = Annotation.create(annotation);\n      annotation = annotation.normalize(this);\n      return annotation;\n    }\n\n    /**\n     * Resolve a `decoration`, relative to the node, ensuring that the keys and\n     * offsets in the decoration exist and that they are synced with the paths.\n     *\n     * @param {Decoration|Object} decoration\n     * @return {Decoration}\n     */\n\n  }, {\n    key: 'resolveDecoration',\n    value: function resolveDecoration(decoration) {\n      decoration = Decoration.create(decoration);\n      decoration = decoration.normalize(this);\n      return decoration;\n    }\n\n    /**\n     * Resolve a `point`, relative to the node, ensuring that the keys and\n     * offsets in the point exist and that they are synced with the paths.\n     *\n     * @param {Point|Object} point\n     * @return {Point}\n     */\n\n  }, {\n    key: 'resolvePoint',\n    value: function resolvePoint(point) {\n      point = Point.create(point);\n      point = point.normalize(this);\n      return point;\n    }\n\n    /**\n     * Resolve a `range`, relative to the node, ensuring that the keys and\n     * offsets in the range exist and that they are synced with the paths.\n     *\n     * @param {Range|Object} range\n     * @return {Range}\n     */\n\n  }, {\n    key: 'resolveRange',\n    value: function resolveRange(range) {\n      range = Range.create(range);\n      range = range.normalize(this);\n      return range;\n    }\n\n    /**\n     * Resolve a `selection`, relative to the node, ensuring that the keys and\n     * offsets in the selection exist and that they are synced with the paths.\n     *\n     * @param {Selection|Object} selection\n     * @return {Selection}\n     */\n\n  }, {\n    key: 'resolveSelection',\n    value: function resolveSelection(selection) {\n      selection = Selection.create(selection);\n      selection = selection.normalize(this);\n      return selection;\n    }\n\n    /**\n     * Set `properties` on a node.\n     *\n     * @param {List|String} path\n     * @param {Object} properties\n     * @return {Node}\n     */\n\n  }, {\n    key: 'setNode',\n    value: function setNode(path, properties) {\n      var node = this.assertNode(path);\n      node = node.merge(properties);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n\n    /**\n     * Set `properties` on `mark` on text at `offset` and `length` in node.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @param {Number} length\n     * @param {Mark} mark\n     * @param {Object} properties\n     * @return {Node}\n     */\n\n  }, {\n    key: 'setMark',\n    value: function setMark(path, properties, newProperties) {\n      path = this.resolvePath(path);\n      var node = this.assertDescendant(path);\n      node = node.setMark(properties, newProperties);\n      var ret = this.replaceNode(path, node);\n      return ret;\n    }\n\n    /**\n     * Create an iteratable for the siblings in the tree at `path`.\n     *\n     * @param {List|Array} path\n     * @return {Iterable}\n     */\n\n  }, {\n    key: 'siblings',\n    value: function siblings(path, options) {\n      var iterable = this.createIterable(_extends({\n        path: path,\n        upward: false,\n        downward: false\n      }, options));\n\n      return iterable;\n    }\n\n    /**\n     * Split a node by `path` at `position` with optional `properties` to apply\n     * to the newly split node.\n     *\n     * @param {List|String} path\n     * @param {Number} position\n     * @param {Object} properties\n     * @return {Node}\n     */\n\n  }, {\n    key: 'splitNode',\n    value: function splitNode(path, position, properties) {\n      var child = this.assertNode(path);\n      path = this.resolvePath(path);\n      var a = void 0;\n      var b = void 0;\n\n      if (child.object === 'text') {\n        \n        var _child$splitText = child.splitText(position);\n\n        var _child$splitText2 = slicedToArray(_child$splitText, 2);\n\n        a = _child$splitText2[0];\n        b = _child$splitText2[1];\n      } else {\n        var befores = child.nodes.take(position);\n        var afters = child.nodes.skip(position);\n        a = child.set('nodes', befores);\n        b = child.set('nodes', afters).regenerateKey();\n      }\n\n      if (properties && child.object !== 'text') {\n        b = b.merge(properties);\n      }\n\n      var ret = this;\n      ret = ret.removeNode(path);\n      ret = ret.insertNode(path, b);\n      ret = ret.insertNode(path, a);\n      return ret;\n    }\n\n    /**\n     * Create an iteratable for all the text node descendants.\n     *\n     * @param {Object} options\n     * @return {Iterable}\n     */\n\n  }, {\n    key: 'texts',\n    value: function texts(options) {\n      var iterable = this.descendants(_extends({\n        includeBlocks: false,\n        includeInlines: false,\n        includeDocument: false\n      }, options));\n\n      return iterable;\n    }\n\n    /**\n     * Deprecated.\n     */\n\n  }, {\n    key: 'getBlocksAtRange',\n    value: function getBlocksAtRange(range) {\n      warning(false, 'As of slate@0.44 the `node.getBlocksAtRange` method has been renamed to `getLeafBlocksAtRange`.');\n\n      return this.getLeafBlocksAtRange(range);\n    }\n  }, {\n    key: 'getBlocksAtRangeAsArray',\n    value: function getBlocksAtRangeAsArray(range) {\n      warning(false, 'As of slate@0.44 the `node.getBlocksAtRangeAsArray` method has been renamed to `getLeafBlocksAtRangeAsArray`.');\n\n      return this.getLeafBlocksAtRangeAsArray(range);\n    }\n  }, {\n    key: 'getInlinesAtRange',\n    value: function getInlinesAtRange(range) {\n      warning(false, 'As of slate@0.44 the `node.getInlinesAtRange` method has been renamed to `getLeafInlinesAtRange`.');\n\n      return this.getLeafInlinesAtRange(range);\n    }\n  }, {\n    key: 'getInlinesAtRangeAsArray',\n    value: function getInlinesAtRangeAsArray(range) {\n      warning(false, 'As of slate@0.44 the `node.getInlinesAtRangeAsArray` method has been renamed to `getLeafInlinesAtRangeAsArray`.');\n\n      return this.getLeafInlinesAtRangeAsArray(range);\n    }\n  }, {\n    key: 'getNextTextAndPath',\n    value: function getNextTextAndPath(path) {\n      warning(false, 'As of slate@0.47, the `getNextTextAndPath` method has been renamed to `getNextTextEntry`.');\n\n      return this.getNextTextEntry(path);\n    }\n  }, {\n    key: 'getNextDeepMatchingNodeAndPath',\n    value: function getNextDeepMatchingNodeAndPath(path) {\n      var iterator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n\n      warning(false, 'As of slate@0.47, the `getNextDeepMatchingNodeAndPath` method is deprecated.');\n\n      var match = this.getNextMatchingNodeAndPath(path);\n\n      if (!match) return null;\n\n      var _match3 = slicedToArray(match, 2),\n          nextNode = _match3[0],\n          nextPath = _match3[1];\n\n      var childMatch = void 0;\n\n      var assign = function assign() {\n        childMatch = nextNode.object !== 'text' && nextNode.findFirstDescendantAndPath(iterator, nextPath);\n        return childMatch;\n      };\n\n      while (assign(childMatch)) {\n        var _childMatch = childMatch;\n\n        var _childMatch2 = slicedToArray(_childMatch, 2);\n\n        nextNode = _childMatch2[0];\n        nextPath = _childMatch2[1];\n      }\n\n      if (!nextNode) return null;\n\n      return iterator(nextNode) ? [nextNode, nextPath] : this.getNextDeepMatchingNodeAndPath(match[1], iterator);\n    }\n  }, {\n    key: 'getPreviousTextAndPath',\n    value: function getPreviousTextAndPath(path) {\n      warning(false, 'As of slate@0.47, the `getPreviousTextAndPath` method has been renamed to `getPreviousTextEntry`.');\n\n      return this.getPreviousTextEntry(path);\n    }\n  }, {\n    key: 'findFirstDescendantAndPath',\n    value: function findFirstDescendantAndPath(iterator, pathToThisNode) {\n      warning(false, 'As of slate@0.47, the `findFirstDescendantAndPath` method is deprecated.');\n\n      return this.findDescendantAndPath(iterator, pathToThisNode, false);\n    }\n  }, {\n    key: 'getPreviousMatchingNodeAndPath',\n    value: function getPreviousMatchingNodeAndPath(path) {\n      var iterator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n\n      warning(false, 'As of slate@0.47, the `getPreviousMatchingNodeAndPath` method is deprecated.');\n\n      if (!path) return null;\n\n      for (var i = path.size; i > 0; i--) {\n        var p = path.slice(0, i);\n        if (p.last() === 0) continue;\n\n        var previousPath = PathUtils.decrement(p);\n        var previousNode = this.getNode(previousPath);\n\n        while (previousNode && !iterator(previousNode)) {\n          previousPath = PathUtils.decrement(previousPath);\n          previousNode = this.getNode(previousPath);\n        }\n\n        if (previousNode) return [previousNode, previousPath];\n      }\n\n      return null;\n    }\n  }, {\n    key: 'getPreviousDeepMatchingNodeAndPath',\n    value: function getPreviousDeepMatchingNodeAndPath(path) {\n      var iterator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n\n      warning(false, 'As of slate@0.47, the `getPreviousDeepMatchingNodeAndPath` method is deprecated.');\n\n      var match = this.getPreviousMatchingNodeAndPath(path);\n\n      if (!match) return null;\n\n      var _match4 = slicedToArray(match, 2),\n          previousNode = _match4[0],\n          previousPath = _match4[1];\n\n      var childMatch = void 0;\n\n      var assign = function assign() {\n        childMatch = previousNode.object !== 'text' && previousNode.findLastDescendantAndPath(iterator, previousPath);\n        return childMatch;\n      };\n\n      while (assign(childMatch)) {\n        var _childMatch3 = childMatch;\n\n        var _childMatch4 = slicedToArray(_childMatch3, 2);\n\n        previousNode = _childMatch4[0];\n        previousPath = _childMatch4[1];\n      }\n\n      if (!previousNode) return null;\n\n      return iterator(previousNode) ? [previousNode, previousPath] : this.getPreviousDeepMatchingNodeAndPath(match[1], iterator);\n    }\n  }, {\n    key: 'findLastDescendantAndPath',\n    value: function findLastDescendantAndPath(iterator, pathToThisNode) {\n      warning(false, 'As of slate@0.47, the `findLastDescendantAndPath` method is deprecated.');\n\n      return this.findDescendantAndPath(iterator, pathToThisNode, true);\n    }\n  }, {\n    key: 'findDescendantAndPath',\n    value: function findDescendantAndPath(iterator) {\n      var pathToThisNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PathUtils.create([]);\n      var findLast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n      warning(false, 'As of slate@0.47, the `findDescendantAndPath` method is deprecated.');\n\n      var found = void 0;\n      var foundPath = void 0;\n\n      this.forEachDescendantWithPath(function (node, path, nodes) {\n        if (iterator(node, path, nodes)) {\n          found = node;\n          foundPath = path;\n          return false;\n        }\n      }, pathToThisNode, findLast);\n\n      return found ? [found, foundPath] : null;\n    }\n  }, {\n    key: 'forEachDescendantWithPath',\n    value: function forEachDescendantWithPath(iterator) {\n      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PathUtils.create([]);\n      var findLast = arguments[2];\n\n      warning(false, 'As of slate@0.47, the `forEachDescendantWithPath` method is deprecated.');\n\n      var nodes = this.nodes;\n      var ret = void 0;\n\n      if (findLast) nodes = nodes.reverse();\n\n      nodes.forEach(function (child, i) {\n        var childPath = path.concat(i);\n\n        if (iterator(child, childPath, nodes) === false) {\n          ret = false;\n          return false;\n        }\n\n        if (child.object !== 'text') {\n          ret = child.forEachDescendantWithPath(iterator, childPath, findLast);\n          return ret;\n        }\n      });\n\n      return ret;\n    }\n  }, {\n    key: 'getNextMatchingNodeAndPath',\n    value: function getNextMatchingNodeAndPath(path) {\n      var iterator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n        return true;\n      };\n\n      warning(false, 'As of slate@0.47, the `getNextMatchingNodeAndPath` method is deprecated.');\n\n      if (!path) return null;\n\n      for (var i = path.size; i > 0; i--) {\n        var p = path.slice(0, i);\n\n        var nextPath = PathUtils.increment(p);\n        var nextNode = this.getNode(nextPath);\n\n        while (nextNode && !iterator(nextNode)) {\n          nextPath = PathUtils.increment(nextPath);\n          nextNode = this.getNode(nextPath);\n        }\n\n        if (nextNode) return [nextNode, nextPath];\n      }\n\n      return null;\n    }\n  }, {\n    key: 'getSelectionIndexes',\n    value: function getSelectionIndexes(range) {\n      var isSelected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      warning(false, 'As of slate@0.47, the `getSelectionIndexes` method is deprecated.');\n\n      var start = range.start,\n          end = range.end;\n\n      // PERF: if we're not selected, we can exit early.\n\n      if (!isSelected) {\n        return null;\n      }\n\n      // PERF: if we've been given an invalid selection we can exit early.\n      if (range.isUnset) {\n        return null;\n      }\n\n      // PERF: if the start and end keys are the same, just check for the child\n      // that contains that single key.\n      if (start.path.equals(end.path)) {\n        var child = this.getFurthestAncestor(start.path);\n        var index = child ? this.nodes.indexOf(child) : null;\n        return { start: index, end: index + 1 };\n      }\n\n      // Otherwise, check all of the children...\n      var startIndex = null;\n      var endIndex = null;\n\n      this.nodes.forEach(function (child, i) {\n        if (child.object === 'text') {\n          if (startIndex == null && child.key === start.key) startIndex = i;\n          if (endIndex == null && child.key === end.key) endIndex = i + 1;\n        } else {\n          if (startIndex == null && child.hasDescendant(start.key)) startIndex = i;\n          if (endIndex == null && child.hasDescendant(end.key)) endIndex = i + 1;\n        }\n\n        // PERF: exit early if both start and end have been found.\n        return startIndex == null || endIndex == null;\n      });\n\n      if (isSelected && startIndex == null) {\n        startIndex = 0;\n      }\n\n      if (isSelected && endIndex == null) {\n        endIndex = this.nodes.size;\n      }\n\n      if (startIndex == null) {\n        return null;\n      }\n\n      return { start: startIndex, end: endIndex };\n    }\n  }, {\n    key: 'getTextsBetweenPositionsAsArray',\n    value: function getTextsBetweenPositionsAsArray(startPath, endPath) {\n      warning(false, 'As of slate@0.47, the `getTextsBetweenPositionsAsArray` method is deprecated.');\n\n      startPath = this.resolvePath(startPath);\n      endPath = this.resolvePath(endPath);\n\n      return this.getTextsBetweenPathPositionsAsArray(startPath, endPath);\n    }\n  }, {\n    key: 'getOrderedMarksBetweenPositions',\n    value: function getOrderedMarksBetweenPositions(startPath, startOffset, endPath, endOffset) {\n      warning(false, 'As of slate@0.47, the `getOrderedMarksBetweenPositions` method is deprecated.');\n\n      startPath = this.resolvePath(startPath);\n      endPath = this.resolvePath(endPath);\n      var startText = this.getDescendant(startPath);\n\n      // PERF: if the paths are equal, we can just use the start.\n      if (PathUtils.isEqual(startPath, endPath)) {\n        return startText.marks;\n      }\n\n      var texts = this.getTextsBetweenPathPositionsAsArray(startPath, endPath);\n\n      return immutable.OrderedSet().withMutations(function (result) {\n        texts.forEach(function (text) {\n          result.union(text.marks);\n        });\n      });\n    }\n  }, {\n    key: 'getTextsBetweenPathPositionsAsArray',\n    value: function getTextsBetweenPathPositionsAsArray(startPath, endPath) {\n      warning(false, 'As of slate@0.47, the `getTextsBetweenPathPositionsAsArray` method is deprecated.');\n\n      // PERF: the most common case is when the range is in a single text node,\n      // where we can avoid a lot of iterating of the tree.\n      if (startPath && endPath && PathUtils.isEqual(startPath, endPath)) {\n        return [this.getDescendant(startPath)];\n      } else if (!startPath && !endPath) {\n        return this.getTextsAsArray();\n      }\n\n      var startIndex = startPath ? startPath.get(0, 0) : 0;\n      var endIndex = endPath ? endPath.get(0, this.nodes.size - 1) : this.nodes.size - 1;\n\n      var array = [];\n\n      this.nodes.slice(startIndex, endIndex + 1).forEach(function (node, i) {\n        if (node.object === 'text') {\n          array.push(node);\n        } else {\n          // For the node at start and end of this list, we want to provide a start and end path\n          // For other nodes, we can just get all their text nodes, they are between the paths\n          var childStartPath = startPath && i === 0 ? PathUtils.drop(startPath) : null;\n          var childEndPath = endPath && i === endIndex - startIndex ? PathUtils.drop(endPath) : null;\n\n          array = array.concat(node.getTextsBetweenPathPositionsAsArray(childStartPath, childEndPath));\n        }\n      });\n\n      return array;\n    }\n  }, {\n    key: 'getFurthestAncestor',\n    value: function getFurthestAncestor(path) {\n      warning(false, 'As of slate@0.47, the `getFurthestAncestor` method has been renamed to `getFurthestChild`.');\n\n      return this.getFurthestChild(path);\n    }\n  }, {\n    key: 'getLeafBlocksAtRangeAsArray',\n    value: function getLeafBlocksAtRangeAsArray(range) {\n      warning(false, 'As of slate@0.47, the `getLeafBlocksAtRangeAsArray` method is deprecated.');\n\n      range = this.resolveRange(range);\n      if (range.isUnset) return [];\n\n      var _range6 = range,\n          start = _range6.start,\n          end = _range6.end;\n\n\n      return this.getLeafBlocksBetweenPathPositionsAsArray(start.path, end.path);\n    }\n  }, {\n    key: 'getLeafBlocksBetweenPathPositionsAsArray',\n    value: function getLeafBlocksBetweenPathPositionsAsArray(startPath, endPath) {\n      warning(false, 'As of slate@0.47, the `getLeafBlocksBetweenPathPositionsAsArray` method is deprecated.');\n\n      // PERF: the most common case is when the range is in a single block node,\n      // where we can avoid a lot of iterating of the tree.\n      if (startPath && endPath && PathUtils.isEqual(startPath, endPath)) {\n        return [this.getClosestBlock(startPath)];\n      } else if (!startPath && !endPath) {\n        return this.getBlocksAsArray();\n      }\n\n      var startIndex = startPath ? startPath.get(0, 0) : 0;\n      var endIndex = endPath ? endPath.get(0, this.nodes.size - 1) : this.nodes.size - 1;\n\n      var array = [];\n\n      this.nodes.slice(startIndex, endIndex + 1).forEach(function (node, i) {\n        if (node.object !== 'block') {\n          return;\n        } else if (node.isLeafBlock()) {\n          array.push(node);\n        } else {\n          var childStartPath = startPath && i === 0 ? PathUtils.drop(startPath) : null;\n          var childEndPath = endPath && i === endIndex - startIndex ? PathUtils.drop(endPath) : null;\n\n          array = array.concat(node.getLeafBlocksBetweenPathPositionsAsArray(childStartPath, childEndPath));\n        }\n      });\n\n      return array;\n    }\n  }, {\n    key: 'getBlocksAsArray',\n    value: function getBlocksAsArray() {\n      warning(false, 'As of slate@0.47, the `getBlocksAsArray` method is deprecated.');\n\n      var iterable = this.blocks({ onlyLeaves: true });\n      var array = Array.from(iterable, function (_ref43) {\n        var _ref44 = slicedToArray(_ref43, 1),\n            node = _ref44[0];\n\n        return node;\n      });\n      return array;\n    }\n  }, {\n    key: 'getBlocksByTypeAsArray',\n    value: function getBlocksByTypeAsArray(type) {\n      warning(false, 'As of slate@0.47, the `getBlocksByTypeAsArray` method is deprecated.');\n\n      var iterable = this.blocks({ onlyLeaves: true, onlyTypes: [type] });\n      var array = Array.from(iterable, function (_ref45) {\n        var _ref46 = slicedToArray(_ref45, 1),\n            node = _ref46[0];\n\n        return node;\n      });\n      return array;\n    }\n  }, {\n    key: 'getFurthestOnlyChildAncestor',\n    value: function getFurthestOnlyChildAncestor(path) {\n      warning(false, 'As of slate@0.47, the `getFurthestOnlyChildAncestor` method is deprecated.');\n\n      var ancestors = this.getAncestors(path);\n      if (!ancestors) return null;\n\n      var furthest = ancestors.rest().reverse().takeUntil(function (p) {\n        return p.nodes.size > 1;\n      }).last();\n\n      return furthest || null;\n    }\n  }, {\n    key: 'getInlinesAsArray',\n    value: function getInlinesAsArray() {\n      warning(false, 'As of slate@0.47, the `getInlinesAsArray` method is deprecated.');\n\n      var array = Array.from(this.inlines({ onlyLeaves: true }), function (_ref47) {\n        var _ref48 = slicedToArray(_ref47, 1),\n            node = _ref48[0];\n\n        return node;\n      });\n      return array;\n    }\n  }, {\n    key: 'getInlinesByTypeAsArray',\n    value: function getInlinesByTypeAsArray(type) {\n      warning(false, 'As of slate@0.47, the `getInlinesByTypeAsArray` method is deprecated.');\n\n      var array = Array.from(this.inlines({ onlyLeaves: true, onlyTypes: [type] }), function (_ref49) {\n        var _ref50 = slicedToArray(_ref49, 1),\n            node = _ref50[0];\n\n        return node;\n      });\n      return array;\n    }\n  }, {\n    key: 'getLeafInlinesAtRangeAsArray',\n    value: function getLeafInlinesAtRangeAsArray(range) {\n      var _this4 = this;\n\n      warning(false, 'As of slate@0.47, the `getLeafInlinesAtRangeAsArray` method is deprecated.');\n\n      range = this.resolveRange(range);\n      if (range.isUnset) return [];\n\n      var array = this.getTextsAtRangeAsArray(range).map(function (text) {\n        return _this4.getClosestInline(text.key);\n      }).filter(function (exists) {\n        return exists;\n      });\n\n      return array;\n    }\n  }, {\n    key: 'getOrderedMarks',\n    value: function getOrderedMarks() {\n      warning(false, 'As of slate@0.47, the `getOrderedMarks` method has been folded into `getMarks`, which will now return an ordered set.');\n      return this.getMarks();\n    }\n  }, {\n    key: 'getOrderedMarksAtRange',\n    value: function getOrderedMarksAtRange(range) {\n      warning(false, 'As of slate@0.47, the `getOrderedMarksAtRange` method has been folded into `getMarksAtRange`, which will now return an ordered set.');\n      return this.getMarksAtRange(range);\n    }\n  }, {\n    key: 'getOrderedMarksByType',\n    value: function getOrderedMarksByType(type) {\n      warning(false, 'As of slate@0.47, the `getOrderedMarksByType` method has been folded into `getMarksByType`, which will now return an ordered set.');\n      return this.getMarksByType(type);\n    }\n  }, {\n    key: 'getMarksByTypeAsArray',\n    value: function getMarksByTypeAsArray(type) {\n      warning(false, 'As of slate@0.47, the `getMarksByTypeAsArray` method is deprecated.');\n\n      var array = this.nodes.reduce(function (memo, node) {\n        return node.object === 'text' ? memo.concat(node.marks.filter(function (m) {\n          return m.type === type;\n        })) : memo.concat(node.getMarksByTypeAsArray(type));\n      }, []);\n\n      return array;\n    }\n  }, {\n    key: 'getMarksAsArray',\n    value: function getMarksAsArray() {\n      var _ref53;\n\n      warning(false, 'As of slate@0.47, the `getMarksAsArray` method is deprecated.');\n\n      var result = [];\n\n      var _iteratorNormalCompletion8 = true;\n      var _didIteratorError8 = false;\n      var _iteratorError8 = undefined;\n\n      try {\n        for (var _iterator8 = this.texts()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\n          var _ref51 = _step8.value;\n\n          var _ref52 = slicedToArray(_ref51, 1);\n\n          var node = _ref52[0];\n\n          result.push(node.marks.toArray());\n        }\n\n        // PERF: use only one concat rather than multiple for speed.\n      } catch (err) {\n        _didIteratorError8 = true;\n        _iteratorError8 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion8 && _iterator8.return) {\n            _iterator8.return();\n          }\n        } finally {\n          if (_didIteratorError8) {\n            throw _iteratorError8;\n          }\n        }\n      }\n\n      var array = (_ref53 = []).concat.apply(_ref53, result);\n      return array;\n    }\n  }, {\n    key: 'getRootInlinesAtRangeAsArray',\n    value: function getRootInlinesAtRangeAsArray(range) {\n      var _this5 = this;\n\n      warning(false, 'As of slate@0.47, the `getRootInlinesAtRangeAsArray` method is deprecated.');\n\n      range = this.resolveRange(range);\n      if (range.isUnset) return immutable.List();\n\n      var array = this.getTextsAtRangeAsArray(range).map(function (text) {\n        return _this5.getFurthestInline(text.key);\n      }).filter(function (exists) {\n        return exists;\n      });\n\n      return array;\n    }\n  }, {\n    key: 'getTextsAsArray',\n    value: function getTextsAsArray() {\n      warning(false, 'As of slate@0.47, the `getTextsAsArray` method is deprecated.');\n\n      var iterable = this.texts();\n      var array = Array.from(iterable, function (_ref54) {\n        var _ref55 = slicedToArray(_ref54, 1),\n            node = _ref55[0];\n\n        return node;\n      });\n      return array;\n    }\n  }, {\n    key: 'getTextsAtRangeAsArray',\n    value: function getTextsAtRangeAsArray(range) {\n      warning(false, 'As of slate@0.47, the `getTextsAtRangeAsArray` method is deprecated.');\n\n      var iterable = this.texts({ range: range });\n      var array = Array.from(iterable, function (_ref56) {\n        var _ref57 = slicedToArray(_ref56, 1),\n            node = _ref57[0];\n\n        return node;\n      });\n      return array;\n    }\n  }, {\n    key: 'getMarksAtPosition',\n    value: function getMarksAtPosition(path, offset) {\n      warning(false, 'As of slate@0.47, the `getMarksAtPosition` method is deprecated.');\n\n      path = this.resolvePath(path);\n      var text = this.getDescendant(path);\n      var currentMarks = text.marks;\n\n      if (offset !== 0) {\n        return immutable.OrderedSet(currentMarks);\n      }\n\n      var closestBlock = this.getClosestBlock(path);\n\n      // insert mark for empty block; the empty block are often created by split node or add marks in a range including empty blocks\n      if (closestBlock.text === '') {\n        return immutable.OrderedSet(currentMarks);\n      }\n\n      var _texts13 = this.texts({ path: path, direction: 'backward' }),\n          _texts14 = slicedToArray(_texts13, 1),\n          previous = _texts14[0];\n\n      if (!previous) {\n        return immutable.OrderedSet();\n      }\n\n      var _previous2 = slicedToArray(previous, 2),\n          previousText = _previous2[0],\n          previousPath = _previous2[1];\n\n      if (closestBlock.hasDescendant(previousPath)) {\n        return immutable.OrderedSet(previousText.marks);\n      }\n\n      return immutable.OrderedSet(currentMarks);\n    }\n  }, {\n    key: 'getNodesAtRange',\n    value: function getNodesAtRange(range) {\n      warning(false, 'As of slate@0.47, the `getNodesAtRange` method has been renamed to `getDescendantsAtRange`.');\n\n      var iterable = this.descendants({ range: range });\n      var array = Array.from(iterable, function (_ref58) {\n        var _ref59 = slicedToArray(_ref58, 1),\n            node = _ref59[0];\n\n        return node;\n      });\n      var list = immutable.List(array);\n      return list;\n    }\n  }, {\n    key: 'isNodeInRange',\n    value: function isNodeInRange(path, range) {\n      warning(false, 'As of slate@0.47, the `isNodeInRange` method has been renamed to `isInRange`.');\n\n      return this.isInRange(path, range);\n    }\n  }, {\n    key: 'text',\n\n    /**\n     * Get the concatenated text of the node.\n     *\n     * @return {String}\n     */\n\n    get: function get$$1() {\n      return this.getText();\n    }\n  }]);\n  return ElementInterface;\n}();\n\n/**\n * Mix in assertion variants.\n */\n\nvar ASSERTS = ['Child', 'Depth', 'Descendant', 'Node', 'Parent', 'Path'];\n\nvar _loop$1 = function _loop(method) {\n  ElementInterface.prototype['assert' + method] = function (path) {\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    var ret = this['get' + method].apply(this, [path].concat(args));\n\n    if (ret == null) {\n      throw new Error('`Node.assert' + method + '` could not find node with path or key: ' + path);\n    }\n\n    return ret;\n  };\n};\n\nvar _iteratorNormalCompletion9 = true;\nvar _didIteratorError9 = false;\nvar _iteratorError9 = undefined;\n\ntry {\n  for (var _iterator9 = ASSERTS[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\n    var method$1 = _step9.value;\n\n    _loop$1(method$1);\n  }\n\n  /**\n   * Memoize read methods.\n   */\n} catch (err) {\n  _didIteratorError9 = true;\n  _iteratorError9 = err;\n} finally {\n  try {\n    if (!_iteratorNormalCompletion9 && _iterator9.return) {\n      _iterator9.return();\n    }\n  } finally {\n    if (_didIteratorError9) {\n      throw _iteratorError9;\n    }\n  }\n}\n\nmemoize(ElementInterface.prototype, ['getBlocksAsArray', 'getBlocksByTypeAsArray', 'getDecorations', 'getFragmentAtRange', 'getInlinesAsArray', 'getInlinesByTypeAsArray', 'getInsertMarksAtRange', 'getLeafBlocksAtRangeAsArray', 'getLeafBlocksAtRangeAsArray', 'getLeafInlinesAtRangeAsArray', 'getMarksAsArray', 'getMarksAtPosition', 'getMarksByTypeAsArray', 'getNextBlock', 'getNodesAtRange', 'getNodesToPathsMap', 'getOffset', 'getOffsetAtRange', 'getOrderedMarksBetweenPositions', 'getPreviousBlock', 'getRootBlocksAtRange', 'getRootInlinesAtRangeAsArray', 'getTextAtOffset', 'getTextDirection', 'getTextsAsArray', 'getTextsBetweenPathPositionsAsArray']);\n\n/**\n * Mix in the element interface.\n */\n\nmixin(ElementInterface, [Block, Document, Inline]);\n\n/**\n * The interface that `Decoration`, `Range` and `Selection` all implement, to make\n * working anchor and focus points easier.\n *\n * @type {Class}\n */\n\nvar RangeInterface = function () {\n  function RangeInterface() {\n    classCallCheck(this, RangeInterface);\n  }\n\n  createClass(RangeInterface, [{\n    key: 'flip',\n\n\n    /**\n     * Flip the range.\n     *\n     * @return {Range}\n     */\n\n    value: function flip() {\n      var range = this.setPoints([this.focus, this.anchor]);\n      return range;\n    }\n\n    /**\n     * Move the anchor and focus offsets forward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveForward',\n    value: function moveForward(n) {\n      return this.updatePoints(function (point) {\n        return point.moveForward(n);\n      });\n    }\n\n    /**\n     * Move the anchor and focus offsets backward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveBackward',\n    value: function moveBackward(n) {\n      return this.updatePoints(function (point) {\n        return point.moveBackward(n);\n      });\n    }\n\n    /**\n     * Move the anchor offset backward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorBackward',\n    value: function moveAnchorBackward(n) {\n      var range = this.setAnchor(this.anchor.moveBackward(n));\n      return range;\n    }\n\n    /**\n     * Move the anchor offset forward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorForward',\n    value: function moveAnchorForward(n) {\n      var range = this.setAnchor(this.anchor.moveForward(n));\n      return range;\n    }\n\n    /**\n     * Move the range's anchor point to a new `path` and `offset`.\n     *\n     * Optionally, the `path` can be a key string, or omitted entirely in which\n     * case it would be the offset number.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorTo',\n    value: function moveAnchorTo(path, offset) {\n      var range = this.setAnchor(this.anchor.moveTo(path, offset));\n      return range;\n    }\n\n    /**\n     * Move the range's anchor point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorToStartOfNode',\n    value: function moveAnchorToStartOfNode(node) {\n      var range = this.setAnchor(this.anchor.moveToStartOfNode(node));\n      return range;\n    }\n\n    /**\n     * Move the range's anchor point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveAnchorToEndOfNode',\n    value: function moveAnchorToEndOfNode(node) {\n      var range = this.setAnchor(this.anchor.moveToEndOfNode(node));\n      return range;\n    }\n\n    /**\n     * Move the end offset backward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveEndBackward',\n    value: function moveEndBackward(n) {\n      var range = this.setEnd(this.end.moveBackward(n));\n      return range;\n    }\n\n    /**\n     * Move the end offset forward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveEndForward',\n    value: function moveEndForward(n) {\n      var range = this.setEnd(this.end.moveForward(n));\n      return range;\n    }\n\n    /**\n     * Move the range's end point to a new `path` and `offset`.\n     *\n     * Optionally, the `path` can be a key string, or omitted entirely in which\n     * case it would be the offset number.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveEndTo',\n    value: function moveEndTo(path, offset) {\n      var range = this.setEnd(this.end.moveTo(path, offset));\n      return range;\n    }\n\n    /**\n     * Move the range's end point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveEndToStartOfNode',\n    value: function moveEndToStartOfNode(node) {\n      var range = this.setEnd(this.end.moveToStartOfNode(node));\n      return range;\n    }\n\n    /**\n     * Move the range's end point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveEndToEndOfNode',\n    value: function moveEndToEndOfNode(node) {\n      var range = this.setEnd(this.end.moveToEndOfNode(node));\n      return range;\n    }\n\n    /**\n     * Move the focus offset backward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusBackward',\n    value: function moveFocusBackward(n) {\n      var range = this.setFocus(this.focus.moveBackward(n));\n      return range;\n    }\n\n    /**\n     * Move the focus offset forward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusForward',\n    value: function moveFocusForward(n) {\n      var range = this.setFocus(this.focus.moveForward(n));\n      return range;\n    }\n\n    /**\n     * Move the range's focus point to a new `path` and `offset`.\n     *\n     * Optionally, the `path` can be a key string, or omitted entirely in which\n     * case it would be the offset number.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusTo',\n    value: function moveFocusTo(path, offset) {\n      var range = this.setFocus(this.focus.moveTo(path, offset));\n      return range;\n    }\n\n    /**\n     * Move the range's focus point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusToStartOfNode',\n    value: function moveFocusToStartOfNode(node) {\n      var range = this.setFocus(this.focus.moveToStartOfNode(node));\n      return range;\n    }\n\n    /**\n     * Move the range's focus point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveFocusToEndOfNode',\n    value: function moveFocusToEndOfNode(node) {\n      var range = this.setFocus(this.focus.moveToEndOfNode(node));\n      return range;\n    }\n\n    /**\n     * Move the start offset backward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveStartBackward',\n    value: function moveStartBackward(n) {\n      var range = this.setStart(this.start.moveBackward(n));\n      return range;\n    }\n\n    /**\n     * Move the start offset forward `n` characters.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveStartForward',\n    value: function moveStartForward(n) {\n      var range = this.setStart(this.start.moveForward(n));\n      return range;\n    }\n\n    /**\n     * Move the range's start point to a new `path` and `offset`.\n     *\n     * Optionally, the `path` can be a key string, or omitted entirely in which\n     * case it would be the offset number.\n     *\n     * @param {List|String} path\n     * @param {Number} offset\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveStartTo',\n    value: function moveStartTo(path, offset) {\n      var range = this.setStart(this.start.moveTo(path, offset));\n      return range;\n    }\n\n    /**\n     * Move the range's start point to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveStartToStartOfNode',\n    value: function moveStartToStartOfNode(node) {\n      var range = this.setStart(this.start.moveToStartOfNode(node));\n      return range;\n    }\n\n    /**\n     * Move the range's start point to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveStartToEndOfNode',\n    value: function moveStartToEndOfNode(node) {\n      var range = this.setStart(this.start.moveToEndOfNode(node));\n      return range;\n    }\n\n    /**\n     * Move range's points to a new `path` and `offset`.\n     *\n     * @param {Number} n\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveTo',\n    value: function moveTo(path, offset) {\n      return this.updatePoints(function (point) {\n        return point.moveTo(path, offset);\n      });\n    }\n\n    /**\n     * Move the focus point to the anchor point.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToAnchor',\n    value: function moveToAnchor() {\n      var range = this.setFocus(this.anchor);\n      return range;\n    }\n\n    /**\n     * Move the start point to the end point.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToEnd',\n    value: function moveToEnd() {\n      var range = this.setStart(this.end);\n      return range;\n    }\n\n    /**\n     * Move the range's points to the end of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToEndOfNode',\n    value: function moveToEndOfNode(node) {\n      return this.updatePoints(function (point) {\n        return point.moveToEndOfNode(node);\n      });\n    }\n\n    /**\n     * Move the anchor point to the focus point.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToFocus',\n    value: function moveToFocus() {\n      var range = this.setAnchor(this.focus);\n      return range;\n    }\n\n    /**\n     * Move to the entire range of `start` and `end` nodes.\n     *\n     * @param {Node} start\n     * @param {Node} end (optional)\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToRangeOfNode',\n    value: function moveToRangeOfNode(start) {\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : start;\n\n      var range = this.setPoints([this.anchor.moveToStartOfNode(start), this.focus.moveToEndOfNode(end)]);\n\n      return range;\n    }\n\n    /**\n     * Move the end point to the start point.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToStart',\n    value: function moveToStart() {\n      var range = this.setEnd(this.start);\n      return range;\n    }\n\n    /**\n     * Move the range's points to the start of a `node`.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'moveToStartOfNode',\n    value: function moveToStartOfNode(node) {\n      return this.updatePoints(function (point) {\n        return point.moveToStartOfNode(node);\n      });\n    }\n\n    /**\n     * Normalize the range, relative to a `node`, ensuring that the anchor\n     * and focus nodes of the range always refer to leaf text nodes.\n     *\n     * @param {Node} node\n     * @return {Range}\n     */\n\n  }, {\n    key: 'normalize',\n    value: function normalize(node) {\n      return this.updatePoints(function (point) {\n        return point.normalize(node);\n      });\n    }\n\n    /**\n     * Set the anchor point to a new `anchor`.\n     *\n     * @param {Point} anchor\n     * @return {Range}\n     */\n\n  }, {\n    key: 'setAnchor',\n    value: function setAnchor(anchor) {\n      var range = this.set('anchor', anchor);\n      return range;\n    }\n\n    /**\n     * Set the end point to a new `point`.\n     *\n     * @param {Point} point\n     * @return {Range}\n     */\n\n  }, {\n    key: 'setEnd',\n    value: function setEnd(point) {\n      var range = this.isBackward ? this.setAnchor(point) : this.setFocus(point);\n      return range;\n    }\n\n    /**\n     * Set the focus point to a new `focus`.\n     *\n     * @param {Point} focus\n     * @return {Range}\n     */\n\n  }, {\n    key: 'setFocus',\n    value: function setFocus(focus) {\n      var range = this.set('focus', focus);\n      return range;\n    }\n\n    /**\n     * Set the anchor and focus points to new `values`.\n     *\n     * @param {Array<Point>} values\n     * @return {Range}\n     */\n\n  }, {\n    key: 'setPoints',\n    value: function setPoints(values) {\n      var _values = slicedToArray(values, 2),\n          anchor = _values[0],\n          focus = _values[1];\n\n      var range = this.set('anchor', anchor).set('focus', focus);\n      return range;\n    }\n\n    /**\n     * Set the anchor and focus points with `updater` callback\n     *\n     * @param {Function} updater\n     * @return {Range}\n     */\n\n  }, {\n    key: 'updatePoints',\n    value: function updatePoints(updater) {\n      var anchor = this.anchor,\n          focus = this.focus;\n\n      anchor = updater(anchor);\n      focus = updater(focus);\n      return this.merge({ anchor: anchor, focus: focus });\n    }\n\n    /**\n     * Set the start point to a new `point`.\n     *\n     * @param {Point} point\n     * @return {Range}\n     */\n\n  }, {\n    key: 'setStart',\n    value: function setStart(point) {\n      var range = this.isBackward ? this.setFocus(point) : this.setAnchor(point);\n      return range;\n    }\n\n    /**\n     * Set new `properties` on the range.\n     *\n     * @param {Object|Range} properties\n     * @return {Range}\n     */\n\n  }, {\n    key: 'setProperties',\n    value: function setProperties(properties) {\n      properties = Range.createProperties(properties);\n      var _properties = properties,\n          anchor = _properties.anchor,\n          focus = _properties.focus,\n          props = objectWithoutProperties(_properties, ['anchor', 'focus']);\n\n\n      if (anchor) {\n        props.anchor = Point.create(anchor);\n      }\n\n      if (focus) {\n        props.focus = Point.create(focus);\n      }\n\n      var range = this.merge(props);\n      return range;\n    }\n\n    /**\n     * Return a JSON representation of the range.\n     *\n     * @param {Object} options\n     * @return {Object}\n     */\n\n  }, {\n    key: 'toJSON',\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      var object = {\n        object: this.object,\n        anchor: this.anchor.toJSON(options),\n        focus: this.focus.toJSON(options)\n      };\n\n      return object;\n    }\n\n    /**\n     * Return a `Range` instance from any range-like instance.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'toRange',\n    value: function toRange() {\n      var properties = Range.createProperties(this);\n      var range = Range.create(properties);\n      return range;\n    }\n\n    /**\n     * Unset the range.\n     *\n     * @return {Range}\n     */\n\n  }, {\n    key: 'unset',\n    value: function unset() {\n      var range = this.updatePoints(function (p) {\n        return p.unset();\n      });\n      return range;\n    }\n  }, {\n    key: 'isCollapsed',\n\n    /**\n     * Check whether the range is collapsed.\n     *\n     * @return {Boolean}\n     */\n\n    get: function get$$1() {\n      return this.anchor === this.focus || this.anchor.key === this.focus.key && this.anchor.offset === this.focus.offset;\n    }\n\n    /**\n     * Check whether the range is expanded.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isExpanded',\n    get: function get$$1() {\n      return !this.isCollapsed;\n    }\n\n    /**\n     * Check whether the range is backward.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isBackward',\n    get: function get$$1() {\n      var isUnset = this.isUnset,\n          anchor = this.anchor,\n          focus = this.focus;\n\n\n      if (isUnset) {\n        return null;\n      }\n\n      if (anchor.key === focus.key) {\n        return anchor.offset > focus.offset;\n      }\n\n      var isBackward = PathUtils.isBefore(focus.path, anchor.path);\n      return isBackward;\n    }\n\n    /**\n     * Check whether the range is forward.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isForward',\n    get: function get$$1() {\n      var isBackward = this.isBackward;\n\n      var isForward = isBackward == null ? null : !isBackward;\n      return isForward;\n    }\n\n    /**\n     * Check whether the range isn't set.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isUnset',\n    get: function get$$1() {\n      var anchor = this.anchor,\n          focus = this.focus;\n\n      var isUnset = anchor.isUnset || focus.isUnset;\n      return isUnset;\n    }\n\n    /**\n     * Check whether the range is set.\n     *\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'isSet',\n    get: function get$$1() {\n      return !this.isUnset;\n    }\n\n    /**\n     * Get the start point.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'start',\n    get: function get$$1() {\n      return this.isBackward ? this.focus : this.anchor;\n    }\n\n    /**\n     * Get the end point.\n     *\n     * @return {String}\n     */\n\n  }, {\n    key: 'end',\n    get: function get$$1() {\n      return this.isBackward ? this.anchor : this.focus;\n    }\n  }]);\n  return RangeInterface;\n}();\n\n/**\n * Mix in the range interface.\n *\n * @param {Record}\n */\n\nmixin(RangeInterface, [Annotation, Decoration, Range, Selection]);\n\nvar index = {\n  Annotation: Annotation,\n  Block: Block,\n  Change: Change,\n  Data: Data,\n  Decoration: Decoration,\n  Document: Document,\n  Editor: Editor,\n  Inline: Inline,\n  KeyUtils: KeyUtils,\n  Leaf: Leaf$1,\n  Mark: Mark,\n  Node: Node,\n  Operation: Operation,\n  PathUtils: PathUtils,\n  Point: Point,\n  Range: Range,\n  resetMemoization: resetMemoization,\n  Selection: Selection,\n  Text: Text,\n  TextUtils: TextUtils,\n  useMemoization: useMemoization,\n  Value: Value\n};\n\nexports.Annotation = Annotation;\nexports.Block = Block;\nexports.Change = Change;\nexports.Data = Data;\nexports.Decoration = Decoration;\nexports.Document = Document;\nexports.Editor = Editor;\nexports.Inline = Inline;\nexports.KeyUtils = KeyUtils;\nexports.Leaf = Leaf$1;\nexports.Mark = Mark;\nexports.Node = Node;\nexports.Operation = Operation;\nexports.PathUtils = PathUtils;\nexports.Point = Point;\nexports.Range = Range;\nexports.resetMemoization = resetMemoization;\nexports.Selection = Selection;\nexports.Text = Text;\nexports.TextUtils = TextUtils;\nexports.useMemoization = useMemoization;\nexports.Value = Value;\nexports.default = index;\n//# sourceMappingURL=slate.js.map\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$is_plain_object$index","~$module$node_modules$lodash$omit","~$module$node_modules$debug$src$browser","~$shadow.js","~$module$node_modules$tiny_invariant$dist$tiny_invariant_cjs","~$module$node_modules$esrever$esrever","~$module$node_modules$immutable$dist$immutable","~$module$node_modules$tiny_warning$dist$tiny_warning_cjs","~$module$node_modules$lodash$pick","~$module$node_modules$direction$index"]],"~:properties",["^5",["moveAnchorForward","skip","moveAnchorToStartOfPreviousText","insertInline","properties","moveAnchorToStartOfPreviousBlock","unwrapNodeByPath","removeTextByPath","withoutSaving","deleteWordForward","moveAnchorToEndOfDocument","removeMarkByPath","TextUtils","moveStartToEndOfNextBlock","addMarksAtRange","setAnnotations","compare","Annotation","merge_node","includeInlines","moveStartToStartOfInline","moveStartToStartOfPreviousText","object","deleteCharForward","insertFragmentByPath","range","moveToStartOfDocument","onlyLeaves","moveStartTo","save","setData","resetGenerator","moveFocusToEndOfDocument","isVoid","min","Editor","deleteLineForwardAtRange","moveAnchorToStartOfNextInline","addAnnotation","setInlines","moveEndWordBackward","insert_node","rule","moveFocusToEndOfNextInline","moveForward","isPath","wrapBlockAtRange","normalize","moveAnchorWordBackward","deleteCharBackward","next","insertBlock","moveNodeByKey","addMarkByPath","moveFocusToEndOfPreviousBlock","includeRoot","splitInlineAtRange","redo","moveEndToEndOfDocument","moveFocusToStartOfPreviousText","moveEndToStartOfPreviousInline","index","onChange","deleteWordBackward","deleteLineBackwardAtRange","setMarkByPath","crop","replaceMark","moveEndToStartOfPreviousBlock","offset","moveStartToEndOfPreviousText","unwrapInlineByPath","removeAnnotation","moveToStartOfText","moveStartWordBackward","isEqual","prototype","insertTextAtRange","moveEndToEndOfPreviousText","addMarks","lift","includeDocument","moveFocusToEndOfNode","delete","moveEndToStartOfNextInline","moveStartToEndOfDocument","moveEndToEndOfText","args","moveAnchorBackward","moveStartToEndOfInline","moveFocusToStartOfNextInline","every","moveStartToEndOfBlock","getCharLength","moveToStartOfNextBlock","newPath","moveFocusToEndOfInline","getCharOffsetBackward","add_annotation","child","moveAnchorToStartOfInline","moveEndToStartOfDocument","moveAnchorToStartOfNode","moveToEndOfDocument","insertFragmentAtRange","add_mark","insertBlockAtRange","Selection","fromJS","set_mark","moveEndToEndOfInline","inline","toggleMarkAtRange","toggleMark","wrapInline","key","parent","onlyTypes","unwrapBlock","focus","moveFocusToEndOfPreviousText","__esModule","remove_annotation","moveEndBackward","max","moveFocusToStartOfBlock","path","moveToEndOfNode","deleteForwardAtRange","setAnchor","moveToEndOfNextInline","moveEndToStartOfNextBlock","moveStartToEndOfNextText","dirty","Operation","moveEndToEndOfNextBlock","schema","moveAnchorToStartOfNextText","moveFocusToEndOfText","v","moveStartToEndOfText","moveFocusWordForward","transform","moveEndForward","moveNodeByPath","increment","snapshot","setNodeByPath","moveFocusToStartOfInline","isBefore","downward","flip","block","moveStartToStartOfNextText","Block","useMemoization","deleteBackward","count","moveAnchorToEndOfNextBlock","moveStartToStartOfPreviousBlock","moveToStartOfInline","deleteWordForwardAtRange","moveStartWordForward","moveToAnchor","wrapInlineAtRange","marks","deleteLineBackward","snapshotSelection","undo","normalizeNode","removeAllMarksByPath","includeTargetAncestors","onlyRoots","wrapNodeByPath","splitInline","onConstruct","anchor","insertInlineAtRange","document","moveAnchorToEndOfInline","moveFocusToEndOfNextText","removeMark","remove_node","moveEndToEndOfNode","Range","deleteForward","PathUtils","position","includeTexts","removeMarksByPath","moveEndToEndOfBlock","newProperties","replaceMarksByPath","configurable","resetMemoization","moveToEndOfPreviousBlock","limit","isOlder","replaceNodeByPath","moveToRangeOfNode","moveFocusTo","moveAnchorToEndOfNode","unwrapChildrenByPath","Mark","unwrapInline","value","moveAnchorTo","deleteAtRange","drop","splitNodeByPath","insert_text","moveToStart","leaf","getWordOffsetBackward","moveFocusBackward","enumerable","moveFocusToStartOfNextText","rules","move_node","moveAnchorToEndOfText","set_value","addMark","setTextByPath","direction","noArgs","previous","select","moveFocusToStartOfPreviousInline","Leaf","Value","insertNodeByPath","mergeNodeByPath","getWordOffset","moveFocusToEndOfPreviousInline","wrapTextAtRange","start","decrement","moveToStartOfNextInline","moveToEndOfPreviousText","removeMarkAtRange","moveToEndOfNextText","middleware","operation","text","wrapText","deleteWordBackwardAtRange","moveStartToStartOfNode","moveStartToStartOfPreviousInline","moveEndToStartOfInline","KeyUtils","setBlocksAtRange","writable","moveEndToStartOfText","moveEndToEndOfNextText","getWordOffsetForward","isYounger","splitDescendantsByKey","moveBackward","onCommand","moveToStartOfPreviousInline","wrapInlineByPath","relate","moveEndToStartOfNextText","decoration","setEnd","moveEndToEndOfNextInline","Change","moveToEndOfNextBlock","deselect","moveAnchorToStartOfDocument","Point","moveAnchorToStartOfBlock","length","moveEndWordForward","moveEndTo","readOnly","props","flushing","annotations","addMarkAtRange","moveToEndOfInline","moveStartToStartOfDocument","nodes","splitBlock","Decoration","validateNode","splitDescendantsByPath","moveToStartOfNode","last","Data","deleteLineForward","isSurrogate","Inline","moveTo","type","moveEndToEndOfPreviousBlock","deleteCharForwardAtRange","moveStartBackward","__command","moveFocusToEndOfBlock","moveFocusToStartOfText","remove_text","moveAnchorToEndOfNextInline","moveStartToStartOfBlock","match","decorations","__proto__","onQuery","moveFocusToStartOfDocument","moveStartToStartOfNextBlock","wrapBlockByPath","unwrapInlineAtRange","target","isAfter","insertText","hasArgs","annotation","moveWordBackward","moveAnchorToStartOfText","insertFragment","set_node","create","moveEndToStartOfPreviousText","removeNodeByPath","Text","getCharOffset","moveAnchorToEndOfPreviousText","withoutMerging","moveAnchorWordForward","moveWordForward","moveStartForward","selection","deleteCharBackwardAtRange","moveToEndOfText","moveAnchorToEndOfBlock","replaceTextByPath","getCharOffsetForward","moveToStartOfPreviousBlock","unwrapBlockByPath","moveToStartOfBlock","moveStartToEndOfNextInline","moveStartToEndOfNode","moveAnchorToStartOfPreviousInline","deleteBackwardAtRange","__query","upward","moveToStartOfPreviousText","moveAnchorToEndOfPreviousBlock","moveFocusWordBackward","moveToEnd","wrapBlock","Document","moveStartToStartOfNextInline","moveToFocus","setStart","split_node","insertTextByPath","setInlinesAtRange","isSibling","mark","tmp","setAnnotation","isWord","moveEndToStartOfNode","moveToStartOfNextText","blur","data","getAncestors","get","merge","setGenerator","isAtomic","Node","set_selection","moveStartToStartOfText","moveFocusToStartOfPreviousBlock","moveToEndOfPreviousInline","set_annotation","moveFocusToStartOfNextBlock","default","controller","moveToEndOfBlock","code","done","plugins","moveStartToEndOfPreviousInline","end","moveToRangeOfDocument","remove_mark","point","moveAnchorToStartOfNextBlock","moveFocusToStartOfNode","moveEndToEndOfPreviousInline","moveStartToEndOfPreviousBlock","addMarksByPath","node","stack","change","setFocus","moveFocusToEndOfNextBlock","constructor","splitBlockAtRange","first","moveFocusForward","includeBlocks","moveAnchorToEndOfNextText","moveEndToStartOfBlock","setBlocks","isFocused","moveAnchorToEndOfPreviousInline","unwrapBlockAtRange","isAbove","editor","operations"]],"~:compiled-at",1574889105346,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$slate$lib$slate.js\",\n\"lineCount\":436,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/slate/lib/slate.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$slate$lib$slate\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', { value: true });\\n\\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\\n\\nvar immutable = require('immutable');\\nvar isPlainObject = _interopDefault(require('is-plain-object'));\\nvar warning = _interopDefault(require('tiny-warning'));\\nvar invariant = _interopDefault(require('tiny-invariant'));\\nvar Debug = _interopDefault(require('debug'));\\nvar esrever = require('esrever');\\nvar pick = _interopDefault(require('lodash/pick'));\\nvar omit = _interopDefault(require('lodash/omit'));\\nvar getDirection = _interopDefault(require('direction'));\\n\\n/**\\n * An auto-incrementing index for generating keys.\\n *\\n * @type {Number}\\n */\\n\\nvar n = void 0;\\n\\n/**\\n * The global key generating function.\\n *\\n * @type {Function}\\n */\\n\\nvar generate = void 0;\\n\\n/**\\n * Create a key, using a provided key if available.\\n *\\n * @param {String|Void} key\\n * @return {String}\\n */\\n\\nfunction create(key) {\\n  if (key == null) {\\n    return generate();\\n  }\\n\\n  if (typeof key === 'string') {\\n    return key;\\n  }\\n\\n  throw new Error('Keys must be strings, but you passed: ' + key);\\n}\\n\\n/**\\n * Set a different unique ID generating `function`.\\n *\\n * @param {Function} func\\n */\\n\\nfunction setGenerator(func) {\\n  generate = func;\\n}\\n\\n/**\\n * Reset the key generating function to its initial state.\\n */\\n\\nfunction resetGenerator() {\\n  n = 0;\\n  generate = function generate() {\\n    return '' + n++;\\n  };\\n}\\n\\n/**\\n * Set the initial state.\\n */\\n\\nresetGenerator();\\n\\n/**\\n * Export.\\n *\\n * @type {Object}\\n */\\n\\nvar KeyUtils = {\\n  create: create,\\n  setGenerator: setGenerator,\\n  resetGenerator: resetGenerator\\n};\\n\\nvar _typeof = typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\" ? function (obj) {\\n  return typeof obj;\\n} : function (obj) {\\n  return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj;\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar classCallCheck = function (instance, Constructor) {\\n  if (!(instance instanceof Constructor)) {\\n    throw new TypeError(\\\"Cannot call a class as a function\\\");\\n  }\\n};\\n\\nvar createClass = function () {\\n  function defineProperties(target, props) {\\n    for (var i = 0; i < props.length; i++) {\\n      var descriptor = props[i];\\n      descriptor.enumerable = descriptor.enumerable || false;\\n      descriptor.configurable = true;\\n      if (\\\"value\\\" in descriptor) descriptor.writable = true;\\n      Object.defineProperty(target, descriptor.key, descriptor);\\n    }\\n  }\\n\\n  return function (Constructor, protoProps, staticProps) {\\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\\n    if (staticProps) defineProperties(Constructor, staticProps);\\n    return Constructor;\\n  };\\n}();\\n\\n\\n\\n\\n\\nvar defineProperty = function (obj, key, value) {\\n  if (key in obj) {\\n    Object.defineProperty(obj, key, {\\n      value: value,\\n      enumerable: true,\\n      configurable: true,\\n      writable: true\\n    });\\n  } else {\\n    obj[key] = value;\\n  }\\n\\n  return obj;\\n};\\n\\nvar _extends = Object.assign || function (target) {\\n  for (var i = 1; i < arguments.length; i++) {\\n    var source = arguments[i];\\n\\n    for (var key in source) {\\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\\n        target[key] = source[key];\\n      }\\n    }\\n  }\\n\\n  return target;\\n};\\n\\n\\n\\nvar inherits = function (subClass, superClass) {\\n  if (typeof superClass !== \\\"function\\\" && superClass !== null) {\\n    throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass);\\n  }\\n\\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\\n    constructor: {\\n      value: subClass,\\n      enumerable: false,\\n      writable: true,\\n      configurable: true\\n    }\\n  });\\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar objectWithoutProperties = function (obj, keys) {\\n  var target = {};\\n\\n  for (var i in obj) {\\n    if (keys.indexOf(i) >= 0) continue;\\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\\n    target[i] = obj[i];\\n  }\\n\\n  return target;\\n};\\n\\nvar possibleConstructorReturn = function (self, call) {\\n  if (!self) {\\n    throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\");\\n  }\\n\\n  return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self;\\n};\\n\\n\\n\\n\\n\\nvar slicedToArray = function () {\\n  function sliceIterator(arr, i) {\\n    var _arr = [];\\n    var _n = true;\\n    var _d = false;\\n    var _e = undefined;\\n\\n    try {\\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\\n        _arr.push(_s.value);\\n\\n        if (i && _arr.length === i) break;\\n      }\\n    } catch (err) {\\n      _d = true;\\n      _e = err;\\n    } finally {\\n      try {\\n        if (!_n && _i[\\\"return\\\"]) _i[\\\"return\\\"]();\\n      } finally {\\n        if (_d) throw _e;\\n      }\\n    }\\n\\n    return _arr;\\n  }\\n\\n  return function (arr, i) {\\n    if (Array.isArray(arr)) {\\n      return arr;\\n    } else if (Symbol.iterator in Object(arr)) {\\n      return sliceIterator(arr, i);\\n    } else {\\n      throw new TypeError(\\\"Invalid attempt to destructure non-iterable instance\\\");\\n    }\\n  };\\n}();\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar toConsumableArray = function (arr) {\\n  if (Array.isArray(arr)) {\\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\\n\\n    return arr2;\\n  } else {\\n    return Array.from(arr);\\n  }\\n};\\n\\n/**\\n * Compare paths `path` and `target` to see which is before or after.\\n *\\n * @param {List} path\\n * @param {List} target\\n * @return {Number|Null}\\n */\\n\\nfunction compare(path, target) {\\n  var m = min(path, target);\\n\\n  for (var i = 0; i < m; i++) {\\n    var pv = path.get(i);\\n    var tv = target.get(i);\\n\\n    // If the path's value is ever less than the target's, it's before.\\n    if (pv < tv) return -1;\\n\\n    // If the target's value is ever less than the path's, it's after.\\n    if (pv > tv) return 1;\\n  }\\n\\n  // Paths should now be equal, otherwise something is wrong\\n  return path.size === target.size ? 0 : null;\\n}\\n\\n/**\\n * Create a path from `attrs`.\\n *\\n * @param {Array|List} attrs\\n * @return {List}\\n */\\n\\nfunction create$1(attrs) {\\n  if (attrs == null) {\\n    return null;\\n  }\\n\\n  if (immutable.List.isList(attrs)) {\\n    return attrs;\\n  }\\n\\n  if (Array.isArray(attrs)) {\\n    return immutable.List(attrs);\\n  }\\n\\n  throw new Error('Paths can only be created from arrays or lists, but you passed: ' + attrs);\\n}\\n\\n/**\\n * Crop paths `a` and `b` to an equal size, defaulting to the shortest.\\n *\\n * @param {List} a\\n * @param {List} b\\n */\\n\\nfunction crop(a, b) {\\n  var size = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : min(a, b);\\n\\n  var ca = a.slice(0, size);\\n  var cb = b.slice(0, size);\\n  return [ca, cb];\\n}\\n\\n/**\\n * Decrement a `path` by `n` at `index`, defaulting to the last index.\\n *\\n * @param {List} path\\n * @param {Number} n\\n * @param {Number} index\\n */\\n\\nfunction decrement(path) {\\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\\n  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path.size - 1;\\n\\n  return increment(path, 0 - n, index);\\n}\\n\\n/**\\n * Get all ancestor paths of th given path.\\n *\\n * @param {List} path\\n * @returns {List}\\n */\\n\\nfunction getAncestors(path) {\\n  var ancestors = immutable.List().withMutations(function (list) {\\n    for (var i = 0; i < path.size; i++) {\\n      list.push(path.slice(0, i));\\n    }\\n  });\\n\\n  return ancestors;\\n}\\n\\n/**\\n * Increment a `path` by `n` at `index`, defaulting to the last index.\\n *\\n * @param {List} path\\n * @param {Number} n\\n * @param {Number} index\\n */\\n\\nfunction increment(path) {\\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\\n  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path.size - 1;\\n\\n  var value = path.get(index);\\n  var newValue = value + n;\\n  var newPath = path.set(index, newValue);\\n  return newPath;\\n}\\n\\n/**\\n * Is a `path` above another `target` path?\\n *\\n * @param {List} path\\n * @param {List} target\\n * @return {Boolean}\\n */\\n\\nfunction isAbove(path, target) {\\n  var _crop = crop(path, target),\\n      _crop2 = slicedToArray(_crop, 2),\\n      p = _crop2[0],\\n      t = _crop2[1];\\n\\n  return path.size < target.size && compare(p, t) === 0;\\n}\\n\\n/**\\n * Is a `path` after another `target` path in a document?\\n *\\n * @param {List} path\\n * @param {List} target\\n * @return {Boolean}\\n */\\n\\nfunction isAfter(path, target) {\\n  var _crop3 = crop(path, target),\\n      _crop4 = slicedToArray(_crop3, 2),\\n      p = _crop4[0],\\n      t = _crop4[1];\\n\\n  return compare(p, t) === 1;\\n}\\n\\n/**\\n * Is a `path` before another `target` path in a document?\\n *\\n * @param {List} path\\n * @param {List} target\\n * @return {Boolean}\\n */\\n\\nfunction isBefore(path, target) {\\n  var _crop5 = crop(path, target),\\n      _crop6 = slicedToArray(_crop5, 2),\\n      p = _crop6[0],\\n      t = _crop6[1];\\n\\n  return compare(p, t) === -1;\\n}\\n\\n/**\\n * Is a `path` equal to another `target` path in a document?\\n *\\n * @param {List} path\\n * @param {List} target\\n * @return {Boolean}\\n */\\n\\nfunction isEqual(path, target) {\\n  return path.equals(target);\\n}\\n\\n/**\\n * Is a `path` older than a `target` path? Meaning that it ends as an older\\n * sibling of one of the indexes in the target.\\n *\\n * @param {List} path\\n * @param {List} target\\n * @return {Boolean}\\n */\\n\\nfunction isOlder(path, target) {\\n  var index = path.size - 1;\\n\\n  var _crop7 = crop(path, target, index),\\n      _crop8 = slicedToArray(_crop7, 2),\\n      p = _crop8[0],\\n      t = _crop8[1];\\n\\n  var pl = path.get(index);\\n  var tl = target.get(index);\\n  return isEqual(p, t) && pl > tl;\\n}\\n\\n/**\\n * Is an `any` object a path?\\n *\\n * @param {Mixed} any\\n * @return {Boolean}\\n */\\n\\nfunction isPath(any) {\\n  return (immutable.List.isList(any) || Array.isArray(any)) && any.every(function (n) {\\n    return typeof n === 'number';\\n  });\\n}\\n\\n/**\\n * Is a `path` a sibling of a `target` path?\\n *\\n * @param {List} path\\n * @param {List} target\\n * @return {Boolean}\\n */\\n\\nfunction isSibling(path, target) {\\n  if (path.size !== target.size) return false;\\n  var p = path.butLast();\\n  var t = target.butLast();\\n  return p.equals(t);\\n}\\n\\n/**\\n * Is a `path` younger than a `target` path? Meaning that it ends as a younger\\n * sibling of one of the indexes in the target.\\n *\\n * @param {List} path\\n * @param {List} target\\n * @return {Boolean}\\n */\\n\\nfunction isYounger(path, target) {\\n  var index = path.size - 1;\\n\\n  var _crop9 = crop(path, target, index),\\n      _crop10 = slicedToArray(_crop9, 2),\\n      p = _crop10[0],\\n      t = _crop10[1];\\n\\n  var pl = path.get(index);\\n  var tl = target.get(index);\\n  return isEqual(p, t) && pl < tl;\\n}\\n\\n/**\\n * Lift a `path` to refer to its `n`th ancestor.\\n *\\n * @param {List} path\\n * @return {List}\\n */\\n\\nfunction lift(path) {\\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\\n\\n  var ancestor = path.slice(0, -1 * n);\\n  return ancestor;\\n}\\n\\n/**\\n * Drop a `path`, returning a relative path from a depth of `n`.\\n *\\n * @param {List} path\\n * @param {Number} n\\n * @return {List}\\n */\\n\\nfunction drop(path) {\\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\\n\\n  var relative = path.slice(n);\\n  return relative;\\n}\\n\\n/**\\n * Get the maximum length of paths `a` and `b`.\\n *\\n * @param {List} path\\n * @param {List} path\\n * @return {Number}\\n */\\n\\nfunction max(a, b) {\\n  var n = Math.max(a.size, b.size);\\n  return n;\\n}\\n\\n/**\\n * Get the minimum length of paths `a` and `b`.\\n *\\n * @param {List} path\\n * @param {List} path\\n * @return {Number}\\n */\\n\\nfunction min(a, b) {\\n  var n = Math.min(a.size, b.size);\\n  return n;\\n}\\n\\n/**\\n * Get the common ancestor path of path `a` and path `b`.\\n *\\n * @param {List} a\\n * @param {List} b\\n * @return {List}\\n */\\n\\nfunction relate(a, b) {\\n  var array = [];\\n\\n  for (var i = 0; i < a.size && i < b.size; i++) {\\n    var av = a.get(i);\\n    var bv = b.get(i);\\n\\n    // If the values aren't equal, they've diverged and don't share an ancestor.\\n    if (av !== bv) break;\\n\\n    // Otherwise, the current value is still a common ancestor.\\n    array.push(av);\\n  }\\n\\n  var path = create$1(array);\\n  return path;\\n}\\n\\n/**\\n * Transform a `path` by an `operation`, adjusting it to stay current.\\n *\\n * @param {List} path\\n * @param {Operation} operation\\n * @return {List<List>}\\n */\\n\\nfunction transform(path, operation) {\\n  var type = operation.type,\\n      position = operation.position,\\n      p = operation.path;\\n\\n\\n  if (type === 'add_mark' || type === 'insert_text' || type === 'remove_mark' || type === 'remove_text' || type === 'set_mark' || type === 'set_node' || type === 'set_selection' || type === 'set_value' || type === 'add_annotation' || type === 'remove_annotation' || type === 'set_annotation' || path.size === 0) {\\n    return immutable.List([path]);\\n  }\\n\\n  var pIndex = p.size - 1;\\n  var pEqual = isEqual(p, path);\\n  var pYounger = isYounger(p, path);\\n  var pAbove = isAbove(p, path);\\n\\n  if (type === 'insert_node') {\\n    if (pEqual || pYounger || pAbove) {\\n      path = increment(path, 1, pIndex);\\n    }\\n  }\\n\\n  if (type === 'remove_node') {\\n    if (pYounger) {\\n      path = decrement(path, 1, pIndex);\\n    } else if (pEqual || pAbove) {\\n      path = [];\\n    }\\n  }\\n\\n  if (type === 'merge_node') {\\n    if (pEqual || pYounger) {\\n      path = decrement(path, 1, pIndex);\\n    } else if (pAbove) {\\n      path = decrement(path, 1, pIndex);\\n      path = increment(path, position, pIndex + 1);\\n    }\\n  }\\n\\n  if (type === 'split_node') {\\n    if (pEqual) {\\n      path = [path, increment(path)];\\n    } else if (pYounger) {\\n      path = increment(path, 1, pIndex);\\n    } else if (pAbove) {\\n      if (path.get(pIndex + 1) >= position) {\\n        path = increment(path, 1, pIndex);\\n        path = decrement(path, position, pIndex + 1);\\n      }\\n    }\\n  }\\n\\n  if (type === 'move_node') {\\n    var np = operation.newPath;\\n\\n\\n    if (isEqual(p, np)) {\\n      return immutable.List([path]);\\n    }\\n\\n    if (pAbove || pEqual) {\\n      // We are comparing something that was moved\\n      // The new path is unaffected unless the old path was the left-sibling of an ancestor\\n      if (isYounger(p, np) && p.size < np.size) {\\n        path = decrement(np, 1, min(np, p) - 1).concat(path.slice(p.size));\\n      } else {\\n        path = np.concat(path.slice(p.size));\\n      }\\n    } else {\\n      // This is equivalent logic to remove_node for path\\n      if (pYounger) {\\n        path = decrement(path, 1, pIndex);\\n      }\\n\\n      // This is the equivalent logic to insert_node for newPath\\n      if (isYounger(np, path) || isEqual(np, path) || isAbove(np, path)) {\\n        path = increment(path, 1, np.size - 1);\\n      }\\n    }\\n  }\\n\\n  var paths = Array.isArray(path) ? path : [path];\\n  return immutable.List(paths);\\n}\\n\\n/**\\n * Export.\\n *\\n * @type {Object}\\n */\\n\\nvar PathUtils = {\\n  compare: compare,\\n  create: create$1,\\n  crop: crop,\\n  decrement: decrement,\\n  getAncestors: getAncestors,\\n  increment: increment,\\n  isAbove: isAbove,\\n  isAfter: isAfter,\\n  isBefore: isBefore,\\n  isEqual: isEqual,\\n  isOlder: isOlder,\\n  isPath: isPath,\\n  isSibling: isSibling,\\n  isYounger: isYounger,\\n  lift: lift,\\n  drop: drop,\\n  max: max,\\n  min: min,\\n  relate: relate,\\n  transform: transform\\n};\\n\\n/**\\n * Default properties.\\n *\\n * @type {Object}\\n */\\n\\nvar DEFAULTS = {\\n  key: undefined,\\n  offset: undefined,\\n  path: undefined\\n\\n  /**\\n   * Point.\\n   *\\n   * @type {Point}\\n   */\\n\\n};\\nvar Point = function (_Record) {\\n  inherits(Point, _Record);\\n\\n  function Point() {\\n    classCallCheck(this, Point);\\n    return possibleConstructorReturn(this, (Point.__proto__ || Object.getPrototypeOf(Point)).apply(this, arguments));\\n  }\\n\\n  createClass(Point, [{\\n    key: 'isAfterPoint',\\n\\n\\n    /**\\n     * Check whether the point is after another `point`.\\n     *\\n     * @return {Boolean}\\n     */\\n\\n    value: function isAfterPoint(point) {\\n      if (this.isUnset) return false;\\n      var is = this.key === point.key && this.offset > point.offset || PathUtils.compare(this.path, point.path) === 1;\\n      return is;\\n    }\\n\\n    /**\\n     * Check whether the point is after a `range`.\\n     *\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isAfterRange',\\n    value: function isAfterRange(range) {\\n      if (this.isUnset) return false;\\n      var is = this.isAfterPoint(range.end);\\n      return is;\\n    }\\n\\n    /**\\n     * Check whether the point is at the end of a `range`.\\n     *\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isAtEndOfRange',\\n    value: function isAtEndOfRange(range) {\\n      if (this.isUnset) return false;\\n      var is = this.equals(range.end);\\n      return is;\\n    }\\n\\n    /**\\n     * Check whether the point is at the start of a `range`.\\n     *\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isAtStartOfRange',\\n    value: function isAtStartOfRange(range) {\\n      if (this.isUnset) return false;\\n      var is = this.equals(range.start);\\n      return is;\\n    }\\n\\n    /**\\n     * Check whether the point is before another `point`.\\n     *\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isBeforePoint',\\n    value: function isBeforePoint(point) {\\n      if (this.isUnset) return false;\\n      var is = this.key === point.key && this.offset < point.offset || PathUtils.compare(this.path, point.path) === -1;\\n      return is;\\n    }\\n\\n    /**\\n     * Check whether the point is before a `range`.\\n     *\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isBeforeRange',\\n    value: function isBeforeRange(range) {\\n      if (this.isUnset) return false;\\n      var is = this.isBeforePoint(range.start);\\n      return is;\\n    }\\n\\n    /**\\n     * Check whether the point is inside a `range`.\\n     *\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isInRange',\\n    value: function isInRange(range) {\\n      if (this.isUnset) return false;\\n      var is = this.equals(range.start) || this.equals(range.end) || this.isAfterPoint(range.start) && this.isBeforePoint(range.end);\\n      return is;\\n    }\\n\\n    /**\\n     * Check whether the point is at the end of a `node`.\\n     *\\n     * @param {Node} node\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isAtEndOfNode',\\n    value: function isAtEndOfNode(node) {\\n      if (this.isUnset) return false;\\n      var last = node.getLastText();\\n      var is = this.key === last.key && this.offset === last.text.length;\\n      return is;\\n    }\\n\\n    /**\\n     * Check whether the point is at the start of a `node`.\\n     *\\n     * @param {Node} node\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isAtStartOfNode',\\n    value: function isAtStartOfNode(node) {\\n      if (this.isUnset) return false;\\n\\n      // PERF: Do a check for a `0` offset first since it's quickest.\\n      if (this.offset !== 0) return false;\\n\\n      var first = node.getFirstText();\\n      var is = this.key === first.key;\\n      return is;\\n    }\\n\\n    /**\\n     * Check whether the point is in a `node`.\\n     *\\n     * @param {Node} node\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isInNode',\\n    value: function isInNode(node) {\\n      if (this.isUnset) return false;\\n      if (node.object === 'text' && node.key === this.key) return true;\\n      if (node.hasNode(this.key)) return true;\\n      return false;\\n    }\\n\\n    /**\\n     * Move the point's offset backward `n` characters.\\n     *\\n     * @param {Number} n (optional)\\n     * @return {Point}\\n     */\\n\\n  }, {\\n    key: 'moveBackward',\\n    value: function moveBackward() {\\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\\n\\n      if (n === 0) return this;\\n      if (n < 0) return this.moveForward(-n);\\n      var point = this.setOffset(this.offset - n);\\n      return point;\\n    }\\n\\n    /**\\n     * Move the point's offset forward `n` characters.\\n     *\\n     * @param {Number} n (optional)\\n     * @return {Point}\\n     */\\n\\n  }, {\\n    key: 'moveForward',\\n    value: function moveForward() {\\n      var n = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\\n\\n      if (n === 0) return this;\\n      if (n < 0) return this.moveBackward(-n);\\n      var point = this.setOffset(this.offset + n);\\n      return point;\\n    }\\n\\n    /**\\n     * Move the point's anchor point to a new `path` and `offset`.\\n     *\\n     * Optionally, the `path` can be a key string, or omitted entirely in which\\n     * case it would be the offset number.\\n     *\\n     * @param {List|String|Number} path\\n     * @param {Number} offset\\n     * @return {Point}\\n     */\\n\\n  }, {\\n    key: 'moveTo',\\n    value: function moveTo(path) {\\n      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n\\n      var key = this.key;\\n\\n      if (typeof path === 'number') {\\n        offset = path;\\n        path = this.path;\\n      } else if (typeof path === 'string') {\\n        key = path;\\n        path = key === this.key ? this.path : null;\\n      } else {\\n        key = path.equals(this.path) ? this.key : null;\\n      }\\n\\n      var point = this.merge({ key: key, path: path, offset: offset });\\n      return point;\\n    }\\n\\n    /**\\n     * Move the point's anchor point to the start of a `node`.\\n     *\\n     * @param {Node} node\\n     * @return {Point}\\n     */\\n\\n  }, {\\n    key: 'moveToStartOfNode',\\n    value: function moveToStartOfNode(node) {\\n      var first = node.getFirstText();\\n      var point = this.moveTo(first.key, 0);\\n      return point;\\n    }\\n\\n    /**\\n     * Move the point's anchor point to the end of a `node`.\\n     *\\n     * @param {Node} node\\n     * @return {Point}\\n     */\\n\\n  }, {\\n    key: 'moveToEndOfNode',\\n    value: function moveToEndOfNode(node) {\\n      var last = node.getLastText();\\n      var point = this.moveTo(last.key, last.text.length);\\n      return point;\\n    }\\n\\n    /**\\n     * Normalize the point relative to a `node`, ensuring that its key and path\\n     * reference a text node, or that it gets unset.\\n     *\\n     * @param {Node} node\\n     * @return {Point}\\n     */\\n\\n  }, {\\n    key: 'normalize',\\n    value: function normalize(node) {\\n      // If both the key and path are null, there's no reference to a node, so\\n      // make sure it is entirely unset.\\n      if (this.key == null && this.path == null) {\\n        return this.setOffset(null);\\n      }\\n\\n      var key = this.key,\\n          offset = this.offset,\\n          path = this.path;\\n\\n      // PERF: this function gets called a lot.\\n      // to avoid creating the key -> path lookup table, we attempt to look up by path first.\\n\\n      var target = path && node.getNode(path);\\n\\n      if (!target) {\\n        target = node.getNode(key);\\n\\n        if (target) {\\n          // There is a misalignment of path and key\\n          var _point = this.merge({\\n            path: node.getPath(key)\\n          });\\n\\n          return _point;\\n        }\\n      }\\n\\n      if (!target) {\\n        warning(false, \\\"A point's `path` or `key` invalid and was reset!\\\");\\n\\n        var text = node.getFirstText();\\n        if (!text) return Point.create();\\n\\n        var _point2 = this.merge({\\n          key: text.key,\\n          offset: 0,\\n          path: node.getPath(text.key)\\n        });\\n\\n        return _point2;\\n      }\\n\\n      if (target.object !== 'text') {\\n        warning(false, 'A point should not reference a non-text node!');\\n\\n        var _text = target.getTextAtOffset(offset);\\n        var before = target.getOffset(_text.key);\\n        var _point3 = this.merge({\\n          offset: offset - before,\\n          key: _text.key,\\n          path: node.getPath(_text.key)\\n        });\\n\\n        return _point3;\\n      }\\n\\n      if (target && path && key && key !== target.key) {\\n        warning(false, \\\"A point's `key` did not match its `path`!\\\");\\n\\n        // TODO: if we look up by path above and it differs by key, do we want to reset it to looking up by key?\\n      }\\n\\n      var point = this.merge({\\n        key: target.key,\\n        path: path == null ? node.getPath(target.key) : path,\\n        offset: offset == null ? 0 : Math.min(offset, target.text.length)\\n      });\\n\\n      // COMPAT: There is an ambiguity, since a point can exist at the end of a\\n      // text node, or at the start of the following one. To eliminate it we\\n      // enforce that if there is a following text node, we always move it there.\\n      if (point.offset === target.text.length) {\\n        var block = node.getClosestBlock(point.path);\\n        // TODO: this next line is broken because `getNextText` takes a path\\n        var next = block.getNextText();\\n\\n        if (next) {\\n          point = point.merge({\\n            key: next.key,\\n            path: node.getPath(next.key),\\n            offset: 0\\n          });\\n        }\\n      }\\n\\n      return point;\\n    }\\n\\n    /**\\n     * Set the point's key to a new `key`.\\n     *\\n     * @param {String} key\\n     * @return {Point}\\n     */\\n\\n  }, {\\n    key: 'setKey',\\n    value: function setKey(key) {\\n      if (key != null) {\\n        key = KeyUtils.create(key);\\n      }\\n\\n      var point = this.set('key', key);\\n      return point;\\n    }\\n\\n    /**\\n     * Set the point's offset to a new `offset`.\\n     *\\n     * @param {Number} offset\\n     * @return {Point}\\n     */\\n\\n  }, {\\n    key: 'setOffset',\\n    value: function setOffset(offset) {\\n      var point = this.set('offset', offset);\\n      return point;\\n    }\\n\\n    /**\\n     * Set the point's path to a new `path`.\\n     *\\n     * @param {List|Array} path\\n     * @return {Point}\\n     */\\n\\n  }, {\\n    key: 'setPath',\\n    value: function setPath(path) {\\n      if (path != null) {\\n        path = PathUtils.create(path);\\n      }\\n\\n      var point = this.set('path', path);\\n      return point;\\n    }\\n\\n    /**\\n     * Return a JSON representation of the point.\\n     *\\n     * @param {Object} options\\n     * @return {Object}\\n     */\\n\\n  }, {\\n    key: 'toJSON',\\n    value: function toJSON() {\\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      var object = {\\n        object: this.object,\\n        key: this.key,\\n        offset: this.offset,\\n        path: this.path && this.path.toArray()\\n      };\\n\\n      if (!options.preserveKeys) {\\n        delete object.key;\\n      }\\n\\n      return object;\\n    }\\n\\n    /**\\n     * Unset the point.\\n     *\\n     * @return {Point}\\n     */\\n\\n  }, {\\n    key: 'unset',\\n    value: function unset() {\\n      return this.merge({\\n        key: null,\\n        offset: null,\\n        path: null\\n      });\\n    }\\n  }, {\\n    key: 'isSet',\\n\\n\\n    /**\\n     * Check whether all properties of the point are set.\\n     *\\n     * @return {Boolean}\\n     */\\n\\n    get: function get$$1() {\\n      return this.key != null && this.offset != null && this.path != null;\\n    }\\n\\n    /**\\n     * Check whether any property of the point is not set.\\n     *\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isUnset',\\n    get: function get$$1() {\\n      return !this.isSet;\\n    }\\n  }], [{\\n    key: 'create',\\n\\n    /**\\n     * Create a new `Point` with `attrs`.\\n     *\\n     * @param {Object|Point} attrs\\n     * @return {Point}\\n     */\\n\\n    value: function create() {\\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      if (Point.isPoint(attrs)) {\\n        return attrs;\\n      }\\n\\n      if (isPlainObject(attrs)) {\\n        return Point.fromJSON(attrs);\\n      }\\n\\n      throw new Error('`Point.create` only accepts objects or points, but you passed it: ' + attrs);\\n    }\\n\\n    /**\\n     * Create a dictionary of settable point properties from `attrs`.\\n     *\\n     * @param {Object|Point} attrs\\n     * @return {Object}\\n     */\\n\\n  }, {\\n    key: 'createProperties',\\n    value: function createProperties() {\\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      if (Point.isPoint(a)) {\\n        return {\\n          key: a.key,\\n          offset: a.offset,\\n          path: a.path\\n        };\\n      }\\n\\n      if (isPlainObject(a)) {\\n        var p = {};\\n        if ('key' in a) p.key = a.key;\\n        if ('offset' in a) p.offset = a.offset;\\n        if ('path' in a) p.path = PathUtils.create(a.path);\\n\\n        // If only a path is set, or only a key is set, ensure that the other is\\n        // set to null so that it can be normalized back to the right value.\\n        // Otherwise we won't realize that the path and key don't match anymore.\\n        if ('path' in a && !('key' in a)) p.key = null;\\n        if ('key' in a && !('path' in a)) p.path = null;\\n\\n        return p;\\n      }\\n\\n      throw new Error('`Point.createProperties` only accepts objects or points, but you passed it: ' + a);\\n    }\\n\\n    /**\\n     * Create a `Point` from a JSON `object`.\\n     *\\n     * @param {Object} object\\n     * @return {Point}\\n     */\\n\\n  }, {\\n    key: 'fromJSON',\\n    value: function fromJSON(object) {\\n      var _object$key = object.key,\\n          key = _object$key === undefined ? null : _object$key,\\n          _object$offset = object.offset,\\n          offset = _object$offset === undefined ? null : _object$offset,\\n          _object$path = object.path,\\n          path = _object$path === undefined ? null : _object$path;\\n\\n\\n      var point = new Point({\\n        key: key,\\n        offset: offset,\\n        path: PathUtils.create(path)\\n      });\\n\\n      return point;\\n    }\\n  }]);\\n  return Point;\\n}(immutable.Record(DEFAULTS));\\n\\n/**\\n * Data.\\n *\\n * This isn't an immutable record, it's just a thin wrapper around `Map` so that\\n * we can allow for more convenient creation.\\n *\\n * @type {Object}\\n */\\n\\nvar Data = function () {\\n  function Data() {\\n    classCallCheck(this, Data);\\n  }\\n\\n  createClass(Data, null, [{\\n    key: 'create',\\n\\n    /**\\n     * Create a new `Data` with `attrs`.\\n     *\\n     * @param {Object|Data|Map} attrs\\n     * @return {Data} data\\n     */\\n\\n    value: function create() {\\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      if (immutable.Map.isMap(attrs)) {\\n        return attrs;\\n      }\\n\\n      if (isPlainObject(attrs)) {\\n        return Data.fromJSON(attrs);\\n      }\\n\\n      throw new Error('`Data.create` only accepts objects or maps, but you passed it: ' + attrs);\\n    }\\n\\n    /**\\n     * Create a `Data` from a JSON `object`.\\n     *\\n     * @param {Object} object\\n     * @return {Data}\\n     */\\n\\n  }, {\\n    key: 'fromJSON',\\n    value: function fromJSON(object) {\\n      return new immutable.Map(object);\\n    }\\n\\n    /**\\n     * Alias `fromJS`.\\n     */\\n\\n  }]);\\n  return Data;\\n}();\\n\\n/**\\n * Export.\\n *\\n * @type {Object}\\n */\\n\\nData.fromJS = Data.fromJSON;\\n\\n/**\\n * Default properties.\\n *\\n * @type {Object}\\n */\\n\\nvar DEFAULTS$1 = {\\n  data: undefined,\\n  type: undefined\\n\\n  /**\\n   * Mark.\\n   *\\n   * @type {Mark}\\n   */\\n\\n};\\nvar Mark = function (_Record) {\\n  inherits(Mark, _Record);\\n\\n  function Mark() {\\n    classCallCheck(this, Mark);\\n    return possibleConstructorReturn(this, (Mark.__proto__ || Object.getPrototypeOf(Mark)).apply(this, arguments));\\n  }\\n\\n  createClass(Mark, [{\\n    key: 'toJSON',\\n\\n\\n    /**\\n     * Return a JSON representation of the mark.\\n     *\\n     * @return {Object}\\n     */\\n\\n    value: function toJSON() {\\n      var object = {\\n        object: this.object,\\n        type: this.type,\\n        data: this.data.toJSON()\\n      };\\n\\n      return object;\\n    }\\n  }], [{\\n    key: 'create',\\n\\n    /**\\n     * Create a new `Mark` with `attrs`.\\n     *\\n     * @param {Object|Mark} attrs\\n     * @return {Mark}\\n     */\\n\\n    value: function create() {\\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      if (Mark.isMark(attrs)) {\\n        return attrs;\\n      }\\n\\n      if (typeof attrs === 'string') {\\n        attrs = { type: attrs };\\n      }\\n\\n      if (isPlainObject(attrs)) {\\n        return Mark.fromJSON(attrs);\\n      }\\n\\n      throw new Error('`Mark.create` only accepts objects, strings or marks, but you passed it: ' + attrs);\\n    }\\n\\n    /**\\n     * Create a set of marks.\\n     *\\n     * @param {Array<Object|Mark>} elements\\n     * @return {Set<Mark>}\\n     */\\n\\n  }, {\\n    key: 'createSet',\\n    value: function createSet(elements) {\\n      if (immutable.Set.isSet(elements) || Array.isArray(elements)) {\\n        var marks = new immutable.Set(elements.map(Mark.create));\\n        return marks;\\n      }\\n\\n      if (elements == null) {\\n        return immutable.Set();\\n      }\\n\\n      throw new Error('`Mark.createSet` only accepts sets, arrays or null, but you passed it: ' + elements);\\n    }\\n\\n    /**\\n     * Create a dictionary of settable mark properties from `attrs`.\\n     *\\n     * @param {Object|String|Mark} attrs\\n     * @return {Object}\\n     */\\n\\n  }, {\\n    key: 'createProperties',\\n    value: function createProperties() {\\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      if (Mark.isMark(attrs)) {\\n        return {\\n          data: attrs.data,\\n          type: attrs.type\\n        };\\n      }\\n\\n      if (typeof attrs === 'string') {\\n        return { type: attrs };\\n      }\\n\\n      if (isPlainObject(attrs)) {\\n        var props = {};\\n        if ('type' in attrs) props.type = attrs.type;\\n        if ('data' in attrs) props.data = Data.create(attrs.data);\\n        return props;\\n      }\\n\\n      throw new Error('`Mark.createProperties` only accepts objects, strings or marks, but you passed it: ' + attrs);\\n    }\\n\\n    /**\\n     * Create a `Mark` from a JSON `object`.\\n     *\\n     * @param {Object} object\\n     * @return {Mark}\\n     */\\n\\n  }, {\\n    key: 'fromJSON',\\n    value: function fromJSON(object) {\\n      var _object$data = object.data,\\n          data = _object$data === undefined ? {} : _object$data,\\n          type = object.type;\\n\\n\\n      if (typeof type !== 'string') {\\n        throw new Error('`Mark.fromJS` requires a `type` string.');\\n      }\\n\\n      var mark = new Mark({\\n        type: type,\\n        data: new immutable.Map(data)\\n      });\\n\\n      return mark;\\n    }\\n\\n    /**\\n     * Check if `any` is a set of marks.\\n     *\\n     * @param {Any} any\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isMarkSet',\\n    value: function isMarkSet(any) {\\n      return immutable.Set.isSet(any) && any.every(function (item) {\\n        return Mark.isMark(item);\\n      });\\n    }\\n  }]);\\n  return Mark;\\n}(immutable.Record(DEFAULTS$1));\\n\\n/**\\n * Default properties.\\n *\\n * @type {Object}\\n */\\n\\nvar DEFAULTS$2 = {\\n  type: undefined,\\n  data: undefined,\\n  anchor: undefined,\\n  focus: undefined\\n\\n  /**\\n   * Decoration.\\n   *\\n   * @type {Decoration}\\n   */\\n\\n};\\nvar Decoration = function (_Record) {\\n  inherits(Decoration, _Record);\\n\\n  function Decoration() {\\n    classCallCheck(this, Decoration);\\n    return possibleConstructorReturn(this, (Decoration.__proto__ || Object.getPrototypeOf(Decoration)).apply(this, arguments));\\n  }\\n\\n  createClass(Decoration, [{\\n    key: 'setProperties',\\n\\n\\n    /**\\n     * Set new `properties` on the decoration.\\n     *\\n     * @param {Object|Range|Selection} properties\\n     * @return {Range}\\n     */\\n\\n    value: function setProperties(properties) {\\n      properties = Decoration.createProperties(properties);\\n      var decoration = this.merge(properties);\\n      return decoration;\\n    }\\n\\n    /**\\n     * Return a JSON representation of the decoration.\\n     *\\n     * @param {Object} options\\n     * @return {Object}\\n     */\\n\\n  }, {\\n    key: 'toJSON',\\n    value: function toJSON() {\\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      var object = {\\n        object: this.object,\\n        type: this.type,\\n        data: this.data.toJSON(),\\n        anchor: this.anchor.toJSON(options),\\n        focus: this.focus.toJSON(options)\\n      };\\n\\n      return object;\\n    }\\n  }], [{\\n    key: 'create',\\n\\n    /**\\n     * Create a new `Decoration` with `attrs`.\\n     *\\n     * @param {Object|Decoration} attrs\\n     * @return {Decoration}\\n     */\\n\\n    value: function create() {\\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      if (Decoration.isDecoration(attrs)) {\\n        return attrs;\\n      }\\n\\n      if (Range.isRange(attrs)) {\\n        return Decoration.fromJSON(Range.createProperties(attrs));\\n      }\\n\\n      if (isPlainObject(attrs)) {\\n        return Decoration.fromJSON(attrs);\\n      }\\n\\n      throw new Error('`Decoration.create` only accepts objects or decorations, but you passed it: ' + attrs);\\n    }\\n\\n    /**\\n     * Create a list of `Ranges` from `elements`.\\n     *\\n     * @param {Array<Decoration|Object>|List<Decoration|Object>} elements\\n     * @return {List<Decoration>}\\n     */\\n\\n  }, {\\n    key: 'createList',\\n    value: function createList() {\\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\\n        var list = new immutable.List(elements.map(Decoration.create));\\n        return list;\\n      }\\n\\n      throw new Error('`Decoration.createList` only accepts arrays or lists, but you passed it: ' + elements);\\n    }\\n\\n    /**\\n     * Create a dictionary of settable decoration properties from `attrs`.\\n     *\\n     * @param {Object|String|Decoration} attrs\\n     * @return {Object}\\n     */\\n\\n  }, {\\n    key: 'createProperties',\\n    value: function createProperties() {\\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      if (Decoration.isDecoration(a)) {\\n        return {\\n          type: a.type,\\n          data: a.data,\\n          anchor: Point.createProperties(a.anchor),\\n          focus: Point.createProperties(a.focus),\\n          mark: Mark.create(a.mark)\\n        };\\n      }\\n\\n      if (isPlainObject(a)) {\\n        var p = {};\\n        if ('type' in a) p.type = a.type;\\n        if ('data' in a) p.data = Data.create(a.data);\\n        if ('anchor' in a) p.anchor = Point.create(a.anchor);\\n        if ('focus' in a) p.focus = Point.create(a.focus);\\n        return p;\\n      }\\n\\n      throw new Error('`Decoration.createProperties` only accepts objects or decorations, but you passed it: ' + a);\\n    }\\n\\n    /**\\n     * Create a `Decoration` from a JSON `object`.\\n     *\\n     * @param {Object} object\\n     * @return {Decoration}\\n     */\\n\\n  }, {\\n    key: 'fromJSON',\\n    value: function fromJSON(object) {\\n      var anchor = object.anchor,\\n          focus = object.focus;\\n      var type = object.type,\\n          data = object.data;\\n\\n\\n      if (object.mark && !type) {\\n        warning(false, 'As of slate@0.47 the `decoration.mark` property has been changed to `decoration.type` and `decoration.data` directly.');\\n\\n        type = object.mark.type;\\n        data = object.mark.data;\\n      }\\n\\n      if (!type) {\\n        throw new Error('Decorations must be created with a `type`, but you passed: ' + JSON.stringify(object));\\n      }\\n\\n      var decoration = new Decoration({\\n        type: type,\\n        data: Data.create(data || {}),\\n        anchor: Point.fromJSON(anchor || {}),\\n        focus: Point.fromJSON(focus || {})\\n      });\\n\\n      return decoration;\\n    }\\n  }]);\\n  return Decoration;\\n}(immutable.Record(DEFAULTS$2));\\n\\n/**\\n * Default properties.\\n *\\n * @type {Object}\\n */\\n\\nvar DEFAULTS$3 = {\\n  anchor: undefined,\\n  focus: undefined,\\n  isFocused: undefined,\\n  marks: undefined\\n\\n  /**\\n   * Selection.\\n   *\\n   * @type {Selection}\\n   */\\n\\n};\\nvar Selection = function (_Record) {\\n  inherits(Selection, _Record);\\n\\n  function Selection() {\\n    classCallCheck(this, Selection);\\n    return possibleConstructorReturn(this, (Selection.__proto__ || Object.getPrototypeOf(Selection)).apply(this, arguments));\\n  }\\n\\n  createClass(Selection, [{\\n    key: 'setIsFocused',\\n\\n\\n    /**\\n     * Set the `isFocused` property to a new `value`.\\n     *\\n     * @param {Boolean} value\\n     * @return {Selection}\\n     */\\n\\n    value: function setIsFocused(value) {\\n      var selection = this.set('isFocused', value);\\n      return selection;\\n    }\\n\\n    /**\\n     * Set the `marks` property to a new set of `marks`.\\n     *\\n     * @param {Set} marks\\n     * @return {Selection}\\n     */\\n\\n  }, {\\n    key: 'setMarks',\\n    value: function setMarks(marks) {\\n      var selection = this.set('marks', marks);\\n      return selection;\\n    }\\n\\n    /**\\n     * Set new `properties` on the selection.\\n     *\\n     * @param {Object|Range|Selection} properties\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'setProperties',\\n    value: function setProperties(properties) {\\n      properties = Selection.createProperties(properties);\\n      var _properties = properties,\\n          anchor = _properties.anchor,\\n          focus = _properties.focus,\\n          props = objectWithoutProperties(_properties, ['anchor', 'focus']);\\n\\n\\n      if (anchor) {\\n        props.anchor = Point.create(anchor);\\n      }\\n\\n      if (focus) {\\n        props.focus = Point.create(focus);\\n      }\\n\\n      var selection = this.merge(props);\\n      return selection;\\n    }\\n\\n    /**\\n     * Return a JSON representation of the selection.\\n     *\\n     * @param {Object} options\\n     * @return {Object}\\n     */\\n\\n  }, {\\n    key: 'toJSON',\\n    value: function toJSON() {\\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      var object = {\\n        object: this.object,\\n        anchor: this.anchor.toJSON(options),\\n        focus: this.focus.toJSON(options),\\n        isFocused: this.isFocused,\\n        marks: this.marks == null ? null : this.marks.toArray().map(function (m) {\\n          return m.toJSON();\\n        })\\n      };\\n\\n      return object;\\n    }\\n  }, {\\n    key: 'isBlurred',\\n\\n\\n    /**\\n     * Check whether the selection is blurred.\\n     *\\n     * @return {Boolean}\\n     */\\n\\n    get: function get$$1() {\\n      return !this.isFocused;\\n    }\\n  }], [{\\n    key: 'create',\\n\\n    /**\\n     * Create a new `Selection` with `attrs`.\\n     *\\n     * @param {Object|Selection} attrs\\n     * @return {Selection}\\n     */\\n\\n    value: function create() {\\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      if (Selection.isSelection(attrs)) {\\n        return attrs;\\n      }\\n\\n      if (Range.isRange(attrs)) {\\n        return Selection.fromJSON(Range.createProperties(attrs));\\n      }\\n\\n      if (isPlainObject(attrs)) {\\n        return Selection.fromJSON(attrs);\\n      }\\n\\n      throw new Error('`Selection.create` only accepts objects, ranges or selections, but you passed it: ' + attrs);\\n    }\\n\\n    /**\\n     * Create a dictionary of settable selection properties from `attrs`.\\n     *\\n     * @param {Object|String|Selection} attrs\\n     * @return {Object}\\n     */\\n\\n  }, {\\n    key: 'createProperties',\\n    value: function createProperties() {\\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      if (Selection.isSelection(a)) {\\n        return {\\n          anchor: Point.createProperties(a.anchor),\\n          focus: Point.createProperties(a.focus),\\n          isFocused: a.isFocused,\\n          marks: a.marks\\n        };\\n      }\\n\\n      if (Range.isRange(a)) {\\n        return {\\n          anchor: Point.createProperties(a.anchor),\\n          focus: Point.createProperties(a.focus)\\n        };\\n      }\\n\\n      if (isPlainObject(a)) {\\n        var p = {};\\n        if ('anchor' in a) p.anchor = Point.create(a.anchor);\\n        if ('focus' in a) p.focus = Point.create(a.focus);\\n        if ('isFocused' in a) p.isFocused = a.isFocused;\\n        if ('marks' in a) p.marks = a.marks == null ? null : Mark.createSet(a.marks);\\n        return p;\\n      }\\n\\n      throw new Error('`Selection.createProperties` only accepts objects, ranges or selections, but you passed it: ' + a);\\n    }\\n\\n    /**\\n     * Create a `Selection` from a JSON `object`.\\n     *\\n     * @param {Object} object\\n     * @return {Selection}\\n     */\\n\\n  }, {\\n    key: 'fromJSON',\\n    value: function fromJSON(object) {\\n      var anchor = object.anchor,\\n          focus = object.focus,\\n          _object$isFocused = object.isFocused,\\n          isFocused = _object$isFocused === undefined ? false : _object$isFocused,\\n          _object$marks = object.marks,\\n          marks = _object$marks === undefined ? null : _object$marks;\\n\\n      var selection = new Selection({\\n        anchor: Point.fromJSON(anchor || {}),\\n        focus: Point.fromJSON(focus || {}),\\n        isFocused: isFocused,\\n        marks: marks == null ? null : new immutable.Set(marks.map(Mark.fromJSON))\\n      });\\n\\n      return selection;\\n    }\\n  }]);\\n  return Selection;\\n}(immutable.Record(DEFAULTS$3));\\n\\n/**\\n * Slate-specific object types.\\n *\\n * @type {Object}\\n */\\n\\nvar TYPES = {\\n  annotation: '@@__SLATE_ANNOTATION__@@',\\n  block: '@@__SLATE_BLOCK__@@',\\n  change: '@@__SLATE_CHANGE__@@',\\n  decoration: '@@__SLATE_DECORATION__@@',\\n  document: '@@__SLATE_DOCUMENT__@@',\\n  editor: '@@__SLATE_EDITOR__@@',\\n  inline: '@@__SLATE_INLINE__@@',\\n  leaf: '@@__SLATE_LEAF__@@',\\n  mark: '@@__SLATE_MARK__@@',\\n  operation: '@@__SLATE_OPERATION__@@',\\n  point: '@@__SLATE_POINT__@@',\\n  range: '@@__SLATE_RANGE__@@',\\n  selection: '@@__SLATE_SELECTION__@@',\\n  text: '@@__SLATE_TEXT__@@',\\n  value: '@@__SLATE_VALUE__@@'\\n\\n  /**\\n   * Determine whether a `value` is of `type`.\\n   *\\n   * @param {string} type\\n   * @param {any} value\\n   * @return {boolean}\\n   */\\n\\n};function isObject(type, value) {\\n  return !!(value && value[TYPES[type]]);\\n}\\n\\n/**\\n * Default properties.\\n *\\n * @type {Object}\\n */\\n\\nvar DEFAULTS$4 = {\\n  anchor: undefined,\\n  focus: undefined\\n\\n  /**\\n   * Range.\\n   *\\n   * @type {Range}\\n   */\\n\\n};\\nvar Range = function (_Record) {\\n  inherits(Range, _Record);\\n\\n  function Range() {\\n    classCallCheck(this, Range);\\n    return possibleConstructorReturn(this, (Range.__proto__ || Object.getPrototypeOf(Range)).apply(this, arguments));\\n  }\\n\\n  createClass(Range, [{\\n    key: 'toJSON',\\n\\n\\n    /**\\n     * Return a JSON representation of the range.\\n     *\\n     * @param {Object} options\\n     * @return {Object}\\n     */\\n\\n    value: function toJSON() {\\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      var object = {\\n        object: this.object,\\n        anchor: this.anchor.toJSON(options),\\n        focus: this.focus.toJSON(options)\\n      };\\n\\n      return object;\\n    }\\n  }], [{\\n    key: 'create',\\n\\n    /**\\n     * Create a new `Range` with `attrs`.\\n     *\\n     * @param {Object|Range} attrs\\n     * @return {Range}\\n     */\\n\\n    value: function create() {\\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      if (Range.isRange(attrs)) {\\n        if (attrs.object === 'range') {\\n          return attrs;\\n        } else {\\n          return Range.fromJSON(Range.createProperties(attrs));\\n        }\\n      }\\n\\n      if (isPlainObject(attrs)) {\\n        return Range.fromJSON(attrs);\\n      }\\n\\n      throw new Error('`Range.create` only accepts objects or ranges, but you passed it: ' + attrs);\\n    }\\n\\n    /**\\n     * Create a list of `Ranges` from `elements`.\\n     *\\n     * @param {Array<Range|Object>|List<Range|Object>} elements\\n     * @return {List<Range>}\\n     */\\n\\n  }, {\\n    key: 'createList',\\n    value: function createList() {\\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\\n        var list = new immutable.List(elements.map(Range.create));\\n        return list;\\n      }\\n\\n      throw new Error('`Range.createList` only accepts arrays or lists, but you passed it: ' + elements);\\n    }\\n\\n    /**\\n     * Create a dictionary of settable range properties from `attrs`.\\n     *\\n     * @param {Object|String|Range} attrs\\n     * @return {Object}\\n     */\\n\\n  }, {\\n    key: 'createProperties',\\n    value: function createProperties() {\\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      if (Range.isRange(a)) {\\n        return {\\n          anchor: Point.createProperties(a.anchor),\\n          focus: Point.createProperties(a.focus)\\n        };\\n      }\\n\\n      if (isPlainObject(a)) {\\n        var p = {};\\n        if ('anchor' in a) p.anchor = Point.create(a.anchor);\\n        if ('focus' in a) p.focus = Point.create(a.focus);\\n        return p;\\n      }\\n\\n      throw new Error('`Range.createProperties` only accepts objects, annotations, decorations, ranges or selections, but you passed it: ' + a);\\n    }\\n\\n    /**\\n     * Create a `Range` from a JSON `object`.\\n     *\\n     * @param {Object} object\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'fromJSON',\\n    value: function fromJSON(object) {\\n      var anchor = object.anchor,\\n          focus = object.focus;\\n\\n      var range = new Range({\\n        anchor: Point.fromJSON(anchor || {}),\\n        focus: Point.fromJSON(focus || {})\\n      });\\n\\n      return range;\\n    }\\n\\n    /**\\n     * Check if a `value` is a `Range`, or is range-like.\\n     *\\n     * @param {Any} value\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isRange',\\n    value: function isRange(value) {\\n      return isObject('range', value) || Decoration.isDecoration(value) || Selection.isSelection(value);\\n    }\\n  }]);\\n  return Range;\\n}(immutable.Record(DEFAULTS$4));\\n\\n/**\\n * Default properties.\\n *\\n * @type {Object}\\n */\\n\\nvar DEFAULTS$5 = {\\n  key: undefined,\\n  type: undefined,\\n  data: undefined,\\n  anchor: undefined,\\n  focus: undefined\\n\\n  /**\\n   * Annotation.\\n   *\\n   * @type {Annotation}\\n   */\\n\\n};\\nvar Annotation = function (_Record) {\\n  inherits(Annotation, _Record);\\n\\n  function Annotation() {\\n    classCallCheck(this, Annotation);\\n    return possibleConstructorReturn(this, (Annotation.__proto__ || Object.getPrototypeOf(Annotation)).apply(this, arguments));\\n  }\\n\\n  createClass(Annotation, [{\\n    key: 'setProperties',\\n\\n\\n    /**\\n     * Set new `properties` on the annotation.\\n     *\\n     * @param {Object|Range|Selection} properties\\n     * @return {Range}\\n     */\\n\\n    value: function setProperties(properties) {\\n      properties = Annotation.createProperties(properties);\\n      var annotation = this.merge(properties);\\n      return annotation;\\n    }\\n\\n    /**\\n     * Return a JSON representation of the annotation.\\n     *\\n     * @param {Object} options\\n     * @return {Object}\\n     */\\n\\n  }, {\\n    key: 'toJSON',\\n    value: function toJSON() {\\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      var object = {\\n        object: this.object,\\n        key: this.key,\\n        type: this.type,\\n        data: this.data.toJSON(),\\n        anchor: this.anchor.toJSON(options),\\n        focus: this.focus.toJSON(options)\\n      };\\n\\n      return object;\\n    }\\n  }], [{\\n    key: 'create',\\n\\n    /**\\n     * Create a new `Annotation` with `attrs`.\\n     *\\n     * @param {Object|Annotation} attrs\\n     * @return {Annotation}\\n     */\\n\\n    value: function create() {\\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      if (Annotation.isAnnotation(attrs)) {\\n        return attrs;\\n      }\\n\\n      if (Range.isRange(attrs)) {\\n        return Annotation.fromJSON(Range.createProperties(attrs));\\n      }\\n\\n      if (isPlainObject(attrs)) {\\n        return Annotation.fromJSON(attrs);\\n      }\\n\\n      throw new Error('`Annotation.create` only accepts objects or annotations, but you passed it: ' + attrs);\\n    }\\n\\n    /**\\n     * Create a map of annotations from `elements`.\\n     *\\n     * @param {Object<String,Annotation>|Map<String,Annotation>} elements\\n     * @return {Map<String,Annotation>}\\n     */\\n\\n  }, {\\n    key: 'createMap',\\n    value: function createMap() {\\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n      if (immutable.Map.isMap(elements)) {\\n        return elements;\\n      }\\n\\n      if (isPlainObject(elements)) {\\n        var obj = {};\\n\\n        for (var key in elements) {\\n          var value = elements[key];\\n          var annotation = Annotation.create(value);\\n          obj[key] = annotation;\\n        }\\n\\n        return immutable.Map(obj);\\n      }\\n\\n      throw new Error('`Annotation.createMap` only accepts arrays or lists, but you passed it: ' + elements);\\n    }\\n\\n    /**\\n     * Create a dictionary of settable annotation properties from `attrs`.\\n     *\\n     * @param {Object|String|Annotation} attrs\\n     * @return {Object}\\n     */\\n\\n  }, {\\n    key: 'createProperties',\\n    value: function createProperties() {\\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      if (Annotation.isAnnotation(a)) {\\n        return {\\n          key: a.key,\\n          type: a.type,\\n          data: a.data,\\n          anchor: Point.createProperties(a.anchor),\\n          focus: Point.createProperties(a.focus)\\n        };\\n      }\\n\\n      if (isPlainObject(a)) {\\n        var p = {};\\n        if ('key' in a) p.key = a.key;\\n        if ('type' in a) p.type = a.type;\\n        if ('data' in a) p.data = Data.create(a.data);\\n        if ('anchor' in a) p.anchor = Point.create(a.anchor);\\n        if ('focus' in a) p.focus = Point.create(a.focus);\\n        return p;\\n      }\\n\\n      throw new Error('`Annotation.createProperties` only accepts objects or annotations, but you passed it: ' + a);\\n    }\\n\\n    /**\\n     * Create a `Annotation` from a JSON `object`.\\n     *\\n     * @param {Object} object\\n     * @return {Annotation}\\n     */\\n\\n  }, {\\n    key: 'fromJSON',\\n    value: function fromJSON(object) {\\n      var key = object.key,\\n          type = object.type,\\n          data = object.data,\\n          anchor = object.anchor,\\n          focus = object.focus;\\n\\n\\n      if (!key) {\\n        throw new Error('Annotations must be created with a `key`, but you passed: ' + JSON.stringify(object));\\n      }\\n\\n      if (!type) {\\n        throw new Error('Annotations must be created with a `type`, but you passed: ' + JSON.stringify(object));\\n      }\\n\\n      var annotation = new Annotation({\\n        key: key,\\n        type: type,\\n        data: Data.create(data || {}),\\n        anchor: Point.fromJSON(anchor || {}),\\n        focus: Point.fromJSON(focus || {})\\n      });\\n\\n      return annotation;\\n    }\\n  }]);\\n  return Annotation;\\n}(immutable.Record(DEFAULTS$5));\\n\\n/**\\n * Default properties.\\n *\\n * @type {Object}\\n */\\n\\nvar DEFAULTS$6 = {\\n  data: undefined,\\n  key: undefined,\\n  nodes: undefined\\n\\n  /**\\n   * Document.\\n   *\\n   * @type {Document}\\n   */\\n\\n};\\nvar Document = function (_Record) {\\n  inherits(Document, _Record);\\n\\n  function Document() {\\n    classCallCheck(this, Document);\\n    return possibleConstructorReturn(this, (Document.__proto__ || Object.getPrototypeOf(Document)).apply(this, arguments));\\n  }\\n\\n  createClass(Document, [{\\n    key: 'toJSON',\\n\\n\\n    /**\\n     * Return a JSON representation of the document.\\n     *\\n     * @param {Object} options\\n     * @return {Object}\\n     */\\n\\n    value: function toJSON() {\\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      var object = {\\n        object: this.object,\\n        data: this.data.toJSON(),\\n        nodes: this.nodes.toArray().map(function (n) {\\n          return n.toJSON(options);\\n        })\\n      };\\n\\n      if (options.preserveKeys) {\\n        object.key = this.key;\\n      }\\n\\n      return object;\\n    }\\n  }], [{\\n    key: 'create',\\n\\n    /**\\n     * Create a new `Document` with `attrs`.\\n     *\\n     * @param {Object|Array|List|Text} attrs\\n     * @return {Document}\\n     */\\n\\n    value: function create() {\\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      if (Document.isDocument(attrs)) {\\n        return attrs;\\n      }\\n\\n      if (immutable.List.isList(attrs) || Array.isArray(attrs)) {\\n        attrs = { nodes: attrs };\\n      }\\n\\n      if (isPlainObject(attrs)) {\\n        return Document.fromJSON(attrs);\\n      }\\n\\n      throw new Error('`Document.create` only accepts objects, arrays, lists or documents, but you passed it: ' + attrs);\\n    }\\n\\n    /**\\n     * Create a `Document` from a JSON `object`.\\n     *\\n     * @param {Object|Document} object\\n     * @return {Document}\\n     */\\n\\n  }, {\\n    key: 'fromJSON',\\n    value: function fromJSON(object) {\\n      if (Document.isDocument(object)) {\\n        return object;\\n      }\\n\\n      var _object$data = object.data,\\n          data = _object$data === undefined ? {} : _object$data,\\n          _object$key = object.key,\\n          key = _object$key === undefined ? KeyUtils.create() : _object$key,\\n          _object$nodes = object.nodes,\\n          nodes = _object$nodes === undefined ? [] : _object$nodes;\\n\\n\\n      var document = new Document({\\n        key: key,\\n        data: new immutable.Map(data),\\n        nodes: Node.createList(nodes)\\n      });\\n\\n      return document;\\n    }\\n  }]);\\n  return Document;\\n}(immutable.Record(DEFAULTS$6));\\n\\n/**\\n * Default properties.\\n *\\n * @type {Object}\\n */\\n\\nvar DEFAULTS$7 = {\\n  data: undefined,\\n  key: undefined,\\n  nodes: undefined,\\n  type: undefined\\n\\n  /**\\n   * Inline.\\n   *\\n   * @type {Inline}\\n   */\\n\\n};\\nvar Inline = function (_Record) {\\n  inherits(Inline, _Record);\\n\\n  function Inline() {\\n    classCallCheck(this, Inline);\\n    return possibleConstructorReturn(this, (Inline.__proto__ || Object.getPrototypeOf(Inline)).apply(this, arguments));\\n  }\\n\\n  createClass(Inline, [{\\n    key: 'toJSON',\\n\\n\\n    /**\\n     * Return a JSON representation of the inline.\\n     *\\n     * @param {Object} options\\n     * @return {Object}\\n     */\\n\\n    value: function toJSON() {\\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      var object = {\\n        object: this.object,\\n        type: this.type,\\n        data: this.data.toJSON(),\\n        nodes: this.nodes.toArray().map(function (n) {\\n          return n.toJSON(options);\\n        })\\n      };\\n\\n      if (options.preserveKeys) {\\n        object.key = this.key;\\n      }\\n\\n      return object;\\n    }\\n  }], [{\\n    key: 'create',\\n\\n    /**\\n     * Create a new `Inline` with `attrs`.\\n     *\\n     * @param {Object|String|Inline} attrs\\n     * @return {Inline}\\n     */\\n\\n    value: function create() {\\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      if (Inline.isInline(attrs)) {\\n        return attrs;\\n      }\\n\\n      if (typeof attrs === 'string') {\\n        attrs = { type: attrs };\\n      }\\n\\n      if (isPlainObject(attrs)) {\\n        return Inline.fromJSON(attrs);\\n      }\\n\\n      throw new Error('`Inline.create` only accepts objects, strings or inlines, but you passed it: ' + attrs);\\n    }\\n\\n    /**\\n     * Create a list of `Inlines` from an array.\\n     *\\n     * @param {Array<Inline|Object>|List<Inline|Object>} elements\\n     * @return {List<Inline>}\\n     */\\n\\n  }, {\\n    key: 'createList',\\n    value: function createList() {\\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\\n        var list = new immutable.List(elements.map(Inline.create));\\n        return list;\\n      }\\n\\n      throw new Error('`Inline.createList` only accepts arrays or lists, but you passed it: ' + elements);\\n    }\\n\\n    /**\\n     * Create a `Inline` from a JSON `object`.\\n     *\\n     * @param {Object|Inline} object\\n     * @return {Inline}\\n     */\\n\\n  }, {\\n    key: 'fromJSON',\\n    value: function fromJSON(object) {\\n      if (Inline.isInline(object)) {\\n        return object;\\n      }\\n\\n      var _object$data = object.data,\\n          data = _object$data === undefined ? {} : _object$data,\\n          _object$key = object.key,\\n          key = _object$key === undefined ? KeyUtils.create() : _object$key,\\n          _object$nodes = object.nodes,\\n          nodes = _object$nodes === undefined ? [] : _object$nodes,\\n          type = object.type;\\n\\n\\n      if (typeof type !== 'string') {\\n        throw new Error('`Inline.fromJS` requires a `type` string.');\\n      }\\n\\n      var inline = new Inline({\\n        key: key,\\n        type: type,\\n        data: new immutable.Map(data),\\n        nodes: Node.createList(nodes)\\n      });\\n\\n      return inline;\\n    }\\n\\n    /**\\n     * Check if `any` is a list of inlines.\\n     *\\n     * @param {Any} any\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isInlineList',\\n    value: function isInlineList(any) {\\n      return immutable.List.isList(any) && any.every(function (item) {\\n        return Inline.isInline(item);\\n      });\\n    }\\n  }]);\\n  return Inline;\\n}(immutable.Record(DEFAULTS$7));\\n\\n/**\\n * Default properties.\\n *\\n * @type {Object}\\n */\\n\\nvar DEFAULTS$8 = {\\n  key: undefined,\\n  marks: undefined,\\n  text: undefined\\n};\\n\\nvar Leaf = immutable.Record({\\n  text: undefined,\\n  marks: undefined,\\n  annotations: undefined,\\n  decorations: undefined\\n});\\n\\n/**\\n * Text.\\n *\\n * @type {Text}\\n */\\n\\nvar Text = function (_Record) {\\n  inherits(Text, _Record);\\n\\n  function Text() {\\n    classCallCheck(this, Text);\\n    return possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).apply(this, arguments));\\n  }\\n\\n  createClass(Text, [{\\n    key: 'addMark',\\n\\n\\n    /**\\n     * Add a `mark`.\\n     *\\n     * @param {Mark} mark\\n     * @return {Text}\\n     */\\n\\n    value: function addMark(mark) {\\n      mark = Mark.create(mark);\\n      var marks = this.marks;\\n\\n      var next = marks.add(mark);\\n      var node = this.set('marks', next);\\n      return node;\\n    }\\n\\n    /**\\n     * Add a set of `marks`.\\n     *\\n     * @param {Set<Mark>} marks\\n     * @return {Text}\\n     */\\n\\n  }, {\\n    key: 'addMarks',\\n    value: function addMarks(marks) {\\n      marks = Mark.createSet(marks);\\n      var node = this.set('marks', this.marks.union(marks));\\n      return node;\\n    }\\n\\n    /**\\n     * Get a list of uniquely-formatted leaves for the text node, given its\\n     * existing marks, and its current `annotations` and `decorations`.\\n     *\\n     * @param {Map<String,Annotation>} annotations\\n     * @param {List<Decoration>} decorations\\n     * @return {List<Leaf>}\\n     */\\n\\n  }, {\\n    key: 'getLeaves',\\n    value: function getLeaves(annotations, decorations) {\\n      var text = this.text,\\n          marks = this.marks;\\n\\n      var leaves = [{ text: text, marks: marks, annotations: [], decorations: [] }];\\n\\n      // Helper to split a leaf into two `at` an offset.\\n      var split = function split(leaf, at) {\\n        return [{\\n          text: leaf.text.slice(0, at),\\n          marks: leaf.marks,\\n          annotations: [].concat(toConsumableArray(leaf.annotations)),\\n          decorations: [].concat(toConsumableArray(leaf.decorations))\\n        }, {\\n          text: leaf.text.slice(at),\\n          marks: leaf.marks,\\n          annotations: [].concat(toConsumableArray(leaf.annotations)),\\n          decorations: [].concat(toConsumableArray(leaf.decorations))\\n        }];\\n      };\\n\\n      // Helper to compile the leaves for a `kind` of format.\\n      var compile = function compile(kind) {\\n        var formats = kind === 'annotations' ? annotations.values() : decorations;\\n\\n        var _iteratorNormalCompletion = true;\\n        var _didIteratorError = false;\\n        var _iteratorError = undefined;\\n\\n        try {\\n          for (var _iterator = formats[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n            var format = _step.value;\\n            var start = format.start,\\n                end = format.end;\\n\\n            var next = [];\\n            var o = 0;\\n\\n            var _iteratorNormalCompletion2 = true;\\n            var _didIteratorError2 = false;\\n            var _iteratorError2 = undefined;\\n\\n            try {\\n              for (var _iterator2 = leaves[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n                var leaf = _step2.value;\\n                var length = leaf.text.length;\\n\\n                var offset = o;\\n                o += length;\\n\\n                // If the range encompases the entire leaf, add the format.\\n                if (start.offset <= offset && end.offset >= offset + length) {\\n                  leaf[kind].push(format);\\n                  next.push(leaf);\\n                  continue;\\n                }\\n\\n                // If the range starts after the leaf, or ends before it, continue.\\n                if (start.offset > offset + length || end.offset < offset || end.offset === offset && offset !== 0) {\\n                  next.push(leaf);\\n                  continue;\\n                }\\n\\n                // Otherwise we need to split the leaf, at the start, end, or both,\\n                // and add the format to the middle intersecting section. Do the end\\n                // split first since we don't need to update the offset that way.\\n                var middle = leaf;\\n                var before = void 0;\\n                var after = void 0;\\n\\n                if (end.offset < offset + length) {\\n                  \\n                  var _split = split(middle, end.offset - offset);\\n\\n                  var _split2 = slicedToArray(_split, 2);\\n\\n                  middle = _split2[0];\\n                  after = _split2[1];\\n                }\\n\\n                if (start.offset > offset) {\\n                  \\n                  var _split3 = split(middle, start.offset - offset);\\n\\n                  var _split4 = slicedToArray(_split3, 2);\\n\\n                  before = _split4[0];\\n                  middle = _split4[1];\\n                }\\n\\n                middle[kind].push(format);\\n\\n                if (before) {\\n                  next.push(before);\\n                }\\n\\n                next.push(middle);\\n\\n                if (after) {\\n                  next.push(after);\\n                }\\n              }\\n            } catch (err) {\\n              _didIteratorError2 = true;\\n              _iteratorError2 = err;\\n            } finally {\\n              try {\\n                if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n                  _iterator2.return();\\n                }\\n              } finally {\\n                if (_didIteratorError2) {\\n                  throw _iteratorError2;\\n                }\\n              }\\n            }\\n\\n            leaves = next;\\n          }\\n        } catch (err) {\\n          _didIteratorError = true;\\n          _iteratorError = err;\\n        } finally {\\n          try {\\n            if (!_iteratorNormalCompletion && _iterator.return) {\\n              _iterator.return();\\n            }\\n          } finally {\\n            if (_didIteratorError) {\\n              throw _iteratorError;\\n            }\\n          }\\n        }\\n      };\\n\\n      compile('annotations');\\n      compile('decorations');\\n\\n      leaves = leaves.map(function (leaf) {\\n        return new Leaf(_extends({}, leaf, {\\n          annotations: immutable.List(leaf.annotations),\\n          decorations: immutable.List(leaf.decorations)\\n        }));\\n      });\\n\\n      var list = immutable.List(leaves);\\n      return list;\\n    }\\n\\n    /**\\n     * Insert `text` at `index`.\\n     *\\n     * @param {Number} index\\n     * @param {String} string\\n     * @return {Text}\\n     */\\n\\n  }, {\\n    key: 'insertText',\\n    value: function insertText(index, string) {\\n      var text = this.text;\\n\\n      var next = text.slice(0, index) + string + text.slice(index);\\n      var node = this.set('text', next);\\n      return node;\\n    }\\n\\n    /**\\n     * Remove a `mark`.\\n     *\\n     * @param {Mark} mark\\n     * @return {Text}\\n     */\\n\\n  }, {\\n    key: 'removeMark',\\n    value: function removeMark(mark) {\\n      mark = Mark.create(mark);\\n      var marks = this.marks;\\n\\n      var next = marks.remove(mark);\\n      var node = this.set('marks', next);\\n      return node;\\n    }\\n\\n    /**\\n     * Remove text from the text node at `index` for `length`.\\n     *\\n     * @param {Number} index\\n     * @param {Number} length\\n     * @return {Text}\\n     */\\n\\n  }, {\\n    key: 'removeText',\\n    value: function removeText(index, length) {\\n      var text = this.text;\\n\\n      var next = text.slice(0, index) + text.slice(index + length);\\n      var node = this.set('text', next);\\n      return node;\\n    }\\n\\n    /**\\n     * Return a JSON representation of the text.\\n     *\\n     * @param {Object} options\\n     * @return {Object}\\n     */\\n\\n  }, {\\n    key: 'toJSON',\\n    value: function toJSON() {\\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      var object = {\\n        object: this.object,\\n        text: this.text,\\n        marks: this.marks.toArray().map(function (m) {\\n          return m.toJSON();\\n        })\\n      };\\n\\n      if (options.preserveKeys) {\\n        object.key = this.key;\\n      }\\n\\n      return object;\\n    }\\n\\n    /**\\n     * Set a `newProperties` on an existing `mark`.\\n     *\\n     * @param {Object} mark\\n     * @param {Object} newProperties\\n     * @return {Text}\\n     */\\n\\n  }, {\\n    key: 'setMark',\\n    value: function setMark(properties, newProperties) {\\n      var marks = this.marks;\\n\\n      var mark = Mark.create(properties);\\n      var newMark = mark.merge(newProperties);\\n      var next = marks.remove(mark).add(newMark);\\n      var node = this.set('marks', next);\\n      return node;\\n    }\\n\\n    /**\\n     * Split the node into two at `index`.\\n     *\\n     * @param {Number} index\\n     * @returns {Array<Text>}\\n     */\\n\\n  }, {\\n    key: 'splitText',\\n    value: function splitText(index) {\\n      var text = this.text;\\n\\n      var one = this.set('text', text.slice(0, index));\\n      var two = this.set('text', text.slice(index)).regenerateKey();\\n      return [one, two];\\n    }\\n\\n    /**\\n     * Merge the node with an `other` text node.\\n     *\\n     * @param {Text} other\\n     * @returns {Text}\\n     */\\n\\n  }, {\\n    key: 'mergeText',\\n    value: function mergeText(other) {\\n      var next = this.text + other.text;\\n      var node = this.set('text', next);\\n      return node;\\n    }\\n  }], [{\\n    key: 'create',\\n\\n    /**\\n     * Create a new `Text` with `attrs`.\\n     *\\n     * @param {Object|Array|List|String|Text} attrs\\n     * @return {Text}\\n     */\\n\\n    value: function create() {\\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\\n\\n      if (Text.isText(attrs)) {\\n        return attrs;\\n      }\\n\\n      if (typeof attrs === 'string') {\\n        attrs = { text: attrs };\\n      }\\n\\n      if (isPlainObject(attrs)) {\\n        return Text.fromJSON(attrs);\\n      }\\n\\n      throw new Error('`Text.create` only accepts objects, arrays, strings or texts, but you passed it: ' + attrs);\\n    }\\n\\n    /**\\n     * Create a list of `Texts` from `elements`.\\n     *\\n     * @param {Array<Text|Object>|List<Text|Object>} elements\\n     * @return {List<Text>}\\n     */\\n\\n  }, {\\n    key: 'createList',\\n    value: function createList() {\\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\\n        var list = new immutable.List(elements.map(Text.create));\\n        return list;\\n      }\\n\\n      throw new Error('`Text.createList` only accepts arrays or lists, but you passed it: ' + elements);\\n    }\\n\\n    /**\\n     * Create a `Text` from a JSON `object`.\\n     *\\n     * @param {Object|Text} object\\n     * @return {Text}\\n     */\\n\\n  }, {\\n    key: 'fromJSON',\\n    value: function fromJSON(object) {\\n      if (Text.isText(object)) {\\n        return object;\\n      }\\n\\n      invariant(object.leaves == null, 'As of slate@0.46, the `leaves` property of text nodes has been removed! Each individual leaf should be created as a text node instead.');\\n\\n      var _object$text = object.text,\\n          text = _object$text === undefined ? '' : _object$text,\\n          _object$marks = object.marks,\\n          marks = _object$marks === undefined ? [] : _object$marks,\\n          _object$key = object.key,\\n          key = _object$key === undefined ? KeyUtils.create() : _object$key;\\n\\n      var node = new Text({\\n        key: key,\\n        text: text,\\n        marks: Mark.createSet(marks)\\n      });\\n\\n      return node;\\n    }\\n\\n    /**\\n     * Check if `any` is a list\\u00a0of texts.\\n     *\\n     * @param {Any} any\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isTextList',\\n    value: function isTextList(any) {\\n      return immutable.List.isList(any) && any.every(function (item) {\\n        return Text.isText(item);\\n      });\\n    }\\n  }]);\\n  return Text;\\n}(immutable.Record(DEFAULTS$8));\\n\\n/**\\n * A pseudo-model that is used for its static methods only.\\n *\\n * @type {Node}\\n */\\n\\nvar Node = function () {\\n  function Node() {\\n    classCallCheck(this, Node);\\n  }\\n\\n  createClass(Node, null, [{\\n    key: 'create',\\n\\n    /**\\n     * Create a new `Node` with `attrs`.\\n     *\\n     * @param {Object|Node} attrs\\n     * @return {Node}\\n     */\\n\\n    value: function create() {\\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      if (Node.isNode(attrs)) {\\n        return attrs;\\n      }\\n\\n      if (isPlainObject(attrs)) {\\n        var object = attrs.object;\\n\\n\\n        if (!object && attrs.kind) {\\n          warning(false, 'As of slate@0.32.0, the `kind` property of Slate objects has been renamed to `object`.');\\n\\n          object = attrs.kind;\\n        }\\n\\n        switch (object) {\\n          case 'block':\\n            return Block.create(attrs);\\n          case 'document':\\n            return Document.create(attrs);\\n          case 'inline':\\n            return Inline.create(attrs);\\n          case 'text':\\n            return Text.create(attrs);\\n\\n          default:\\n            {\\n              throw new Error('`Node.create` requires a `object` string.');\\n            }\\n        }\\n      }\\n\\n      throw new Error('`Node.create` only accepts objects or nodes but you passed it: ' + attrs);\\n    }\\n\\n    /**\\n     * Create a list of `Nodes` from an array.\\n     *\\n     * @param {Array<Object|Node>} elements\\n     * @return {List<Node>}\\n     */\\n\\n  }, {\\n    key: 'createList',\\n    value: function createList() {\\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\\n        var array = [];\\n\\n        elements.forEach(function (el) {\\n          if (el && el.object === 'text' && el.leaves && Array.isArray(el.leaves)) {\\n            warning(false, 'As of slate@0.46, the `leaves` property of Text nodes has been removed. Instead, each text node contains a string of text and a unique set of marks and leaves are unnecessary.');\\n\\n            var texts = Text.createList(el.leaves).toArray();\\n            array = array.concat(texts);\\n            return;\\n          }\\n\\n          var node = Node.create(el);\\n          array.push(node);\\n        });\\n\\n        var list = immutable.List(array);\\n        return list;\\n      }\\n\\n      throw new Error('`Node.createList` only accepts lists or arrays, but you passed it: ' + elements);\\n    }\\n\\n    /**\\n     * Create a dictionary of settable node properties from `attrs`.\\n     *\\n     * @param {Object|String|Node} attrs\\n     * @return {Object}\\n     */\\n\\n  }, {\\n    key: 'createProperties',\\n    value: function createProperties() {\\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      if (Block.isBlock(attrs) || Inline.isInline(attrs)) {\\n        return {\\n          data: attrs.data,\\n          type: attrs.type\\n        };\\n      }\\n\\n      if (typeof attrs === 'string') {\\n        return { type: attrs };\\n      }\\n\\n      if (isPlainObject(attrs)) {\\n        var props = {};\\n        if ('type' in attrs) props.type = attrs.type;\\n        if ('data' in attrs) props.data = Data.create(attrs.data);\\n        return props;\\n      }\\n\\n      throw new Error('`Node.createProperties` only accepts objects, strings, blocks or inlines, but you passed it: ' + attrs);\\n    }\\n\\n    /**\\n     * Create a `Node` from a JSON `value`.\\n     *\\n     * @param {Object} value\\n     * @return {Node}\\n     */\\n\\n  }, {\\n    key: 'fromJSON',\\n    value: function fromJSON(value) {\\n      var object = value.object;\\n\\n\\n      if (!object && value.kind) {\\n        warning(false, 'As of slate@0.32.0, the `kind` property of Slate objects has been renamed to `object`.');\\n\\n        object = value.kind;\\n      }\\n\\n      switch (object) {\\n        case 'block':\\n          return Block.fromJSON(value);\\n        case 'document':\\n          return Document.fromJSON(value);\\n        case 'inline':\\n          return Inline.fromJSON(value);\\n        case 'text':\\n          return Text.fromJSON(value);\\n\\n        default:\\n          {\\n            throw new Error('`Node.fromJSON` requires an `object` of either \\\\'block\\\\', \\\\'document\\\\', \\\\'inline\\\\' or \\\\'text\\\\', but you passed: ' + value);\\n          }\\n      }\\n    }\\n\\n    /**\\n     * Check if `any` is a `Node`.\\n     *\\n     * @param {Any} any\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isNode',\\n    value: function isNode(any) {\\n      return Block.isBlock(any) || Document.isDocument(any) || Inline.isInline(any) || Text.isText(any);\\n    }\\n\\n    /**\\n     * Check if `any` is a list of nodes.\\n     *\\n     * @param {Any} any\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isNodeList',\\n    value: function isNodeList(any) {\\n      return immutable.List.isList(any) && any.every(function (item) {\\n        return Node.isNode(item);\\n      });\\n    }\\n  }]);\\n  return Node;\\n}();\\n\\n/**\\n * Default properties.\\n *\\n * @type {Object}\\n */\\n\\nvar DEFAULTS$9 = {\\n  data: undefined,\\n  key: undefined,\\n  nodes: undefined,\\n  type: undefined\\n\\n  /**\\n   * Block.\\n   *\\n   * @type {Block}\\n   */\\n\\n};\\nvar Block = function (_Record) {\\n  inherits(Block, _Record);\\n\\n  function Block() {\\n    classCallCheck(this, Block);\\n    return possibleConstructorReturn(this, (Block.__proto__ || Object.getPrototypeOf(Block)).apply(this, arguments));\\n  }\\n\\n  createClass(Block, [{\\n    key: 'toJSON',\\n\\n\\n    /**\\n     * Return a JSON representation of the block.\\n     *\\n     * @param {Object} options\\n     * @return {Object}\\n     */\\n\\n    value: function toJSON() {\\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      var object = {\\n        object: this.object,\\n        type: this.type,\\n        data: this.data.toJSON(),\\n        nodes: this.nodes.toArray().map(function (n) {\\n          return n.toJSON(options);\\n        })\\n      };\\n\\n      if (options.preserveKeys) {\\n        object.key = this.key;\\n      }\\n\\n      return object;\\n    }\\n  }], [{\\n    key: 'create',\\n\\n    /**\\n     * Create a new `Block` from `attrs`.\\n     *\\n     * @param {Object|String|Block} attrs\\n     * @return {Block}\\n     */\\n\\n    value: function create() {\\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      if (Block.isBlock(attrs)) {\\n        return attrs;\\n      }\\n\\n      if (typeof attrs === 'string') {\\n        attrs = { type: attrs };\\n      }\\n\\n      if (isPlainObject(attrs)) {\\n        return Block.fromJSON(attrs);\\n      }\\n\\n      throw new Error('`Block.create` only accepts objects, strings or blocks, but you passed it: ' + attrs);\\n    }\\n\\n    /**\\n     * Create a list of `Blocks` from `attrs`.\\n     *\\n     * @param {Array<Block|Object>|List<Block|Object>} attrs\\n     * @return {List<Block>}\\n     */\\n\\n  }, {\\n    key: 'createList',\\n    value: function createList() {\\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n      if (immutable.List.isList(attrs) || Array.isArray(attrs)) {\\n        var list = new immutable.List(attrs.map(Block.create));\\n        return list;\\n      }\\n\\n      throw new Error('`Block.createList` only accepts arrays or lists, but you passed it: ' + attrs);\\n    }\\n\\n    /**\\n     * Create a `Block` from a JSON `object`.\\n     *\\n     * @param {Object|Block} object\\n     * @return {Block}\\n     */\\n\\n  }, {\\n    key: 'fromJSON',\\n    value: function fromJSON(object) {\\n      if (Block.isBlock(object)) {\\n        return object;\\n      }\\n\\n      var _object$data = object.data,\\n          data = _object$data === undefined ? {} : _object$data,\\n          _object$key = object.key,\\n          key = _object$key === undefined ? KeyUtils.create() : _object$key,\\n          _object$nodes = object.nodes,\\n          nodes = _object$nodes === undefined ? [] : _object$nodes,\\n          type = object.type;\\n\\n\\n      if (typeof type !== 'string') {\\n        throw new Error('`Block.fromJSON` requires a `type` string.');\\n      }\\n\\n      var block = new Block({\\n        key: key,\\n        type: type,\\n        data: immutable.Map(data),\\n        nodes: Node.createList(nodes)\\n      });\\n\\n      return block;\\n    }\\n\\n    /**\\n     * Check if `any` is a block list.\\n     *\\n     * @param {Any} any\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isBlockList',\\n    value: function isBlockList(any) {\\n      return immutable.List.isList(any) && any.every(function (item) {\\n        return Block.isBlock(item);\\n      });\\n    }\\n  }]);\\n  return Block;\\n}(immutable.Record(DEFAULTS$9));\\n\\n/**\\n * Default properties.\\n *\\n * @type {Object}\\n */\\n\\nvar DEFAULTS$10 = {\\n  annotations: undefined,\\n  data: undefined,\\n  document: undefined,\\n  selection: undefined\\n\\n  /**\\n   * Value.\\n   *\\n   * @type {Value}\\n   */\\n\\n};\\nvar Value = function (_Record) {\\n  inherits(Value, _Record);\\n\\n  function Value() {\\n    classCallCheck(this, Value);\\n    return possibleConstructorReturn(this, (Value.__proto__ || Object.getPrototypeOf(Value)).apply(this, arguments));\\n  }\\n\\n  createClass(Value, [{\\n    key: 'addAnnotation',\\n\\n\\n    /**\\n     * Add an `annotation` to the value.\\n     *\\n     * @param {Annotation} annotation\\n     * @param {Mark} mark\\n     * @return {Value}\\n     */\\n\\n    value: function addAnnotation(annotation) {\\n      annotation = Annotation.create(annotation);\\n      var value = this;\\n      var _value = value,\\n          annotations = _value.annotations,\\n          document = _value.document;\\n      var _annotation = annotation,\\n          key = _annotation.key;\\n\\n      annotation = annotation.updatePoints(function (point) {\\n        return point.normalize(document);\\n      });\\n      annotations = annotations.set(key, annotation);\\n      value = value.set('annotations', annotations);\\n      return value;\\n    }\\n\\n    /**\\n     * Add `mark` to text at `path`.\\n     *\\n     * @param {List|String} path\\n     * @param {Mark} mark\\n     * @return {Value}\\n     */\\n\\n  }, {\\n    key: 'addMark',\\n    value: function addMark(path, mark) {\\n      mark = Mark.create(mark);\\n      var value = this;\\n      var _value2 = value,\\n          document = _value2.document;\\n\\n      document = document.addMark(path, mark);\\n      value = value.set('document', document);\\n      return value;\\n    }\\n\\n    /**\\n     * Insert a `node`.\\n     *\\n     * @param {List|String} path\\n     * @param {Node} node\\n     * @return {Value}\\n     */\\n\\n  }, {\\n    key: 'insertNode',\\n    value: function insertNode(path, node) {\\n      var value = this;\\n      var _value3 = value,\\n          document = _value3.document;\\n\\n      document = document.insertNode(path, node);\\n      value = value.set('document', document);\\n\\n      value = value.mapRanges(function (range) {\\n        return range.updatePoints(function (point) {\\n          return point.setPath(null);\\n        });\\n      });\\n\\n      return value;\\n    }\\n\\n    /**\\n     * Insert `text` at `offset` in node by `path`.\\n     *\\n     * @param {List|String} path\\n     * @param {Number} offset\\n     * @param {String} text\\n     * @return {Value}\\n     */\\n\\n  }, {\\n    key: 'insertText',\\n    value: function insertText(path, offset, text) {\\n      var value = this;\\n      var _value4 = value,\\n          document = _value4.document;\\n\\n      var node = document.assertNode(path);\\n      document = document.insertText(path, offset, text);\\n      node = document.assertNode(path);\\n      value = value.set('document', document);\\n\\n      value = value.mapPoints(function (point) {\\n        if (point.key === node.key && point.offset >= offset) {\\n          return point.setOffset(point.offset + text.length);\\n        } else {\\n          return point;\\n        }\\n      });\\n\\n      return value;\\n    }\\n\\n    /**\\n     * Merge a node backwards its previous sibling.\\n     *\\n     * @param {List|Key} path\\n     * @return {Value}\\n     */\\n\\n  }, {\\n    key: 'mergeNode',\\n    value: function mergeNode(path) {\\n      var value = this;\\n      var _value5 = value,\\n          document = _value5.document;\\n\\n      var newDocument = document.mergeNode(path);\\n      path = document.resolvePath(path);\\n      var withPath = PathUtils.decrement(path);\\n      var one = document.getNode(withPath);\\n      var two = document.getNode(path);\\n      value = value.set('document', newDocument);\\n\\n      value = value.mapRanges(function (range) {\\n        if (two.object === 'text') {\\n          var max = one.text.length;\\n\\n          if (range.anchor.key === two.key) {\\n            range = range.moveAnchorTo(one.key, max + range.anchor.offset);\\n          }\\n\\n          if (range.focus.key === two.key) {\\n            range = range.moveFocusTo(one.key, max + range.focus.offset);\\n          }\\n        }\\n\\n        range = range.updatePoints(function (point) {\\n          return point.setPath(null);\\n        });\\n\\n        return range;\\n      });\\n\\n      return value;\\n    }\\n\\n    /**\\n     * Move a node by `path` to `newPath`.\\n     *\\n     * A `newIndex` can be provided when move nodes by `key`, to account for not\\n     * being able to have a key for a location in the tree that doesn't exist yet.\\n     *\\n     * @param {List|Key} path\\n     * @param {List|Key} newPath\\n     * @param {Number} newIndex\\n     * @return {Value}\\n     */\\n\\n  }, {\\n    key: 'moveNode',\\n    value: function moveNode(path, newPath) {\\n      var newIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\\n\\n      var value = this;\\n      var _value6 = value,\\n          document = _value6.document;\\n\\n\\n      if (PathUtils.isEqual(path, newPath)) {\\n        return value;\\n      }\\n\\n      document = document.moveNode(path, newPath, newIndex);\\n      value = value.set('document', document);\\n      value = value.mapPoints(function (point) {\\n        return point.setPath(null);\\n      });\\n      return value;\\n    }\\n\\n    /**\\n     * Remove an `annotation` from the value.\\n     *\\n     * @param {Annotation} annotation\\n     * @param {Mark} mark\\n     * @return {Value}\\n     */\\n\\n  }, {\\n    key: 'removeAnnotation',\\n    value: function removeAnnotation(annotation) {\\n      annotation = Annotation.create(annotation);\\n      var value = this;\\n      var _value7 = value,\\n          annotations = _value7.annotations;\\n      var _annotation2 = annotation,\\n          key = _annotation2.key;\\n\\n      annotations = annotations.delete(key);\\n      value = value.set('annotations', annotations);\\n      return value;\\n    }\\n\\n    /**\\n     * Remove `mark` at `path`.\\n     *\\n     * @param {List|String} path\\n     * @param {Mark} mark\\n     * @return {Value}\\n     */\\n\\n  }, {\\n    key: 'removeMark',\\n    value: function removeMark(path, mark) {\\n      mark = Mark.create(mark);\\n      var value = this;\\n      var _value8 = value,\\n          document = _value8.document;\\n\\n      document = document.removeMark(path, mark);\\n      value = value.set('document', document);\\n      return value;\\n    }\\n\\n    /**\\n     * Remove a node by `path`.\\n     *\\n     * @param {List|String} path\\n     * @return {Value}\\n     */\\n\\n  }, {\\n    key: 'removeNode',\\n    value: function removeNode(path) {\\n      var value = this;\\n      var _value9 = value,\\n          document = _value9.document;\\n\\n      var node = document.assertNode(path);\\n      var first = node.object === 'text' ? node : node.getFirstText() || node;\\n      var last = node.object === 'text' ? node : node.getLastText() || node;\\n      var prev = document.getPreviousText(first.key);\\n      var next = document.getNextText(last.key);\\n\\n      document = document.removeNode(path);\\n      value = value.set('document', document);\\n\\n      value = value.mapRanges(function (range) {\\n        var _range = range,\\n            anchor = _range.anchor,\\n            focus = _range.focus;\\n\\n\\n        if (node.hasNode(anchor.key)) {\\n          range = prev ? range.moveAnchorTo(prev.key, prev.text.length) : next ? range.moveAnchorTo(next.key, 0) : range.unset();\\n        }\\n\\n        if (node.hasNode(focus.key)) {\\n          range = prev ? range.moveFocusTo(prev.key, prev.text.length) : next ? range.moveFocusTo(next.key, 0) : range.unset();\\n        }\\n\\n        range = range.updatePoints(function (point) {\\n          return point.setPath(null);\\n        });\\n\\n        return range;\\n      });\\n\\n      return value;\\n    }\\n\\n    /**\\n     * Remove `text` at `offset` in node by `path`.\\n     *\\n     * @param {List|Key} path\\n     * @param {Number} offset\\n     * @param {String} text\\n     * @return {Value}\\n     */\\n\\n  }, {\\n    key: 'removeText',\\n    value: function removeText(path, offset, text) {\\n      var value = this;\\n      var _value10 = value,\\n          document = _value10.document;\\n\\n      var node = document.assertNode(path);\\n      document = document.removeText(path, offset, text);\\n      value = value.set('document', document);\\n\\n      var length = text.length;\\n\\n      var start = offset;\\n      var end = offset + length;\\n\\n      value = value.mapPoints(function (point) {\\n        if (point.key !== node.key) {\\n          return point;\\n        }\\n\\n        if (point.offset >= end) {\\n          return point.setOffset(point.offset - length);\\n        }\\n\\n        if (point.offset > start) {\\n          return point.setOffset(start);\\n        }\\n\\n        return point;\\n      });\\n\\n      return value;\\n    }\\n\\n    /**\\n     * Add an `annotation` to the value.\\n     *\\n     * @param {Annotation} annotation\\n     * @param {Mark} mark\\n     * @return {Value}\\n     */\\n\\n  }, {\\n    key: 'setAnnotation',\\n    value: function setAnnotation(properties, newProperties) {\\n      newProperties = Annotation.createProperties(newProperties);\\n      var annotation = Annotation.create(properties);\\n      var next = annotation.merge(newProperties);\\n      var value = this;\\n      var _value11 = value,\\n          annotations = _value11.annotations;\\n      var key = annotation.key;\\n\\n      annotations = annotations.set(key, next);\\n      value = value.set('annotations', annotations);\\n      return value;\\n    }\\n\\n    /**\\n     * Set `properties` on a node.\\n     *\\n     * @param {List|String} path\\n     * @param {Object} properties\\n     * @return {Value}\\n     */\\n\\n  }, {\\n    key: 'setNode',\\n    value: function setNode(path, properties) {\\n      var value = this;\\n      var _value12 = value,\\n          document = _value12.document;\\n\\n      document = document.setNode(path, properties);\\n      value = value.set('document', document);\\n      return value;\\n    }\\n\\n    /**\\n     * Set `properties` on `mark` on text at `offset` and `length` in node.\\n     *\\n     * @param {List|String} path\\n     * @param {Mark} mark\\n     * @param {Object} properties\\n     * @return {Value}\\n     */\\n\\n  }, {\\n    key: 'setMark',\\n    value: function setMark(path, mark, properties) {\\n      var value = this;\\n      var _value13 = value,\\n          document = _value13.document;\\n\\n      document = document.setMark(path, mark, properties);\\n      value = value.set('document', document);\\n      return value;\\n    }\\n\\n    /**\\n     * Set `properties` on the value.\\n     *\\n     * @param {Object} properties\\n     * @return {Value}\\n     */\\n\\n  }, {\\n    key: 'setProperties',\\n    value: function setProperties(properties) {\\n      var value = this;\\n      var _value14 = value,\\n          document = _value14.document;\\n      var data = properties.data,\\n          annotations = properties.annotations;\\n\\n      var props = {};\\n\\n      if (data) {\\n        props.data = data;\\n      }\\n\\n      if (annotations) {\\n        props.annotations = annotations.map(function (a) {\\n          return a.isSet ? a : document.resolveAnnotation(a);\\n        });\\n      }\\n\\n      value = value.merge(props);\\n      return value;\\n    }\\n\\n    /**\\n     * Set `properties` on the selection.\\n     *\\n     * @param {Value} value\\n     * @param {Operation} operation\\n     * @return {Value}\\n     */\\n\\n  }, {\\n    key: 'setSelection',\\n    value: function setSelection(properties) {\\n      var value = this;\\n      var _value15 = value,\\n          document = _value15.document,\\n          selection = _value15.selection;\\n\\n      var next = selection.setProperties(properties);\\n      selection = document.resolveSelection(next);\\n      value = value.set('selection', selection);\\n      return value;\\n    }\\n\\n    /**\\n     * Split a node by `path` at `position` with optional `properties` to apply\\n     * to the newly split node.\\n     *\\n     * @param {List|String} path\\n     * @param {Number} position\\n     * @param {Object} properties\\n     * @return {Value}\\n     */\\n\\n  }, {\\n    key: 'splitNode',\\n    value: function splitNode(path, position, properties) {\\n      var value = this;\\n      var _value16 = value,\\n          document = _value16.document;\\n\\n      var newDocument = document.splitNode(path, position, properties);\\n      var node = document.assertNode(path);\\n      value = value.set('document', newDocument);\\n\\n      value = value.mapRanges(function (range) {\\n        var next = newDocument.getNextText(node.key);\\n        var _range2 = range,\\n            anchor = _range2.anchor,\\n            focus = _range2.focus;\\n\\n        // If the anchor was after the split, move it to the next node.\\n\\n        if (node.key === anchor.key && position <= anchor.offset) {\\n          range = range.moveAnchorTo(next.key, anchor.offset - position);\\n        }\\n\\n        // If the focus was after the split, move it to the next node.\\n        if (node.key === focus.key && position <= focus.offset) {\\n          range = range.moveFocusTo(next.key, focus.offset - position);\\n        }\\n\\n        range = range.updatePoints(function (point) {\\n          return point.setPath(null);\\n        });\\n\\n        return range;\\n      });\\n\\n      return value;\\n    }\\n\\n    /**\\n     * Map all range objects to apply adjustments with an `iterator`.\\n     *\\n     * @param {Function} iterator\\n     * @return {Value}\\n     */\\n\\n  }, {\\n    key: 'mapRanges',\\n    value: function mapRanges(iterator) {\\n      var value = this;\\n      var _value17 = value,\\n          document = _value17.document,\\n          selection = _value17.selection,\\n          annotations = _value17.annotations;\\n\\n\\n      var sel = selection.isSet ? iterator(selection) : selection;\\n      if (!sel) sel = selection.unset();\\n      if (sel !== selection) sel = document.createSelection(sel);\\n      value = value.set('selection', sel);\\n\\n      var anns = annotations.map(function (annotation) {\\n        var n = annotation.isSet ? iterator(annotation) : annotation;\\n        if (n && n !== annotation) n = document.createAnnotation(n);\\n        return n;\\n      });\\n\\n      anns = anns.filter(function (annotation) {\\n        return !!annotation;\\n      });\\n      value = value.set('annotations', anns);\\n      return value;\\n    }\\n  }, {\\n    key: 'mapPoints',\\n    value: function mapPoints(iterator) {\\n      return this.mapRanges(function (range) {\\n        return range.updatePoints(iterator);\\n      });\\n    }\\n\\n    /**\\n     * Return a JSON representation of the value.\\n     *\\n     * @param {Object} options\\n     * @return {Object}\\n     */\\n\\n  }, {\\n    key: 'toJSON',\\n    value: function toJSON() {\\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      var object = {\\n        object: this.object,\\n        document: this.document.toJSON(options)\\n      };\\n\\n      if (options.preserveData) {\\n        object.data = this.data.toJSON(options);\\n      }\\n\\n      if (options.preserveAnnotations) {\\n        object.annotations = this.annotations.map(function (a) {\\n          return a.toJSON(options);\\n        }).toObject();\\n      }\\n\\n      if (options.preserveSelection) {\\n        object.selection = this.selection.toJSON(options);\\n      }\\n\\n      return object;\\n    }\\n\\n    /**\\n     * Deprecated.\\n     */\\n\\n  }, {\\n    key: 'change',\\n    value: function change() {\\n      invariant(false, 'As of Slate 0.42.0, value object are no longer schema-aware, and the `value.change()` method is no longer available. Use the `editor.change()` method on the new `Editor` controller instead.');\\n    }\\n  }, {\\n    key: 'startBlock',\\n\\n\\n    /**\\n     * Get the current start text node's closest block parent.\\n     *\\n     * @return {Block}\\n     */\\n\\n    get: function get$$1() {\\n      return this.selection.start.key && this.document.getClosestBlock(this.selection.start.key);\\n    }\\n\\n    /**\\n     * Get the current end text node's closest block parent.\\n     *\\n     * @return {Block}\\n     */\\n\\n  }, {\\n    key: 'endBlock',\\n    get: function get$$1() {\\n      return this.selection.end.key && this.document.getClosestBlock(this.selection.end.key);\\n    }\\n\\n    /**\\n     * Get the current anchor text node's closest block parent.\\n     *\\n     * @return {Block}\\n     */\\n\\n  }, {\\n    key: 'anchorBlock',\\n    get: function get$$1() {\\n      return this.selection.anchor.key && this.document.getClosestBlock(this.selection.anchor.key);\\n    }\\n\\n    /**\\n     * Get the current focus text node's closest block parent.\\n     *\\n     * @return {Block}\\n     */\\n\\n  }, {\\n    key: 'focusBlock',\\n    get: function get$$1() {\\n      return this.selection.focus.key && this.document.getClosestBlock(this.selection.focus.key);\\n    }\\n\\n    /**\\n     * Get the current start text node's closest inline parent.\\n     *\\n     * @return {Inline}\\n     */\\n\\n  }, {\\n    key: 'startInline',\\n    get: function get$$1() {\\n      return this.selection.start.key && this.document.getClosestInline(this.selection.start.key);\\n    }\\n\\n    /**\\n     * Get the current end text node's closest inline parent.\\n     *\\n     * @return {Inline}\\n     */\\n\\n  }, {\\n    key: 'endInline',\\n    get: function get$$1() {\\n      return this.selection.end.key && this.document.getClosestInline(this.selection.end.key);\\n    }\\n\\n    /**\\n     * Get the current anchor text node's closest inline parent.\\n     *\\n     * @return {Inline}\\n     */\\n\\n  }, {\\n    key: 'anchorInline',\\n    get: function get$$1() {\\n      return this.selection.anchor.key && this.document.getClosestInline(this.selection.anchor.key);\\n    }\\n\\n    /**\\n     * Get the current focus text node's closest inline parent.\\n     *\\n     * @return {Inline}\\n     */\\n\\n  }, {\\n    key: 'focusInline',\\n    get: function get$$1() {\\n      return this.selection.focus.key && this.document.getClosestInline(this.selection.focus.key);\\n    }\\n\\n    /**\\n     * Get the current start text node.\\n     *\\n     * @return {Text}\\n     */\\n\\n  }, {\\n    key: 'startText',\\n    get: function get$$1() {\\n      return this.selection.start.key && this.document.getDescendant(this.selection.start.key);\\n    }\\n\\n    /**\\n     * Get the current end node.\\n     *\\n     * @return {Text}\\n     */\\n\\n  }, {\\n    key: 'endText',\\n    get: function get$$1() {\\n      return this.selection.end.key && this.document.getDescendant(this.selection.end.key);\\n    }\\n\\n    /**\\n     * Get the current anchor node.\\n     *\\n     * @return {Text}\\n     */\\n\\n  }, {\\n    key: 'anchorText',\\n    get: function get$$1() {\\n      return this.selection.anchor.key && this.document.getDescendant(this.selection.anchor.key);\\n    }\\n\\n    /**\\n     * Get the current focus node.\\n     *\\n     * @return {Text}\\n     */\\n\\n  }, {\\n    key: 'focusText',\\n    get: function get$$1() {\\n      return this.selection.focus.key && this.document.getDescendant(this.selection.focus.key);\\n    }\\n\\n    /**\\n     * Get the next block node.\\n     *\\n     * @return {Block}\\n     */\\n\\n  }, {\\n    key: 'nextBlock',\\n    get: function get$$1() {\\n      return this.selection.end.key && this.document.getNextBlock(this.selection.end.key);\\n    }\\n\\n    /**\\n     * Get the previous block node.\\n     *\\n     * @return {Block}\\n     */\\n\\n  }, {\\n    key: 'previousBlock',\\n    get: function get$$1() {\\n      return this.selection.start.key && this.document.getPreviousBlock(this.selection.start.key);\\n    }\\n\\n    /**\\n     * Get the next inline node.\\n     *\\n     * @return {Inline}\\n     */\\n\\n  }, {\\n    key: 'nextInline',\\n    get: function get$$1() {\\n      return this.selection.end.key && this.document.getNextInline(this.selection.end.key);\\n    }\\n\\n    /**\\n     * Get the previous inline node.\\n     *\\n     * @return {Inline}\\n     */\\n\\n  }, {\\n    key: 'previousInline',\\n    get: function get$$1() {\\n      return this.selection.start.key && this.document.getPreviousInline(this.selection.start.key);\\n    }\\n\\n    /**\\n     * Get the next text node.\\n     *\\n     * @return {Text}\\n     */\\n\\n  }, {\\n    key: 'nextText',\\n    get: function get$$1() {\\n      return this.selection.end.key && this.document.getNextText(this.selection.end.key);\\n    }\\n\\n    /**\\n     * Get the previous text node.\\n     *\\n     * @return {Text}\\n     */\\n\\n  }, {\\n    key: 'previousText',\\n    get: function get$$1() {\\n      return this.selection.start.key && this.document.getPreviousText(this.selection.start.key);\\n    }\\n\\n    /**\\n     * Get the marks of the current selection.\\n     *\\n     * @return {Set<Mark>}\\n     */\\n\\n  }, {\\n    key: 'marks',\\n    get: function get$$1() {\\n      return this.selection.isUnset ? new immutable.Set() : this.selection.marks || this.document.getMarksAtRange(this.selection);\\n    }\\n\\n    /**\\n     * Get the active marks of the current selection.\\n     *\\n     * @return {Set<Mark>}\\n     */\\n\\n  }, {\\n    key: 'activeMarks',\\n    get: function get$$1() {\\n      return this.selection.isUnset ? new immutable.Set() : this.selection.marks || this.document.getActiveMarksAtRange(this.selection);\\n    }\\n\\n    /**\\n     * Get the block nodes in the current selection.\\n     *\\n     * @return {List<Block>}\\n     */\\n\\n  }, {\\n    key: 'blocks',\\n    get: function get$$1() {\\n      return this.selection.isUnset ? new immutable.List() : this.document.getLeafBlocksAtRange(this.selection);\\n    }\\n\\n    /**\\n     * Get the fragment of the current selection.\\n     *\\n     * @return {Document}\\n     */\\n\\n  }, {\\n    key: 'fragment',\\n    get: function get$$1() {\\n      return this.selection.isUnset ? Document.create() : this.document.getFragmentAtRange(this.selection);\\n    }\\n\\n    /**\\n     * Get the bottom-most inline nodes in the current selection.\\n     *\\n     * @return {List<Inline>}\\n     */\\n\\n  }, {\\n    key: 'inlines',\\n    get: function get$$1() {\\n      return this.selection.isUnset ? new immutable.List() : this.document.getLeafInlinesAtRange(this.selection);\\n    }\\n\\n    /**\\n     * Get the text nodes in the current selection.\\n     *\\n     * @return {List<Text>}\\n     */\\n\\n  }, {\\n    key: 'texts',\\n    get: function get$$1() {\\n      return this.selection.isUnset ? new immutable.List() : this.document.getTextsAtRange(this.selection);\\n    }\\n  }, {\\n    key: 'history',\\n    get: function get$$1() {\\n      invariant(false, 'As of Slate 0.42.0, the `value.history` model no longer exists, and the history is stored in `value.data` instead using plugins.');\\n    }\\n  }], [{\\n    key: 'create',\\n\\n    /**\\n     * Create a new `Value` with `attrs`.\\n     *\\n     * @param {Object|Value} attrs\\n     * @param {Object} options\\n     * @return {Value}\\n     */\\n\\n    value: function create() {\\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n\\n      if (Value.isValue(attrs)) {\\n        return attrs;\\n      }\\n\\n      if (isPlainObject(attrs)) {\\n        return Value.fromJSON(attrs, options);\\n      }\\n\\n      throw new Error('`Value.create` only accepts objects or values, but you passed it: ' + attrs);\\n    }\\n\\n    /**\\n     * Create a dictionary of settable value properties from `attrs`.\\n     *\\n     * @param {Object|Value} attrs\\n     * @return {Object}\\n     */\\n\\n  }, {\\n    key: 'createProperties',\\n    value: function createProperties() {\\n      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      if (Value.isValue(a)) {\\n        return {\\n          annotations: a.annotations,\\n          data: a.data\\n        };\\n      }\\n\\n      if (isPlainObject(a)) {\\n        var p = {};\\n        if ('annotations' in a) p.annotations = Annotation.createMap(a.annotations);\\n        if ('data' in a) p.data = Data.create(a.data);\\n        return p;\\n      }\\n\\n      throw new Error('`Value.createProperties` only accepts objects or values, but you passed it: ' + a);\\n    }\\n\\n    /**\\n     * Create a `Value` from a JSON `object`.\\n     *\\n     * @param {Object} object\\n     * @param {Object} options\\n     *   @property {Boolean} normalize\\n     *   @property {Array} plugins\\n     * @return {Value}\\n     */\\n\\n  }, {\\n    key: 'fromJSON',\\n    value: function fromJSON(object) {\\n      var _object$data = object.data,\\n          data = _object$data === undefined ? {} : _object$data,\\n          _object$annotations = object.annotations,\\n          annotations = _object$annotations === undefined ? {} : _object$annotations,\\n          _object$document = object.document,\\n          document = _object$document === undefined ? {} : _object$document,\\n          _object$selection = object.selection,\\n          selection = _object$selection === undefined ? {} : _object$selection;\\n\\n      data = Data.fromJSON(data);\\n      document = Document.fromJSON(document);\\n      selection = document.createSelection(selection);\\n      annotations = Annotation.createMap(annotations);\\n\\n      if (selection.isUnset) {\\n        var text = document.getFirstText();\\n        if (text) selection = selection.moveToStartOfNode(text);\\n        selection = document.createSelection(selection);\\n      }\\n\\n      var value = new Value({\\n        annotations: annotations,\\n        data: data,\\n        document: document,\\n        selection: selection\\n      });\\n\\n      return value;\\n    }\\n  }]);\\n  return Value;\\n}(immutable.Record(DEFAULTS$10));\\n\\n/**\\n * Debug.\\n *\\n * @type {Function}\\n */\\n\\nvar debug = Debug('slate:operation:apply');\\n\\n/**\\n * Apply an `op` to a `value`.\\n *\\n * @param {Value} value\\n * @param {Object|Operation} op\\n * @return {Value} value\\n */\\n\\nfunction applyOperation(value, op) {\\n  op = Operation.create(op);\\n  var _op = op,\\n      type = _op.type;\\n\\n  debug(type, op);\\n\\n  switch (type) {\\n    case 'add_annotation':\\n      {\\n        var _op2 = op,\\n            annotation = _op2.annotation;\\n\\n        var next = value.addAnnotation(annotation);\\n        return next;\\n      }\\n\\n    case 'add_mark':\\n      {\\n        var _op3 = op,\\n            path = _op3.path,\\n            mark = _op3.mark;\\n\\n        var _next = value.addMark(path, mark);\\n        return _next;\\n      }\\n\\n    case 'insert_node':\\n      {\\n        var _op4 = op,\\n            _path = _op4.path,\\n            node = _op4.node;\\n\\n        var _next2 = value.insertNode(_path, node);\\n        return _next2;\\n      }\\n\\n    case 'insert_text':\\n      {\\n        var _op5 = op,\\n            _path2 = _op5.path,\\n            offset = _op5.offset,\\n            text = _op5.text,\\n            marks = _op5.marks;\\n\\n        var _next3 = value.insertText(_path2, offset, text, marks);\\n        return _next3;\\n      }\\n\\n    case 'merge_node':\\n      {\\n        var _op6 = op,\\n            _path3 = _op6.path;\\n\\n        var _next4 = value.mergeNode(_path3);\\n        return _next4;\\n      }\\n\\n    case 'move_node':\\n      {\\n        var _op7 = op,\\n            _path4 = _op7.path,\\n            newPath = _op7.newPath;\\n\\n        var _next5 = value.moveNode(_path4, newPath);\\n        return _next5;\\n      }\\n\\n    case 'remove_annotation':\\n      {\\n        var _op8 = op,\\n            _annotation = _op8.annotation;\\n\\n        var _next6 = value.removeAnnotation(_annotation);\\n        return _next6;\\n      }\\n\\n    case 'remove_mark':\\n      {\\n        var _op9 = op,\\n            _path5 = _op9.path,\\n            _mark = _op9.mark;\\n\\n        var _next7 = value.removeMark(_path5, _mark);\\n        return _next7;\\n      }\\n\\n    case 'remove_node':\\n      {\\n        var _op10 = op,\\n            _path6 = _op10.path;\\n\\n        var _next8 = value.removeNode(_path6);\\n        return _next8;\\n      }\\n\\n    case 'remove_text':\\n      {\\n        var _op11 = op,\\n            _path7 = _op11.path,\\n            _offset = _op11.offset,\\n            _text = _op11.text;\\n\\n        var _next9 = value.removeText(_path7, _offset, _text);\\n        return _next9;\\n      }\\n\\n    case 'set_annotation':\\n      {\\n        var _op12 = op,\\n            properties = _op12.properties,\\n            newProperties = _op12.newProperties;\\n\\n        var _next10 = value.setAnnotation(properties, newProperties);\\n        return _next10;\\n      }\\n\\n    case 'set_mark':\\n      {\\n        var _op13 = op,\\n            _path8 = _op13.path,\\n            _properties = _op13.properties,\\n            _newProperties = _op13.newProperties;\\n\\n        var _next11 = value.setMark(_path8, _properties, _newProperties);\\n        return _next11;\\n      }\\n\\n    case 'set_node':\\n      {\\n        var _op14 = op,\\n            _path9 = _op14.path,\\n            _newProperties2 = _op14.newProperties;\\n\\n        var _next12 = value.setNode(_path9, _newProperties2);\\n        return _next12;\\n      }\\n\\n    case 'set_selection':\\n      {\\n        var _op15 = op,\\n            _newProperties3 = _op15.newProperties;\\n\\n        var _next13 = value.setSelection(_newProperties3);\\n        return _next13;\\n      }\\n\\n    case 'set_value':\\n      {\\n        var _op16 = op,\\n            _newProperties4 = _op16.newProperties;\\n\\n        var _next14 = value.setProperties(_newProperties4);\\n        return _next14;\\n      }\\n\\n    case 'split_node':\\n      {\\n        var _op17 = op,\\n            _path10 = _op17.path,\\n            position = _op17.position,\\n            _properties2 = _op17.properties;\\n\\n        var _next15 = value.splitNode(_path10, position, _properties2);\\n        return _next15;\\n      }\\n\\n    default:\\n      {\\n        throw new Error('Unknown operation type: \\\"' + type + '\\\".');\\n      }\\n  }\\n}\\n\\n/**\\n * Debug.\\n *\\n * @type {Function}\\n */\\n\\nvar debug$1 = Debug('slate:operation:invert');\\n\\n/**\\n * Invert an `op`.\\n *\\n * @param {Object} op\\n * @return {Object}\\n */\\n\\nfunction invertOperation(op) {\\n  op = Operation.create(op);\\n  var _op = op,\\n      type = _op.type;\\n\\n  debug$1(type, op);\\n\\n  switch (type) {\\n    case 'move_node':\\n      {\\n        var _op2 = op,\\n            newPath = _op2.newPath,\\n            path = _op2.path;\\n\\n        // PERF: this case can exit early.\\n\\n        if (PathUtils.isEqual(newPath, path)) {\\n          return op;\\n        }\\n\\n        var inversePath = PathUtils.transform(path, op).first();\\n\\n        // Get the true path we are trying to move back to\\n        // We transform the right-sibling of the path\\n        // This will end up at the operation.path most of the time\\n        // But if the newPath is a left-sibling or left-ancestor-sibling, this will account for it\\n        var inverseNewPath = PathUtils.transform(PathUtils.increment(path), op).first();\\n\\n        var inverse = op.set('path', inversePath).set('newPath', inverseNewPath);\\n        return inverse;\\n      }\\n\\n    case 'merge_node':\\n      {\\n        var _op3 = op,\\n            _path = _op3.path;\\n\\n        var _inversePath = PathUtils.decrement(_path);\\n        var _inverse = op.set('type', 'split_node').set('path', _inversePath);\\n        return _inverse;\\n      }\\n\\n    case 'split_node':\\n      {\\n        var _op4 = op,\\n            _path2 = _op4.path;\\n\\n        var _inversePath2 = PathUtils.increment(_path2);\\n        var _inverse2 = op.set('type', 'merge_node').set('path', _inversePath2);\\n        return _inverse2;\\n      }\\n\\n    case 'set_annotation':\\n    case 'set_node':\\n    case 'set_value':\\n    case 'set_selection':\\n    case 'set_mark':\\n      {\\n        var _op5 = op,\\n            properties = _op5.properties,\\n            newProperties = _op5.newProperties;\\n\\n        var _inverse3 = op.set('properties', newProperties).set('newProperties', properties);\\n        return _inverse3;\\n      }\\n\\n    case 'insert_node':\\n    case 'insert_text':\\n      {\\n        var _inverse4 = op.set('type', type.replace('insert_', 'remove_'));\\n        return _inverse4;\\n      }\\n\\n    case 'remove_node':\\n    case 'remove_text':\\n      {\\n        var _inverse5 = op.set('type', type.replace('remove_', 'insert_'));\\n        return _inverse5;\\n      }\\n\\n    case 'add_annotation':\\n    case 'add_mark':\\n      {\\n        var _inverse6 = op.set('type', type.replace('add_', 'remove_'));\\n        return _inverse6;\\n      }\\n\\n    case 'remove_annotation':\\n    case 'remove_mark':\\n      {\\n        var _inverse7 = op.set('type', type.replace('remove_', 'add_'));\\n        return _inverse7;\\n      }\\n\\n    default:\\n      {\\n        throw new Error('Unknown operation type: \\\"' + type + '\\\".');\\n      }\\n  }\\n}\\n\\n/**\\n * Operation attributes.\\n *\\n * @type {Array}\\n */\\n\\nvar OPERATION_ATTRIBUTES = {\\n  add_mark: ['path', 'mark', 'data'],\\n  add_annotation: ['annotation', 'data'],\\n  insert_node: ['path', 'node', 'data'],\\n  insert_text: ['path', 'offset', 'text', 'data'],\\n  merge_node: ['path', 'position', 'properties', 'target', 'data'],\\n  move_node: ['path', 'newPath', 'data'],\\n  remove_annotation: ['annotation', 'data'],\\n  remove_mark: ['path', 'mark', 'data'],\\n  remove_node: ['path', 'node', 'data'],\\n  remove_text: ['path', 'offset', 'text', 'data'],\\n  set_annotation: ['properties', 'newProperties', 'data'],\\n  set_mark: ['path', 'properties', 'newProperties', 'data'],\\n  set_node: ['path', 'properties', 'newProperties', 'data'],\\n  set_selection: ['properties', 'newProperties', 'data'],\\n  set_value: ['properties', 'newProperties', 'data'],\\n  split_node: ['path', 'position', 'properties', 'target', 'data']\\n\\n  /**\\n   * Default properties.\\n   *\\n   * @type {Object}\\n   */\\n\\n};var DEFAULTS$11 = {\\n  annotation: undefined,\\n  data: undefined,\\n  length: undefined,\\n  mark: undefined,\\n  marks: undefined,\\n  newPath: undefined,\\n  newProperties: undefined,\\n  node: undefined,\\n  offset: undefined,\\n  path: undefined,\\n  position: undefined,\\n  properties: undefined,\\n  target: undefined,\\n  text: undefined,\\n  type: undefined\\n\\n  /**\\n   * Operation.\\n   *\\n   * @type {Operation}\\n   */\\n\\n};\\nvar Operation = function (_Record) {\\n  inherits(Operation, _Record);\\n\\n  function Operation() {\\n    classCallCheck(this, Operation);\\n    return possibleConstructorReturn(this, (Operation.__proto__ || Object.getPrototypeOf(Operation)).apply(this, arguments));\\n  }\\n\\n  createClass(Operation, [{\\n    key: 'apply',\\n\\n\\n    /**\\n     * Apply the operation to a `value`.\\n     *\\n     * @param {Value} value\\n     * @return {Value}\\n     */\\n\\n    value: function apply(value) {\\n      var next = applyOperation(value, this);\\n      return next;\\n    }\\n\\n    /**\\n     * Invert the operation.\\n     *\\n     * @return {Operation}\\n     */\\n\\n  }, {\\n    key: 'invert',\\n    value: function invert() {\\n      var inverted = invertOperation(this);\\n      return inverted;\\n    }\\n\\n    /**\\n     * Return a JSON representation of the operation.\\n     *\\n     * @param {Object} options\\n     * @return {Object}\\n     */\\n\\n  }, {\\n    key: 'toJSON',\\n    value: function toJSON() {\\n      var object = this.object,\\n          type = this.type;\\n\\n      var json = { object: object, type: type };\\n      var ATTRIBUTES = OPERATION_ATTRIBUTES[type];\\n\\n      var _iteratorNormalCompletion = true;\\n      var _didIteratorError = false;\\n      var _iteratorError = undefined;\\n\\n      try {\\n        for (var _iterator = ATTRIBUTES[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n          var key = _step.value;\\n\\n          var value = this[key];\\n\\n          if (key === 'annotation' || key === 'mark' || key === 'marks' || key === 'node' || key === 'path' || key === 'newPath') {\\n            value = value.toJSON();\\n          }\\n\\n          if (key === 'properties' && type === 'merge_node') {\\n            var v = {};\\n            if ('data' in value) v.data = value.data.toJS();\\n            if ('type' in value) v.type = value.type;\\n            value = v;\\n          }\\n\\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_annotation') {\\n            var _v = {};\\n            if ('anchor' in value) _v.anchor = value.anchor.toJS();\\n            if ('focus' in value) _v.focus = value.focus.toJS();\\n            if ('key' in value) _v.key = value.key;\\n            if ('data' in value) _v.data = value.data.toJS();\\n            if ('type' in value) _v.type = value.type;\\n            value = _v;\\n          }\\n\\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_mark') {\\n            var _v2 = {};\\n            if ('data' in value) _v2.data = value.data.toJS();\\n            if ('type' in value) _v2.type = value.type;\\n            value = _v2;\\n          }\\n\\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_node') {\\n            var _v3 = {};\\n            if ('data' in value) _v3.data = value.data.toJS();\\n            if ('type' in value) _v3.type = value.type;\\n            value = _v3;\\n          }\\n\\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_selection') {\\n            var _v4 = {};\\n            if ('anchor' in value) _v4.anchor = value.anchor.toJSON();\\n            if ('focus' in value) _v4.focus = value.focus.toJSON();\\n            if ('isFocused' in value) _v4.isFocused = value.isFocused;\\n            if ('marks' in value) _v4.marks = value.marks && value.marks.toJSON();\\n            value = _v4;\\n          }\\n\\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_value') {\\n            var _v5 = {};\\n            if ('data' in value) _v5.data = value.data.toJS();\\n            value = _v5;\\n          }\\n\\n          if (key === 'properties' && type === 'split_node') {\\n            var _v6 = {};\\n            if ('data' in value) _v6.data = value.data.toJS();\\n            if ('type' in value) _v6.type = value.type;\\n            value = _v6;\\n          }\\n\\n          if (key === 'data') {\\n            value = value.toJSON();\\n          }\\n\\n          json[key] = value;\\n        }\\n      } catch (err) {\\n        _didIteratorError = true;\\n        _iteratorError = err;\\n      } finally {\\n        try {\\n          if (!_iteratorNormalCompletion && _iterator.return) {\\n            _iterator.return();\\n          }\\n        } finally {\\n          if (_didIteratorError) {\\n            throw _iteratorError;\\n          }\\n        }\\n      }\\n\\n      return json;\\n    }\\n  }], [{\\n    key: 'create',\\n\\n    /**\\n     * Create a new `Operation` with `attrs`.\\n     *\\n     * @param {Object|Array|List|String|Operation} attrs\\n     * @return {Operation}\\n     */\\n\\n    value: function create() {\\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      if (Operation.isOperation(attrs)) {\\n        return attrs;\\n      }\\n\\n      if (isPlainObject(attrs)) {\\n        return Operation.fromJSON(attrs);\\n      }\\n\\n      throw new Error('`Operation.create` only accepts objects or operations, but you passed it: ' + attrs);\\n    }\\n\\n    /**\\n     * Create a list of `Operations` from `elements`.\\n     *\\n     * @param {Array<Operation|Object>|List<Operation|Object>} elements\\n     * @return {List<Operation>}\\n     */\\n\\n  }, {\\n    key: 'createList',\\n    value: function createList() {\\n      var elements = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n      if (immutable.List.isList(elements) || Array.isArray(elements)) {\\n        var list = new immutable.List(elements.map(Operation.create));\\n        return list;\\n      }\\n\\n      throw new Error('`Operation.createList` only accepts arrays or lists, but you passed it: ' + elements);\\n    }\\n\\n    /**\\n     * Create a `Operation` from a JSON `object`.\\n     *\\n     * @param {Object|Operation} object\\n     * @return {Operation}\\n     */\\n\\n  }, {\\n    key: 'fromJSON',\\n    value: function fromJSON(object) {\\n      if (Operation.isOperation(object)) {\\n        return object;\\n      }\\n\\n      var type = object.type;\\n\\n      var ATTRIBUTES = OPERATION_ATTRIBUTES[type];\\n      var attrs = { type: type };\\n\\n      if (!ATTRIBUTES) {\\n        throw new Error('`Operation.fromJSON` was passed an unrecognized operation type: \\\"' + type + '\\\"');\\n      }\\n\\n      var _iteratorNormalCompletion2 = true;\\n      var _didIteratorError2 = false;\\n      var _iteratorError2 = undefined;\\n\\n      try {\\n        for (var _iterator2 = ATTRIBUTES[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n          var key = _step2.value;\\n\\n          var v = object[key];\\n\\n          // Default `data` to an empty object.\\n          if (key === 'data' && v === undefined) {\\n            v = {};\\n          }\\n\\n          if (v === undefined) {\\n            throw new Error('`Operation.fromJSON` was passed a \\\"' + type + '\\\" operation without the required \\\"' + key + '\\\" attribute.');\\n          }\\n\\n          if (key === 'annotation') {\\n            v = Annotation.create(v);\\n          }\\n\\n          if (key === 'path' || key === 'newPath') {\\n            v = PathUtils.create(v);\\n          }\\n\\n          if (key === 'mark') {\\n            v = Mark.create(v);\\n          }\\n\\n          if (key === 'node') {\\n            v = Node.create(v);\\n          }\\n\\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_annotation') {\\n            v = Annotation.createProperties(v);\\n          }\\n\\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_mark') {\\n            v = Mark.createProperties(v);\\n          }\\n\\n          if ((key === 'properties' || key === 'newProperties') && (type === 'set_node' || type === 'merge_node' || type === 'split_node')) {\\n            v = Node.createProperties(v);\\n          }\\n\\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_selection') {\\n            v = Selection.createProperties(v);\\n          }\\n\\n          if ((key === 'properties' || key === 'newProperties') && type === 'set_value') {\\n            v = Value.createProperties(v);\\n          }\\n\\n          if (key === 'data') {\\n            v = immutable.Map(v);\\n          }\\n\\n          attrs[key] = v;\\n        }\\n      } catch (err) {\\n        _didIteratorError2 = true;\\n        _iteratorError2 = err;\\n      } finally {\\n        try {\\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n            _iterator2.return();\\n          }\\n        } finally {\\n          if (_didIteratorError2) {\\n            throw _iteratorError2;\\n          }\\n        }\\n      }\\n\\n      var op = new Operation(attrs);\\n      return op;\\n    }\\n\\n    /**\\n     * Check if `any` is a list\\u00a0of operations.\\n     *\\n     * @param {Any} any\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isOperationList',\\n    value: function isOperationList(any) {\\n      return immutable.List.isList(any) && any.every(function (item) {\\n        return Operation.isOperation(item);\\n      });\\n    }\\n  }]);\\n  return Operation;\\n}(immutable.Record(DEFAULTS$11));\\n\\n/**\\n * Default properties.\\n *\\n * @type {Object}\\n */\\n\\nvar DEFAULTS$12 = {\\n  operations: undefined,\\n  value: undefined\\n\\n  /**\\n   * Change.\\n   *\\n   * @type {Change}\\n   */\\n\\n};\\nvar Change = function (_Record) {\\n  inherits(Change, _Record);\\n\\n  function Change() {\\n    classCallCheck(this, Change);\\n    return possibleConstructorReturn(this, (Change.__proto__ || Object.getPrototypeOf(Change)).apply(this, arguments));\\n  }\\n\\n  createClass(Change, [{\\n    key: 'toJSON',\\n\\n\\n    /**\\n     * Return a JSON representation of the change.\\n     *\\n     * @param {Object} options\\n     * @return {Object}\\n     */\\n\\n    value: function toJSON() {\\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      var object = {\\n        object: this.object,\\n        value: this.value.toJSON(options),\\n        operations: this.operations.toArray().map(function (o) {\\n          return o.toJSON(options);\\n        })\\n      };\\n\\n      return object;\\n    }\\n  }], [{\\n    key: 'create',\\n\\n    /**\\n     * Create a new `Change` with `attrs`.\\n     *\\n     * @param {Object|Change} attrs\\n     * @return {Change}\\n     */\\n\\n    value: function create() {\\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      if (Change.isChange(attrs)) {\\n        return attrs;\\n      }\\n\\n      if (isPlainObject(attrs)) {\\n        return Change.fromJSON(attrs);\\n      }\\n\\n      throw new Error('`Change.create` only accepts objects or changes, but you passed it: ' + attrs);\\n    }\\n\\n    /**\\n     * Create a `Change` from a JSON `object`.\\n     *\\n     * @param {Object} object\\n     * @return {Change}\\n     */\\n\\n  }, {\\n    key: 'fromJSON',\\n    value: function fromJSON(object) {\\n      var value = object.value,\\n          _object$operations = object.operations,\\n          operations = _object$operations === undefined ? [] : _object$operations;\\n\\n\\n      var change = new Change({\\n        value: Value.create(value),\\n        operations: Operation.createList(operations)\\n      });\\n\\n      return change;\\n    }\\n  }]);\\n  return Change;\\n}(immutable.Record(DEFAULTS$12));\\n\\n/**\\n * A plugin that adds a set of commands to the editor.\\n *\\n * @param {Object} commands\\n * @return {Object}\\n */\\n\\nfunction CommandsPlugin() {\\n  var commands = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n  /**\\n   * On command, if it exists in our list of commands, call it.\\n   *\\n   * @param {Object} command\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onCommand(command, editor, next) {\\n    var type = command.type,\\n        args = command.args;\\n\\n    var fn = commands[type];\\n    if (!fn) return next();\\n    editor.command.apply(editor, [fn].concat(toConsumableArray(args)));\\n  }\\n\\n  /**\\n   * On construct, register all the commands.\\n   *\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onConstruct(editor, next) {\\n    for (var command in commands) {\\n      editor.registerCommand(command);\\n    }\\n\\n    return next();\\n  }\\n\\n  /**\\n   * Return the plugin.\\n   *\\n   * @type {Object}\\n   */\\n\\n  return {\\n    onCommand: onCommand,\\n    onConstruct: onConstruct\\n  };\\n}\\n\\n/**\\n * Surrogate pair start and end points.\\n *\\n * @type {Number}\\n */\\n\\nvar SURROGATE_START = 0xd800;\\nvar SURROGATE_END = 0xdfff;\\n\\n/**\\n * A regex to match space characters.\\n *\\n * @type {RegExp}\\n */\\n\\nvar SPACE = /\\\\s/;\\n\\n/**\\n * A regex to match chameleon characters, that count as word characters as long\\n * as they are inside of a word.\\n *\\n * @type {RegExp}\\n */\\n\\nvar CHAMELEON = /['\\\\u2018\\\\u2019]/;\\n\\n/**\\n * A regex that matches punctuation.\\n *\\n * @type {RegExp}\\n */\\n\\nvar PUNCTUATION = /[\\\\u0021-\\\\u0023\\\\u0025-\\\\u002A\\\\u002C-\\\\u002F\\\\u003A\\\\u003B\\\\u003F\\\\u0040\\\\u005B-\\\\u005D\\\\u005F\\\\u007B\\\\u007D\\\\u00A1\\\\u00A7\\\\u00AB\\\\u00B6\\\\u00B7\\\\u00BB\\\\u00BF\\\\u037E\\\\u0387\\\\u055A-\\\\u055F\\\\u0589\\\\u058A\\\\u05BE\\\\u05C0\\\\u05C3\\\\u05C6\\\\u05F3\\\\u05F4\\\\u0609\\\\u060A\\\\u060C\\\\u060D\\\\u061B\\\\u061E\\\\u061F\\\\u066A-\\\\u066D\\\\u06D4\\\\u0700-\\\\u070D\\\\u07F7-\\\\u07F9\\\\u0830-\\\\u083E\\\\u085E\\\\u0964\\\\u0965\\\\u0970\\\\u0AF0\\\\u0DF4\\\\u0E4F\\\\u0E5A\\\\u0E5B\\\\u0F04-\\\\u0F12\\\\u0F14\\\\u0F3A-\\\\u0F3D\\\\u0F85\\\\u0FD0-\\\\u0FD4\\\\u0FD9\\\\u0FDA\\\\u104A-\\\\u104F\\\\u10FB\\\\u1360-\\\\u1368\\\\u1400\\\\u166D\\\\u166E\\\\u169B\\\\u169C\\\\u16EB-\\\\u16ED\\\\u1735\\\\u1736\\\\u17D4-\\\\u17D6\\\\u17D8-\\\\u17DA\\\\u1800-\\\\u180A\\\\u1944\\\\u1945\\\\u1A1E\\\\u1A1F\\\\u1AA0-\\\\u1AA6\\\\u1AA8-\\\\u1AAD\\\\u1B5A-\\\\u1B60\\\\u1BFC-\\\\u1BFF\\\\u1C3B-\\\\u1C3F\\\\u1C7E\\\\u1C7F\\\\u1CC0-\\\\u1CC7\\\\u1CD3\\\\u2010-\\\\u2027\\\\u2030-\\\\u2043\\\\u2045-\\\\u2051\\\\u2053-\\\\u205E\\\\u207D\\\\u207E\\\\u208D\\\\u208E\\\\u2329\\\\u232A\\\\u2768-\\\\u2775\\\\u27C5\\\\u27C6\\\\u27E6-\\\\u27EF\\\\u2983-\\\\u2998\\\\u29D8-\\\\u29DB\\\\u29FC\\\\u29FD\\\\u2CF9-\\\\u2CFC\\\\u2CFE\\\\u2CFF\\\\u2D70\\\\u2E00-\\\\u2E2E\\\\u2E30-\\\\u2E3B\\\\u3001-\\\\u3003\\\\u3008-\\\\u3011\\\\u3014-\\\\u301F\\\\u3030\\\\u303D\\\\u30A0\\\\u30FB\\\\uA4FE\\\\uA4FF\\\\uA60D-\\\\uA60F\\\\uA673\\\\uA67E\\\\uA6F2-\\\\uA6F7\\\\uA874-\\\\uA877\\\\uA8CE\\\\uA8CF\\\\uA8F8-\\\\uA8FA\\\\uA92E\\\\uA92F\\\\uA95F\\\\uA9C1-\\\\uA9CD\\\\uA9DE\\\\uA9DF\\\\uAA5C-\\\\uAA5F\\\\uAADE\\\\uAADF\\\\uAAF0\\\\uAAF1\\\\uABEB\\\\uFD3E\\\\uFD3F\\\\uFE10-\\\\uFE19\\\\uFE30-\\\\uFE52\\\\uFE54-\\\\uFE61\\\\uFE63\\\\uFE68\\\\uFE6A\\\\uFE6B\\\\uFF01-\\\\uFF03\\\\uFF05-\\\\uFF0A\\\\uFF0C-\\\\uFF0F\\\\uFF1A\\\\uFF1B\\\\uFF1F\\\\uFF20\\\\uFF3B-\\\\uFF3D\\\\uFF3F\\\\uFF5B\\\\uFF5D\\\\uFF5F-\\\\uFF65]/;\\n\\n/**\\n * Is a character `code` in a surrogate character.\\n *\\n * @param {Number} code\\n * @return {Boolean}\\n */\\n\\nfunction isSurrogate(code) {\\n  return SURROGATE_START <= code && code <= SURROGATE_END;\\n}\\n\\n/**\\n * Does `code` form Modifier with next one.\\n *\\n * https://emojipedia.org/modifiers/\\n *\\n * @param {Number} code\\n * @param {String} text\\n * @param {Number} offset\\n * @return {Boolean}\\n */\\n\\nfunction isModifier(code, text, offset) {\\n  if (code === 0xd83c) {\\n    var next = text.charCodeAt(offset + 1);\\n    return next <= 0xdfff && next >= 0xdffb;\\n  }\\n  return false;\\n}\\n\\n/**\\n * Is `code` a Variation Selector.\\n *\\n * https://codepoints.net/variation_selectors\\n *\\n * @param {Number} code\\n * @return {Boolean}\\n */\\n\\nfunction isVariationSelector(code) {\\n  return code <= 0xfe0f && code >= 0xfe00;\\n}\\n\\n/**\\n * Is `code` one of the BMP codes used in emoji sequences.\\n *\\n * https://emojipedia.org/emoji-zwj-sequences/\\n *\\n * @param {Number} code\\n * @return {Boolean}\\n */\\n\\nfunction isBMPEmoji(code) {\\n  // This requires tiny bit of maintanance, better ideas?\\n  // Fortunately it only happens if new Unicode Standard\\n  // is released. Fails gracefully if upkeep lags behind,\\n  // same way Slate previously behaved with all emojis.\\n  return code === 0x2764 || // heart (\\u2764)\\n  code === 0x2642 || // male (\\u2642)\\n  code === 0x2640 || // female (\\u2640)\\n  code === 0x2620 || // scull (\\u2620)\\n  code === 0x2695 || // medical (\\u2695)\\n  code === 0x2708 || // plane (\\u2708\\ufe0f)\\n  code === 0x25ef // large circle (\\u25ef)\\n  ;\\n}\\n\\n/**\\n * Is a character a word character? Needs the `remaining` characters too.\\n *\\n * @param {String} char\\n * @param {String|Void} remaining\\n * @return {Boolean}\\n */\\n\\nfunction isWord(char, remaining) {\\n  if (SPACE.test(char)) return false;\\n\\n  // If it's a chameleon character, recurse to see if the next one is or not.\\n  if (CHAMELEON.test(char)) {\\n    var next = remaining.charAt(0);\\n    var length = getCharLength(next);\\n    next = remaining.slice(0, length);\\n    var rest = remaining.slice(length);\\n    if (isWord(next, rest)) return true;\\n  }\\n\\n  if (PUNCTUATION.test(char)) return false;\\n  return true;\\n}\\n\\n/**\\n * Get the length of a `character`.\\n *\\n * @param {String} char\\n * @return {Number}\\n */\\n\\nfunction getCharLength(char) {\\n  return isSurrogate(char.charCodeAt(0)) ? 2 : 1;\\n}\\n\\n/**\\n * Get the offset to the end of the character(s) in `text`.\\n * This function is emoji aware and handles them correctly.\\n *\\n * @param {String} text\\n * @param {Number} chars\\n * @param {Boolean} forward\\n * @return {Number}\\n */\\n\\nfunction getCharOffset(text, chars, forward) {\\n  var offset = 0;\\n\\n  // Handle end/beginning of node: we have to return 1 in order not to\\n  // break cursor's jumping to next/previous node. We need to return early\\n  // because otherwise, ''.charCodeAt(0) returned NaN and, the default\\n  // handling 'latin characters' at the end of the while loop would\\n  // would never be reached an we returned '0' as offset.\\n  if (text === '') return 1;\\n\\n  // Calculate offset sum of each character\\n  for (var i = 0; i < chars; i++) {\\n    // `prev` types (better ideas?):\\n    // - SURR: surrogate pair\\n    // - MOD: modifier (technically also surrogate pair)\\n    // - ZWJ: zero width joiner\\n    // - VAR: variation selector\\n    // - BMP: sequenceable character from Basic Multilingual Plane\\n    var prev = null;\\n    var charCode = text.charCodeAt(offset);\\n\\n    while (charCode) {\\n      if (isSurrogate(charCode)) {\\n        var modifier = isModifier(charCode, text, offset);\\n\\n        // Early returns are the heart of this loop where\\n        // we decide if previous and current codepoints\\n        // should form a single character (in other words:\\n        // how many of them should selection jump over).\\n        if (forward) {\\n          if (!modifier && prev && prev !== 'ZWJ' || modifier && prev && prev !== 'SURR') {\\n            break;\\n          }\\n        } else if (prev === 'SURR' || prev === 'BMP') {\\n          break;\\n        }\\n\\n        offset += 2;\\n        prev = modifier ? 'MOD' : 'SURR';\\n        charCode = text.charCodeAt(offset);\\n        // It's okay to `continue` without checking\\n        // because if `charCode` is NaN (which is\\n        // the case when out of `text` range), next\\n        // `while` loop won't execute and we're done.\\n        continue;\\n      }\\n\\n      // If zero width joiner\\n      if (charCode === 0x200d) {\\n        offset += 1;\\n        prev = 'ZWJ';\\n        charCode = text.charCodeAt(offset);\\n        continue;\\n      }\\n\\n      if (isBMPEmoji(charCode)) {\\n        if (forward && prev === 'VAR' || prev && prev !== 'ZWJ' && prev !== 'VAR') {\\n          break;\\n        }\\n\\n        offset += 1;\\n        prev = 'BMP';\\n        charCode = text.charCodeAt(offset);\\n        continue;\\n      }\\n\\n      if (isVariationSelector(charCode)) {\\n        if (!forward && prev && prev !== 'ZWJ') {\\n          break;\\n        }\\n\\n        offset += 1;\\n        prev = 'VAR';\\n        charCode = text.charCodeAt(offset);\\n        continue;\\n      }\\n\\n      // Modifier \\\"fuses\\\" with what ever character is before that\\n      // (even whitespace), need to look ahead if loop gets here.\\n      if (forward) {\\n        var nextCharCode = text.charCodeAt(offset + 1);\\n\\n        if (isModifier(nextCharCode, text, offset + 1)) {\\n          offset += 3;\\n          prev = 'MOD';\\n          charCode = text.charCodeAt(offset);\\n          continue;\\n        }\\n      } else if (prev === 'MOD') {\\n        offset += 1;\\n        break;\\n      }\\n\\n      // If while loop ever gets here, we're\\n      // done (e.g Latin characters, length 1).\\n      if (prev === null) offset += 1;\\n      break;\\n    }\\n  }\\n\\n  return offset;\\n}\\n\\n/**\\n * Get the offset to the end of character(s) before an `offset` in `text`.\\n *\\n * @param {String} text\\n * @param {Number} offset\\n * @param {Number} chars\\n * @return {Number}\\n */\\n\\nfunction getCharOffsetBackward(text, offset) {\\n  var chars = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\\n\\n  text = text.slice(0, offset);\\n  text = esrever.reverse(text);\\n  return getCharOffset(text, chars);\\n}\\n\\n/**\\n * Get the offset to the end of character(s) after an `offset` in `text`.\\n *\\n * @param {String} text\\n * @param {Number} offset\\n * @param {Number} chars\\n * @return {Number}\\n */\\n\\nfunction getCharOffsetForward(text, offset) {\\n  var chars = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\\n\\n  text = text.slice(offset);\\n  return getCharOffset(text, chars, true);\\n}\\n\\n/**\\n * Get the offset to the end of the first word in `text`.\\n *\\n * @param {String} text\\n * @return {Number}\\n */\\n\\nfunction getWordOffset(text) {\\n  var length = 0;\\n  var i = 0;\\n  var started = false;\\n  var char = void 0;\\n\\n  while (char = text.charAt(i)) {\\n    var l = getCharLength(char);\\n    char = text.slice(i, i + l);\\n    var rest = text.slice(i + l);\\n\\n    if (isWord(char, rest)) {\\n      started = true;\\n      length += l;\\n    } else if (!started) {\\n      length += l;\\n    } else {\\n      break;\\n    }\\n\\n    i += l;\\n  }\\n\\n  return length;\\n}\\n\\n/**\\n * Get the offset to the end of the word before an `offset` in `text`.\\n *\\n * @param {String} text\\n * @param {Number} offset\\n * @return {Number}\\n */\\n\\nfunction getWordOffsetBackward(text, offset) {\\n  text = text.slice(0, offset);\\n  text = esrever.reverse(text);\\n  var o = getWordOffset(text);\\n  return o;\\n}\\n\\n/**\\n * Get the offset to the end of the word after an `offset` in `text`.\\n *\\n * @param {String} text\\n * @param {Number} offset\\n * @return {Number}\\n */\\n\\nfunction getWordOffsetForward(text, offset) {\\n  text = text.slice(offset);\\n  var o = getWordOffset(text);\\n  return o;\\n}\\n\\n/**\\n * Export.\\n *\\n * @type {Object}\\n */\\n\\nvar TextUtils = {\\n  getCharLength: getCharLength,\\n  getCharOffset: getCharOffset,\\n  getCharOffsetBackward: getCharOffsetBackward,\\n  getCharOffsetForward: getCharOffsetForward,\\n  getWordOffset: getWordOffset,\\n  getWordOffsetBackward: getWordOffsetBackward,\\n  getWordOffsetForward: getWordOffsetForward,\\n  isSurrogate: isSurrogate,\\n  isWord: isWord\\n};\\n\\n/**\\n * Ensure that an expanded selection is deleted first, and return the updated\\n * range to account for the deleted part.\\n *\\n * @param {Editor}\\n */\\n\\nfunction deleteExpandedAtRange(editor, range) {\\n  if (range.isExpanded) {\\n    editor.deleteAtRange(range);\\n  }\\n\\n  var value = editor.value;\\n  var document = value.document;\\n  var _range = range,\\n      start = _range.start,\\n      end = _range.end;\\n\\n\\n  if (document.hasDescendant(start.path)) {\\n    range = range.moveToStart();\\n  } else {\\n    range = range.moveTo(end.path, 0).normalize(document);\\n  }\\n\\n  return range;\\n}\\n\\n/**\\n * Commands.\\n *\\n * @type {Object}\\n */\\n\\nvar Commands$1 = {};\\n\\n/**\\n * Add a new `mark` to the characters at `range`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n * @param {Mixed} mark\\n */\\n\\nCommands$1.addMarkAtRange = function (editor, range, mark) {\\n  if (range.isCollapsed) return;\\n\\n  var value = editor.value;\\n  var document = value.document;\\n  var start = range.start,\\n      end = range.end;\\n\\n  var texts = document.getTextsAtRange(range);\\n\\n  editor.withoutNormalizing(function () {\\n    texts.forEach(function (node) {\\n      var key = node.key;\\n\\n      var index = 0;\\n      var length = node.text.length;\\n\\n      if (key === start.key) index = start.offset;\\n      if (key === end.key) length = end.offset;\\n      if (key === start.key && key === end.key) length = end.offset - start.offset;\\n\\n      editor.addMarkByKey(key, index, length, mark);\\n    });\\n  });\\n};\\n\\n/**\\n * Add a list of `marks` to the characters at `range`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n * @param {Array<Mixed>} mark\\n */\\n\\nCommands$1.addMarksAtRange = function (editor, range, marks) {\\n  marks.forEach(function (mark) {\\n    return editor.addMarkAtRange(range, mark);\\n  });\\n};\\n\\n/**\\n * Delete everything in a `range`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n */\\n\\nCommands$1.deleteAtRange = function (editor, range) {\\n  // Snapshot the selection, which creates an extra undo save point, so that\\n  // when you undo a delete, the expanded selection will be retained.\\n  editor.snapshotSelection();\\n\\n  var value = editor.value;\\n  var start = range.start,\\n      end = range.end;\\n\\n  var startKey = start.key;\\n  var startOffset = start.offset;\\n  var endKey = end.key;\\n  var endOffset = end.offset;\\n  var document = value.document;\\n\\n  var isStartVoid = document.hasVoidParent(startKey, editor);\\n  var isEndVoid = document.hasVoidParent(endKey, editor);\\n  var startBlock = document.getClosestBlock(startKey);\\n  var endBlock = document.getClosestBlock(endKey);\\n\\n  // Check if we have a \\\"hanging\\\" selection case where the even though the\\n  // selection extends into the start of the end node, we actually want to\\n  // ignore that for UX reasons.\\n  var isHanging = startOffset === 0 && endOffset === 0 && isStartVoid === false && startKey === startBlock.getFirstText().key && endKey === endBlock.getFirstText().key && startKey !== endKey;\\n\\n  // If it's a hanging selection, nudge it back to end in the previous text.\\n  if (isHanging && isEndVoid) {\\n    var prevText = document.getPreviousText(endKey);\\n    endKey = prevText.key;\\n    endOffset = prevText.text.length;\\n    isEndVoid = document.hasVoidParent(endKey, editor);\\n  }\\n\\n  editor.withoutNormalizing(function () {\\n    // If the start node is inside a void node, remove the void node and update\\n    // the starting point to be right after it, continuously until the start point\\n    // is not a void, or until the entire range is handled.\\n    while (isStartVoid) {\\n      var startVoid = document.getClosestVoid(startKey, editor);\\n      var nextText = document.getNextText(startKey);\\n      editor.removeNodeByKey(startVoid.key);\\n\\n      // If the start and end keys are the same, we're done.\\n      if (startKey === endKey) return;\\n\\n      // If there is no next text node, we're done.\\n      if (!nextText) return;\\n\\n      // Continue...\\n      document = editor.value.document;\\n      startKey = nextText.key;\\n      startOffset = 0;\\n      isStartVoid = document.hasVoidParent(startKey, editor);\\n    }\\n\\n    // If the end node is inside a void node, do the same thing but backwards. But\\n    // we don't need any aborting checks because if we've gotten this far there\\n    // must be a non-void node that will exit the loop.\\n    while (isEndVoid) {\\n      var endVoid = document.getClosestVoid(endKey, editor);\\n      var _prevText = document.getPreviousText(endKey);\\n      editor.removeNodeByKey(endVoid.key);\\n\\n      // Continue...\\n      document = editor.value.document;\\n      endKey = _prevText.key;\\n      endOffset = _prevText.text.length;\\n      isEndVoid = document.hasVoidParent(endKey, editor);\\n    }\\n\\n    // If the start and end key are the same, and it was a hanging selection, we\\n    // can just remove the entire block.\\n    if (startKey === endKey && isHanging) {\\n      editor.removeNodeByKey(startBlock.key);\\n      return;\\n    } else if (startKey === endKey) {\\n      // Otherwise, if it wasn't hanging, we're inside a single text node, so we can\\n      // simply remove the text in the range.\\n      var index = startOffset;\\n      var length = endOffset - startOffset;\\n      editor.removeTextByKey(startKey, index, length);\\n      return;\\n    } else {\\n      // Otherwise, we need to recursively remove text and nodes inside the start\\n      // block after the start offset and inside the end block before the end\\n      // offset. Then remove any blocks that are in between the start and end\\n      // blocks. Then finally merge the start and end nodes.\\n      startBlock = document.getClosestBlock(startKey);\\n      endBlock = document.getClosestBlock(endKey);\\n      var startText = document.getNode(startKey);\\n      var endText = document.getNode(endKey);\\n      var startLength = startText.text.length - startOffset;\\n      var endLength = endOffset;\\n\\n      var ancestor = document.getCommonAncestor(startKey, endKey);\\n      var startChild = ancestor.getFurthestChild(startKey);\\n      var endChild = ancestor.getFurthestChild(endKey);\\n\\n      var startParent = document.getParent(startBlock.key);\\n      var startParentIndex = startParent.nodes.indexOf(startBlock);\\n      var endParentIndex = startParent.nodes.indexOf(endBlock);\\n\\n      var child = void 0;\\n\\n      // Iterate through all of the nodes in the tree after the start text node\\n      // but inside the end child, and remove them.\\n      child = startText;\\n\\n      while (child.key !== startChild.key) {\\n        var parent = document.getParent(child.key);\\n        var _index = parent.nodes.indexOf(child);\\n        var afters = parent.nodes.slice(_index + 1);\\n\\n        afters.reverse().forEach(function (node) {\\n          editor.removeNodeByKey(node.key);\\n        });\\n\\n        child = parent;\\n      }\\n\\n      // Remove all of the middle children.\\n      var startChildIndex = ancestor.nodes.indexOf(startChild);\\n      var endChildIndex = ancestor.nodes.indexOf(endChild);\\n      var middles = ancestor.nodes.slice(startChildIndex + 1, endChildIndex);\\n\\n      middles.reverse().forEach(function (node) {\\n        editor.removeNodeByKey(node.key);\\n      });\\n\\n      // Remove the nodes before the end text node in the tree.\\n      child = endText;\\n\\n      while (child.key !== endChild.key) {\\n        var _parent = document.getParent(child.key);\\n        var _index2 = _parent.nodes.indexOf(child);\\n        var befores = _parent.nodes.slice(0, _index2);\\n\\n        befores.reverse().forEach(function (node) {\\n          editor.removeNodeByKey(node.key);\\n        });\\n\\n        child = _parent;\\n      }\\n\\n      // Remove any overlapping text content from the leaf text nodes.\\n      if (startLength !== 0) {\\n        editor.removeTextByKey(startKey, startOffset, startLength);\\n      }\\n\\n      if (endLength !== 0) {\\n        editor.removeTextByKey(endKey, 0, endOffset);\\n      }\\n\\n      // If the start and end blocks aren't the same, move and merge the end block\\n      // into the start block.\\n      if (startBlock.key !== endBlock.key) {\\n        document = editor.value.document;\\n        var onlyChildAncestor = void 0;\\n\\n        var _iteratorNormalCompletion = true;\\n        var _didIteratorError = false;\\n        var _iteratorError = undefined;\\n\\n        try {\\n          for (var _iterator = document.ancestors(endBlock.key)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n            var _ref = _step.value;\\n\\n            var _ref2 = slicedToArray(_ref, 1);\\n\\n            var node = _ref2[0];\\n\\n            if (node.nodes.size > 1) {\\n              break;\\n            } else {\\n              onlyChildAncestor = node;\\n            }\\n          }\\n\\n          // Move the end block to be right after the start block.\\n        } catch (err) {\\n          _didIteratorError = true;\\n          _iteratorError = err;\\n        } finally {\\n          try {\\n            if (!_iteratorNormalCompletion && _iterator.return) {\\n              _iterator.return();\\n            }\\n          } finally {\\n            if (_didIteratorError) {\\n              throw _iteratorError;\\n            }\\n          }\\n        }\\n\\n        if (endParentIndex !== startParentIndex + 1) {\\n          editor.moveNodeByKey(endBlock.key, startParent.key, startParentIndex + 1);\\n        }\\n\\n        // If the selection is hanging, just remove the start block, otherwise\\n        // merge the end block into it.\\n        if (isHanging) {\\n          editor.removeNodeByKey(startBlock.key);\\n        } else {\\n          editor.mergeNodeByKey(endBlock.key);\\n        }\\n\\n        // If nested empty blocks are left over above the end block, remove them.\\n        if (onlyChildAncestor) {\\n          editor.removeNodeByKey(onlyChildAncestor.key);\\n        }\\n      }\\n    }\\n  });\\n};\\n\\n/**\\n * Delete backward `n` characters at a `range`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n * @param {Number} n (optional)\\n */\\n\\nCommands$1.deleteBackwardAtRange = function (editor, range) {\\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\\n\\n  if (n === 0) return;\\n  var value = editor.value;\\n  var document = value.document;\\n  var _range2 = range,\\n      start = _range2.start,\\n      focus = _range2.focus;\\n\\n  // If the range is expanded, perform a regular delete instead.\\n\\n  if (range.isExpanded) {\\n    editor.deleteAtRange(range);\\n    return;\\n  }\\n\\n  var voidParent = document.getClosestVoid(start.path, editor);\\n\\n  // If there is a void parent, delete it.\\n  if (voidParent) {\\n    editor.removeNodeByKey(voidParent.key);\\n    return;\\n  }\\n\\n  // If the range is at the start of the document, abort.\\n  if (start.isAtStartOfNode(document)) {\\n    return;\\n  }\\n\\n  var block = document.getClosestBlock(start.path);\\n\\n  // PERF: If the closest block is empty, remove it. This is just a shortcut,\\n  // since merging it would result in the same outcome.\\n  if (document.nodes.size !== 1 && block && block.text === '' && block.nodes.size === 1) {\\n    editor.removeNodeByKey(block.key);\\n    return;\\n  }\\n\\n  // If the range is at the start of the text node, we need to figure out what\\n  // is behind it to know how to delete...\\n  var text = document.getDescendant(start.path);\\n\\n  if (start.isAtStartOfNode(text)) {\\n    var prev = document.getPreviousText(text.key);\\n    var inline = document.getClosestInline(text.key);\\n\\n    // If the range is at the start of the inline node, and previous text node\\n    // is empty, take the text node before that, or \\\"prevBlock\\\" would be the\\n    // same node as \\\"block\\\"\\n    if (inline && prev.text === '') {\\n      prev = document.getPreviousText(prev.key);\\n    }\\n\\n    var prevBlock = document.getClosestBlock(prev.key);\\n    var prevVoid = document.getClosestVoid(prev.key, editor);\\n\\n    // If the previous text node has a void parent, remove it.\\n    if (prevVoid) {\\n      editor.removeNodeByKey(prevVoid.key);\\n      return;\\n    }\\n\\n    // If we're deleting by one character and the previous text node is not\\n    // inside the current block, we need to merge the two blocks together.\\n    if (n === 1 && prevBlock !== block) {\\n      range = range.moveAnchorTo(prev.key, prev.text.length);\\n      editor.deleteAtRange(range);\\n      return;\\n    }\\n  }\\n\\n  // If the focus offset is farther than the number of characters to delete,\\n  // just remove the characters backwards inside the current node.\\n  if (n <= focus.offset) {\\n    range = range.moveFocusBackward(n);\\n    editor.deleteAtRange(range);\\n    return;\\n  }\\n\\n  // Otherwise, we need to see how many nodes backwards to go.\\n  var node = text;\\n  var offset = 0;\\n  var traversed = focus.offset;\\n\\n  while (n > traversed) {\\n    node = document.getPreviousText(node.key);\\n    var next = traversed + node.text.length;\\n\\n    if (n <= next) {\\n      offset = next - n;\\n      break;\\n    } else {\\n      traversed = next;\\n    }\\n  }\\n\\n  range = range.moveAnchorTo(node.key, offset);\\n  editor.deleteAtRange(range);\\n};\\n\\n/**\\n * Delete backward until the character boundary at a `range`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n */\\n\\nCommands$1.deleteCharBackwardAtRange = function (editor, range) {\\n  if (range.isExpanded) {\\n    editor.deleteAtRange(range);\\n    return;\\n  }\\n\\n  var value = editor.value;\\n  var document = value.document;\\n  var start = range.start;\\n\\n  var startBlock = document.getClosestBlock(start.path);\\n  var offset = startBlock.getOffset(start.key);\\n  var o = offset + start.offset;\\n  var text = startBlock.text;\\n\\n  var n = TextUtils.getCharOffsetBackward(text, o);\\n  editor.deleteBackwardAtRange(range, n);\\n};\\n\\n/**\\n * Delete forward until the character boundary at a `range`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n */\\n\\nCommands$1.deleteCharForwardAtRange = function (editor, range) {\\n  if (range.isExpanded) {\\n    editor.deleteAtRange(range);\\n    return;\\n  }\\n\\n  var value = editor.value;\\n  var document = value.document;\\n  var start = range.start;\\n\\n  var startBlock = document.getClosestBlock(start.path);\\n  var offset = startBlock.getOffset(start.key);\\n  var o = offset + start.offset;\\n  var text = startBlock.text;\\n\\n  var n = TextUtils.getCharOffsetForward(text, o);\\n  editor.deleteForwardAtRange(range, n);\\n};\\n\\n/**\\n * Delete forward `n` characters at a `range`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n * @param {Number} n (optional)\\n */\\n\\nCommands$1.deleteForwardAtRange = function (editor, range) {\\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\\n\\n  if (n === 0) return;\\n  var value = editor.value;\\n  var document = value.document;\\n  var _range3 = range,\\n      start = _range3.start,\\n      focus = _range3.focus;\\n\\n  // If the range is expanded, perform a regular delete instead.\\n\\n  if (range.isExpanded) {\\n    editor.deleteAtRange(range);\\n    return;\\n  }\\n\\n  var voidParent = document.getClosestVoid(start.path, editor);\\n\\n  // If the node has a void parent, delete it.\\n  if (voidParent) {\\n    editor.removeNodeByKey(voidParent.key);\\n    return;\\n  }\\n\\n  var block = document.getClosestBlock(start.path);\\n\\n  // If the closest is not void, but empty, remove it\\n  if (block && !editor.isVoid(block) && block.text === '' && document.nodes.size !== 1) {\\n    var nextBlock = document.getNextBlock(block.key);\\n    editor.removeNodeByKey(block.key);\\n\\n    if (nextBlock && nextBlock.key) {\\n      editor.moveToStartOfNode(nextBlock);\\n    }\\n\\n    return;\\n  }\\n\\n  // If the range is at the start of the document, abort.\\n  if (start.isAtEndOfNode(document)) {\\n    return;\\n  }\\n\\n  // If the range is at the start of the text node, we need to figure out what\\n  // is behind it to know how to delete...\\n  var text = document.getDescendant(start.path);\\n\\n  if (start.isAtEndOfNode(text)) {\\n    var next = document.getNextText(text.key);\\n    var _nextBlock = document.getClosestBlock(next.key);\\n    var nextVoid = document.getClosestVoid(next.key, editor);\\n\\n    // If the next text node has a void parent, remove it.\\n    if (nextVoid) {\\n      editor.removeNodeByKey(nextVoid.key);\\n      return;\\n    }\\n\\n    // If we're deleting by one character and the previous text node is not\\n    // inside the current block, we need to merge the two blocks together.\\n    if (n === 1 && _nextBlock !== block) {\\n      range = range.moveFocusTo(next.key, 0);\\n      editor.deleteAtRange(range);\\n      return;\\n    }\\n  }\\n\\n  // If the remaining characters to the end of the node is greater than or equal\\n  // to the number of characters to delete, just remove the characters forwards\\n  // inside the current node.\\n  if (n <= text.text.length - focus.offset) {\\n    range = range.moveFocusForward(n);\\n    editor.deleteAtRange(range);\\n    return;\\n  }\\n\\n  // Otherwise, we need to see how many nodes forwards to go.\\n  var node = text;\\n  var offset = focus.offset;\\n  var traversed = text.text.length - focus.offset;\\n\\n  while (n > traversed) {\\n    node = document.getNextText(node.key);\\n    var _next = traversed + node.text.length;\\n\\n    if (n <= _next) {\\n      offset = n - traversed;\\n      break;\\n    } else {\\n      traversed = _next;\\n    }\\n  }\\n\\n  range = range.moveFocusTo(node.key, offset);\\n  editor.deleteAtRange(range);\\n};\\n\\n/**\\n * Delete backward until the line boundary at a `range`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n */\\n\\nCommands$1.deleteLineBackwardAtRange = function (editor, range) {\\n  if (range.isExpanded) {\\n    editor.deleteAtRange(range);\\n    return;\\n  }\\n\\n  var value = editor.value;\\n  var document = value.document;\\n  var start = range.start;\\n\\n  var startBlock = document.getClosestBlock(start.path);\\n  var offset = startBlock.getOffset(start.key);\\n  var o = offset + start.offset;\\n  editor.deleteBackwardAtRange(range, o);\\n};\\n\\n/**\\n * Delete forward until the line boundary at a `range`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n */\\n\\nCommands$1.deleteLineForwardAtRange = function (editor, range) {\\n  if (range.isExpanded) {\\n    editor.deleteAtRange(range);\\n    return;\\n  }\\n\\n  var value = editor.value;\\n  var document = value.document;\\n  var start = range.start;\\n\\n  var startBlock = document.getClosestBlock(start.path);\\n  var offset = startBlock.getOffset(start.key);\\n  var o = offset + start.offset;\\n  editor.deleteForwardAtRange(range, startBlock.text.length - o);\\n};\\n\\n/**\\n * Delete backward until the word boundary at a `range`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n */\\n\\nCommands$1.deleteWordBackwardAtRange = function (editor, range) {\\n  if (range.isExpanded) {\\n    editor.deleteAtRange(range);\\n    return;\\n  }\\n\\n  var value = editor.value;\\n  var document = value.document;\\n  var start = range.start;\\n\\n  var startBlock = document.getClosestBlock(start.path);\\n  var offset = startBlock.getOffset(start.key);\\n  var o = offset + start.offset;\\n  var text = startBlock.text;\\n\\n  var n = o === 0 ? 1 : TextUtils.getWordOffsetBackward(text, o);\\n  editor.deleteBackwardAtRange(range, n);\\n};\\n\\n/**\\n * Delete forward until the word boundary at a `range`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n */\\n\\nCommands$1.deleteWordForwardAtRange = function (editor, range) {\\n  if (range.isExpanded) {\\n    editor.deleteAtRange(range);\\n    return;\\n  }\\n\\n  var value = editor.value;\\n  var document = value.document;\\n  var start = range.start;\\n\\n  var startBlock = document.getClosestBlock(start.path);\\n  var offset = startBlock.getOffset(start.key);\\n  var o = offset + start.offset;\\n  var text = startBlock.text;\\n\\n  var wordOffset = TextUtils.getWordOffsetForward(text, o);\\n  var n = wordOffset === 0 ? 1 : wordOffset;\\n  editor.deleteForwardAtRange(range, n);\\n};\\n\\n/**\\n * Insert a `block` node at `range`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n * @param {Block|String|Object} block\\n */\\n\\nCommands$1.insertBlockAtRange = function (editor, range, block) {\\n  range = deleteExpandedAtRange(editor, range);\\n  block = Block.create(block);\\n\\n  var value = editor.value;\\n  var document = value.document;\\n  var _range4 = range,\\n      start = _range4.start;\\n\\n  var startKey = start.key;\\n  var startOffset = start.offset;\\n  var startBlock = document.getClosestBlock(startKey);\\n  var startInline = document.getClosestInline(startKey);\\n  var parent = document.getParent(startBlock.key);\\n  var index = parent.nodes.indexOf(startBlock);\\n  var insertionMode = getInsertionMode(editor, range);\\n\\n  if (insertionMode === 'before') {\\n    editor.insertNodeByKey(parent.key, index, block);\\n  } else if (insertionMode === 'behind') {\\n    editor.insertNodeByKey(parent.key, index + 1, block);\\n  } else {\\n    if (startInline && editor.isVoid(startInline)) {\\n      var atEnd = start.isAtEndOfNode(startInline);\\n      var siblingText = atEnd ? document.getNextText(startKey) : document.getPreviousText(startKey);\\n\\n      var splitRange = atEnd ? range.moveToStartOfNode(siblingText) : range.moveToEndOfNode(siblingText);\\n\\n      startKey = splitRange.start.key;\\n      startOffset = splitRange.start.offset;\\n    }\\n\\n    editor.withoutNormalizing(function () {\\n      editor.splitDescendantsByKey(startBlock.key, startKey, startOffset);\\n      editor.insertNodeByKey(parent.key, index + 1, block);\\n    });\\n  }\\n};\\n\\n/**\\n * Check if current block should be split or new block should be added before or behind it.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n */\\n\\nvar getInsertionMode = function getInsertionMode(editor, range) {\\n  var value = editor.value;\\n  var document = value.document;\\n  var start = range.start;\\n\\n  var startKey = start.key;\\n  var startBlock = document.getClosestBlock(startKey);\\n  var startInline = document.getClosestInline(startKey);\\n\\n  if (editor.isVoid(startBlock)) {\\n    if (start.isAtEndOfNode(startBlock)) return 'behind';else return 'before';\\n  } else if (!startInline && startBlock.text === '') {\\n    return 'behind';\\n  } else if (start.isAtStartOfNode(startBlock)) {\\n    return 'before';\\n  } else if (start.isAtEndOfNode(startBlock)) {\\n    return 'behind';\\n  }\\n  return 'split';\\n};\\n\\n/**\\n * Insert a `fragment` at a `range`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n * @param {Document} fragment\\n */\\n\\nCommands$1.insertFragmentAtRange = function (editor, range, fragment) {\\n  editor.withoutNormalizing(function () {\\n    range = deleteExpandedAtRange(editor, range);\\n\\n    // If the fragment is empty, there's nothing to do after deleting.\\n    if (!fragment.nodes.size) return;\\n\\n    // Regenerate the keys for all of the fragments nodes, so that they're\\n    // guaranteed not to collide with the existing keys in the document. Otherwise\\n    // they will be regenerated automatically and we won't have an easy way to\\n    // reference them.\\n    fragment = fragment.mapDescendants(function (child) {\\n      return child.regenerateKey();\\n    });\\n\\n    // Calculate a few things...\\n    var _range5 = range,\\n        start = _range5.start;\\n    var value = editor.value;\\n    var document = value.document;\\n\\n    var startText = document.getDescendant(start.path);\\n    var startBlock = document.getClosestBlock(startText.key);\\n    var startChild = startBlock.getFurthestChild(startText.key);\\n    var isAtStart = start.isAtStartOfNode(startBlock);\\n    var parent = document.getParent(startBlock.key);\\n    var index = parent.nodes.indexOf(startBlock);\\n    var blocks = fragment.getBlocks();\\n    var firstChild = fragment.nodes.first();\\n    var lastChild = fragment.nodes.last();\\n    var firstBlock = blocks.first();\\n    var lastBlock = blocks.last();\\n    var insertionNode = findInsertionNode(fragment, document, startBlock.key);\\n\\n    // If the fragment only contains a void block, use `insertBlock` instead.\\n    if (firstBlock === lastBlock && editor.isVoid(firstBlock)) {\\n      editor.insertBlockAtRange(range, firstBlock);\\n      return;\\n    }\\n\\n    // If inserting the entire fragment and it starts or ends with a single\\n    // nested block, e.g. a table, we do not merge it with existing blocks.\\n    if (insertionNode === fragment && (firstChild.hasBlockChildren() || lastChild.hasBlockChildren())) {\\n      // check if reversal is necessary or not\\n      var insertionMode = getInsertionMode(editor, range);\\n      var nodes = insertionMode === 'before' ? fragment.nodes : fragment.nodes.reverse();\\n\\n      nodes.forEach(function (node) {\\n        editor.insertBlockAtRange(range, node);\\n      });\\n      return;\\n    }\\n\\n    // If the first and last block aren't the same, we need to insert all of the\\n    // nodes after the insertion node's first block at the index.\\n    if (firstBlock !== lastBlock) {\\n      var lonelyParent = insertionNode.getFurthest(firstBlock.key, function (p) {\\n        return p.nodes.size === 1;\\n      });\\n      var lonelyChild = lonelyParent || firstBlock;\\n\\n      var startIndex = parent.nodes.indexOf(startBlock);\\n      var excludingLonelyChild = insertionNode.removeNode(lonelyChild.key);\\n\\n      excludingLonelyChild.nodes.forEach(function (node, i) {\\n        var newIndex = startIndex + i + 1;\\n        editor.insertNodeByKey(parent.key, newIndex, node);\\n      });\\n    }\\n\\n    // Check if we need to split the node.\\n    if (start.offset !== 0) {\\n      editor.splitDescendantsByKey(startChild.key, start.key, start.offset);\\n    }\\n\\n    // Update our variables with the new value.\\n    document = editor.value.document;\\n    startText = document.getDescendant(start.key);\\n    startBlock = document.getClosestBlock(start.key);\\n    startChild = startBlock.getFurthestChild(startText.key);\\n\\n    // If the first and last block aren't the same, we need to move any of the\\n    // starting block's children after the split into the last block of the\\n    // fragment, which has already been inserted.\\n    if (firstBlock !== lastBlock) {\\n      var nextChild = isAtStart ? startChild : startBlock.getNextSibling(startChild.key);\\n      var nextNodes = nextChild ? startBlock.nodes.skipUntil(function (n) {\\n        return n.key === nextChild.key;\\n      }) : immutable.List();\\n      var lastIndex = lastBlock.nodes.size;\\n\\n      nextNodes.forEach(function (node, i) {\\n        var newIndex = lastIndex + i;\\n        editor.moveNodeByKey(node.key, lastBlock.key, newIndex);\\n      });\\n    }\\n\\n    // If the starting block is empty, we replace it entirely with the first block\\n    // of the fragment, since this leads to a more expected behavior for the user.\\n    if (!editor.isVoid(startBlock) && startBlock.text === '' && !startBlock.findDescendant(function (n) {\\n      return editor.isVoid(n);\\n    })) {\\n      editor.removeNodeByKey(startBlock.key);\\n      editor.insertNodeByKey(parent.key, index, firstBlock);\\n    } else {\\n      // Otherwise, we maintain the starting block, and insert all of the first\\n      // block's inline nodes into it at the split point.\\n      var inlineChild = startBlock.getFurthestChild(startText.key);\\n      var inlineIndex = startBlock.nodes.indexOf(inlineChild);\\n\\n      firstBlock.nodes.forEach(function (inline, i) {\\n        var o = start.offset === 0 ? 0 : 1;\\n        var newIndex = inlineIndex + i + o;\\n        editor.insertNodeByKey(startBlock.key, newIndex, inline);\\n      });\\n    }\\n  });\\n};\\n\\n/**\\n * Get the deepest single child block inside `fragment` whose reversed block\\n * ancestors match the reversed block ancestors of the `document` starting at\\n * the `documentKey`.\\n *\\n * @param {Document} document\\n * @param {string} documentKey\\n * @param {Document} fragment\\n * @return {Node}\\n */\\n\\nvar findInsertionNode = function findInsertionNode(fragment, document, documentKey) {\\n  // Find the deepest block in a doc with no siblings.\\n  var deepestSingleBlock = function deepestSingleBlock(doc) {\\n    var result = doc;\\n\\n    while (result.nodes.size === 1 && result.nodes.first().object === 'block') {\\n      result = result.nodes.first();\\n    }\\n\\n    return result === doc ? null : result;\\n  };\\n\\n  // Return whether every block in the `fragmentAncestors` list has the\\n  // same type as the block in `documentAncestors` with the same index.\\n  var ancestorTypesMatch = function ancestorTypesMatch(fragmentAncestors, documentAncestors) {\\n    return documentAncestors.size >= fragmentAncestors.size && fragmentAncestors.every(function (fragmentNode, i) {\\n      return documentAncestors.get(i).type === fragmentNode.type;\\n    });\\n  };\\n\\n  // Given two reverse lists of ancestors, check if all fragment ancestor types\\n  // match the doc ancestors at some position.\\n  var matchingFragmentAncestor = function matchingFragmentAncestor(documentAncestors, fragmentAncestors) {\\n    var depthDifference = documentAncestors.size - fragmentAncestors.size;\\n\\n    // There is nothing to align if the fragment is deeper than the document.\\n    if (depthDifference < 0) {\\n      return fragment;\\n    }\\n\\n    for (var fragIdx = 0; fragIdx < fragmentAncestors.size; fragIdx++) {\\n      // The docIdx loop relaxes our check in that we can still match if there\\n      // are node type differences leaf-side.\\n      // This is important for example if our fragment inserts multiple siblings\\n      // or inserts another type while the tree structure remains the same.\\n      for (var docIdx = 0; docIdx <= depthDifference; docIdx++) {\\n        if (ancestorTypesMatch(fragmentAncestors.slice(fragIdx), documentAncestors.slice(docIdx))) {\\n          return fragmentAncestors.get(fragIdx);\\n        }\\n      }\\n    }\\n    return fragment;\\n  };\\n\\n  // Get the type definitions for all ancestors up from node with key `key`,\\n  // except the document object.\\n  var getAncestorBlocks = function getAncestorBlocks(doc, key) {\\n    return doc.getAncestors(key).slice(1).push(doc.getNode(key)).reverse();\\n  };\\n\\n  var fragmentStartBlock = deepestSingleBlock(fragment);\\n\\n  if (!fragmentStartBlock) {\\n    return fragment;\\n  }\\n\\n  var documentAncestors = getAncestorBlocks(document, documentKey);\\n  var fragmentAncestors = getAncestorBlocks(fragment, fragmentStartBlock.key);\\n\\n  return matchingFragmentAncestor(documentAncestors, fragmentAncestors);\\n};\\n\\n/**\\n * Insert an `inline` node at `range`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n * @param {Inline|String|Object} inline\\n */\\n\\nCommands$1.insertInlineAtRange = function (editor, range, inline) {\\n  inline = Inline.create(inline);\\n\\n  editor.withoutNormalizing(function () {\\n    range = deleteExpandedAtRange(editor, range);\\n\\n    var value = editor.value;\\n    var document = value.document;\\n    var _range6 = range,\\n        start = _range6.start;\\n\\n    var parent = document.getParent(start.path);\\n    var startText = document.assertDescendant(start.path);\\n    var index = parent.nodes.indexOf(startText);\\n\\n    if (editor.isVoid(parent)) {\\n      return;\\n    }\\n\\n    editor.splitNodeByPath(start.path, start.offset);\\n    editor.insertNodeByKey(parent.key, index + 1, inline);\\n  });\\n};\\n\\n/**\\n * Insert `text` at a `range`, with optional `marks`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n * @param {String} text\\n * @param {Set<Mark>} marks (optional)\\n */\\n\\nCommands$1.insertTextAtRange = function (editor, range, text, marks) {\\n  editor.withoutNormalizing(function () {\\n    range = deleteExpandedAtRange(editor, range);\\n\\n    var value = editor.value;\\n    var document = value.document;\\n    var _range7 = range,\\n        start = _range7.start;\\n\\n    var offset = start.offset;\\n    var parent = document.getParent(start.path);\\n\\n    if (editor.isVoid(parent)) {\\n      return;\\n    }\\n\\n    editor.insertTextByPath(start.path, offset, text, marks);\\n  });\\n};\\n\\n/**\\n * Remove an existing `mark` to the characters at `range`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n * @param {Mark|String} mark (optional)\\n */\\n\\nCommands$1.removeMarkAtRange = function (editor, range, mark) {\\n  if (range.isCollapsed) return;\\n\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var texts = document.getTextsAtRange(range);\\n  var start = range.start,\\n      end = range.end;\\n\\n\\n  editor.withoutNormalizing(function () {\\n    texts.forEach(function (node) {\\n      var key = node.key;\\n\\n      var index = 0;\\n      var length = node.text.length;\\n\\n      if (key === start.key) index = start.offset;\\n      if (key === end.key) length = end.offset;\\n      if (key === start.key && key === end.key) length = end.offset - start.offset;\\n\\n      editor.removeMarkByKey(key, index, length, mark);\\n    });\\n  });\\n};\\n\\n/**\\n * Set the `properties` of block nodes in a `range`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n * @param {Object|String} properties\\n */\\n\\nCommands$1.setBlocksAtRange = function (editor, range, properties) {\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var blocks = document.getLeafBlocksAtRange(range);\\n\\n  var start = range.start,\\n      end = range.end,\\n      isCollapsed = range.isCollapsed;\\n\\n  var isStartVoid = document.hasVoidParent(start.path, editor);\\n  var startBlock = document.getClosestBlock(start.path);\\n  var endBlock = document.getClosestBlock(end.key);\\n\\n  // Check if we have a \\\"hanging\\\" selection case where the even though the\\n  // selection extends into the start of the end node, we actually want to\\n  // ignore that for UX reasons.\\n  var isHanging = isCollapsed === false && start.offset === 0 && end.offset === 0 && isStartVoid === false && start.key === startBlock.getFirstText().key && end.key === endBlock.getFirstText().key;\\n\\n  // If it's a hanging selection, ignore the last block.\\n  var sets = isHanging ? blocks.slice(0, -1) : blocks;\\n\\n  editor.withoutNormalizing(function () {\\n    sets.forEach(function (block) {\\n      editor.setNodeByKey(block.key, properties);\\n    });\\n  });\\n};\\n\\n/**\\n * Set the `properties` of inline nodes in a `range`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n * @param {Object|String} properties\\n */\\n\\nCommands$1.setInlinesAtRange = function (editor, range, properties) {\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var inlines = document.getLeafInlinesAtRange(range);\\n\\n  editor.withoutNormalizing(function () {\\n    inlines.forEach(function (inline) {\\n      editor.setNodeByKey(inline.key, properties);\\n    });\\n  });\\n};\\n\\n/**\\n * Split the block nodes at a `range`, to optional `height`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n * @param {Number} height (optional)\\n */\\n\\nCommands$1.splitBlockAtRange = function (editor, range) {\\n  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\\n\\n  range = deleteExpandedAtRange(editor, range);\\n\\n  var _range8 = range,\\n      start = _range8.start,\\n      end = _range8.end;\\n  var value = editor.value;\\n  var _value = value,\\n      document = _value.document;\\n\\n  var node = document.assertDescendant(start.path);\\n  var parent = document.getClosestBlock(node.key);\\n  var h = 0;\\n\\n  while (parent && parent.object === 'block' && h < height) {\\n    node = parent;\\n    parent = document.getClosestBlock(parent.key);\\n    h++;\\n  }\\n\\n  editor.withoutNormalizing(function () {\\n    editor.splitDescendantsByKey(node.key, start.path, start.offset);\\n\\n    value = editor.value;\\n    document = value.document;\\n\\n    if (range.isExpanded) {\\n      if (range.isBackward) range = range.flip();\\n      var nextBlock = document.getNextBlock(node.key);\\n      range = range.moveAnchorToStartOfNode(nextBlock);\\n      range = range.setFocus(range.focus.setPath(null));\\n\\n      if (start.path.equals(end.path)) {\\n        range = range.moveFocusTo(range.anchor.key, end.offset - start.offset);\\n      }\\n\\n      range = document.resolveRange(range);\\n      editor.deleteAtRange(range);\\n    }\\n  });\\n};\\n\\n/**\\n * Split the inline nodes at a `range`, to optional `height`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n * @param {Number} height (optional)\\n */\\n\\nCommands$1.splitInlineAtRange = function (editor, range) {\\n  var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Infinity;\\n\\n  range = deleteExpandedAtRange(editor, range);\\n\\n  var _range9 = range,\\n      start = _range9.start;\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var node = document.assertDescendant(start.path);\\n  var parent = document.getClosestInline(node.key);\\n  var h = 0;\\n\\n  while (parent && parent.object === 'inline' && h < height) {\\n    node = parent;\\n    parent = document.getClosestInline(parent.key);\\n    h++;\\n  }\\n\\n  editor.splitDescendantsByKey(node.key, start.path, start.offset);\\n};\\n\\n/**\\n * Add or remove a `mark` from the characters at `range`, depending on whether\\n * it's already there.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n * @param {Mixed} mark\\n */\\n\\nCommands$1.toggleMarkAtRange = function (editor, range, mark) {\\n  if (range.isCollapsed) return;\\n\\n  mark = Mark.create(mark);\\n\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var marks = document.getActiveMarksAtRange(range);\\n  var exists = marks.some(function (m) {\\n    return m.equals(mark);\\n  });\\n\\n  if (exists) {\\n    editor.removeMarkAtRange(range, mark);\\n  } else {\\n    editor.addMarkAtRange(range, mark);\\n  }\\n};\\n\\n/**\\n * Unwrap all of the block nodes in a `range` from a block with `properties`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n * @param {String|Object} properties\\n */\\n\\nCommands$1.unwrapBlockAtRange = function (editor, range, properties) {\\n  properties = Node.createProperties(properties);\\n\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var blocks = document.getLeafBlocksAtRange(range);\\n  var wrappers = blocks.map(function (block) {\\n    return document.getClosest(block.key, function (parent) {\\n      if (parent.object !== 'block') return false;\\n      if (properties.type != null && parent.type !== properties.type) return false;\\n      if (properties.data != null && !parent.data.isSuperset(properties.data)) return false;\\n      return true;\\n    });\\n  }).filter(function (exists) {\\n    return exists;\\n  }).toOrderedSet().toList();\\n\\n  editor.withoutNormalizing(function () {\\n    wrappers.forEach(function (block) {\\n      var first = block.nodes.first();\\n      var last = block.nodes.last();\\n      var parent = editor.value.document.getParent(block.key);\\n      var index = parent.nodes.indexOf(block);\\n\\n      var children = block.nodes.filter(function (child) {\\n        return blocks.some(function (b) {\\n          return child === b || child.hasDescendant(b.key);\\n        });\\n      });\\n\\n      var firstMatch = children.first();\\n      var lastMatch = children.last();\\n\\n      if (first === firstMatch && last === lastMatch) {\\n        block.nodes.forEach(function (child, i) {\\n          editor.moveNodeByKey(child.key, parent.key, index + i);\\n        });\\n\\n        editor.removeNodeByKey(block.key);\\n      } else if (last === lastMatch) {\\n        block.nodes.skipUntil(function (n) {\\n          return n === firstMatch;\\n        }).forEach(function (child, i) {\\n          editor.moveNodeByKey(child.key, parent.key, index + 1 + i);\\n        });\\n      } else if (first === firstMatch) {\\n        block.nodes.takeUntil(function (n) {\\n          return n === lastMatch;\\n        }).push(lastMatch).forEach(function (child, i) {\\n          editor.moveNodeByKey(child.key, parent.key, index + i);\\n        });\\n      } else {\\n        var firstText = firstMatch.getFirstText();\\n\\n        editor.splitDescendantsByKey(block.key, firstText.key, 0);\\n\\n        document = editor.value.document;\\n\\n        children.forEach(function (child, i) {\\n          if (i === 0) {\\n            var extra = child;\\n            child = document.getNextBlock(child.key);\\n            editor.removeNodeByKey(extra.key);\\n          }\\n\\n          editor.moveNodeByKey(child.key, parent.key, index + 1 + i);\\n        });\\n      }\\n    });\\n  });\\n};\\n\\n/**\\n * Unwrap the inline nodes in a `range` from an inline with `properties`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n * @param {String|Object} properties\\n */\\n\\nCommands$1.unwrapInlineAtRange = function (editor, range, properties) {\\n  properties = Node.createProperties(properties);\\n\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var texts = document.getTextsAtRange(range);\\n  var inlines = texts.map(function (text) {\\n    return document.getClosest(text.key, function (parent) {\\n      if (parent.object !== 'inline') return false;\\n      if (properties.type != null && parent.type !== properties.type) return false;\\n      if (properties.data != null && !parent.data.isSuperset(properties.data)) return false;\\n      return true;\\n    });\\n  }).filter(function (exists) {\\n    return exists;\\n  }).toOrderedSet().toList();\\n\\n  editor.withoutNormalizing(function () {\\n    inlines.forEach(function (inline) {\\n      var parent = editor.value.document.getParent(inline.key);\\n      var index = parent.nodes.indexOf(inline);\\n\\n      inline.nodes.forEach(function (child, i) {\\n        editor.moveNodeByKey(child.key, parent.key, index + i);\\n      });\\n\\n      editor.removeNodeByKey(inline.key);\\n    });\\n  });\\n};\\n\\n/**\\n * Wrap all of the blocks in a `range` in a new `block`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n * @param {Block|Object|String} block\\n */\\n\\nCommands$1.wrapBlockAtRange = function (editor, range, block) {\\n  block = Block.create(block);\\n  block = block.set('nodes', block.nodes.clear());\\n\\n  var value = editor.value;\\n  var document = value.document;\\n\\n\\n  var blocks = document.getLeafBlocksAtRange(range);\\n  var firstblock = blocks.first();\\n  var lastblock = blocks.last();\\n  var parent = void 0,\\n      siblings = void 0,\\n      index = void 0;\\n\\n  // If there is only one block in the selection then we know the parent and\\n  // siblings.\\n  if (blocks.length === 1) {\\n    parent = document.getParent(firstblock.key);\\n    siblings = blocks;\\n  } else {\\n    // Determine closest shared parent to all blocks in selection.\\n    parent = document.getClosest(firstblock.key, function (p1) {\\n      return !!document.getClosest(lastblock.key, function (p2) {\\n        return p1 === p2;\\n      });\\n    });\\n  }\\n\\n  // If no shared parent could be found then the parent is the document.\\n  if (parent == null) parent = document;\\n\\n  // Create a list of direct children siblings of parent that fall in the\\n  // selection.\\n  if (siblings == null) {\\n    var indexes = parent.nodes.reduce(function (ind, node, i) {\\n      if (node === firstblock || node.hasDescendant(firstblock.key)) ind[0] = i;\\n      if (node === lastblock || node.hasDescendant(lastblock.key)) ind[1] = i;\\n      return ind;\\n    }, []);\\n\\n    index = indexes[0];\\n    siblings = parent.nodes.slice(indexes[0], indexes[1] + 1);\\n  }\\n\\n  // Get the index to place the new wrapped node at.\\n  if (index == null) {\\n    index = parent.nodes.indexOf(siblings.first());\\n  }\\n\\n  editor.withoutNormalizing(function () {\\n    // Inject the new block node into the parent.\\n    editor.insertNodeByKey(parent.key, index, block);\\n\\n    // Move the sibling nodes into the new block node.\\n    siblings.forEach(function (node, i) {\\n      editor.moveNodeByKey(node.key, block.key, i);\\n    });\\n  });\\n};\\n\\n/**\\n * Wrap the text and inlines in a `range` in a new `inline`.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n * @param {Inline|Object|String} inline\\n */\\n\\nCommands$1.wrapInlineAtRange = function (editor, range, inline) {\\n  var value = editor.value;\\n  var document = value.document;\\n  var start = range.start,\\n      end = range.end;\\n\\n\\n  if (range.isCollapsed) {\\n    // Wrapping an inline void\\n    var inlineParent = document.getClosestInline(start.path);\\n\\n    if (!inlineParent) {\\n      return;\\n    }\\n\\n    if (!editor.isVoid(inlineParent)) {\\n      return;\\n    }\\n\\n    return editor.wrapInlineByKey(inlineParent.key, inline);\\n  }\\n\\n  inline = Inline.create(inline);\\n  inline = inline.set('nodes', inline.nodes.clear());\\n\\n  var blocks = document.getLeafBlocksAtRange(range);\\n  var startBlock = document.getClosestBlock(start.path);\\n  var endBlock = document.getClosestBlock(end.path);\\n  var startInline = document.getClosestInline(start.path);\\n  var endInline = document.getClosestInline(end.path);\\n  var startChild = startBlock.getFurthestChild(start.key);\\n  var endChild = endBlock.getFurthestChild(end.key);\\n\\n  editor.withoutNormalizing(function () {\\n    if (!startInline || startInline !== endInline) {\\n      editor.splitDescendantsByKey(endChild.key, end.key, end.offset);\\n      editor.splitDescendantsByKey(startChild.key, start.key, start.offset);\\n    }\\n\\n    document = editor.value.document;\\n    startBlock = document.getDescendant(startBlock.key);\\n    endBlock = document.getDescendant(endBlock.key);\\n    startChild = startBlock.getFurthestChild(start.key);\\n    endChild = endBlock.getFurthestChild(end.key);\\n    var startIndex = startBlock.nodes.indexOf(startChild);\\n    var endIndex = endBlock.nodes.indexOf(endChild);\\n\\n    if (startInline && startInline === endInline) {\\n      var texts = startBlock.getTextsAtRange(range).map(function (text) {\\n        if (start.key === text.key && end.key === text.key) {\\n          return text.splitText(start.offset)[1].splitText(end.offset - start.offset)[0].regenerateKey();\\n        } else if (start.key === text.key) {\\n          return text.splitText(start.offset)[1].regenerateKey();\\n        } else if (end.key === text.key) {\\n          return text.splitText(end.offset)[0].regenerateKey();\\n        } else {\\n          return text.regenerateKey();\\n        }\\n      });\\n\\n      inline = inline.set('nodes', texts);\\n      editor.insertInlineAtRange(range, inline);\\n    } else if (startBlock === endBlock) {\\n      document = editor.value.document;\\n      startBlock = document.getClosestBlock(start.key);\\n      startChild = startBlock.getFurthestChild(start.key);\\n\\n      var startInner = document.getNextSibling(startChild.key);\\n      var startInnerIndex = startBlock.nodes.indexOf(startInner);\\n      var endInner = start.key === end.key ? startInner : startBlock.getFurthestChild(end.key);\\n      var inlines = startBlock.nodes.skipUntil(function (n) {\\n        return n === startInner;\\n      }).takeUntil(function (n) {\\n        return n === endInner;\\n      }).push(endInner);\\n\\n      var node = inline.regenerateKey();\\n\\n      editor.insertNodeByKey(startBlock.key, startInnerIndex, node);\\n\\n      inlines.forEach(function (child, i) {\\n        editor.moveNodeByKey(child.key, node.key, i);\\n      });\\n    } else {\\n      var startInlines = startBlock.nodes.slice(startIndex + 1);\\n      var endInlines = endBlock.nodes.slice(0, endIndex + 1);\\n      var startNode = inline.regenerateKey();\\n      var endNode = inline.regenerateKey();\\n\\n      editor.insertNodeByKey(startBlock.key, startIndex + 1, startNode);\\n      editor.insertNodeByKey(endBlock.key, endIndex, endNode);\\n\\n      startInlines.forEach(function (child, i) {\\n        editor.moveNodeByKey(child.key, startNode.key, i);\\n      });\\n\\n      endInlines.forEach(function (child, i) {\\n        editor.moveNodeByKey(child.key, endNode.key, i);\\n      });\\n\\n      blocks.slice(1, -1).forEach(function (block) {\\n        var node = inline.regenerateKey();\\n        editor.insertNodeByKey(block.key, 0, node);\\n\\n        block.nodes.forEach(function (child, i) {\\n          editor.moveNodeByKey(child.key, node.key, i);\\n        });\\n      });\\n    }\\n  });\\n};\\n\\n/**\\n * Wrap the text in a `range` in a prefix/suffix.\\n *\\n * @param {Editor} editor\\n * @param {Range} range\\n * @param {String} prefix\\n * @param {String} suffix (optional)\\n */\\n\\nCommands$1.wrapTextAtRange = function (editor, range, prefix) {\\n  var suffix = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : prefix;\\n  var start = range.start,\\n      end = range.end;\\n\\n  var startRange = range.moveToStart();\\n  var endRange = range.moveToEnd();\\n\\n  if (start.path.equals(end.path)) {\\n    endRange = endRange.moveForward(prefix.length);\\n  }\\n\\n  editor.withoutNormalizing(function () {\\n    editor.insertTextAtRange(startRange, prefix);\\n    editor.insertTextAtRange(endRange, suffix);\\n  });\\n};\\n\\n/**\\n * Commands.\\n *\\n * @type {Object}\\n */\\n\\nvar Commands$2 = {};\\n\\n/**\\n * Add mark to text at `offset` and `length` in node by `path`.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n * @param {Number} offset\\n * @param {Number} length\\n * @param {Mixed} mark\\n */\\n\\nCommands$2.addMarkByPath = function (editor, path, offset, length, mark) {\\n  mark = Mark.create(mark);\\n  editor.addMarksByPath(path, offset, length, [mark]);\\n};\\n\\nCommands$2.addMarksByPath = function (editor, path, offset, length, marks) {\\n  marks = Mark.createSet(marks);\\n\\n  if (!marks.size) {\\n    return;\\n  }\\n\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var node = document.assertNode(path);\\n\\n  editor.withoutNormalizing(function () {\\n    // If it ends before the end of the node, we'll need to split to create a new\\n    // text with different marks.\\n    if (offset + length < node.text.length) {\\n      editor.splitNodeByPath(path, offset + length);\\n    }\\n\\n    // Same thing if it starts after the start. But in that case, we need to\\n    // update our path and offset to point to the new start.\\n    if (offset > 0) {\\n      editor.splitNodeByPath(path, offset);\\n      path = PathUtils.increment(path);\\n      offset = 0;\\n    }\\n\\n    marks.forEach(function (mark) {\\n      editor.applyOperation({\\n        type: 'add_mark',\\n        path: path,\\n        mark: Mark.create(mark)\\n      });\\n    });\\n  });\\n};\\n\\n/**\\n * Sets specific set of marks on the path\\n * @param {Editor} editor\\n * @param {Array} path\\n * @param {Number} offset\\n * @param {Number} length\\n * @param {Array<Object|Mark>} marks\\n */\\n\\nCommands$2.replaceMarksByPath = function (editor, path, offset, length, marks) {\\n  var marksSet = Mark.createSet(marks);\\n\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var node = document.assertNode(path);\\n\\n  if (node.marks.equals(marksSet)) {\\n    return;\\n  }\\n\\n  editor.withoutNormalizing(function () {\\n    // If it ends before the end of the node, we'll need to split to create a new\\n    // text with different marks.\\n    if (offset + length < node.text.length) {\\n      editor.splitNodeByPath(path, offset + length);\\n    }\\n\\n    // Same thing if it starts after the start. But in that case, we need to\\n    // update our path and offset to point to the new start.\\n    if (offset > 0) {\\n      editor.splitNodeByPath(path, offset);\\n      path = PathUtils.increment(path);\\n      offset = 0;\\n    }\\n\\n    var marksToApply = marksSet.subtract(node.marks);\\n    var marksToRemove = node.marks.subtract(marksSet);\\n\\n    marksToRemove.forEach(function (mark) {\\n      editor.applyOperation({\\n        type: 'remove_mark',\\n        path: path,\\n        mark: Mark.create(mark)\\n      });\\n    });\\n\\n    marksToApply.forEach(function (mark) {\\n      editor.applyOperation({\\n        type: 'add_mark',\\n        path: path,\\n        mark: Mark.create(mark)\\n      });\\n    });\\n  });\\n};\\n\\n/**\\n * Insert a `fragment` at `index` in a node by `path`.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n * @param {Number} index\\n * @param {Fragment} fragment\\n */\\n\\nCommands$2.insertFragmentByPath = function (editor, path, index, fragment) {\\n  fragment.nodes.forEach(function (node, i) {\\n    editor.insertNodeByPath(path, index + i, node);\\n  });\\n};\\n\\n/**\\n * Insert a `node` at `index` in a node by `path`.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n * @param {Number} index\\n * @param {Node} node\\n */\\n\\nCommands$2.insertNodeByPath = function (editor, path, index, node) {\\n  editor.applyOperation({\\n    type: 'insert_node',\\n    path: path.concat(index),\\n    node: node\\n  });\\n};\\n\\n/**\\n * Insert `text` at `offset` in node by `path`.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n * @param {Number} offset\\n * @param {String} text\\n * @param {Set<Mark>} marks (optional)\\n */\\n\\nCommands$2.insertTextByPath = function (editor, path, offset, text, marks) {\\n  var value = editor.value;\\n  var annotations = value.annotations,\\n      document = value.document;\\n\\n  document.assertNode(path);\\n\\n  editor.withoutNormalizing(function () {\\n    var _iteratorNormalCompletion = true;\\n    var _didIteratorError = false;\\n    var _iteratorError = undefined;\\n\\n    try {\\n      for (var _iterator = annotations.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n        var annotation = _step.value;\\n        var start = annotation.start,\\n            end = annotation.end;\\n\\n        var isAtomic = editor.isAtomic(annotation);\\n\\n        if (!isAtomic) {\\n          continue;\\n        }\\n\\n        if (!start.path.equals(path)) {\\n          continue;\\n        }\\n\\n        if (start.offset < offset && (!end.path.equals(path) || end.offset > offset)) {\\n          editor.removeAnnotation(annotation);\\n        }\\n      }\\n    } catch (err) {\\n      _didIteratorError = true;\\n      _iteratorError = err;\\n    } finally {\\n      try {\\n        if (!_iteratorNormalCompletion && _iterator.return) {\\n          _iterator.return();\\n        }\\n      } finally {\\n        if (_didIteratorError) {\\n          throw _iteratorError;\\n        }\\n      }\\n    }\\n\\n    editor.applyOperation({\\n      type: 'insert_text',\\n      path: path,\\n      offset: offset,\\n      text: text\\n    });\\n\\n    if (marks) {\\n      editor.replaceMarksByPath(path, offset, text.length, marks);\\n    }\\n  });\\n};\\n\\n/**\\n * Merge a node by `path` with the previous node.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n */\\n\\nCommands$2.mergeNodeByPath = function (editor, path) {\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var original = document.getDescendant(path);\\n  var previous = document.getPreviousSibling(path);\\n\\n  if (!previous) {\\n    throw new Error('Unable to merge node with path \\\"' + path + '\\\", because it has no previous sibling.');\\n  }\\n\\n  var position = previous.object === 'text' ? previous.text.length : previous.nodes.size;\\n\\n  editor.applyOperation({\\n    type: 'merge_node',\\n    path: path,\\n    position: position,\\n    // for undos to succeed we only need the type and data because\\n    // these are the only properties that get changed in the merge operation\\n    properties: {\\n      type: original.type,\\n      data: original.data\\n    },\\n    target: null\\n  });\\n};\\n\\n/**\\n * Move a node by `path` to a new parent by `newParentPath` and `newIndex`.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n * @param {String} newParentPath\\n * @param {Number} newIndex\\n */\\n\\nCommands$2.moveNodeByPath = function (editor, path, newParentPath, newIndex) {\\n  // If the operation path and newParentPath are the same,\\n  // this should be considered a NOOP\\n  if (PathUtils.isEqual(path, newParentPath)) {\\n    return editor;\\n  }\\n\\n  var newPath = newParentPath.concat(newIndex);\\n\\n  if (PathUtils.isEqual(path, newPath)) {\\n    return editor;\\n  }\\n\\n  editor.applyOperation({\\n    type: 'move_node',\\n    path: path,\\n    newPath: newPath\\n  });\\n};\\n\\n/**\\n * Remove mark from text at `offset` and `length` in node by `path`.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n * @param {Number} offset\\n * @param {Number} length\\n * @param {Mark} mark\\n */\\n\\nCommands$2.removeMarkByPath = function (editor, path, offset, length, mark) {\\n  mark = Mark.create(mark);\\n  editor.removeMarksByPath(path, offset, length, [mark]);\\n};\\n\\nCommands$2.removeMarksByPath = function (editor, path, offset, length, marks) {\\n  marks = Mark.createSet(marks);\\n\\n  if (!marks.size) {\\n    return;\\n  }\\n\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var node = document.assertNode(path);\\n\\n  if (marks.intersect(node.marks).isEmpty()) {\\n    return;\\n  }\\n\\n  editor.withoutNormalizing(function () {\\n    // If it ends before the end of the node, we'll need to split to create a new\\n    // text with different marks.\\n    if (offset + length < node.text.length) {\\n      editor.splitNodeByPath(path, offset + length);\\n    }\\n\\n    // Same thing if it starts after the start. But in that case, we need to\\n    // update our path and offset to point to the new start.\\n    if (offset > 0) {\\n      editor.splitNodeByPath(path, offset);\\n      path = PathUtils.increment(path);\\n      offset = 0;\\n    }\\n\\n    marks.forEach(function (mark) {\\n      editor.applyOperation({\\n        type: 'remove_mark',\\n        path: path,\\n        offset: offset,\\n        length: length,\\n        mark: mark\\n      });\\n    });\\n  });\\n};\\n\\n/**\\n * Remove all `marks` from node by `path`.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n */\\n\\nCommands$2.removeAllMarksByPath = function (editor, path) {\\n  var state = editor.state;\\n  var document = state.document;\\n\\n  var node = document.assertNode(path);\\n\\n  editor.withoutNormalizing(function () {\\n    if (node.object === 'text') {\\n      editor.removeMarksByPath(path, 0, node.text.length, node.marks);\\n      return;\\n    }\\n\\n    var _iteratorNormalCompletion2 = true;\\n    var _didIteratorError2 = false;\\n    var _iteratorError2 = undefined;\\n\\n    try {\\n      for (var _iterator2 = node.texts()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n        var _ref = _step2.value;\\n\\n        var _ref2 = slicedToArray(_ref, 2);\\n\\n        var n = _ref2[0];\\n        var p = _ref2[1];\\n\\n        var pth = path.concat(p);\\n        editor.removeMarksByPath(pth, 0, n.text.length, n.marks);\\n      }\\n    } catch (err) {\\n      _didIteratorError2 = true;\\n      _iteratorError2 = err;\\n    } finally {\\n      try {\\n        if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n          _iterator2.return();\\n        }\\n      } finally {\\n        if (_didIteratorError2) {\\n          throw _iteratorError2;\\n        }\\n      }\\n    }\\n  });\\n};\\n\\n/**\\n * Remove a node by `path`.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n */\\n\\nCommands$2.removeNodeByPath = function (editor, path) {\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var node = document.assertNode(path);\\n\\n  editor.applyOperation({\\n    type: 'remove_node',\\n    path: path,\\n    node: node\\n  });\\n};\\n\\n/**\\n * Remove text at `offset` and `length` in node by `path`.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n * @param {Number} offset\\n * @param {Number} length\\n */\\n\\nCommands$2.removeTextByPath = function (editor, path, offset, length) {\\n  var value = editor.value;\\n  var document = value.document,\\n      annotations = value.annotations;\\n\\n  var node = document.assertNode(path);\\n  var text = node.text.slice(offset, offset + length);\\n\\n  editor.withoutNormalizing(function () {\\n    var _iteratorNormalCompletion3 = true;\\n    var _didIteratorError3 = false;\\n    var _iteratorError3 = undefined;\\n\\n    try {\\n      for (var _iterator3 = annotations.values()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\\n        var annotation = _step3.value;\\n        var start = annotation.start,\\n            end = annotation.end;\\n\\n        var isAtomic = editor.isAtomic(annotation);\\n\\n        if (!isAtomic) {\\n          continue;\\n        }\\n\\n        if (!start.path.equals(path)) {\\n          continue;\\n        }\\n\\n        if (start.offset < offset && (!end.path.equals(path) || end.offset > offset)) {\\n          editor.removeAnnotation(annotation);\\n        }\\n      }\\n    } catch (err) {\\n      _didIteratorError3 = true;\\n      _iteratorError3 = err;\\n    } finally {\\n      try {\\n        if (!_iteratorNormalCompletion3 && _iterator3.return) {\\n          _iterator3.return();\\n        }\\n      } finally {\\n        if (_didIteratorError3) {\\n          throw _iteratorError3;\\n        }\\n      }\\n    }\\n\\n    editor.applyOperation({\\n      type: 'remove_text',\\n      path: path,\\n      offset: offset,\\n      text: text\\n    });\\n  });\\n};\\n\\n/**\\n`* Replace a `node` with another `node`\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n * @param {Object|Node} node\\n */\\n\\nCommands$2.replaceNodeByPath = function (editor, path, newNode) {\\n  newNode = Node.create(newNode);\\n  var index = path.last();\\n  var parentPath = PathUtils.lift(path);\\n\\n  editor.withoutNormalizing(function () {\\n    editor.removeNodeByPath(path);\\n    editor.insertNodeByPath(parentPath, index, newNode);\\n  });\\n};\\n\\n/**\\n * Replace a `length` of text at `offset` with new `text` and optional `marks`.\\n *\\n * @param {Editor} editor\\n * @param {String} key\\n * @param {Number} offset\\n * @param {Number} length\\n * @param {string} text\\n * @param {Set<Mark>} marks (optional)\\n */\\n\\nCommands$2.replaceTextByPath = function (editor, path, offset, length, text, marks) {\\n  editor.withoutNormalizing(function () {\\n    editor.removeTextByPath(path, offset, length);\\n    editor.insertTextByPath(path, offset, text, marks);\\n  });\\n};\\n\\n/**\\n * Set `newProperties` on mark on text at `offset` and `length` in node by `path`.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n * @param {Number} offset\\n * @param {Number} length\\n * @param {Object|Mark} properties\\n * @param {Object} newProperties\\n */\\n\\nCommands$2.setMarkByPath = function (editor, path, offset, length, properties, newProperties) {\\n  properties = Mark.create(properties);\\n  newProperties = Mark.createProperties(newProperties);\\n\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var node = document.assertNode(path);\\n\\n  editor.withoutNormalizing(function () {\\n    // If it ends before the end of the node, we'll need to split to create a new\\n    // text with different marks.\\n    if (offset + length < node.text.length) {\\n      editor.splitNodeByPath(path, offset + length);\\n    }\\n\\n    // Same thing if it starts after the start. But in that case, we need to\\n    // update our path and offset to point to the new start.\\n    if (offset > 0) {\\n      editor.splitNodeByPath(path, offset);\\n      path = PathUtils.increment(path);\\n      offset = 0;\\n    }\\n\\n    editor.applyOperation({\\n      type: 'set_mark',\\n      path: path,\\n      properties: properties,\\n      newProperties: newProperties\\n    });\\n  });\\n};\\n\\n/**\\n * Set `properties` on a node by `path`.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n * @param {Object|String} newProperties\\n */\\n\\nCommands$2.setNodeByPath = function (editor, path, newProperties) {\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var node = document.assertNode(path);\\n  newProperties = Node.createProperties(newProperties);\\n  var prevProperties = pick(node, Object.keys(newProperties));\\n\\n  editor.applyOperation({\\n    type: 'set_node',\\n    path: path,\\n    properties: prevProperties,\\n    newProperties: newProperties\\n  });\\n};\\n\\n/**\\n * Insert `text` at `offset` in node by `path`.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n * @param {String} text\\n * @param {Set<Mark>} marks (optional)\\n */\\n\\nCommands$2.setTextByPath = function (editor, path, text, marks) {\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var node = document.assertNode(path);\\n  var end = node.text.length;\\n  editor.replaceTextByPath(path, 0, end, text, marks);\\n};\\n\\n/**\\n * Split a node by `path` at `position`.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n * @param {Number} position\\n * @param {Object} options\\n */\\n\\nCommands$2.splitNodeByPath = function (editor, path, position) {\\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\\n  var _options$target = options.target,\\n      target = _options$target === undefined ? null : _options$target;\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var node = document.getDescendant(path);\\n\\n  editor.applyOperation({\\n    type: 'split_node',\\n    path: path,\\n    position: position,\\n    target: target,\\n    properties: {\\n      type: node.type,\\n      data: node.data\\n    }\\n  });\\n};\\n\\n/**\\n * Split a node deeply down the tree by `path`, `textPath` and `textOffset`.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n * @param {Array} textPath\\n * @param {Number} textOffset\\n */\\n\\nCommands$2.splitDescendantsByPath = function (editor, path, textPath, textOffset) {\\n  if (path.equals(textPath)) {\\n    editor.splitNodeByPath(textPath, textOffset);\\n    return;\\n  }\\n\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var index = textOffset;\\n  var lastPath = textPath;\\n\\n  editor.withoutNormalizing(function () {\\n    editor.splitNodeByKey(textPath, textOffset);\\n\\n    var _iteratorNormalCompletion4 = true;\\n    var _didIteratorError4 = false;\\n    var _iteratorError4 = undefined;\\n\\n    try {\\n      for (var _iterator4 = document.ancestors(textPath)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\\n        var _ref3 = _step4.value;\\n\\n        var _ref4 = slicedToArray(_ref3, 2);\\n\\n        var ancestorPath = _ref4[1];\\n\\n        var target = index;\\n        index = lastPath.last() + 1;\\n        lastPath = ancestorPath;\\n        editor.splitNodeByPath(ancestorPath, index, { target: target });\\n\\n        if (ancestorPath.equals(path)) {\\n          break;\\n        }\\n      }\\n    } catch (err) {\\n      _didIteratorError4 = true;\\n      _iteratorError4 = err;\\n    } finally {\\n      try {\\n        if (!_iteratorNormalCompletion4 && _iterator4.return) {\\n          _iterator4.return();\\n        }\\n      } finally {\\n        if (_didIteratorError4) {\\n          throw _iteratorError4;\\n        }\\n      }\\n    }\\n  });\\n};\\n\\n/**\\n * Unwrap content from an inline parent with `properties`.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n * @param {Object|String} properties\\n */\\n\\nCommands$2.unwrapInlineByPath = function (editor, path, properties) {\\n  var value = editor.value;\\n  var document = value.document,\\n      selection = value.selection;\\n\\n  var node = document.assertNode(path);\\n  var first = node.getFirstText();\\n  var last = node.getLastText();\\n  var range = selection.moveToRangeOfNode(first, last);\\n  editor.unwrapInlineAtRange(range, properties);\\n};\\n\\n/**\\n * Unwrap content from a block parent with `properties`.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n * @param {Object|String} properties\\n */\\n\\nCommands$2.unwrapBlockByPath = function (editor, path, properties) {\\n  var value = editor.value;\\n  var document = value.document,\\n      selection = value.selection;\\n\\n  var node = document.assertNode(path);\\n  var first = node.getFirstText();\\n  var last = node.getLastText();\\n  var range = selection.moveToRangeOfNode(first, last);\\n  editor.unwrapBlockAtRange(range, properties);\\n};\\n\\n/**\\n * Unwrap a single node from its parent.\\n *\\n * If the node is surrounded with siblings, its parent will be\\n * split. If the node is the only child, the parent is removed, and\\n * simply replaced by the node itself.  Cannot unwrap a root node.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n */\\n\\nCommands$2.unwrapNodeByPath = function (editor, path) {\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  document.assertNode(path);\\n\\n  var parentPath = PathUtils.lift(path);\\n  var parent = document.assertNode(parentPath);\\n  var index = path.last();\\n  var parentIndex = parentPath.last();\\n  var grandPath = PathUtils.lift(parentPath);\\n  var isFirst = index === 0;\\n  var isLast = index === parent.nodes.size - 1;\\n\\n  editor.withoutNormalizing(function () {\\n    if (parent.nodes.size === 1) {\\n      editor.moveNodeByPath(path, grandPath, parentIndex + 1);\\n      editor.removeNodeByPath(parentPath);\\n    } else if (isFirst) {\\n      editor.moveNodeByPath(path, grandPath, parentIndex);\\n    } else if (isLast) {\\n      editor.moveNodeByPath(path, grandPath, parentIndex + 1);\\n    } else {\\n      var updatedPath = PathUtils.increment(path, 1, parentPath.size - 1);\\n      updatedPath = updatedPath.set(updatedPath.size - 1, 0);\\n      editor.splitNodeByPath(parentPath, index);\\n      editor.moveNodeByPath(updatedPath, grandPath, parentIndex + 1);\\n    }\\n  });\\n};\\n\\n/**\\n * Unwrap all of the children of a node, by removing the node and replacing it\\n * with the children in the tree.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n */\\n\\nCommands$2.unwrapChildrenByPath = function (editor, path) {\\n  path = PathUtils.create(path);\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var node = document.assertNode(path);\\n  var parentPath = PathUtils.lift(path);\\n  var index = path.last();\\n  var nodes = node.nodes;\\n\\n\\n  editor.withoutNormalizing(function () {\\n    nodes.reverse().forEach(function (child, i) {\\n      var childIndex = nodes.size - i - 1;\\n      var childPath = path.push(childIndex);\\n      editor.moveNodeByPath(childPath, parentPath, index + 1);\\n    });\\n\\n    editor.removeNodeByPath(path);\\n  });\\n};\\n\\n/**\\n * Wrap a node in a block with `properties`.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n * @param {Block|Object|String} block\\n */\\n\\nCommands$2.wrapBlockByPath = function (editor, path, block) {\\n  block = Block.create(block);\\n  block = block.set('nodes', block.nodes.clear());\\n  var parentPath = PathUtils.lift(path);\\n  var index = path.last();\\n  var newPath = PathUtils.increment(path);\\n\\n  editor.withoutNormalizing(function () {\\n    editor.insertNodeByPath(parentPath, index, block);\\n    editor.moveNodeByPath(newPath, path, 0);\\n  });\\n};\\n\\n/**\\n * Wrap a node in an inline with `properties`.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n * @param {Block|Object|String} inline\\n */\\n\\nCommands$2.wrapInlineByPath = function (editor, path, inline) {\\n  inline = Inline.create(inline);\\n  inline = inline.set('nodes', inline.nodes.clear());\\n  var parentPath = PathUtils.lift(path);\\n  var index = path.last();\\n  var newPath = PathUtils.increment(path);\\n\\n  editor.withoutNormalizing(function () {\\n    editor.insertNodeByPath(parentPath, index, inline);\\n    editor.moveNodeByPath(newPath, path, 0);\\n  });\\n};\\n\\n/**\\n * Wrap a node by `path` with `node`.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n * @param {Node|Object} node\\n */\\n\\nCommands$2.wrapNodeByPath = function (editor, path, node) {\\n  node = Node.create(node);\\n\\n  if (node.object === 'block') {\\n    editor.wrapBlockByPath(path, node);\\n  } else if (node.object === 'inline') {\\n    editor.wrapInlineByPath(path, node);\\n  }\\n};\\n\\n/**\\n * Mix in `*ByKey` variants.\\n */\\n\\nvar COMMANDS = ['addMark', 'insertFragment', 'insertNode', 'insertText', 'mergeNode', 'removeAllMarks', 'removeMark', 'removeNode', 'removeText', 'replaceMarks', 'replaceNode', 'replaceText', 'setMark', 'setNode', 'setText', 'splitNode', 'unwrapBlock', 'unwrapChildren', 'unwrapInline', 'unwrapNode', 'wrapBlock', 'wrapInline', 'wrapNode'];\\n\\nvar _loop = function _loop(method) {\\n  Commands$2[method + 'ByKey'] = function (editor, key) {\\n    for (var _len3 = arguments.length, args = Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {\\n      args[_key3 - 2] = arguments[_key3];\\n    }\\n\\n    var value = editor.value;\\n    var document = value.document;\\n\\n    var path = document.assertPath(key);\\n    editor[method + 'ByPath'].apply(editor, [path].concat(args));\\n  };\\n};\\n\\nvar _iteratorNormalCompletion5 = true;\\nvar _didIteratorError5 = false;\\nvar _iteratorError5 = undefined;\\n\\ntry {\\n  for (var _iterator5 = COMMANDS[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\\n    var method = _step5.value;\\n\\n    _loop(method);\\n  }\\n\\n  // Moving nodes takes two keys, so it's slightly different.\\n} catch (err) {\\n  _didIteratorError5 = true;\\n  _iteratorError5 = err;\\n} finally {\\n  try {\\n    if (!_iteratorNormalCompletion5 && _iterator5.return) {\\n      _iterator5.return();\\n    }\\n  } finally {\\n    if (_didIteratorError5) {\\n      throw _iteratorError5;\\n    }\\n  }\\n}\\n\\nCommands$2.moveNodeByKey = function (editor, key, newKey) {\\n  for (var _len = arguments.length, args = Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\\n    args[_key - 3] = arguments[_key];\\n  }\\n\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var path = document.assertPath(key);\\n  var newPath = document.assertPath(newKey);\\n  editor.moveNodeByPath.apply(editor, [path, newPath].concat(args));\\n};\\n\\n// Splitting descendants takes two keys, so it's slightly different.\\nCommands$2.splitDescendantsByKey = function (editor, key, textKey) {\\n  for (var _len2 = arguments.length, args = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\\n    args[_key2 - 3] = arguments[_key2];\\n  }\\n\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var path = document.assertPath(key);\\n  var textPath = document.assertPath(textKey);\\n  editor.splitDescendantsByPath.apply(editor, [path, textPath].concat(args));\\n};\\n\\n/**\\n * Commands.\\n *\\n * @type {Object}\\n */\\n\\nvar Commands$3 = {};\\n\\n/**\\n * Save an `operation` into the history.\\n *\\n * @param {Editor} editor\\n * @param {Object} operation\\n */\\n\\nCommands$3.save = function (editor, operation) {\\n  var operations = editor.operations,\\n      value = editor.value;\\n  var data = value.data;\\n  var _editor$tmp = editor.tmp,\\n      save = _editor$tmp.save,\\n      merge = _editor$tmp.merge;\\n\\n  if (save === false || !isValidOperation(operation)) return;\\n\\n  var undos = data.get('undos') || immutable.List();\\n  var lastBatch = undos.last();\\n  var lastOperation = lastBatch && lastBatch.last();\\n\\n  // If `merge` is non-commital, and this is not the first operation in a new\\n  // editor, then merge, otherwise merge based on the last operation.\\n  if (merge == null) {\\n    if (operations.size !== 0) {\\n      merge = true;\\n    } else {\\n      merge = shouldMerge(operation, lastOperation);\\n    }\\n  }\\n\\n  // If the `merge` flag is true, add the operation to the last batch.\\n  if (merge && lastBatch) {\\n    var batch = lastBatch.push(operation);\\n    undos = undos.pop();\\n    undos = undos.push(batch);\\n  } else {\\n    // Otherwise, create a new batch with the operation.\\n    var _batch = immutable.List([operation]);\\n    undos = undos.push(_batch);\\n  }\\n\\n  // Constrain the history to 100 entries for memory's sake.\\n  if (undos.size > 100) {\\n    undos = undos.takeLast(100);\\n  }\\n\\n  // Clear the redos and update the history.\\n  editor.withoutSaving(function () {\\n    var redos = immutable.List();\\n    var newData = data.set('undos', undos).set('redos', redos);\\n    editor.setData(newData);\\n  });\\n};\\n\\n/**\\n * Redo to the next value in the history.\\n *\\n * @param {Editor} editor\\n */\\n\\nCommands$3.redo = function (editor) {\\n  var value = editor.value;\\n  var data = value.data;\\n\\n  var redos = data.get('redos') || immutable.List();\\n  var undos = data.get('undos') || immutable.List();\\n  var batch = redos.last();\\n  if (!batch) return;\\n\\n  editor.withoutSaving(function () {\\n    editor.withoutNormalizing(function () {\\n      // Replay the batch of operations.\\n      batch.forEach(function (op) {\\n        var _op = op,\\n            type = _op.type,\\n            newProperties = _op.newProperties;\\n\\n        // When the operation mutates the selection, omit its `isFocused` value to\\n        // prevent the editor focus from changing during redoing.\\n\\n        if (type === 'set_selection') {\\n          op = op.set('newProperties', omit(newProperties, 'isFocused'));\\n        }\\n\\n        editor.applyOperation(op);\\n      });\\n\\n      // Shift the next value into the undo stack.\\n      redos = redos.pop();\\n      undos = undos.push(batch);\\n      var newData = data.set('undos', undos).set('redos', redos);\\n      editor.setData(newData);\\n    });\\n  });\\n};\\n\\n/**\\n * Undo the previous operations in the history.\\n *\\n * @param {Editor} editor\\n */\\n\\nCommands$3.undo = function (editor) {\\n  var value = editor.value;\\n  var data = value.data;\\n\\n  var redos = data.get('redos') || immutable.List();\\n  var undos = data.get('undos') || immutable.List();\\n  var batch = undos.last();\\n  if (!batch) return;\\n\\n  editor.withoutSaving(function () {\\n    editor.withoutNormalizing(function () {\\n      // Replay the inverse of the previous operations.\\n      batch.slice().reverse().map(function (op) {\\n        return op.invert();\\n      }).forEach(function (inverse) {\\n        var _inverse = inverse,\\n            type = _inverse.type,\\n            newProperties = _inverse.newProperties;\\n\\n        // When the operation mutates the selection, omit its `isFocused` value to\\n        // prevent the editor focus from changing during undoing.\\n\\n        if (type === 'set_selection') {\\n          inverse = inverse.set('newProperties', omit(newProperties, 'isFocused'));\\n        }\\n\\n        editor.applyOperation(inverse);\\n      });\\n\\n      // Shift the previous operations into the redo stack.\\n      redos = redos.push(batch);\\n      undos = undos.pop();\\n      var newData = data.set('undos', undos).set('redos', redos);\\n      editor.setData(newData);\\n    });\\n  });\\n};\\n\\n/**\\n * Apply a series of changes inside a synchronous `fn`, without merging any of\\n * the new operations into previous save point in the history.\\n *\\n * @param {Editor} editor\\n * @param {Function} fn\\n */\\n\\nCommands$3.withoutMerging = function (editor, fn) {\\n  var value = editor.tmp.merge;\\n  editor.tmp.merge = false;\\n  fn(editor);\\n  editor.tmp.merge = value;\\n};\\n\\n/**\\n * Apply a series of changes inside a synchronous `fn`, without saving any of\\n * their operations into the history.\\n *\\n * @param {Editor} editor\\n * @param {Function} fn\\n */\\n\\nCommands$3.withoutSaving = function (editor, fn) {\\n  var value = editor.tmp.save;\\n  editor.tmp.save = false;\\n  fn(editor);\\n  editor.tmp.save = value;\\n};\\n\\n/**\\n * Check whether to merge a new operation `o` into the previous operation `p`.\\n *\\n * @param {Object} o\\n * @param {Object} p\\n * @return {Boolean}\\n */\\n\\nfunction shouldMerge(o, p) {\\n  if (!p) return false;\\n\\n  var merge = o.type === 'set_selection' && p.type === 'set_selection' || o.type === 'insert_text' && p.type === 'insert_text' && o.offset === p.offset + p.text.length && o.path.equals(p.path) || o.type === 'remove_text' && p.type === 'remove_text' && o.offset + o.text.length === p.offset && o.path.equals(p.path);\\n\\n  return merge;\\n}\\n\\n/**\\n * Check weather an operation needs to be saved to the history\\n * @param {Object} o - operation\\n * @returns {Boolean}\\n */\\n\\nfunction isValidOperation(o) {\\n  if (o.type === 'set_selection') {\\n    var _o$newProperties = o.newProperties,\\n        isFocused = _o$newProperties.isFocused,\\n        anchor = _o$newProperties.anchor,\\n        focus = _o$newProperties.focus;\\n\\n    // this is blur/focus operation, dont need to store it into the history\\n\\n    if (isFocused !== undefined && !anchor && !focus) {\\n      return false;\\n    }\\n  }\\n  return true;\\n}\\n\\nvar Commands$4 = {};\\n\\nCommands$4.blur = function (editor) {\\n  editor.select({ isFocused: false });\\n};\\n\\nCommands$4.deselect = function (editor) {\\n  var range = Selection.create();\\n  editor.select(range);\\n};\\n\\nCommands$4.focus = function (editor) {\\n  editor.select({ isFocused: true });\\n};\\n\\nCommands$4.flip = function (editor) {\\n  editor.command(proxy, 'flip');\\n};\\n\\nCommands$4.moveAnchorBackward = function (editor) {\\n  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n    args[_key - 1] = arguments[_key];\\n  }\\n\\n  editor.command.apply(editor, [pointBackward, 'anchor'].concat(args));\\n};\\n\\nCommands$4.moveAnchorWordBackward = function (editor) {\\n  for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\\n    args[_key2 - 1] = arguments[_key2];\\n  }\\n\\n  editor.command.apply(editor, [pointWordBackward, 'anchor'].concat(args));\\n};\\n\\nCommands$4.moveAnchorForward = function (editor) {\\n  for (var _len3 = arguments.length, args = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\\n    args[_key3 - 1] = arguments[_key3];\\n  }\\n\\n  editor.command.apply(editor, [pointForward, 'anchor'].concat(args));\\n};\\n\\nCommands$4.moveAnchorWordForward = function (editor) {\\n  for (var _len4 = arguments.length, args = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\\n    args[_key4 - 1] = arguments[_key4];\\n  }\\n\\n  editor.command.apply(editor, [pointWordForward, 'anchor'].concat(args));\\n};\\n\\nCommands$4.moveAnchorTo = function (editor) {\\n  for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\\n    args[_key5 - 1] = arguments[_key5];\\n  }\\n\\n  editor.command.apply(editor, [proxy, 'moveAnchorTo'].concat(args));\\n};\\n\\nCommands$4.moveAnchorToEndOfBlock = function (editor) {\\n  editor.command(pointEdgeObject, 'anchor', 'end', 'block');\\n};\\n\\nCommands$4.moveAnchorToEndOfInline = function (editor) {\\n  editor.command(pointEdgeObject, 'anchor', 'end', 'inline');\\n};\\n\\nCommands$4.moveAnchorToEndOfDocument = function (editor) {\\n  editor.moveAnchorToEndOfNode(editor.value.document).moveToAnchor();\\n};\\n\\nCommands$4.moveAnchorToEndOfNextBlock = function (editor) {\\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'next', 'block');\\n};\\n\\nCommands$4.moveAnchorToEndOfNextInline = function (editor) {\\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'next', 'inline');\\n};\\n\\nCommands$4.moveAnchorToEndOfNextText = function (editor) {\\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'next', 'text');\\n};\\n\\nCommands$4.moveAnchorToEndOfNode = function (editor) {\\n  for (var _len6 = arguments.length, args = Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {\\n    args[_key6 - 1] = arguments[_key6];\\n  }\\n\\n  editor.command.apply(editor, [proxy, 'moveAnchorToEndOfNode'].concat(args));\\n};\\n\\nCommands$4.moveAnchorToEndOfPreviousBlock = function (editor) {\\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'previous', 'block');\\n};\\n\\nCommands$4.moveAnchorToEndOfPreviousInline = function (editor) {\\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'previous', 'inline');\\n};\\n\\nCommands$4.moveAnchorToEndOfPreviousText = function (editor) {\\n  editor.command(pointEdgeSideObject, 'anchor', 'end', 'previous', 'text');\\n};\\n\\nCommands$4.moveAnchorToEndOfText = function (editor) {\\n  editor.command(pointEdgeObject, 'anchor', 'end', 'text');\\n};\\n\\nCommands$4.moveAnchorToStartOfBlock = function (editor) {\\n  editor.command(pointEdgeObject, 'anchor', 'start', 'block');\\n};\\n\\nCommands$4.moveAnchorToStartOfDocument = function (editor) {\\n  editor.moveAnchorToStartOfNode(editor.value.document).moveToAnchor();\\n};\\n\\nCommands$4.moveAnchorToStartOfInline = function (editor) {\\n  editor.command(pointEdgeObject, 'anchor', 'start', 'inline');\\n};\\n\\nCommands$4.moveAnchorToStartOfNextBlock = function (editor) {\\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'next', 'block');\\n};\\n\\nCommands$4.moveAnchorToStartOfNextInline = function (editor) {\\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'next', 'inline');\\n};\\n\\nCommands$4.moveAnchorToStartOfNextText = function (editor) {\\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'next', 'text');\\n};\\n\\nCommands$4.moveAnchorToStartOfNode = function (editor) {\\n  for (var _len7 = arguments.length, args = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\\n    args[_key7 - 1] = arguments[_key7];\\n  }\\n\\n  editor.command.apply(editor, [proxy, 'moveAnchorToStartOfNode'].concat(args));\\n};\\n\\nCommands$4.moveAnchorToStartOfPreviousBlock = function (editor) {\\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'previous', 'block');\\n};\\n\\nCommands$4.moveAnchorToStartOfPreviousInline = function (editor) {\\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'previous', 'inline');\\n};\\n\\nCommands$4.moveAnchorToStartOfPreviousText = function (editor) {\\n  editor.command(pointEdgeSideObject, 'anchor', 'start', 'previous', 'text');\\n};\\n\\nCommands$4.moveAnchorToStartOfText = function (editor) {\\n  editor.command(pointEdgeObject, 'anchor', 'start', 'text');\\n};\\n\\nCommands$4.moveBackward = function (editor) {\\n  var chars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\\n\\n  if (chars === 0) return;\\n\\n  var value = editor.value;\\n  var document = value.document,\\n      selection = value.selection;\\n  var start = selection.start;\\n\\n  var startBlock = document.getClosestBlock(start.key);\\n  var o = startBlock.getOffset(start.key);\\n  var offset = o + start.offset;\\n  var text = startBlock.text;\\n\\n  var charsOffset = TextUtils.getCharOffsetBackward(text, offset, chars);\\n  editor.moveAnchorBackward(charsOffset).moveFocusBackward(charsOffset);\\n};\\n\\nCommands$4.moveWordBackward = function (editor) {\\n  for (var _len8 = arguments.length, args = Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\\n    args[_key8 - 1] = arguments[_key8];\\n  }\\n\\n  editor.moveFocusWordBackward.apply(editor, args).moveToFocus();\\n};\\n\\nCommands$4.moveEndBackward = function (editor) {\\n  for (var _len9 = arguments.length, args = Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\\n    args[_key9 - 1] = arguments[_key9];\\n  }\\n\\n  editor.command.apply(editor, [pointBackward, 'end'].concat(args));\\n};\\n\\nCommands$4.moveEndWordBackward = function (editor) {\\n  for (var _len10 = arguments.length, args = Array(_len10 > 1 ? _len10 - 1 : 0), _key10 = 1; _key10 < _len10; _key10++) {\\n    args[_key10 - 1] = arguments[_key10];\\n  }\\n\\n  editor.command.apply(editor, [pointWordBackward, 'end'].concat(args));\\n};\\n\\nCommands$4.moveEndForward = function (editor) {\\n  for (var _len11 = arguments.length, args = Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\\n    args[_key11 - 1] = arguments[_key11];\\n  }\\n\\n  editor.command.apply(editor, [pointForward, 'end'].concat(args));\\n};\\n\\nCommands$4.moveEndWordForward = function (editor) {\\n  for (var _len12 = arguments.length, args = Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {\\n    args[_key12 - 1] = arguments[_key12];\\n  }\\n\\n  editor.command.apply(editor, [pointWordForward, 'end'].concat(args));\\n};\\n\\nCommands$4.moveEndTo = function (editor) {\\n  for (var _len13 = arguments.length, args = Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {\\n    args[_key13 - 1] = arguments[_key13];\\n  }\\n\\n  editor.command.apply(editor, [proxy, 'moveEndTo'].concat(args));\\n};\\n\\nCommands$4.moveEndToEndOfBlock = function (editor) {\\n  editor.command(pointEdgeObject, 'end', 'end', 'block');\\n};\\n\\nCommands$4.moveEndToEndOfDocument = function (editor) {\\n  editor.moveEndToEndOfNode(editor.value.document).moveToEnd();\\n};\\n\\nCommands$4.moveEndToEndOfInline = function (editor) {\\n  editor.command(pointEdgeObject, 'end', 'end', 'inline');\\n};\\n\\nCommands$4.moveEndToEndOfNextBlock = function (editor) {\\n  editor.command(pointEdgeSideObject, 'end', 'end', 'next', 'block');\\n};\\n\\nCommands$4.moveEndToEndOfNextInline = function (editor) {\\n  editor.command(pointEdgeSideObject, 'end', 'end', 'next', 'inline');\\n};\\n\\nCommands$4.moveEndToEndOfNextText = function (editor) {\\n  editor.command(pointEdgeSideObject, 'end', 'end', 'next', 'text');\\n};\\n\\nCommands$4.moveEndToEndOfNode = function (editor) {\\n  for (var _len14 = arguments.length, args = Array(_len14 > 1 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) {\\n    args[_key14 - 1] = arguments[_key14];\\n  }\\n\\n  editor.command.apply(editor, [proxy, 'moveEndToEndOfNode'].concat(args));\\n};\\n\\nCommands$4.moveEndToEndOfPreviousBlock = function (editor) {\\n  editor.command(pointEdgeSideObject, 'end', 'end', 'previous', 'block');\\n};\\n\\nCommands$4.moveEndToEndOfPreviousInline = function (editor) {\\n  editor.command(pointEdgeSideObject, 'end', 'end', 'previous', 'inline');\\n};\\n\\nCommands$4.moveEndToEndOfPreviousText = function (editor) {\\n  editor.command(pointEdgeSideObject, 'end', 'end', 'previous', 'text');\\n};\\n\\nCommands$4.moveEndToEndOfText = function (editor) {\\n  editor.command(pointEdgeObject, 'end', 'end', 'text');\\n};\\n\\nCommands$4.moveEndToStartOfBlock = function (editor) {\\n  editor.command(pointEdgeObject, 'end', 'start', 'block');\\n};\\n\\nCommands$4.moveEndToStartOfDocument = function (editor) {\\n  editor.moveEndToStartOfNode(editor.value.document).moveToEnd();\\n};\\n\\nCommands$4.moveEndToStartOfInline = function (editor) {\\n  editor.command(pointEdgeObject, 'end', 'start', 'inline');\\n};\\n\\nCommands$4.moveEndToStartOfNextBlock = function (editor) {\\n  editor.command(pointEdgeSideObject, 'end', 'start', 'next', 'block');\\n};\\n\\nCommands$4.moveEndToStartOfNextInline = function (editor) {\\n  editor.command(pointEdgeSideObject, 'end', 'start', 'next', 'inline');\\n};\\n\\nCommands$4.moveEndToStartOfNextText = function (editor) {\\n  editor.command(pointEdgeSideObject, 'end', 'start', 'next', 'text');\\n};\\n\\nCommands$4.moveEndToStartOfNode = function (editor) {\\n  for (var _len15 = arguments.length, args = Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {\\n    args[_key15 - 1] = arguments[_key15];\\n  }\\n\\n  editor.command.apply(editor, [proxy, 'moveEndToStartOfNode'].concat(args));\\n};\\n\\nCommands$4.moveEndToStartOfPreviousBlock = function (editor) {\\n  editor.command(pointEdgeSideObject, 'end', 'start', 'previous', 'block');\\n};\\n\\nCommands$4.moveEndToStartOfPreviousInline = function (editor) {\\n  editor.command(pointEdgeSideObject, 'end', 'start', 'previous', 'inline');\\n};\\n\\nCommands$4.moveEndToStartOfPreviousText = function (editor) {\\n  editor.command(pointEdgeSideObject, 'end', 'start', 'previous', 'text');\\n};\\n\\nCommands$4.moveEndToStartOfText = function (editor) {\\n  editor.command(pointEdgeObject, 'end', 'start', 'text');\\n};\\n\\nCommands$4.moveFocusBackward = function (editor) {\\n  for (var _len16 = arguments.length, args = Array(_len16 > 1 ? _len16 - 1 : 0), _key16 = 1; _key16 < _len16; _key16++) {\\n    args[_key16 - 1] = arguments[_key16];\\n  }\\n\\n  editor.command.apply(editor, [pointBackward, 'focus'].concat(args));\\n};\\n\\nCommands$4.moveFocusWordBackward = function (editor) {\\n  for (var _len17 = arguments.length, args = Array(_len17 > 1 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) {\\n    args[_key17 - 1] = arguments[_key17];\\n  }\\n\\n  editor.command.apply(editor, [pointWordBackward, 'focus'].concat(args));\\n};\\n\\nCommands$4.moveFocusForward = function (editor) {\\n  for (var _len18 = arguments.length, args = Array(_len18 > 1 ? _len18 - 1 : 0), _key18 = 1; _key18 < _len18; _key18++) {\\n    args[_key18 - 1] = arguments[_key18];\\n  }\\n\\n  editor.command.apply(editor, [pointForward, 'focus'].concat(args));\\n};\\n\\nCommands$4.moveFocusWordForward = function (editor) {\\n  for (var _len19 = arguments.length, args = Array(_len19 > 1 ? _len19 - 1 : 0), _key19 = 1; _key19 < _len19; _key19++) {\\n    args[_key19 - 1] = arguments[_key19];\\n  }\\n\\n  editor.command.apply(editor, [pointWordForward, 'focus'].concat(args));\\n};\\n\\nCommands$4.moveFocusTo = function (editor) {\\n  for (var _len20 = arguments.length, args = Array(_len20 > 1 ? _len20 - 1 : 0), _key20 = 1; _key20 < _len20; _key20++) {\\n    args[_key20 - 1] = arguments[_key20];\\n  }\\n\\n  editor.command.apply(editor, [proxy, 'moveFocusTo'].concat(args));\\n};\\n\\nCommands$4.moveFocusToEndOfBlock = function (editor) {\\n  editor.command(pointEdgeObject, 'focus', 'end', 'block');\\n};\\n\\nCommands$4.moveFocusToEndOfDocument = function (editor) {\\n  editor.moveFocusToEndOfNode(editor.value.document).moveToFocus();\\n};\\n\\nCommands$4.moveFocusToEndOfInline = function (editor) {\\n  editor.command(pointEdgeObject, 'focus', 'end', 'inline');\\n};\\n\\nCommands$4.moveFocusToEndOfNextBlock = function (editor) {\\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'next', 'block');\\n};\\n\\nCommands$4.moveFocusToEndOfNextInline = function (editor) {\\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'next', 'inline');\\n};\\n\\nCommands$4.moveFocusToEndOfNextText = function (editor) {\\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'next', 'text');\\n};\\n\\nCommands$4.moveFocusToEndOfNode = function (editor) {\\n  for (var _len21 = arguments.length, args = Array(_len21 > 1 ? _len21 - 1 : 0), _key21 = 1; _key21 < _len21; _key21++) {\\n    args[_key21 - 1] = arguments[_key21];\\n  }\\n\\n  editor.command.apply(editor, [proxy, 'moveFocusToEndOfNode'].concat(args));\\n};\\n\\nCommands$4.moveFocusToEndOfPreviousBlock = function (editor) {\\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'previous', 'block');\\n};\\n\\nCommands$4.moveFocusToEndOfPreviousInline = function (editor) {\\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'previous', 'inline');\\n};\\n\\nCommands$4.moveFocusToEndOfPreviousText = function (editor) {\\n  editor.command(pointEdgeSideObject, 'focus', 'end', 'previous', 'text');\\n};\\n\\nCommands$4.moveFocusToEndOfText = function (editor) {\\n  editor.command(pointEdgeObject, 'focus', 'end', 'text');\\n};\\n\\nCommands$4.moveFocusToStartOfBlock = function (editor) {\\n  editor.command(pointEdgeObject, 'focus', 'start', 'block');\\n};\\n\\nCommands$4.moveFocusToStartOfDocument = function (editor) {\\n  editor.moveFocusToStartOfNode(editor.value.document).moveToFocus();\\n};\\n\\nCommands$4.moveFocusToStartOfInline = function (editor) {\\n  editor.command(pointEdgeObject, 'focus', 'start', 'inline');\\n};\\n\\nCommands$4.moveFocusToStartOfNextBlock = function (editor) {\\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'next', 'block');\\n};\\n\\nCommands$4.moveFocusToStartOfNextInline = function (editor) {\\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'next', 'inline');\\n};\\n\\nCommands$4.moveFocusToStartOfNextText = function (editor) {\\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'next', 'text');\\n};\\n\\nCommands$4.moveFocusToStartOfNode = function (editor) {\\n  for (var _len22 = arguments.length, args = Array(_len22 > 1 ? _len22 - 1 : 0), _key22 = 1; _key22 < _len22; _key22++) {\\n    args[_key22 - 1] = arguments[_key22];\\n  }\\n\\n  editor.command.apply(editor, [proxy, 'moveFocusToStartOfNode'].concat(args));\\n};\\n\\nCommands$4.moveFocusToStartOfPreviousBlock = function (editor) {\\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'previous', 'block');\\n};\\n\\nCommands$4.moveFocusToStartOfPreviousInline = function (editor) {\\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'previous', 'inline');\\n};\\n\\nCommands$4.moveFocusToStartOfPreviousText = function (editor) {\\n  editor.command(pointEdgeSideObject, 'focus', 'start', 'previous', 'text');\\n};\\n\\nCommands$4.moveFocusToStartOfText = function (editor) {\\n  editor.command(pointEdgeObject, 'focus', 'start', 'text');\\n};\\n\\nCommands$4.moveForward = function (editor) {\\n  var chars = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\\n\\n  if (chars === 0) return;\\n\\n  var value = editor.value;\\n  var document = value.document,\\n      selection = value.selection;\\n  var start = selection.start;\\n\\n  var startBlock = document.getClosestBlock(start.path);\\n  var o = startBlock.getOffset(start.key);\\n  var offset = o + start.offset;\\n  var text = startBlock.text;\\n\\n  var charsOffset = TextUtils.getCharOffsetForward(text, offset, chars);\\n  editor.moveAnchorForward(charsOffset).moveFocusForward(charsOffset);\\n};\\n\\nCommands$4.moveWordForward = function (editor) {\\n  var _editor$moveFocusWord;\\n\\n  for (var _len23 = arguments.length, args = Array(_len23 > 1 ? _len23 - 1 : 0), _key23 = 1; _key23 < _len23; _key23++) {\\n    args[_key23 - 1] = arguments[_key23];\\n  }\\n\\n  (_editor$moveFocusWord = editor.moveFocusWordForward.apply(editor, args)).moveToFocus.apply(_editor$moveFocusWord, args);\\n};\\n\\nCommands$4.moveStartBackward = function (editor) {\\n  for (var _len24 = arguments.length, args = Array(_len24 > 1 ? _len24 - 1 : 0), _key24 = 1; _key24 < _len24; _key24++) {\\n    args[_key24 - 1] = arguments[_key24];\\n  }\\n\\n  editor.command.apply(editor, [pointBackward, 'start'].concat(args));\\n};\\n\\nCommands$4.moveStartWordBackward = function (editor) {\\n  for (var _len25 = arguments.length, args = Array(_len25 > 1 ? _len25 - 1 : 0), _key25 = 1; _key25 < _len25; _key25++) {\\n    args[_key25 - 1] = arguments[_key25];\\n  }\\n\\n  editor.command.apply(editor, [pointWordBackward, 'start'].concat(args));\\n};\\n\\nCommands$4.moveStartForward = function (editor) {\\n  for (var _len26 = arguments.length, args = Array(_len26 > 1 ? _len26 - 1 : 0), _key26 = 1; _key26 < _len26; _key26++) {\\n    args[_key26 - 1] = arguments[_key26];\\n  }\\n\\n  editor.command.apply(editor, [pointForward, 'start'].concat(args));\\n};\\n\\nCommands$4.moveStartWordForward = function (editor) {\\n  for (var _len27 = arguments.length, args = Array(_len27 > 1 ? _len27 - 1 : 0), _key27 = 1; _key27 < _len27; _key27++) {\\n    args[_key27 - 1] = arguments[_key27];\\n  }\\n\\n  editor.command.apply(editor, [pointWordForward, 'start'].concat(args));\\n};\\n\\nCommands$4.moveStartTo = function (editor) {\\n  for (var _len28 = arguments.length, args = Array(_len28 > 1 ? _len28 - 1 : 0), _key28 = 1; _key28 < _len28; _key28++) {\\n    args[_key28 - 1] = arguments[_key28];\\n  }\\n\\n  editor.command.apply(editor, [proxy, 'moveStartTo'].concat(args));\\n};\\n\\nCommands$4.moveStartToEndOfBlock = function (editor) {\\n  editor.command(pointEdgeObject, 'start', 'end', 'block');\\n};\\n\\nCommands$4.moveStartToEndOfDocument = function (editor) {\\n  editor.moveStartToEndOfNode(editor.value.document).moveToStart();\\n};\\n\\nCommands$4.moveStartToEndOfInline = function (editor) {\\n  editor.command(pointEdgeObject, 'start', 'end', 'inline');\\n};\\n\\nCommands$4.moveStartToEndOfNextBlock = function (editor) {\\n  editor.command(pointEdgeSideObject, 'start', 'end', 'next', 'block');\\n};\\n\\nCommands$4.moveStartToEndOfNextInline = function (editor) {\\n  editor.command(pointEdgeSideObject, 'start', 'end', 'next', 'inline');\\n};\\n\\nCommands$4.moveStartToEndOfNextText = function (editor) {\\n  editor.command(pointEdgeSideObject, 'start', 'end', 'next', 'text');\\n};\\n\\nCommands$4.moveStartToEndOfNode = function (editor) {\\n  for (var _len29 = arguments.length, args = Array(_len29 > 1 ? _len29 - 1 : 0), _key29 = 1; _key29 < _len29; _key29++) {\\n    args[_key29 - 1] = arguments[_key29];\\n  }\\n\\n  editor.command.apply(editor, [proxy, 'moveStartToEndOfNode'].concat(args));\\n};\\n\\nCommands$4.moveStartToEndOfPreviousBlock = function (editor) {\\n  editor.command(pointEdgeSideObject, 'start', 'end', 'previous', 'block');\\n};\\n\\nCommands$4.moveStartToEndOfPreviousInline = function (editor) {\\n  editor.command(pointEdgeSideObject, 'start', 'end', 'previous', 'inline');\\n};\\n\\nCommands$4.moveStartToEndOfPreviousText = function (editor) {\\n  editor.command(pointEdgeSideObject, 'start', 'end', 'previous', 'text');\\n};\\n\\nCommands$4.moveStartToEndOfText = function (editor) {\\n  editor.command(pointEdgeObject, 'start', 'end', 'text');\\n};\\n\\nCommands$4.moveStartToStartOfBlock = function (editor) {\\n  editor.command(pointEdgeObject, 'start', 'start', 'block');\\n};\\n\\nCommands$4.moveStartToStartOfDocument = function (editor) {\\n  editor.moveStartToStartOfNode(editor.value.document).moveToStart();\\n};\\n\\nCommands$4.moveStartToStartOfInline = function (editor) {\\n  editor.command(pointEdgeObject, 'start', 'start', 'inline');\\n};\\n\\nCommands$4.moveStartToStartOfNextBlock = function (editor) {\\n  editor.command(pointEdgeSideObject, 'start', 'start', 'next', 'block');\\n};\\n\\nCommands$4.moveStartToStartOfNextInline = function (editor) {\\n  editor.command(pointEdgeSideObject, 'start', 'start', 'next', 'inline');\\n};\\n\\nCommands$4.moveStartToStartOfNextText = function (editor) {\\n  editor.command(pointEdgeSideObject, 'start', 'start', 'next', 'text');\\n};\\n\\nCommands$4.moveStartToStartOfNode = function (editor) {\\n  for (var _len30 = arguments.length, args = Array(_len30 > 1 ? _len30 - 1 : 0), _key30 = 1; _key30 < _len30; _key30++) {\\n    args[_key30 - 1] = arguments[_key30];\\n  }\\n\\n  editor.command.apply(editor, [proxy, 'moveStartToStartOfNode'].concat(args));\\n};\\n\\nCommands$4.moveStartToStartOfPreviousBlock = function (editor) {\\n  editor.command(pointEdgeSideObject, 'start', 'start', 'previous', 'block');\\n};\\n\\nCommands$4.moveStartToStartOfPreviousInline = function (editor) {\\n  editor.command(pointEdgeSideObject, 'start', 'start', 'previous', 'inline');\\n};\\n\\nCommands$4.moveStartToStartOfPreviousText = function (editor) {\\n  editor.command(pointEdgeSideObject, 'start', 'start', 'previous', 'text');\\n};\\n\\nCommands$4.moveStartToStartOfText = function (editor) {\\n  editor.command(pointEdgeObject, 'start', 'start', 'text');\\n};\\n\\nCommands$4.moveTo = function (editor) {\\n  for (var _len31 = arguments.length, args = Array(_len31 > 1 ? _len31 - 1 : 0), _key31 = 1; _key31 < _len31; _key31++) {\\n    args[_key31 - 1] = arguments[_key31];\\n  }\\n\\n  editor.command.apply(editor, [proxy, 'moveTo'].concat(args));\\n};\\n\\nCommands$4.moveToAnchor = function (editor) {\\n  editor.command(proxy, 'moveToAnchor');\\n};\\n\\nCommands$4.moveToEnd = function (editor) {\\n  editor.command(proxy, 'moveToEnd');\\n};\\n\\nCommands$4.moveToEndOfBlock = function (editor) {\\n  editor.moveEndToEndOfBlock().moveToEnd();\\n};\\n\\nCommands$4.moveToEndOfDocument = function (editor) {\\n  editor.moveEndToEndOfNode(editor.value.document).moveToEnd();\\n};\\n\\nCommands$4.moveToEndOfInline = function (editor) {\\n  editor.moveEndToEndOfInline().moveToEnd();\\n};\\n\\nCommands$4.moveToEndOfNextBlock = function (editor) {\\n  editor.moveEndToEndOfNextBlock().moveToEnd();\\n};\\n\\nCommands$4.moveToEndOfNextInline = function (editor) {\\n  editor.moveEndToEndOfNextInline().moveToEnd();\\n};\\n\\nCommands$4.moveToEndOfNextText = function (editor) {\\n  editor.moveEndToEndOfNextText().moveToEnd();\\n};\\n\\nCommands$4.moveToEndOfNode = function (editor) {\\n  for (var _len32 = arguments.length, args = Array(_len32 > 1 ? _len32 - 1 : 0), _key32 = 1; _key32 < _len32; _key32++) {\\n    args[_key32 - 1] = arguments[_key32];\\n  }\\n\\n  editor.command.apply(editor, [proxy, 'moveToEndOfNode'].concat(args));\\n};\\n\\nCommands$4.moveToEndOfPreviousBlock = function (editor) {\\n  editor.moveStartToEndOfPreviousBlock().moveToStart();\\n};\\n\\nCommands$4.moveToEndOfPreviousInline = function (editor) {\\n  editor.moveStartToEndOfPreviousInline().moveToStart();\\n};\\n\\nCommands$4.moveToEndOfPreviousText = function (editor) {\\n  editor.moveStartToEndOfPreviousText().moveToStart();\\n};\\n\\nCommands$4.moveToEndOfText = function (editor) {\\n  editor.moveEndToEndOfText().moveToEnd();\\n};\\n\\nCommands$4.moveToFocus = function (editor) {\\n  editor.command(proxy, 'moveToFocus');\\n};\\n\\nCommands$4.moveToRangeOfDocument = function (editor) {\\n  editor.moveToRangeOfNode(editor.value.document);\\n};\\n\\nCommands$4.moveToRangeOfNode = function (editor) {\\n  for (var _len33 = arguments.length, args = Array(_len33 > 1 ? _len33 - 1 : 0), _key33 = 1; _key33 < _len33; _key33++) {\\n    args[_key33 - 1] = arguments[_key33];\\n  }\\n\\n  editor.command.apply(editor, [proxy, 'moveToRangeOfNode'].concat(args));\\n};\\n\\nCommands$4.moveToStart = function (editor) {\\n  editor.command(proxy, 'moveToStart');\\n};\\n\\nCommands$4.moveToStartOfBlock = function (editor) {\\n  editor.moveStartToStartOfBlock().moveToStart();\\n};\\n\\nCommands$4.moveToStartOfDocument = function (editor) {\\n  editor.moveStartToStartOfNode(editor.value.document).moveToStart();\\n};\\n\\nCommands$4.moveToStartOfInline = function (editor) {\\n  editor.moveStartToStartOfInline().moveToStart();\\n};\\n\\nCommands$4.moveToStartOfNextBlock = function (editor) {\\n  editor.moveEndToStartOfNextBlock().moveToEnd();\\n};\\n\\nCommands$4.moveToStartOfNextInline = function (editor) {\\n  editor.moveEndToStartOfNextInline().moveToEnd();\\n};\\n\\nCommands$4.moveToStartOfNextText = function (editor) {\\n  editor.moveEndToStartOfNextText().moveToEnd();\\n};\\n\\nCommands$4.moveToStartOfNode = function (editor) {\\n  for (var _len34 = arguments.length, args = Array(_len34 > 1 ? _len34 - 1 : 0), _key34 = 1; _key34 < _len34; _key34++) {\\n    args[_key34 - 1] = arguments[_key34];\\n  }\\n\\n  editor.command.apply(editor, [proxy, 'moveToStartOfNode'].concat(args));\\n};\\n\\nCommands$4.moveToStartOfPreviousBlock = function (editor) {\\n  editor.moveStartToStartOfPreviousBlock().moveToStart();\\n};\\n\\nCommands$4.moveToStartOfPreviousInline = function (editor) {\\n  editor.moveStartToStartOfPreviousInline().moveToStart();\\n};\\n\\nCommands$4.moveToStartOfPreviousText = function (editor) {\\n  editor.moveStartToStartOfPreviousText().moveToStart();\\n};\\n\\nCommands$4.moveToStartOfText = function (editor) {\\n  editor.moveStartToStartOfText().moveToStart();\\n};\\n\\nCommands$4.select = function (editor, properties) {\\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\\n\\n  properties = Selection.createProperties(properties);\\n  var _options$snapshot = options.snapshot,\\n      snapshot = _options$snapshot === undefined ? false : _options$snapshot;\\n  var value = editor.value;\\n  var document = value.document,\\n      selection = value.selection;\\n\\n  var newProperties = {};\\n  var next = selection.setProperties(properties);\\n  next = document.resolveSelection(next);\\n\\n  // Re-compute the properties, to ensure that we get their normalized values.\\n  properties = pick(next, Object.keys(properties));\\n\\n  // Remove any properties that are already equal to the current selection. And\\n  // create a dictionary of the previous values for all of the properties that\\n  // are being changed, for the inverse operation.\\n  for (var k in properties) {\\n    if (snapshot === true || !immutable.is(properties[k], selection[k])) {\\n      newProperties[k] = properties[k];\\n    }\\n  }\\n\\n  // If the selection moves, clear any marks, unless the new selection\\n  // properties change the marks in some way.\\n  if (selection.marks && !newProperties.marks && (newProperties.anchor || newProperties.focus)) {\\n    newProperties.marks = null;\\n  }\\n\\n  // If there are no new properties to set, abort to avoid extra operations.\\n  if (Object.keys(newProperties).length === 0) {\\n    return;\\n  }\\n\\n  // TODO: for some reason toJSON() is required here (it breaks selections between blocks)? - 2018-10-10\\n  var prevProperties = pick(selection.toJSON(), Object.keys(newProperties));\\n\\n  editor.applyOperation({\\n    type: 'set_selection',\\n    value: value,\\n    properties: prevProperties,\\n    newProperties: newProperties\\n  }, snapshot ? { skip: false, merge: false } : {});\\n};\\n\\nCommands$4.setAnchor = function (editor) {\\n  for (var _len35 = arguments.length, args = Array(_len35 > 1 ? _len35 - 1 : 0), _key35 = 1; _key35 < _len35; _key35++) {\\n    args[_key35 - 1] = arguments[_key35];\\n  }\\n\\n  editor.command.apply(editor, [proxy, 'setAnchor'].concat(args));\\n};\\n\\nCommands$4.setEnd = function (editor) {\\n  for (var _len36 = arguments.length, args = Array(_len36 > 1 ? _len36 - 1 : 0), _key36 = 1; _key36 < _len36; _key36++) {\\n    args[_key36 - 1] = arguments[_key36];\\n  }\\n\\n  editor.command.apply(editor, [proxy, 'setEnd'].concat(args));\\n};\\n\\nCommands$4.setFocus = function (editor) {\\n  for (var _len37 = arguments.length, args = Array(_len37 > 1 ? _len37 - 1 : 0), _key37 = 1; _key37 < _len37; _key37++) {\\n    args[_key37 - 1] = arguments[_key37];\\n  }\\n\\n  editor.command.apply(editor, [proxy, 'setFocus'].concat(args));\\n};\\n\\nCommands$4.setStart = function (editor) {\\n  for (var _len38 = arguments.length, args = Array(_len38 > 1 ? _len38 - 1 : 0), _key38 = 1; _key38 < _len38; _key38++) {\\n    args[_key38 - 1] = arguments[_key38];\\n  }\\n\\n  editor.command.apply(editor, [proxy, 'setStart'].concat(args));\\n};\\n\\nCommands$4.snapshotSelection = function (editor) {\\n  editor.withoutMerging(function () {\\n    editor.select(editor.value.selection, { snapshot: true });\\n  });\\n};\\n\\n/**\\n * Helpers.\\n */\\n\\nfunction proxy(editor, method) {\\n  var _editor$value$selecti;\\n\\n  for (var _len39 = arguments.length, args = Array(_len39 > 2 ? _len39 - 2 : 0), _key39 = 2; _key39 < _len39; _key39++) {\\n    args[_key39 - 2] = arguments[_key39];\\n  }\\n\\n  var range = (_editor$value$selecti = editor.value.selection)[method].apply(_editor$value$selecti, args);\\n  editor.select(range);\\n}\\n\\nfunction pointEdgeObject(editor, point, edge, object) {\\n  var Point = point.slice(0, 1).toUpperCase() + point.slice(1);\\n  var Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1);\\n  var Object = object.slice(0, 1).toUpperCase() + object.slice(1);\\n  var method = 'move' + Point + 'To' + Edge + 'OfNode';\\n  var getNode = object === 'text' ? 'getNode' : 'getClosest' + Object;\\n  var value = editor.value;\\n  var document = value.document,\\n      selection = value.selection;\\n\\n  var p = selection[point];\\n  var node = document[getNode](p.key);\\n  if (!node) return;\\n  editor[method](node);\\n}\\n\\nfunction pointEdgeSideObject(editor, point, edge, side, object) {\\n  var Point = point.slice(0, 1).toUpperCase() + point.slice(1);\\n  var Edge = edge.slice(0, 1).toUpperCase() + edge.slice(1);\\n  var Side = side.slice(0, 1).toUpperCase() + side.slice(1);\\n  var Object = object.slice(0, 1).toUpperCase() + object.slice(1);\\n  var method = 'move' + Point + 'To' + Edge + 'OfNode';\\n  var getNode = object === 'text' ? 'getNode' : 'getClosest' + Object;\\n  var getDirectionNode = 'get' + Side + Object;\\n  var value = editor.value;\\n  var document = value.document,\\n      selection = value.selection;\\n\\n  var p = selection[point];\\n  var node = document[getNode](p.key);\\n  if (!node) return;\\n  var target = document[getDirectionNode](node.key);\\n  if (!target) return;\\n  editor[method](target);\\n}\\n\\nfunction pointBackward(editor, point) {\\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\\n\\n  if (n === 0) return;\\n  if (n < 0) return pointForward(editor, point, -n);\\n\\n  var Point = point.slice(0, 1).toUpperCase() + point.slice(1);\\n  var value = editor.value;\\n  var document = value.document,\\n      selection = value.selection;\\n\\n  var p = selection[point];\\n  var hasVoidParent = document.hasVoidParent(p.path, editor);\\n\\n  // what is this?\\n  if (!hasVoidParent && p.offset - n >= 0) {\\n    var range = selection['move' + Point + 'Backward'](n);\\n    editor.select(range);\\n    return;\\n  }\\n\\n  var previous = document.getPreviousText(p.path);\\n  if (!previous) return;\\n\\n  var block = document.getClosestBlock(p.path);\\n  var isInBlock = block.hasNode(previous.key);\\n  var isPreviousInVoid = previous && document.hasVoidParent(previous.key, editor);\\n  editor['move' + Point + 'ToEndOfNode'](previous);\\n\\n  // when is this called?\\n  if (!hasVoidParent && !isPreviousInVoid && isInBlock) {\\n    var _range = editor.value.selection['move' + Point + 'Backward'](n);\\n    editor.select(_range);\\n  }\\n}\\n\\nfunction pointForward(editor, point) {\\n  var n = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\\n\\n  if (n === 0) return;\\n  if (n < 0) return pointBackward(editor, point, -n);\\n\\n  var Point = point.slice(0, 1).toUpperCase() + point.slice(1);\\n  var value = editor.value;\\n  var document = value.document,\\n      selection = value.selection;\\n\\n  var p = selection[point];\\n  var text = document.getNode(p.path);\\n  var hasVoidParent = document.hasVoidParent(p.path, editor);\\n\\n  // what is this?\\n  if (!hasVoidParent && p.offset + n <= text.text.length) {\\n    var range = selection['move' + Point + 'Forward'](n);\\n    editor.select(range);\\n    return;\\n  }\\n\\n  var next = document.getNextText(p.path);\\n  if (!next) return;\\n\\n  var block = document.getClosestBlock(p.path);\\n  var isInBlock = block.hasNode(next.key);\\n  var isNextInVoid = document.hasVoidParent(next.key, editor);\\n  editor['move' + Point + 'ToStartOfNode'](next);\\n\\n  // when is this called?\\n  if (!hasVoidParent && !isNextInVoid && isInBlock) {\\n    var _range2 = editor.value.selection['move' + Point + 'Forward'](n);\\n    editor.select(_range2);\\n  }\\n}\\n\\nfunction pointWordBackward(editor, pointName) {\\n  var value = editor.value;\\n  var document = value.document,\\n      selection = value.selection;\\n\\n  var point = selection[pointName];\\n  var block = document.getClosestBlock(point.key);\\n  var offset = block.getOffset(point.key);\\n  var o = offset + point.offset;\\n  var text = block.text;\\n\\n  var n = TextUtils.getWordOffsetBackward(text, o);\\n  editor.command(pointBackward, pointName, n > 0 ? n : 1);\\n}\\n\\nfunction pointWordForward(editor, pointName) {\\n  var value = editor.value;\\n  var document = value.document,\\n      selection = value.selection;\\n\\n  var point = selection[pointName];\\n  var block = document.getClosestBlock(point.key);\\n  var offset = block.getOffset(point.key);\\n  var o = offset + point.offset;\\n  var text = block.text;\\n\\n  var n = TextUtils.getWordOffsetForward(text, o);\\n  editor.command(pointForward, pointName, n > 0 ? n : 1);\\n}\\n\\n/**\\n * Commands.\\n *\\n * @type {Object}\\n */\\n\\nvar Commands$5 = {};\\n\\n/**\\n * Set `properties` on the value.\\n *\\n * @param {Editor} editor\\n * @param {Object|Value} properties\\n */\\n\\nCommands$5.setData = function (editor) {\\n  var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n  var value = editor.value;\\n\\n  var newProperties = Value.createProperties({ data: data });\\n  var prevProperties = pick(value, Object.keys(newProperties));\\n\\n  editor.applyOperation({\\n    type: 'set_value',\\n    properties: prevProperties,\\n    newProperties: newProperties\\n  });\\n};\\n\\nCommands$5.addAnnotation = function (editor, annotation) {\\n  annotation = Annotation.create(annotation);\\n\\n  editor.applyOperation({\\n    type: 'add_annotation',\\n    annotation: annotation\\n  });\\n};\\n\\nCommands$5.removeAnnotation = function (editor, annotation) {\\n  annotation = Annotation.create(annotation);\\n\\n  editor.applyOperation({\\n    type: 'remove_annotation',\\n    annotation: annotation\\n  });\\n};\\n\\nCommands$5.setAnnotation = function (editor, annotation, newProperties) {\\n  annotation = Annotation.create(annotation);\\n  newProperties = Annotation.createProperties(newProperties);\\n\\n  editor.applyOperation({\\n    type: 'set_annotation',\\n    properties: annotation,\\n    newProperties: newProperties\\n  });\\n};\\n\\nCommands$5.setAnnotations = function (editor) {\\n  var annotations = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\\n  var value = editor.value;\\n\\n  var newProperties = Value.createProperties({ annotations: annotations });\\n  var prevProperties = pick(value, Object.keys(newProperties));\\n\\n  editor.applyOperation({\\n    type: 'set_value',\\n    properties: prevProperties,\\n    newProperties: newProperties\\n  });\\n};\\n\\n/**\\n * A plugin that adds a set of queries to the editor.\\n *\\n * @param {Object} queries\\n * @return {Object}\\n */\\n\\nfunction QueriesPlugin() {\\n  var queries = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n  /**\\n   * On construct, register all the queries.\\n   *\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onConstruct(editor, next) {\\n    for (var query in queries) {\\n      editor.registerQuery(query);\\n    }\\n\\n    return next();\\n  }\\n\\n  /**\\n   * On query, if it exists in our list of queries, call it.\\n   *\\n   * @param {Object} query\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onQuery(query, editor, next) {\\n    var type = query.type,\\n        args = query.args;\\n\\n    var fn = queries[type];\\n    if (!fn) return next();\\n    var ret = fn.apply(undefined, [editor].concat(toConsumableArray(args)));\\n    return ret === undefined ? next() : ret;\\n  }\\n\\n  /**\\n   * Return the plugin.\\n   *\\n   * @type {Object}\\n   */\\n\\n  return {\\n    onConstruct: onConstruct,\\n    onQuery: onQuery\\n  };\\n}\\n\\n/**\\n * Define a Slate error.\\n *\\n * @type {SlateError}\\n */\\n\\nvar SlateError = function (_Error) {\\n  inherits(SlateError, _Error);\\n\\n  function SlateError(code) {\\n    var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n    classCallCheck(this, SlateError);\\n\\n    var _this = possibleConstructorReturn(this, (SlateError.__proto__ || Object.getPrototypeOf(SlateError)).call(this, code));\\n\\n    _this.code = code;\\n\\n    for (var key in attrs) {\\n      _this[key] = attrs[key];\\n    }\\n\\n    if (Error.captureStackTrace) {\\n      Error.captureStackTrace(_this, _this.constructor);\\n    } else {\\n      _this.stack = new Error().stack;\\n    }\\n    return _this;\\n  }\\n\\n  return SlateError;\\n}(Error);\\n\\n/**\\n * Create a plugin from a `schema` definition.\\n *\\n * @param {Object} schema\\n * @return {Object}\\n */\\n\\nfunction SchemaPlugin(schema) {\\n  var rules = schema.rules,\\n      document = schema.document,\\n      blocks = schema.blocks,\\n      inlines = schema.inlines,\\n      marks = schema.marks,\\n      annotations = schema.annotations,\\n      decorations = schema.decorations;\\n\\n  var schemaRules = [];\\n\\n  if (rules) {\\n    schemaRules = schemaRules.concat(rules);\\n  }\\n\\n  if (document) {\\n    schemaRules.push(_extends({\\n      match: [{ object: 'document' }]\\n    }, document));\\n  }\\n\\n  if (blocks) {\\n    for (var key in blocks) {\\n      schemaRules.push(_extends({\\n        match: [{ object: 'block', type: key }]\\n      }, blocks[key]));\\n    }\\n  }\\n\\n  if (inlines) {\\n    for (var _key in inlines) {\\n      schemaRules.push(_extends({\\n        match: [{ object: 'inline', type: _key }]\\n      }, inlines[_key]));\\n    }\\n  }\\n\\n  if (marks) {\\n    for (var _key2 in marks) {\\n      schemaRules.push(_extends({\\n        match: [{ object: 'mark', type: _key2 }]\\n      }, marks[_key2]));\\n    }\\n  }\\n\\n  if (annotations) {\\n    for (var _key3 in annotations) {\\n      schemaRules.push(_extends({\\n        match: [{ object: 'annotation', type: _key3 }]\\n      }, annotations[_key3]));\\n    }\\n  }\\n\\n  if (decorations) {\\n    for (var _key4 in decorations) {\\n      schemaRules.push(_extends({\\n        match: [{ object: 'decoration', type: _key4 }]\\n      }, decorations[_key4]));\\n    }\\n  }\\n\\n  /**\\n   * Check if a `format` is atomic based on the schema rules.\\n   *\\n   * @param {Editor} editor\\n   * @param {Format} format\\n   * @return {Boolean}\\n   */\\n\\n  function isAtomic(editor, format) {\\n    var rule = schemaRules.find(function (r) {\\n      return 'isAtomic' in r && testRules(format, r.match);\\n    });\\n\\n    return rule && rule.isAtomic;\\n  }\\n\\n  /**\\n   * Check if a `node` is void based on the schema rules.\\n   *\\n   * @param {Editor} editor\\n   * @param {Node} node\\n   * @return {Boolean}\\n   */\\n\\n  function isVoid(editor, node) {\\n    var rule = schemaRules.find(function (r) {\\n      return 'isVoid' in r && testRules(node, r.match);\\n    });\\n\\n    return rule && rule.isVoid;\\n  }\\n\\n  /**\\n   * Normalize a `node` with the schema rules, returning a function that will\\n   * fix the invalid node, or void if the node is valid.\\n   *\\n   * @param {Node} node\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   * @return {Function|Void}\\n   */\\n\\n  function normalizeNode(node, editor, next) {\\n    var error = validateNode(node, editor, function () {});\\n    if (!error) return next();\\n\\n    return function () {\\n      var rule = error.rule;\\n      var size = editor.operations.size;\\n\\n      // First run the user-provided `normalize` function if one exists...\\n\\n      if (rule.normalize) {\\n        rule.normalize(editor, error);\\n      }\\n\\n      // If the `normalize` function did not add any operations to the editor\\n      // object, it can't have normalized, so run the default one.\\n      if (editor.operations.size === size) {\\n        defaultNormalize(editor, error);\\n      }\\n    };\\n  }\\n\\n  /**\\n   * Validate a `node` with the schema rules, returning a `SlateError` if it's\\n   * invalid.\\n   *\\n   * @param {Node} node\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   * @return {Error|Void}\\n   */\\n\\n  function validateNode(node, editor, next) {\\n    var matches = schemaRules.filter(function (r) {\\n      return testRules(node, r.match);\\n    });\\n    var failure = validateRules(node, matches, schemaRules, { every: true });\\n    if (!failure) return next();\\n    var error = new SlateError(failure.code, failure);\\n    return error;\\n  }\\n\\n  /**\\n   * On schema-related queries, respond if we can.\\n   *\\n   * @param {Object} query\\n   * @param {Function} next\\n   */\\n\\n  var queries = QueriesPlugin({ isAtomic: isAtomic, isVoid: isVoid });\\n\\n  /**\\n   * Return the plugins.\\n   *\\n   * @type {Object}\\n   */\\n\\n  return [{ normalizeNode: normalizeNode, validateNode: validateNode }, queries];\\n}\\n\\n/**\\n * Normalize an invalid value with `error` with default remedies.\\n *\\n * @param {Editor} editor\\n * @param {SlateError} error\\n */\\n\\nfunction defaultNormalize(editor, error) {\\n  var code = error.code,\\n      node = error.node,\\n      child = error.child,\\n      next = error.next,\\n      previous = error.previous,\\n      key = error.key,\\n      mark = error.mark;\\n\\n\\n  switch (code) {\\n    case 'child_max_invalid':\\n    case 'child_object_invalid':\\n    case 'child_type_invalid':\\n    case 'child_unknown':\\n    case 'first_child_object_invalid':\\n    case 'first_child_type_invalid':\\n    case 'last_child_object_invalid':\\n    case 'last_child_type_invalid':\\n      {\\n        return child.object === 'text' && node.object === 'block' && node.nodes.size === 1 ? editor.removeNodeByKey(node.key) : editor.removeNodeByKey(child.key);\\n      }\\n\\n    case 'previous_sibling_object_invalid':\\n    case 'previous_sibling_type_invalid':\\n      {\\n        return previous.object === 'text' && node.object === 'block' && node.nodes.size === 1 ? editor.removeNodeByKey(node.key) : editor.removeNodeByKey(previous.key);\\n      }\\n\\n    case 'next_sibling_object_invalid':\\n    case 'next_sibling_type_invalid':\\n      {\\n        return next.object === 'text' && node.object === 'block' && node.nodes.size === 1 ? editor.removeNodeByKey(node.key) : editor.removeNodeByKey(next.key);\\n      }\\n\\n    case 'child_min_invalid':\\n    case 'node_text_invalid':\\n    case 'parent_object_invalid':\\n    case 'parent_type_invalid':\\n      {\\n        return node.object === 'document' ? node.nodes.forEach(function (n) {\\n          return editor.removeNodeByKey(n.key);\\n        }) : editor.removeNodeByKey(node.key);\\n      }\\n\\n    case 'node_data_invalid':\\n      {\\n        return node.data.get(key) === undefined && node.object !== 'document' ? editor.removeNodeByKey(node.key) : editor.setNodeByKey(node.key, { data: node.data.delete(key) });\\n      }\\n\\n    case 'node_mark_invalid':\\n      {\\n        return node.getTexts().forEach(function (t) {\\n          return editor.removeMarkByKey(t.key, 0, t.text.length, mark);\\n        });\\n      }\\n\\n    default:\\n      {\\n        return editor.removeNodeByKey(node.key);\\n      }\\n  }\\n}\\n\\n/**\\n * Check that an `object` matches one of a set of `rules`.\\n *\\n * @param {Mixed} object\\n * @param {Object|Array} rules\\n * @return {Boolean}\\n */\\n\\nfunction testRules(object, rules) {\\n  var error = validateRules(object, rules);\\n  return !error;\\n}\\n\\n/**\\n * Validate that a `object` matches a `rule` object or array.\\n *\\n * @param {Mixed} object\\n * @param {Object|Array} rule\\n * @param {Array|Void} rules\\n * @return {Error|Void}\\n */\\n\\nfunction validateRules(object, rule, rules) {\\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\\n  var _options$every = options.every,\\n      every = _options$every === undefined ? false : _options$every,\\n      _options$match = options.match,\\n      match = _options$match === undefined ? null : _options$match;\\n\\n\\n  if (typeof rule === 'function') {\\n    var valid = rule(object, match);\\n    return valid ? null : fail('node_invalid', { rule: rule, node: object });\\n  }\\n\\n  if (Array.isArray(rule)) {\\n    var array = rule.length ? rule : [{}];\\n    var first = void 0;\\n\\n    var _iteratorNormalCompletion = true;\\n    var _didIteratorError = false;\\n    var _iteratorError = undefined;\\n\\n    try {\\n      for (var _iterator = array[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n        var r = _step.value;\\n\\n        var _error = validateRules(object, r, rules);\\n        first = first || _error;\\n        if (every && _error) return _error;\\n        if (!every && !_error) return;\\n      }\\n    } catch (err) {\\n      _didIteratorError = true;\\n      _iteratorError = err;\\n    } finally {\\n      try {\\n        if (!_iteratorNormalCompletion && _iterator.return) {\\n          _iterator.return();\\n        }\\n      } finally {\\n        if (_didIteratorError) {\\n          throw _iteratorError;\\n        }\\n      }\\n    }\\n\\n    return first;\\n  }\\n\\n  var error = validateObject(object, rule) || validateType(object, rule) || validateData(object, rule) || validateMarks(object, rule) || validateText(object, rule) || validateFirst(object, rule) || validateLast(object, rule) || validateNodes(object, rule, rules);\\n\\n  return error;\\n}\\n\\nfunction validateObject(node, rule) {\\n  if (rule.object == null) return;\\n  if (rule.object === node.object) return;\\n  if (typeof rule.object === 'function' && rule.object(node.object)) return;\\n  return fail('node_object_invalid', { rule: rule, node: node });\\n}\\n\\nfunction validateType(node, rule) {\\n  if (rule.type == null) return;\\n  if (rule.type === node.type) return;\\n  if (typeof rule.type === 'function' && rule.type(node.type)) return;\\n  return fail('node_type_invalid', { rule: rule, node: node });\\n}\\n\\nfunction validateData(node, rule) {\\n  if (rule.data == null) return;\\n  if (node.data == null) return;\\n\\n  if (typeof rule.data === 'function') {\\n    if (rule.data(node.data)) return;\\n    return fail('node_data_invalid', { rule: rule, node: node });\\n  }\\n\\n  for (var key in rule.data) {\\n    var fn = rule.data[key];\\n    var value = node.data && node.data.get(key);\\n    var valid = typeof fn === 'function' ? fn(value) : fn === value;\\n    if (valid) continue;\\n    return fail('node_data_invalid', { rule: rule, node: node, key: key, value: value });\\n  }\\n}\\n\\nfunction validateMarks(node, rule) {\\n  if (rule.marks == null) return;\\n\\n  var marks = node.object === 'text' ? node.marks.toArray() : node.getMarks().toArray();\\n\\n  var _loop = function _loop(mark) {\\n    var valid = rule.marks.some(function (def) {\\n      return typeof def.type === 'function' ? def.type(mark.type) : def.type === mark.type;\\n    });\\n    if (valid) return 'continue';\\n    return {\\n      v: fail('node_mark_invalid', { rule: rule, node: node, mark: mark })\\n    };\\n  };\\n\\n  var _iteratorNormalCompletion2 = true;\\n  var _didIteratorError2 = false;\\n  var _iteratorError2 = undefined;\\n\\n  try {\\n    for (var _iterator2 = marks[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n      var mark = _step2.value;\\n\\n      var _ret = _loop(mark);\\n\\n      switch (_ret) {\\n        case 'continue':\\n          continue;\\n\\n        default:\\n          if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \\\"object\\\") return _ret.v;\\n      }\\n    }\\n  } catch (err) {\\n    _didIteratorError2 = true;\\n    _iteratorError2 = err;\\n  } finally {\\n    try {\\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n        _iterator2.return();\\n      }\\n    } finally {\\n      if (_didIteratorError2) {\\n        throw _iteratorError2;\\n      }\\n    }\\n  }\\n}\\n\\nfunction validateText(node, rule) {\\n  if (rule.text == null) return;\\n  var text = node.text;\\n\\n  var valid = typeof rule.text === 'function' ? rule.text(text) : rule.text.test(text);\\n  if (valid) return;\\n  return fail('node_text_invalid', { rule: rule, node: node, text: text });\\n}\\n\\nfunction validateFirst(node, rule) {\\n  if (rule.first == null) return;\\n  var first = node.nodes.first();\\n  if (!first) return;\\n  var error = validateRules(first, rule.first);\\n  if (!error) return;\\n  error.rule = rule;\\n  error.node = node;\\n  error.child = first;\\n  error.code = error.code.replace('node_', 'first_child_');\\n  return error;\\n}\\n\\nfunction validateLast(node, rule) {\\n  if (rule.last == null) return;\\n  var last = node.nodes.last();\\n  if (!last) return;\\n  var error = validateRules(last, rule.last);\\n  if (!error) return;\\n  error.rule = rule;\\n  error.node = node;\\n  error.child = last;\\n  error.code = error.code.replace('node_', 'last_child_');\\n  return error;\\n}\\n\\nfunction validateNodes(node, rule) {\\n  var rules = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\\n\\n  if (node.nodes == null) return;\\n\\n  var children = node.nodes;\\n  var defs = rule.nodes != null ? rule.nodes.slice() : [];\\n  var count = 0;\\n  var lastCount = 0;\\n  var min = null;\\n  var index = -1;\\n  var def = null;\\n  var max = null;\\n  var child = null;\\n  var previous = null;\\n  var next = null;\\n\\n  function nextDef() {\\n    if (defs.length === 0) return false;\\n    def = defs.shift();\\n    lastCount = count;\\n    count = 0;\\n    min = def.min || null;\\n    max = def.max || null;\\n    return true;\\n  }\\n\\n  function nextChild() {\\n    index += 1;\\n    previous = index ? children.get(index - 1) : null;\\n    child = children.get(index);\\n    next = children.get(index + 1);\\n    if (!child) return false;\\n    lastCount = count;\\n    count += 1;\\n    return true;\\n  }\\n\\n  function rewind() {\\n    if (index > 0) {\\n      index -= 1;\\n      count = lastCount;\\n    }\\n  }\\n\\n  if (rule.nodes != null) {\\n    nextDef();\\n  }\\n\\n  while (nextChild()) {\\n    var err = validateParent(node, child, rules) || validatePrevious(node, child, previous, index, rules) || validateNext(node, child, next, index, rules);\\n\\n    if (err) return err;\\n\\n    if (rule.nodes != null) {\\n      if (!def) {\\n        return fail('child_unknown', { rule: rule, node: node, child: child, index: index });\\n      }\\n\\n      if (def.match) {\\n        var error = validateRules(child, def.match);\\n\\n        if (error) {\\n          // Since we want to report overflow on last matching child we don't\\n          // immediately check for count > max, but instead do so once we find\\n          // a child that doesn't match.\\n          if (max != null && count - 1 > max) {\\n            rewind();\\n            return fail('child_max_invalid', {\\n              rule: rule,\\n              node: node,\\n              index: index,\\n              child: children.get(index),\\n              count: count,\\n              limit: max\\n            });\\n          }\\n\\n          var lastMin = min;\\n\\n          // If there are more groups after this one then child might actually\\n          // be valid.\\n          if (nextDef()) {\\n            // If we've already satisfied the minimum for the current group,\\n            // then we can rewind and proceed to the next group.\\n            if (lastCount - 1 >= lastMin) {\\n              index -= 1;\\n              continue;\\n            }\\n\\n            // Otherwise we know that current value is underflowing. There are\\n            // three possible causes for this...\\n\\n            // 1. There might just not be enough elements for current group, and\\n            // current child is in fact the first of the next group. If so, the\\n            // next def will not report errors, in which case we can rewind and\\n            // report an minimum error.\\n            if (validateRules(child, def.match) == null) {\\n              rewind();\\n              return fail('child_min_invalid', {\\n                rule: rule,\\n                node: node,\\n                index: index,\\n                count: lastCount - 1,\\n                limit: lastMin\\n              });\\n            }\\n\\n            // 2. The current group is underflowing, but there is also an\\n            // invalid child before the next group.\\n            // 3. Or the current group is not underflowing but it appears so\\n            // because there's an invalid child between its members.\\n            // It's either the second or third case. If it's the second then\\n            // we could report an underflow, but presence of an invalid child\\n            // is arguably more important, so we report it first. It also lets\\n            // us avoid checking for which case exactly is it.\\n            error.rule = rule;\\n            error.node = node;\\n            error.child = child;\\n            error.index = index;\\n            error.code = error.code.replace('node_', 'child_');\\n            return error;\\n          }\\n\\n          // Otherwise either we exhausted the last group, in which case it's\\n          // an unknown child, ...\\n          if (max != null && count > max) {\\n            return fail('child_unknown', { rule: rule, node: node, child: child, index: index });\\n          }\\n\\n          // ... or it's an invalid child for the last group.\\n          error.rule = rule;\\n          error.node = node;\\n          error.child = child;\\n          error.index = index;\\n          error.code = error.code.replace('node_', 'child_');\\n          return error;\\n        }\\n      }\\n    }\\n  }\\n\\n  // Since we want to report overflow on last matching child we don't\\n  // immediately check for count > max, but do so after processing all nodes.\\n  if (max != null && count > max) {\\n    return fail('child_max_invalid', {\\n      rule: rule,\\n      node: node,\\n      index: index - 1,\\n      count: count,\\n      child: children.get(index - 1),\\n      limit: max\\n    });\\n  }\\n\\n  if (rule.nodes != null) {\\n    do {\\n      if (count < min) {\\n        return fail('child_min_invalid', {\\n          rule: rule,\\n          node: node,\\n          index: index,\\n          count: count,\\n          limit: min\\n        });\\n      }\\n    } while (nextDef());\\n  }\\n}\\n\\nfunction validateParent(node, child, rules) {\\n  var _iteratorNormalCompletion3 = true;\\n  var _didIteratorError3 = false;\\n  var _iteratorError3 = undefined;\\n\\n  try {\\n    for (var _iterator3 = rules[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\\n      var rule = _step3.value;\\n\\n      if (rule.parent == null) continue;\\n      if (!testRules(child, rule.match)) continue;\\n\\n      var error = validateRules(node, rule.parent);\\n      if (!error) continue;\\n\\n      error.rule = rule;\\n      error.parent = node;\\n      error.node = child;\\n      error.code = error.code.replace('node_', 'parent_');\\n      return error;\\n    }\\n  } catch (err) {\\n    _didIteratorError3 = true;\\n    _iteratorError3 = err;\\n  } finally {\\n    try {\\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\\n        _iterator3.return();\\n      }\\n    } finally {\\n      if (_didIteratorError3) {\\n        throw _iteratorError3;\\n      }\\n    }\\n  }\\n}\\n\\nfunction validatePrevious(node, child, previous, index, rules) {\\n  if (!previous) return;\\n\\n  var _iteratorNormalCompletion4 = true;\\n  var _didIteratorError4 = false;\\n  var _iteratorError4 = undefined;\\n\\n  try {\\n    for (var _iterator4 = rules[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\\n      var rule = _step4.value;\\n\\n      if (rule.previous == null) continue;\\n      if (!testRules(child, rule.match)) continue;\\n\\n      var error = validateRules(previous, rule.previous);\\n      if (!error) continue;\\n\\n      error.rule = rule;\\n      error.node = node;\\n      error.child = child;\\n      error.index = index;\\n      error.previous = previous;\\n      error.code = error.code.replace('node_', 'previous_sibling_');\\n      return error;\\n    }\\n  } catch (err) {\\n    _didIteratorError4 = true;\\n    _iteratorError4 = err;\\n  } finally {\\n    try {\\n      if (!_iteratorNormalCompletion4 && _iterator4.return) {\\n        _iterator4.return();\\n      }\\n    } finally {\\n      if (_didIteratorError4) {\\n        throw _iteratorError4;\\n      }\\n    }\\n  }\\n}\\n\\nfunction validateNext(node, child, next, index, rules) {\\n  if (!next) return;\\n\\n  var _iteratorNormalCompletion5 = true;\\n  var _didIteratorError5 = false;\\n  var _iteratorError5 = undefined;\\n\\n  try {\\n    for (var _iterator5 = rules[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\\n      var rule = _step5.value;\\n\\n      if (rule.next == null) continue;\\n      if (!testRules(child, rule.match)) continue;\\n\\n      var error = validateRules(next, rule.next, [], { match: child });\\n      if (!error) continue;\\n\\n      error.rule = rule;\\n      error.node = node;\\n      error.child = child;\\n      error.index = index;\\n      error.next = next;\\n      error.code = error.code.replace('node_', 'next_sibling_');\\n      return error;\\n    }\\n  } catch (err) {\\n    _didIteratorError5 = true;\\n    _iteratorError5 = err;\\n  } finally {\\n    try {\\n      if (!_iteratorNormalCompletion5 && _iterator5.return) {\\n        _iterator5.return();\\n      }\\n    } finally {\\n      if (_didIteratorError5) {\\n        throw _iteratorError5;\\n      }\\n    }\\n  }\\n}\\n\\n/**\\n * Create an interim failure object with `code` and `attrs`.\\n *\\n * @param {String} code\\n * @param {Object} attrs\\n * @return {Object}\\n */\\n\\nfunction fail(code, attrs) {\\n  return _extends({ code: code }, attrs);\\n}\\n\\n/**\\n * Ensure that an expanded selection is deleted first using the `editor.delete`\\n * command. This guarantees that it uses the proper semantic \\\"intent\\\" instead of\\n * using `deleteAtRange` under the covers and skipping `delete`.\\n *\\n * @param {Editor}\\n */\\n\\nfunction deleteExpanded(editor) {\\n  var value = editor.value;\\n  var selection = value.selection;\\n\\n\\n  if (selection.isExpanded) {\\n    editor.delete();\\n  }\\n}\\n\\n/**\\n * Commands.\\n *\\n * @type {Object}\\n */\\n\\nvar Commands$6 = {};\\n\\n/**\\n * Add a `mark` to the characters in the current selection.\\n *\\n * @param {Editor} editor\\n * @param {Mark} mark\\n */\\n\\nCommands$6.addMark = function (editor, mark) {\\n  mark = Mark.create(mark);\\n  var value = editor.value;\\n  var document = value.document,\\n      selection = value.selection;\\n\\n\\n  if (selection.isExpanded) {\\n    editor.addMarkAtRange(selection, mark);\\n  } else if (selection.marks) {\\n    var marks = selection.marks.add(mark);\\n    var sel = selection.set('marks', marks);\\n    editor.select(sel);\\n  } else {\\n    var _marks = document.getActiveMarksAtRange(selection).add(mark);\\n    var _sel = selection.set('marks', _marks);\\n    editor.select(_sel);\\n  }\\n};\\n\\n/**\\n * Add a list of `marks` to the characters in the current selection.\\n *\\n * @param {Editor} editor\\n * @param {Set<Mark>|Array<Object>} marks\\n */\\n\\nCommands$6.addMarks = function (editor, marks) {\\n  marks.forEach(function (mark) {\\n    return editor.addMark(mark);\\n  });\\n};\\n\\n/**\\n * Delete at the current selection.\\n *\\n * @param {Editor} editor\\n */\\n\\nCommands$6.delete = function (editor) {\\n  var value = editor.value;\\n  var selection = value.selection;\\n\\n  editor.deleteAtRange(selection);\\n\\n  // COMPAT: Ensure that the selection is collapsed, because in certain cases\\n  // when deleting across inline nodes, when splitting the inline node the end\\n  // point of the selection will end up after the split point.\\n  editor.moveToFocus();\\n};\\n\\n/**\\n * Delete backward `n` characters.\\n *\\n * @param {Editor} editor\\n * @param {Number} n (optional)\\n */\\n\\nCommands$6.deleteBackward = function (editor) {\\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\\n  var value = editor.value;\\n  var selection = value.selection;\\n\\n\\n  if (selection.isExpanded) {\\n    editor.delete();\\n  } else {\\n    editor.deleteBackwardAtRange(selection, n);\\n  }\\n};\\n\\n/**\\n * Delete backward one character.\\n *\\n * @param {Editor} editor\\n */\\n\\nCommands$6.deleteCharBackward = function (editor) {\\n  var value = editor.value;\\n  var selection = value.selection;\\n\\n\\n  if (selection.isExpanded) {\\n    editor.delete();\\n  } else {\\n    editor.deleteCharBackwardAtRange(selection);\\n  }\\n};\\n\\n/**\\n * Delete backward one line.\\n *\\n * @param {Editor} editor\\n */\\n\\nCommands$6.deleteLineBackward = function (editor) {\\n  var value = editor.value;\\n  var selection = value.selection;\\n\\n\\n  if (selection.isExpanded) {\\n    editor.delete();\\n  } else {\\n    editor.deleteLineBackwardAtRange(selection);\\n  }\\n};\\n\\n/**\\n * Delete backward one word.\\n *\\n * @param {Editor} editor\\n */\\n\\nCommands$6.deleteWordBackward = function (editor) {\\n  var value = editor.value;\\n  var selection = value.selection;\\n\\n\\n  if (selection.isExpanded) {\\n    editor.delete();\\n  } else {\\n    editor.deleteWordBackwardAtRange(selection);\\n  }\\n};\\n\\n/**\\n * Delete backward `n` characters.\\n *\\n * @param {Editor} editor\\n * @param {Number} n (optional)\\n */\\n\\nCommands$6.deleteForward = function (editor) {\\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\\n  var value = editor.value;\\n  var selection = value.selection;\\n\\n\\n  if (selection.isExpanded) {\\n    editor.delete();\\n  } else {\\n    editor.deleteForwardAtRange(selection, n);\\n  }\\n};\\n\\n/**\\n * Delete backward one character.\\n *\\n * @param {Editor} editor\\n */\\n\\nCommands$6.deleteCharForward = function (editor) {\\n  var value = editor.value;\\n  var selection = value.selection;\\n\\n\\n  if (selection.isExpanded) {\\n    editor.delete();\\n  } else {\\n    editor.deleteCharForwardAtRange(selection);\\n  }\\n};\\n\\n/**\\n * Delete backward one line.\\n *\\n * @param {Editor} editor\\n */\\n\\nCommands$6.deleteLineForward = function (editor) {\\n  var value = editor.value;\\n  var selection = value.selection;\\n\\n\\n  if (selection.isExpanded) {\\n    editor.delete();\\n  } else {\\n    editor.deleteLineForwardAtRange(selection);\\n  }\\n};\\n\\n/**\\n * Delete backward one word.\\n *\\n * @param {Editor} editor\\n */\\n\\nCommands$6.deleteWordForward = function (editor) {\\n  var value = editor.value;\\n  var selection = value.selection;\\n\\n\\n  if (selection.isExpanded) {\\n    editor.delete();\\n  } else {\\n    editor.deleteWordForwardAtRange(selection);\\n  }\\n};\\n\\n/**\\n * Insert a `block` at the current selection.\\n *\\n * @param {Editor} editor\\n * @param {String|Object|Block} block\\n */\\n\\nCommands$6.insertBlock = function (editor, block) {\\n  deleteExpanded(editor);\\n\\n  block = Block.create(block);\\n  var value = editor.value;\\n  var selection = value.selection;\\n\\n  editor.insertBlockAtRange(selection, block);\\n\\n  // If the node was successfully inserted, update the selection.\\n  var node = editor.value.document.getNode(block.key);\\n  if (node) editor.moveToEndOfNode(node);\\n};\\n\\n/**\\n * Insert a `fragment` at the current selection.\\n *\\n * @param {Editor} editor\\n * @param {Document} fragment\\n */\\n\\nCommands$6.insertFragment = function (editor, fragment) {\\n  if (!fragment.nodes.size) return;\\n\\n  deleteExpanded(editor);\\n\\n  var value = editor.value;\\n  var _value = value,\\n      document = _value.document,\\n      selection = _value.selection;\\n  var start = selection.start;\\n\\n  var keys = Array.from(document.texts(), function (_ref) {\\n    var _ref2 = slicedToArray(_ref, 1),\\n        text = _ref2[0];\\n\\n    return text.key;\\n  });\\n\\n  editor.insertFragmentAtRange(selection, fragment);\\n  value = editor.value;\\n  document = value.document;\\n\\n  var newTexts = document.getTexts().filter(function (n) {\\n    return !keys.includes(n.key);\\n  });\\n  if (newTexts.size === 0) return;\\n  var fragmentLength = fragment.text.length;\\n\\n  // Either startText is still here, or we want the first un-previously known text\\n  var startText = document.getNode(start.key) || newTexts.first();\\n  // We want the last un-previously known text\\n  var endText = newTexts.last() || startText;\\n\\n  if (startText === endText) {\\n    editor.moveTo(endText.key, fragmentLength);\\n    return;\\n  }\\n\\n  // Everything will be calculated relative to the first common ancestor to optimize speed\\n  var parent = document.getCommonAncestor(startText.key, endText.key);\\n\\n  var startOffset = parent.getOffset(startText.key) + (start.key === startText.key ? start.offset : 0);\\n\\n  // endText might not be the last un-previously known text node, so we precisely pick it by offset\\n  endText = parent.getTextAtOffset(startOffset + fragmentLength - 1) || endText;\\n\\n  editor.moveTo(endText.key, startOffset + fragmentLength - parent.getOffset(endText.key));\\n};\\n\\n/**\\n * Insert an `inline` at the current selection.\\n *\\n * @param {Editor} editor\\n * @param {String|Object|Inline} inline\\n */\\n\\nCommands$6.insertInline = function (editor, inline) {\\n  deleteExpanded(editor);\\n\\n  inline = Inline.create(inline);\\n  var value = editor.value;\\n  var selection = value.selection;\\n\\n  editor.insertInlineAtRange(selection, inline);\\n\\n  // If the node was successfully inserted, update the selection.\\n  var node = editor.value.document.getNode(inline.key);\\n  if (node) editor.moveToEndOfNode(node);\\n};\\n\\n/**\\n * Insert a string of `text` with optional `marks` at the current selection.\\n *\\n * @param {Editor} editor\\n * @param {String} text\\n * @param {Set<Mark>} marks (optional)\\n */\\n\\nCommands$6.insertText = function (editor, text, marks) {\\n  deleteExpanded(editor);\\n\\n  var value = editor.value;\\n  var document = value.document,\\n      selection = value.selection;\\n\\n  marks = marks || selection.marks || document.getInsertMarksAtRange(selection);\\n\\n  editor.withoutNormalizing(function () {\\n    editor.insertTextAtRange(selection, text, marks);\\n\\n    // If the text was successfully inserted, and the selection had marks on it,\\n    // unset the selection's marks.\\n    if (selection.marks && document !== editor.value.document) {\\n      editor.select({ marks: null });\\n    }\\n  });\\n};\\n\\n/**\\n * Remove a `mark` from the characters in the current selection.\\n *\\n * @param {Editor} editor\\n * @param {Mark} mark\\n */\\n\\nCommands$6.removeMark = function (editor, mark) {\\n  mark = Mark.create(mark);\\n  var value = editor.value;\\n  var document = value.document,\\n      selection = value.selection;\\n\\n\\n  if (selection.isExpanded) {\\n    editor.removeMarkAtRange(selection, mark);\\n  } else if (selection.marks) {\\n    var marks = selection.marks.remove(mark);\\n    var sel = selection.set('marks', marks);\\n    editor.select(sel);\\n  } else {\\n    var _marks2 = document.getActiveMarksAtRange(selection).remove(mark);\\n    var _sel2 = selection.set('marks', _marks2);\\n    editor.select(_sel2);\\n  }\\n};\\n\\n/**\\n * Replace an `oldMark` with a `newMark` in the characters in the current selection.\\n *\\n * @param {Editor} editor\\n * @param {Mark} oldMark\\n * @param {Mark} newMark\\n */\\n\\nCommands$6.replaceMark = function (editor, oldMark, newMark) {\\n  editor.removeMark(oldMark);\\n  editor.addMark(newMark);\\n};\\n\\n/**\\n * Set the `properties` of block nodes.\\n *\\n * @param {Editor} editor\\n * @param {Object|String} properties\\n */\\n\\nCommands$6.setBlocks = function (editor, properties) {\\n  var value = editor.value;\\n  var selection = value.selection;\\n\\n  editor.setBlocksAtRange(selection, properties);\\n};\\n\\n/**\\n * Set the `properties` of inline nodes.\\n *\\n * @param {Editor} editor\\n * @param {Object|String} properties\\n */\\n\\nCommands$6.setInlines = function (editor, properties) {\\n  var value = editor.value;\\n  var selection = value.selection;\\n\\n  editor.setInlinesAtRange(selection, properties);\\n};\\n\\n/**\\n * Split the block node at the current selection, to optional `depth`.\\n *\\n * @param {Editor} editor\\n * @param {Number} depth (optional)\\n */\\n\\nCommands$6.splitBlock = function (editor) {\\n  var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\\n\\n  deleteExpanded(editor);\\n\\n  var value = editor.value;\\n  var selection = value.selection,\\n      document = value.document;\\n\\n  var marks = selection.marks || document.getInsertMarksAtRange(selection);\\n  editor.splitBlockAtRange(selection, depth).moveToEnd();\\n\\n  if (marks && marks.size !== 0) {\\n    editor.select({ marks: marks });\\n  }\\n};\\n\\n/**\\n * Split the inline nodes to optional `height`.\\n *\\n * @param {Editor} editor\\n * @param {Number} height (optional)\\n */\\n\\nCommands$6.splitInline = function (editor, height) {\\n  deleteExpanded(editor);\\n  var value = editor.value;\\n  var selection = value.selection;\\n\\n  editor.splitInlineAtRange(selection, height);\\n};\\n\\n/**\\n * Add or remove a `mark` from the characters in the current selection,\\n * depending on whether it's already there.\\n *\\n * @param {Editor} editor\\n * @param {Mark} mark\\n */\\n\\nCommands$6.toggleMark = function (editor, mark) {\\n  mark = Mark.create(mark);\\n  var value = editor.value;\\n\\n  var exists = value.activeMarks.has(mark);\\n\\n  if (exists) {\\n    editor.removeMark(mark);\\n  } else {\\n    editor.addMark(mark);\\n  }\\n};\\n\\n/**\\n * Unwrap nodes from a block with `properties`.\\n *\\n * @param {Editor} editor\\n * @param {String|Object} properties\\n */\\n\\nCommands$6.unwrapBlock = function (editor, properties) {\\n  var value = editor.value;\\n  var selection = value.selection;\\n\\n  editor.unwrapBlockAtRange(selection, properties);\\n};\\n\\n/**\\n * Unwrap nodes from an inline with `properties`.\\n *\\n * @param {Editor} editor\\n * @param {String|Object} properties\\n */\\n\\nCommands$6.unwrapInline = function (editor, properties) {\\n  var value = editor.value;\\n  var selection = value.selection;\\n\\n  editor.unwrapInlineAtRange(selection, properties);\\n};\\n\\n/**\\n * Wrap nodes in a new `block`.\\n *\\n * @param {Editor} editor\\n * @param {Block|Object|String} block\\n */\\n\\nCommands$6.wrapBlock = function (editor, block) {\\n  var value = editor.value;\\n  var selection = value.selection;\\n\\n  editor.wrapBlockAtRange(selection, block);\\n};\\n\\n/**\\n * Wrap nodes in a new `inline`.\\n *\\n * @param {Editor} editor\\n * @param {Inline|Object|String} inline\\n */\\n\\nCommands$6.wrapInline = function (editor, inline) {\\n  var value = editor.value;\\n  var selection = value.selection;\\n\\n  editor.wrapInlineAtRange(selection, inline);\\n};\\n\\n/**\\n * Wrap the current selection with prefix/suffix.\\n *\\n * @param {Editor} editor\\n * @param {String} prefix\\n * @param {String} suffix\\n */\\n\\nCommands$6.wrapText = function (editor, prefix) {\\n  var suffix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : prefix;\\n  var value = editor.value;\\n  var selection = value.selection;\\n\\n  editor.wrapTextAtRange(selection, prefix, suffix);\\n\\n  // If the selection was collapsed, it will have moved the start offset too.\\n  if (selection.isCollapsed) {\\n    editor.moveStartBackward(prefix.length);\\n  }\\n\\n  // Adding the suffix will have pushed the end of the selection further on, so\\n  // we need to move it back to account for this.\\n  editor.moveEndBackward(suffix.length);\\n\\n  // There's a chance that the selection points moved \\\"through\\\" each other,\\n  // resulting in a now-incorrect selection direction.\\n  if (selection.isForward !== editor.value.selection.isForward) {\\n    editor.flip();\\n  }\\n};\\n\\n/**\\n * A plugin that defines the core Slate logic.\\n *\\n * @param {Object} options\\n * @return {Object}\\n */\\n\\nfunction CorePlugin() {\\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n  var _options$plugins = options.plugins,\\n      plugins = _options$plugins === undefined ? [] : _options$plugins;\\n\\n  /**\\n   * The core Slate commands.\\n   *\\n   * @type {Object}\\n   */\\n\\n  var commands = CommandsPlugin(_extends({}, Commands$1, Commands$2, Commands$3, Commands$4, Commands$5, Commands$6));\\n\\n  /**\\n   * The core Slate queries.\\n   *\\n   * @type {Object}\\n   */\\n\\n  var queries = QueriesPlugin({\\n    isAtomic: function isAtomic() {\\n      return false;\\n    },\\n    isVoid: function isVoid() {\\n      return false;\\n    }\\n  });\\n\\n  /**\\n   * The core Slate schema.\\n   *\\n   * @type {Object}\\n   */\\n\\n  var schema = SchemaPlugin({\\n    rules: [\\n    // Only allow block nodes in documents.\\n    {\\n      match: { object: 'document' },\\n      nodes: [{\\n        match: { object: 'block' }\\n      }]\\n    },\\n\\n    // Only allow block nodes or inline and text nodes in blocks.\\n    {\\n      match: {\\n        object: 'block',\\n        first: { object: 'block' }\\n      },\\n      nodes: [{\\n        match: { object: 'block' }\\n      }]\\n    }, {\\n      match: {\\n        object: 'block',\\n        first: [{ object: 'inline' }, { object: 'text' }]\\n      },\\n      nodes: [{\\n        match: [{ object: 'inline' }, { object: 'text' }]\\n      }]\\n    },\\n\\n    // Only allow inline and text nodes in inlines.\\n    {\\n      match: { object: 'inline' },\\n      nodes: [{ match: [{ object: 'inline' }, { object: 'text' }] }]\\n    },\\n\\n    // Ensure that block and inline nodes have at least one text child.\\n    {\\n      match: [{ object: 'block' }, { object: 'inline' }],\\n      nodes: [{ min: 1 }],\\n      normalize: function normalize(editor, error) {\\n        var code = error.code,\\n            node = error.node;\\n\\n\\n        if (code === 'child_min_invalid' && node.nodes.isEmpty()) {\\n          editor.insertNodeByKey(node.key, 0, Text.create());\\n        }\\n      }\\n    },\\n\\n    // Ensure that inline nodes are surrounded by text nodes.\\n    {\\n      match: { object: 'block' },\\n      first: [{ object: 'block' }, { object: 'text' }],\\n      last: [{ object: 'block' }, { object: 'text' }],\\n      normalize: function normalize(editor, error) {\\n        var code = error.code,\\n            node = error.node;\\n\\n        var text = Text.create();\\n        var i = void 0;\\n\\n        if (code === 'first_child_object_invalid') {\\n          i = 0;\\n        } else if (code === 'last_child_object_invalid') {\\n          i = node.nodes.size;\\n        } else {\\n          return;\\n        }\\n\\n        editor.insertNodeByKey(node.key, i, text);\\n      }\\n    }, {\\n      match: { object: 'inline' },\\n      first: [{ object: 'block' }, { object: 'text' }],\\n      last: [{ object: 'block' }, { object: 'text' }],\\n      previous: [{ object: 'block' }, { object: 'text' }],\\n      next: [{ object: 'block' }, { object: 'text' }],\\n      normalize: function normalize(editor, error) {\\n        var code = error.code,\\n            node = error.node,\\n            index = error.index;\\n\\n        var text = Text.create();\\n        var i = void 0;\\n\\n        if (code === 'first_child_object_invalid') {\\n          i = 0;\\n        } else if (code === 'last_child_object_invalid') {\\n          i = node.nodes.size;\\n        } else if (code === 'previous_sibling_object_invalid') {\\n          i = index;\\n        } else if (code === 'next_sibling_object_invalid') {\\n          i = index + 1;\\n        } else {\\n          return;\\n        }\\n\\n        editor.insertNodeByKey(node.key, i, text);\\n      }\\n    },\\n\\n    // Merge adjacent text nodes with the same marks.\\n    {\\n      match: { object: 'text' },\\n      next: function next(_next, match) {\\n        return _next.object !== 'text' || !match.marks.equals(_next.marks);\\n      },\\n      normalize: function normalize(editor, error) {\\n        var code = error.code,\\n            next = error.next;\\n\\n\\n        if (code === 'next_sibling_invalid') {\\n          editor.mergeNodeByKey(next.key);\\n        }\\n      }\\n    },\\n\\n    // Remove extra adjacent empty text nodes.\\n    {\\n      match: { object: 'text' },\\n      previous: function previous(prev) {\\n        return prev.object !== 'text' || prev.text !== '';\\n      },\\n      next: function next(_next2) {\\n        return _next2.object !== 'text' || _next2.text !== '';\\n      },\\n      normalize: function normalize(editor, error) {\\n        var code = error.code,\\n            next = error.next,\\n            previous = error.previous;\\n\\n\\n        if (code === 'next_sibling_invalid') {\\n          editor.removeNodeByKey(next.key);\\n        } else if (code === 'previous_sibling_invalid') {\\n          editor.removeNodeByKey(previous.key);\\n        }\\n      }\\n    }]\\n  });\\n\\n  /**\\n   * Return the plugins.\\n   *\\n   * @type {Array}\\n   */\\n\\n  return [schema].concat(toConsumableArray(plugins), [commands, queries]);\\n}\\n\\n/**\\n * Debug.\\n *\\n * @type {Function}\\n */\\n\\nvar debug$2 = Debug('slate:editor');\\n\\n/**\\n * Editor.\\n *\\n * @type {Editor}\\n */\\n\\nvar Editor = function () {\\n  /**\\n   * Create a new `Editor` with `attrs`.\\n   *\\n   * @param {Object} attrs\\n   * @param {Object} options\\n   */\\n\\n  function Editor() {\\n    var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n    classCallCheck(this, Editor);\\n    var _options$controller = options.controller,\\n        controller = _options$controller === undefined ? this : _options$controller,\\n        _options$construct = options.construct,\\n        construct = _options$construct === undefined ? true : _options$construct;\\n    var _attrs$onChange = attrs.onChange,\\n        onChange = _attrs$onChange === undefined ? function () {} : _attrs$onChange,\\n        _attrs$plugins = attrs.plugins,\\n        plugins = _attrs$plugins === undefined ? [] : _attrs$plugins,\\n        _attrs$readOnly = attrs.readOnly,\\n        readOnly = _attrs$readOnly === undefined ? false : _attrs$readOnly,\\n        _attrs$value = attrs.value,\\n        value = _attrs$value === undefined ? Value.create() : _attrs$value;\\n\\n\\n    this.controller = controller;\\n    this.middleware = {};\\n    this.onChange = onChange;\\n    this.operations = immutable.List();\\n    this.readOnly = null;\\n    this.value = null;\\n\\n    this.tmp = {\\n      dirty: [],\\n      flushing: false,\\n      merge: null,\\n      normalize: true,\\n      save: true\\n    };\\n\\n    var core = CorePlugin({ plugins: plugins });\\n    registerPlugin(this, core);\\n\\n    if (construct) {\\n      this.run('onConstruct');\\n      this.setReadOnly(readOnly);\\n      this.setValue(value, options);\\n    }\\n  }\\n\\n  /**\\n   * Apply an `operation` to the editor, updating its value.\\n   *\\n   * @param {Operation|Object} operation\\n   * @return {Editor}\\n   */\\n\\n  createClass(Editor, [{\\n    key: 'applyOperation',\\n    value: function applyOperation(operation) {\\n      var _this = this;\\n\\n      var operations = this.operations,\\n          controller = this.controller;\\n\\n      var value = this.value;\\n\\n      // Add in the current `value` in case the operation was serialized.\\n      if (isPlainObject(operation)) {\\n        operation = _extends({}, operation, { value: value });\\n      }\\n\\n      operation = Operation.create(operation);\\n\\n      // Save the operation into the history. Since `save` is a command, we need\\n      // to do it without normalizing, since it would have side effects.\\n      this.withoutNormalizing(function () {\\n        controller.save(operation);\\n        value = _this.value;\\n      });\\n\\n      // Apply the operation to the value.\\n      debug$2('apply', { operation: operation });\\n      this.value = operation.apply(value);\\n      this.operations = operations.push(operation);\\n\\n      // Get the paths of the affected nodes, and mark them as dirty.\\n      var newDirtyPaths = getDirtyPaths(operation);\\n\\n      var dirty = this.tmp.dirty.map(function (path) {\\n        path = PathUtils.create(path);\\n        var transformed = PathUtils.transform(path, operation);\\n        return transformed.toArray();\\n      });\\n\\n      var pathIndex = {};\\n      var dirtyPaths = Array.prototype.concat.apply(newDirtyPaths, dirty);\\n      this.tmp.dirty = [];\\n\\n      // PERF: De-dupe the paths so we don't do extra normalization.\\n      dirtyPaths.forEach(function (dirtyPath) {\\n        var key = dirtyPath.join(',');\\n\\n        if (!pathIndex[key]) {\\n          _this.tmp.dirty.push(dirtyPath);\\n        }\\n\\n        pathIndex[key] = true;\\n      });\\n\\n      // If we're not already, queue the flushing process on the next tick.\\n      if (!this.tmp.flushing) {\\n        this.tmp.flushing = true;\\n        Promise.resolve().then(function () {\\n          return _this.flush();\\n        });\\n      }\\n\\n      return controller;\\n    }\\n\\n    /**\\n     * Flush the editor's current change.\\n     *\\n     * @return {Editor}\\n     */\\n\\n  }, {\\n    key: 'flush',\\n    value: function flush() {\\n      this.run('onChange');\\n      var value = this.value,\\n          operations = this.operations,\\n          controller = this.controller;\\n\\n      var change = { value: value, operations: operations };\\n      this.operations = immutable.List();\\n      this.tmp.flushing = false;\\n      this.onChange(change);\\n      return controller;\\n    }\\n\\n    /**\\n     * Trigger a command by `type` with `...args`.\\n     *\\n     * @param {String|Function} type\\n     * @param {Any} ...args\\n     * @return {Editor}\\n     */\\n\\n  }, {\\n    key: 'command',\\n    value: function command(type) {\\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n        args[_key - 1] = arguments[_key];\\n      }\\n\\n      var controller = this.controller;\\n\\n\\n      if (typeof type === 'function') {\\n        type.apply(undefined, [controller].concat(args));\\n        normalizeDirtyPaths(this);\\n        return controller;\\n      }\\n\\n      debug$2('command', { type: type, args: args });\\n      var obj = { type: type, args: args };\\n      this.run('onCommand', obj);\\n      normalizeDirtyPaths(this);\\n      return controller;\\n    }\\n\\n    /**\\n     * Checks if a command by `type` has been registered.\\n     *\\n     * @param {String} type\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'hasCommand',\\n    value: function hasCommand(type) {\\n      var controller = this.controller;\\n\\n      var has = type in controller && controller[type].__command;\\n\\n      return has;\\n    }\\n\\n    /**\\n     * Checks if a query by `type` has been registered.\\n     *\\n     * @param {String} type\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'hasQuery',\\n    value: function hasQuery(type) {\\n      var controller = this.controller;\\n\\n      var has = type in controller && controller[type].__query;\\n\\n      return has;\\n    }\\n\\n    /**\\n     * Normalize all of the nodes in the document from scratch.\\n     *\\n     * @return {Editor}\\n     */\\n\\n  }, {\\n    key: 'normalize',\\n    value: function normalize() {\\n      var value = this.value,\\n          controller = this.controller;\\n      var document = value.document;\\n\\n      var table = document.getKeysToPathsTable();\\n      var paths = Object.values(table).map(PathUtils.create);\\n      this.tmp.dirty = this.tmp.dirty.concat(paths);\\n      normalizeDirtyPaths(this);\\n\\n      var selection = value.selection;\\n\\n      document = value.document;\\n\\n      if (selection.isUnset && document.nodes.size) {\\n        controller.moveToStartOfDocument();\\n      }\\n\\n      return controller;\\n    }\\n\\n    /**\\n     * Ask a query by `type` with `...args`.\\n     *\\n     * @param {String|Function} type\\n     * @param {Any} ...args\\n     * @return {Any}\\n     */\\n\\n  }, {\\n    key: 'query',\\n    value: function query(type) {\\n      for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\\n        args[_key2 - 1] = arguments[_key2];\\n      }\\n\\n      var controller = this.controller;\\n\\n\\n      if (typeof type === 'function') {\\n        return type.apply(undefined, [controller].concat(args));\\n      }\\n\\n      debug$2('query', { type: type, args: args });\\n      var obj = { type: type, args: args };\\n      return this.run('onQuery', obj);\\n    }\\n\\n    /**\\n     * Register a command `type` with the editor.\\n     *\\n     * @param {String} type\\n     * @return {Editor}\\n     */\\n\\n  }, {\\n    key: 'registerCommand',\\n    value: function registerCommand(type) {\\n      var _this2 = this;\\n\\n      var controller = this.controller;\\n\\n\\n      if (type in controller && controller[type].__command) {\\n        return controller;\\n      }\\n\\n      invariant(!(type in controller), 'You cannot register a `' + type + '` command because it would overwrite an existing property of the `Editor`.');\\n\\n      var method = function method() {\\n        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\\n          args[_key3] = arguments[_key3];\\n        }\\n\\n        return _this2.command.apply(_this2, [type].concat(args));\\n      };\\n      controller[type] = method;\\n      method.__command = true;\\n      return controller;\\n    }\\n\\n    /**\\n     * Register a query `type` with the editor.\\n     *\\n     * @param {String} type\\n     * @return {Editor}\\n     */\\n\\n  }, {\\n    key: 'registerQuery',\\n    value: function registerQuery(type) {\\n      var _this3 = this;\\n\\n      var controller = this.controller;\\n\\n\\n      if (type in controller && controller[type].__query) {\\n        return controller;\\n      }\\n\\n      invariant(!(type in controller), 'You cannot register a `' + type + '` query because it would overwrite an existing property of the `Editor`.');\\n\\n      var method = function method() {\\n        for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\\n          args[_key4] = arguments[_key4];\\n        }\\n\\n        return _this3.query.apply(_this3, [type].concat(args));\\n      };\\n      controller[type] = method;\\n      method.__query = true;\\n      return controller;\\n    }\\n\\n    /**\\n     * Run through the middleware stack by `key` with `args`.\\n     *\\n     * @param {String} key\\n     * @param {Any} ...args\\n     * @return {Any}\\n     */\\n\\n  }, {\\n    key: 'run',\\n    value: function run(key) {\\n      for (var _len5 = arguments.length, args = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {\\n        args[_key5 - 1] = arguments[_key5];\\n      }\\n\\n      var controller = this.controller,\\n          middleware = this.middleware;\\n\\n      var fns = middleware[key] || [];\\n      var i = 0;\\n\\n      function next() {\\n        var fn = fns[i++];\\n        if (!fn) return;\\n\\n        for (var _len6 = arguments.length, overrides = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\\n          overrides[_key6] = arguments[_key6];\\n        }\\n\\n        if (overrides.length) {\\n          args = overrides;\\n        }\\n\\n        var ret = fn.apply(undefined, toConsumableArray(args).concat([controller, next]));\\n        return ret;\\n      }\\n\\n      Object.defineProperty(next, 'change', {\\n        get: function get$$1() {\\n          invariant(false, 'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.');\\n        }\\n      });\\n\\n      Object.defineProperty(next, 'onChange', {\\n        get: function get$$1() {\\n          invariant(false, 'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.');\\n        }\\n      });\\n\\n      Object.defineProperty(next, 'props', {\\n        get: function get$$1() {\\n          invariant(false, 'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.');\\n        }\\n      });\\n\\n      Object.defineProperty(next, 'schema', {\\n        get: function get$$1() {\\n          invariant(false, 'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.');\\n        }\\n      });\\n\\n      Object.defineProperty(next, 'stack', {\\n        get: function get$$1() {\\n          invariant(false, 'As of Slate 0.42, the `editor` is no longer passed as the third argument to event handlers. You can access it via `change.editor` instead.');\\n        }\\n      });\\n\\n      return next();\\n    }\\n\\n    /**\\n     * Set the `readOnly` flag.\\n     *\\n     * @param {Boolean} readOnly\\n     * @return {Editor}\\n     */\\n\\n  }, {\\n    key: 'setReadOnly',\\n    value: function setReadOnly(readOnly) {\\n      this.readOnly = readOnly;\\n      return this;\\n    }\\n\\n    /**\\n     * Set the editor's `value`.\\n     *\\n     * @param {Value} value\\n     * @param {Options} options\\n     * @return {Editor}\\n     */\\n\\n  }, {\\n    key: 'setValue',\\n    value: function setValue(value) {\\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n      var _options$normalize = options.normalize,\\n          normalize = _options$normalize === undefined ? value !== this.value : _options$normalize;\\n\\n      this.value = value;\\n\\n      if (normalize) {\\n        this.normalize();\\n      }\\n\\n      return this;\\n    }\\n\\n    /**\\n     * Apply a series of changes inside a synchronous `fn`, deferring\\n     * normalization until after the function has finished executing.\\n     *\\n     * @param {Function} fn\\n     * @return {Editor}\\n     */\\n\\n  }, {\\n    key: 'withoutNormalizing',\\n    value: function withoutNormalizing(fn) {\\n      var controller = this.controller;\\n\\n      var value = this.tmp.normalize;\\n      this.tmp.normalize = false;\\n      fn(controller);\\n      this.tmp.normalize = value;\\n      normalizeDirtyPaths(this);\\n      return controller;\\n    }\\n\\n    /**\\n     * Deprecated.\\n     */\\n\\n  }, {\\n    key: 'change',\\n    value: function change(fn) {\\n      warning(false, 'As of Slate 0.43 the `change` object has been replaced with `editor`, so the `editor.change()` method is deprecated.`');\\n\\n      for (var _len7 = arguments.length, args = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {\\n        args[_key7 - 1] = arguments[_key7];\\n      }\\n\\n      fn.apply(undefined, [this.controller].concat(args));\\n    }\\n  }, {\\n    key: 'call',\\n    value: function call(fn) {\\n      warning(false, 'As of Slate 0.43 the `editor.call(fn)` method has been deprecated, please use `editor.command(fn)` instead.');\\n\\n      for (var _len8 = arguments.length, args = Array(_len8 > 1 ? _len8 - 1 : 0), _key8 = 1; _key8 < _len8; _key8++) {\\n        args[_key8 - 1] = arguments[_key8];\\n      }\\n\\n      fn.apply(undefined, [this.controller].concat(args));\\n      return this.controller;\\n    }\\n  }, {\\n    key: 'applyOperations',\\n    value: function applyOperations(operations) {\\n      var _this4 = this;\\n\\n      warning(false, 'As of Slate 0.43 the `applyOperations` method is deprecated, please apply each operation in a loop instead.');\\n\\n      operations.forEach(function (op) {\\n        return _this4.applyOperation(op);\\n      });\\n      return this.controller;\\n    }\\n  }, {\\n    key: 'setOperationFlag',\\n    value: function setOperationFlag(key, value) {\\n      warning(false, 'As of slate@0.41 the `change.setOperationFlag` method has been deprecated.');\\n\\n      this.tmp[key] = value;\\n      return this;\\n    }\\n  }, {\\n    key: 'getFlag',\\n    value: function getFlag(key) {\\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\\n\\n      warning(false, 'As of slate@0.41 the `change.getFlag` method has been deprecated.');\\n\\n      return options[key] !== undefined ? options[key] : this.tmp[key];\\n    }\\n  }, {\\n    key: 'unsetOperationFlag',\\n    value: function unsetOperationFlag(key) {\\n      warning(false, 'As of slate@0.41 the `change.unsetOperationFlag` method has been deprecated.');\\n\\n      delete this.tmp[key];\\n      return this;\\n    }\\n  }, {\\n    key: 'withoutNormalization',\\n    value: function withoutNormalization(fn) {\\n      warning(false, 'As of slate@0.41 the `change.withoutNormalization` helper has been renamed to `change.withoutNormalizing`.');\\n\\n      return this.withoutNormalizing(fn);\\n    }\\n  }, {\\n    key: 'editor',\\n    get: function get$$1() {\\n      warning(false, \\\"As of Slate 0.43 the `change` object has been replaced with `editor`, so you don't need to access `change.editor`.\\\");\\n\\n      return this.controller;\\n    }\\n  }]);\\n  return Editor;\\n}();\\n\\n/**\\n * Get the \\\"dirty\\\" paths for a given `operation`.\\n *\\n * @param {Operation} operation\\n * @return {Array}\\n */\\n\\nfunction getDirtyPaths(operation) {\\n  var type = operation.type,\\n      node = operation.node,\\n      path = operation.path,\\n      newPath = operation.newPath;\\n\\n\\n  switch (type) {\\n    case 'add_mark':\\n    case 'insert_text':\\n    case 'remove_mark':\\n    case 'remove_text':\\n    case 'set_mark':\\n    case 'set_node':\\n      {\\n        var ancestors = PathUtils.getAncestors(path).toArray();\\n        return [].concat(toConsumableArray(ancestors), [path]);\\n      }\\n\\n    case 'insert_node':\\n      {\\n        var table = node.getKeysToPathsTable();\\n        var paths = Object.values(table).map(function (p) {\\n          return path.concat(p);\\n        });\\n        var _ancestors = PathUtils.getAncestors(path).toArray();\\n        return [].concat(toConsumableArray(_ancestors), [path], toConsumableArray(paths));\\n      }\\n\\n    case 'split_node':\\n      {\\n        var _ancestors2 = PathUtils.getAncestors(path).toArray();\\n        var nextPath = PathUtils.increment(path);\\n        return [].concat(toConsumableArray(_ancestors2), [path, nextPath]);\\n      }\\n\\n    case 'merge_node':\\n      {\\n        var _ancestors3 = PathUtils.getAncestors(path).toArray();\\n        var previousPath = PathUtils.decrement(path);\\n        return [].concat(toConsumableArray(_ancestors3), [previousPath]);\\n      }\\n\\n    case 'move_node':\\n      {\\n        if (PathUtils.isEqual(path, newPath)) {\\n          return [];\\n        }\\n\\n        var oldAncestors = PathUtils.getAncestors(path).reduce(function (arr, p) {\\n          arr.push.apply(arr, toConsumableArray(PathUtils.transform(p, operation).toArray()));\\n          return arr;\\n        }, []);\\n\\n        var newAncestors = PathUtils.getAncestors(newPath).reduce(function (arr, p) {\\n          arr.push.apply(arr, toConsumableArray(PathUtils.transform(p, operation).toArray()));\\n          return arr;\\n        }, []);\\n\\n        return [].concat(toConsumableArray(oldAncestors), toConsumableArray(newAncestors));\\n      }\\n\\n    case 'remove_node':\\n      {\\n        var _ancestors4 = PathUtils.getAncestors(path).toArray();\\n        return [].concat(toConsumableArray(_ancestors4));\\n      }\\n\\n    default:\\n      {\\n        return [];\\n      }\\n  }\\n}\\n\\n/**\\n * Normalize any new \\\"dirty\\\" paths that have been added to the change.\\n *\\n * @param {Editor}\\n */\\n\\nfunction normalizeDirtyPaths(editor) {\\n  if (!editor.tmp.normalize) {\\n    return;\\n  }\\n\\n  if (!editor.tmp.dirty.length) {\\n    return;\\n  }\\n\\n  editor.withoutNormalizing(function () {\\n    while (editor.tmp.dirty.length) {\\n      var path = editor.tmp.dirty.pop();\\n      normalizeNodeByPath(editor, path);\\n    }\\n  });\\n}\\n\\n/**\\n * Normalize the node at a specific `path`.\\n *\\n * @param {Editor} editor\\n * @param {Array} path\\n */\\n\\nfunction normalizeNodeByPath(editor, path) {\\n  var controller = editor.controller;\\n  var value = editor.value;\\n  var _value = value,\\n      document = _value.document;\\n\\n  var node = document.assertNode(path);\\n  var iterations = 0;\\n  var max = 100 + (node.object === 'text' ? 1 : node.nodes.size);\\n\\n  while (node) {\\n    var fn = node.normalize(controller);\\n\\n    if (!fn) {\\n      break;\\n    }\\n\\n    // Run the normalize `fn` to fix the node.\\n    fn(controller);\\n\\n    // Attempt to re-find the node by path, or by key if it has changed\\n    // locations in the tree continue iterating.\\n    value = editor.value;\\n    document = value.document;\\n    var _node = node,\\n        key = _node.key;\\n\\n    var found = document.getDescendant(path);\\n\\n    if (found && found.key === key) {\\n      node = found;\\n    } else {\\n      found = document.getDescendant(key);\\n\\n      if (found) {\\n        node = found;\\n        path = document.getPath(key);\\n      } else {\\n        // If it no longer exists by key, it was removed, so we're done.\\n        break;\\n      }\\n    }\\n\\n    // Increment the iterations counter, and check to make sure that we haven't\\n    // exceeded the max. Without this check, it's easy for the `normalize`\\n    // function of a schema rule to be written incorrectly and for an infinite\\n    // invalid loop to occur.\\n    iterations++;\\n\\n    if (iterations > max) {\\n      throw new Error('A schema rule could not be normalized after sufficient iterations. This is usually due to a `rule.normalize` or `plugin.normalizeNode` function of a schema being incorrectly written, causing an infinite loop.');\\n    }\\n  }\\n}\\n\\n/**\\n * Register a `plugin` with the editor.\\n *\\n * @param {Editor} editor\\n * @param {Object|Array|Null} plugin\\n */\\n\\nfunction registerPlugin(editor, plugin) {\\n  if (Array.isArray(plugin)) {\\n    plugin.forEach(function (p) {\\n      return registerPlugin(editor, p);\\n    });\\n    return;\\n  }\\n\\n  if (plugin == null) {\\n    return;\\n  }\\n\\n  var commands = plugin.commands,\\n      queries = plugin.queries,\\n      schema = plugin.schema,\\n      rest = objectWithoutProperties(plugin, ['commands', 'queries', 'schema']);\\n\\n\\n  if (commands) {\\n    var commandsPlugin = CommandsPlugin(commands);\\n    registerPlugin(editor, commandsPlugin);\\n  }\\n\\n  if (queries) {\\n    var queriesPlugin = QueriesPlugin(queries);\\n    registerPlugin(editor, queriesPlugin);\\n  }\\n\\n  if (schema) {\\n    var schemaPlugin = SchemaPlugin(schema);\\n    registerPlugin(editor, schemaPlugin);\\n  }\\n\\n  for (var key in rest) {\\n    var fn = rest[key];\\n    var middleware = editor.middleware[key] = editor.middleware[key] || [];\\n    middleware.push(fn);\\n  }\\n}\\n\\n/**\\n * Default properties.\\n *\\n * @type {Object}\\n */\\n\\nvar DEFAULTS$13 = {\\n  marks: undefined,\\n  text: undefined\\n\\n  /**\\n   * Leaf.\\n   *\\n   * @type {Leaf}\\n   */\\n\\n};\\nvar Leaf$1 = function (_Record) {\\n  inherits(Leaf, _Record);\\n\\n  function Leaf() {\\n    classCallCheck(this, Leaf);\\n    return possibleConstructorReturn(this, (Leaf.__proto__ || Object.getPrototypeOf(Leaf)).apply(this, arguments));\\n  }\\n\\n  createClass(Leaf, [{\\n    key: 'updateMark',\\n\\n\\n    /**\\n     * Update a `mark` at leaf, replace with newMark\\n     *\\n     * @param {Mark} mark\\n     * @param {Mark} newMark\\n     * @returns {Leaf}\\n     */\\n\\n    value: function updateMark(mark, newMark) {\\n      var marks = this.marks;\\n\\n      if (newMark.equals(mark)) return this;\\n      if (!marks.has(mark)) return this;\\n      var newMarks = marks.withMutations(function (collection) {\\n        collection.remove(mark).add(newMark);\\n      });\\n      return this.set('marks', newMarks);\\n    }\\n\\n    /**\\n     * Add a `mark` to the leaf.\\n     *\\n     * @param {Mark} mark\\n     * @returns {Text}\\n     */\\n\\n  }, {\\n    key: 'addMark',\\n    value: function addMark(mark) {\\n      var marks = this.marks;\\n\\n      return this.set('marks', marks.add(mark));\\n    }\\n\\n    /**\\n     * Add a `set` of marks to the leaf.\\n     *\\n     * @param {Set<Mark>} set\\n     * @returns {Text}\\n     */\\n\\n  }, {\\n    key: 'addMarks',\\n    value: function addMarks(set$$1) {\\n      var marks = this.marks;\\n\\n      return this.set('marks', marks.union(set$$1));\\n    }\\n\\n    /**\\n     * Insert a text `string` into the leaf at `offset`.\\n     *\\n     * @param {Number} offset\\n     * @param {String} string\\n     * @return {Leaf}\\n     */\\n\\n  }, {\\n    key: 'insertText',\\n    value: function insertText(offset, string) {\\n      var text = this.text;\\n\\n      var next = text.slice(0, offset) + string + text.slice(offset);\\n      return this.set('text', next);\\n    }\\n\\n    /**\\n     * Remove a `mark` from the leaf.\\n     *\\n     * @param {Mark} mark\\n     * @returns {Text}\\n     */\\n\\n  }, {\\n    key: 'removeMark',\\n    value: function removeMark(mark) {\\n      var marks = this.marks;\\n\\n      return this.set('marks', marks.remove(mark));\\n    }\\n\\n    /**\\n     * Return a JSON representation of the leaf.\\n     *\\n     * @return {Object}\\n     */\\n\\n  }, {\\n    key: 'toJSON',\\n    value: function toJSON() {\\n      var object = {\\n        object: this.object,\\n        text: this.text,\\n        marks: this.marks.toArray().map(function (m) {\\n          return m.toJSON();\\n        })\\n      };\\n\\n      return object;\\n    }\\n  }], [{\\n    key: 'create',\\n\\n    /**\\n     * Create a new `Leaf` with `attrs`.\\n     *\\n     * @param {Object|Leaf} attrs\\n     * @return {Leaf}\\n     */\\n\\n    value: function create() {\\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      warning(false, 'As of slate@0.47 the `Leaf` model is deprecated.');\\n\\n      if (Leaf.isLeaf(attrs)) {\\n        return attrs;\\n      }\\n\\n      if (typeof attrs === 'string') {\\n        attrs = { text: attrs };\\n      }\\n\\n      if (isPlainObject(attrs)) {\\n        return Leaf.fromJSON(attrs);\\n      }\\n\\n      throw new Error('`Leaf.create` only accepts objects, strings or leaves, but you passed it: ' + attrs);\\n    }\\n\\n    /**\\n     * Create a valid List of `Leaf` from `leaves`\\n     *\\n     * @param {List<Leaf>} leaves\\n     * @return {List<Leaf>}\\n     */\\n\\n  }, {\\n    key: 'createLeaves',\\n    value: function createLeaves(leaves) {\\n      if (leaves.size <= 1) return leaves;\\n\\n      var invalid = false;\\n\\n      // TODO: we can make this faster with [List] and then flatten\\n      var result = immutable.List().withMutations(function (cache) {\\n        // Search from the leaves left end to find invalid node;\\n        leaves.findLast(function (leaf, index) {\\n          var firstLeaf = cache.first();\\n\\n          // If the first leaf of cache exist, check whether the first leaf is connectable with the current leaf\\n          if (firstLeaf) {\\n            // If marks equals, then the two leaves can be connected\\n            if (firstLeaf.marks.equals(leaf.marks)) {\\n              invalid = true;\\n              cache.set(0, firstLeaf.set('text', '' + leaf.text + firstLeaf.text));\\n              return;\\n            }\\n\\n            // If the cached leaf is empty, drop the empty leaf with the upcoming leaf\\n            if (firstLeaf.text === '') {\\n              invalid = true;\\n              cache.set(0, leaf);\\n              return;\\n            }\\n\\n            // If the current leaf is empty, drop the leaf\\n            if (leaf.text === '') {\\n              invalid = true;\\n              return;\\n            }\\n          }\\n\\n          cache.unshift(leaf);\\n        });\\n      });\\n\\n      if (!invalid) return leaves;\\n      return result;\\n    }\\n\\n    /**\\n     * Split a list of leaves to two lists; if the leaves are valid leaves, the returned leaves are also valid\\n     * Corner Cases:\\n     *   1. if offset is smaller than 0, then return [List(), leaves]\\n     *   2. if offset is bigger than the text length, then return [leaves, List()]\\n     *\\n     * @param {List<Leaf> leaves\\n     * @return {Array<List<Leaf>>}\\n     */\\n\\n  }, {\\n    key: 'splitLeaves',\\n    value: function splitLeaves(leaves, offset) {\\n      if (offset < 0) return [immutable.List(), leaves];\\n\\n      if (leaves.size === 0) {\\n        return [immutable.List(), immutable.List()];\\n      }\\n\\n      var endOffset = 0;\\n      var index = -1;\\n      var left = void 0,\\n          right = void 0;\\n\\n      leaves.find(function (leaf) {\\n        index++;\\n        var startOffset = endOffset;\\n        var text = leaf.text;\\n\\n        endOffset += text.length;\\n\\n        if (endOffset < offset) return false;\\n        if (startOffset > offset) return false;\\n\\n        var length = offset - startOffset;\\n        left = leaf.set('text', text.slice(0, length));\\n        right = leaf.set('text', text.slice(length));\\n        return true;\\n      });\\n\\n      if (!left) return [leaves, immutable.List()];\\n\\n      if (left.text === '') {\\n        if (index === 0) {\\n          return [immutable.List.of(left), leaves];\\n        }\\n\\n        return [leaves.take(index), leaves.skip(index)];\\n      }\\n\\n      if (right.text === '') {\\n        if (index === leaves.size - 1) {\\n          return [leaves, immutable.List.of(right)];\\n        }\\n\\n        return [leaves.take(index + 1), leaves.skip(index + 1)];\\n      }\\n\\n      return [leaves.take(index).push(left), leaves.skip(index + 1).unshift(right)];\\n    }\\n\\n    /**\\n     * Create a `Leaf` list from `attrs`.\\n     *\\n     * @param {Array<Leaf|Object>|List<Leaf|Object>} attrs\\n     * @return {List<Leaf>}\\n     */\\n\\n  }, {\\n    key: 'createList',\\n    value: function createList() {\\n      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\\n\\n      if (immutable.List.isList(attrs) || Array.isArray(attrs)) {\\n        var list = new immutable.List(attrs.map(Leaf.create));\\n        return list;\\n      }\\n\\n      throw new Error('`Leaf.createList` only accepts arrays or lists, but you passed it: ' + attrs);\\n    }\\n\\n    /**\\n     * Create a `Leaf` from a JSON `object`.\\n     *\\n     * @param {Object} object\\n     * @return {Leaf}\\n     */\\n\\n  }, {\\n    key: 'fromJSON',\\n    value: function fromJSON(object) {\\n      var _object$text = object.text,\\n          text = _object$text === undefined ? '' : _object$text,\\n          _object$marks = object.marks,\\n          marks = _object$marks === undefined ? [] : _object$marks;\\n\\n\\n      var leaf = new Leaf({\\n        text: text,\\n        marks: immutable.Set(marks.map(Mark.fromJSON))\\n      });\\n\\n      return leaf;\\n    }\\n\\n    /**\\n     * Check if `any` is a list of leaves.\\n     *\\n     * @param {Any} any\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isLeafList',\\n    value: function isLeafList(any) {\\n      return immutable.List.isList(any) && any.every(function (item) {\\n        return Leaf.isLeaf(item);\\n      });\\n    }\\n  }]);\\n  return Leaf;\\n}(immutable.Record(DEFAULTS$13));\\n\\n/**\\n * Mix in an `Interface` to a `Class`.\\n *\\n * @param {Class} Interface\\n * @param {Class} Class\\n */\\n\\nfunction mixin(Interface, Classes) {\\n  var _iteratorNormalCompletion = true;\\n  var _didIteratorError = false;\\n  var _iteratorError = undefined;\\n\\n  try {\\n    for (var _iterator = Classes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n      var Class = _step.value;\\n\\n      // Copy static properties from the interface.\\n      var _iteratorNormalCompletion2 = true;\\n      var _didIteratorError2 = false;\\n      var _iteratorError2 = undefined;\\n\\n      try {\\n        for (var _iterator2 = Object.getOwnPropertyNames(Interface)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n          var name = _step2.value;\\n\\n          if (Class.hasOwnProperty(name)) continue;\\n          var desc = Object.getOwnPropertyDescriptor(Interface, name);\\n          Object.defineProperty(Class, name, desc);\\n        }\\n\\n        // Copy instance properties from the interface.\\n      } catch (err) {\\n        _didIteratorError2 = true;\\n        _iteratorError2 = err;\\n      } finally {\\n        try {\\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n            _iterator2.return();\\n          }\\n        } finally {\\n          if (_didIteratorError2) {\\n            throw _iteratorError2;\\n          }\\n        }\\n      }\\n\\n      var _iteratorNormalCompletion3 = true;\\n      var _didIteratorError3 = false;\\n      var _iteratorError3 = undefined;\\n\\n      try {\\n        for (var _iterator3 = Object.getOwnPropertyNames(Interface.prototype)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\\n          var _name = _step3.value;\\n\\n          if (Class.prototype.hasOwnProperty(_name)) continue;\\n          var desc = Object.getOwnPropertyDescriptor(Interface.prototype, _name);\\n          Object.defineProperty(Class.prototype, _name, desc);\\n        }\\n      } catch (err) {\\n        _didIteratorError3 = true;\\n        _iteratorError3 = err;\\n      } finally {\\n        try {\\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\\n            _iterator3.return();\\n          }\\n        } finally {\\n          if (_didIteratorError3) {\\n            throw _iteratorError3;\\n          }\\n        }\\n      }\\n    }\\n  } catch (err) {\\n    _didIteratorError = true;\\n    _iteratorError = err;\\n  } finally {\\n    try {\\n      if (!_iteratorNormalCompletion && _iterator.return) {\\n        _iterator.return();\\n      }\\n    } finally {\\n      if (_didIteratorError) {\\n        throw _iteratorError;\\n      }\\n    }\\n  }\\n}\\n\\n/**\\n * A factory for the interface that all Slate objects implement.\\n *\\n * @type {Function}\\n */\\n\\nfunction create$2(type) {\\n  var TYPE = TYPES[type];\\n  var camel = '' + type.charAt(0).toUpperCase() + type.slice(1);\\n  var is = 'is' + camel;\\n\\n  var ObjectInterface = function () {\\n    function ObjectInterface() {\\n      classCallCheck(this, ObjectInterface);\\n    }\\n\\n    createClass(ObjectInterface, [{\\n      key: 'object',\\n\\n      /**\\n       * Return the type of the object.\\n       *\\n       * @return {String}\\n       */\\n\\n      get: function get$$1() {\\n        return type;\\n      }\\n    }]);\\n    return ObjectInterface;\\n  }();\\n\\n  ObjectInterface[is] = isObject.bind(null, type);\\n  ObjectInterface.prototype[TYPE] = true;\\n  return ObjectInterface;\\n}\\n\\n/**\\n * Mix in the object interfaces.\\n */\\n\\nObject.entries({\\n  Annotation: Annotation,\\n  Block: Block,\\n  Change: Change,\\n  Decoration: Decoration,\\n  Document: Document,\\n  Editor: Editor,\\n  Inline: Inline,\\n  Leaf: Leaf$1,\\n  Mark: Mark,\\n  Node: Node,\\n  Operation: Operation,\\n  Point: Point,\\n  Range: Range,\\n  Selection: Selection,\\n  Text: Text,\\n  Value: Value\\n}).forEach(function (_ref) {\\n  var _ref2 = slicedToArray(_ref, 2),\\n      camel = _ref2[0],\\n      obj = _ref2[1];\\n\\n  return mixin(create$2(camel.toLowerCase()), [obj]);\\n});\\n\\n/**\\n * The interface that all Slate models implement.\\n *\\n * @type {Class}\\n */\\n\\nvar ModelInterface = function () {\\n  function ModelInterface() {\\n    classCallCheck(this, ModelInterface);\\n  }\\n\\n  createClass(ModelInterface, [{\\n    key: 'toJS',\\n\\n\\n    /**\\n     * Alias `toJS`.\\n     */\\n\\n    value: function toJS() {\\n      return this.toJSON.apply(this, arguments);\\n    }\\n  }], [{\\n    key: 'fromJS',\\n\\n    /**\\n     * Alias `fromJS`.\\n     */\\n\\n    value: function fromJS() {\\n      return this.fromJSON.apply(this, arguments);\\n    }\\n  }]);\\n  return ModelInterface;\\n}();\\n\\n/**\\n * Mix in the common interface.\\n *\\n * @param {Record}\\n */\\n\\nmixin(ModelInterface, [Annotation, Block, Decoration, Document, Inline, Leaf$1, Mark, Node, Operation, Point, Range, Selection, Text, Value]);\\n\\n/* global WeakMap, Map, Symbol */\\n\\n/**\\n * GLOBAL: True if memoization should is enabled.\\n *\\n * @type {Boolean}\\n */\\n\\nvar ENABLED = true;\\n\\n/**\\n * The leaf node of a cache tree. Used to support variable argument length. A\\n * unique object, so that native Maps will key it by reference.\\n *\\n * @type {Symbol}\\n */\\n\\nvar LEAF = Symbol('LEAF');\\n\\n/**\\n * The node of a cache tree for a WeakMap to store cache visited by objects\\n *\\n * @type {Symbol}\\n */\\n\\nvar STORE_KEY = Symbol('STORE_KEY');\\n\\n/**\\n * Values to represent a memoized undefined and null value. Allows efficient value\\n * retrieval using Map.get only.\\n *\\n * @type {Symbol}\\n */\\n\\nvar UNDEFINED = Symbol('undefined');\\nvar NULL = Symbol('null');\\n\\n/**\\n * Default value for unset keys in native Maps\\n *\\n * @type {Undefined}\\n */\\n\\nvar UNSET = undefined;\\n\\n/**\\n * Global Store for all cached values\\n *\\n * @type {WeakMap}\\n */\\n\\nvar memoizeStore = new WeakMap();\\n\\n/**\\n * Memoize all of the `properties` on a `object`.\\n *\\n * @param {Object} object\\n * @param {Array} properties\\n * @return {Record}\\n */\\n\\nfunction memoize(object, properties) {\\n  var _loop = function _loop(property) {\\n    var original = object[property];\\n\\n    if (!original) {\\n      throw new Error('Object does not have a property named \\\"' + property + '\\\".');\\n    }\\n\\n    object[property] = function () {\\n      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\\n        args[_key] = arguments[_key];\\n      }\\n\\n      // If memoization is disabled, call into the original method.\\n      if (!ENABLED) return original.apply(this, args);\\n\\n      if (!memoizeStore.has(this)) {\\n        memoizeStore.set(this, {\\n          noArgs: {},\\n          hasArgs: {}\\n        });\\n      }\\n\\n      var _memoizeStore$get = memoizeStore.get(this),\\n          noArgs = _memoizeStore$get.noArgs,\\n          hasArgs = _memoizeStore$get.hasArgs;\\n\\n      var takesArguments = args.length !== 0;\\n\\n      var cachedValue = void 0;\\n      var keys = void 0;\\n\\n      if (takesArguments) {\\n        keys = [property].concat(args);\\n        cachedValue = getIn(hasArgs, keys);\\n      } else {\\n        cachedValue = noArgs[property];\\n      }\\n\\n      // If we've got a result already, return it.\\n      if (cachedValue !== UNSET) {\\n        return cachedValue === UNDEFINED ? undefined : cachedValue;\\n      }\\n\\n      // Otherwise calculate what it should be once and cache it.\\n      var value = original.apply(this, args);\\n      var v = value === undefined ? UNDEFINED : value;\\n\\n      if (takesArguments) {\\n        setIn(hasArgs, keys, v);\\n      } else {\\n        noArgs[property] = v;\\n      }\\n\\n      return value;\\n    };\\n  };\\n\\n  var _iteratorNormalCompletion = true;\\n  var _didIteratorError = false;\\n  var _iteratorError = undefined;\\n\\n  try {\\n    for (var _iterator = properties[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n      var property = _step.value;\\n\\n      _loop(property);\\n    }\\n  } catch (err) {\\n    _didIteratorError = true;\\n    _iteratorError = err;\\n  } finally {\\n    try {\\n      if (!_iteratorNormalCompletion && _iterator.return) {\\n        _iterator.return();\\n      }\\n    } finally {\\n      if (_didIteratorError) {\\n        throw _iteratorError;\\n      }\\n    }\\n  }\\n}\\n\\n/**\\n * Get a value at a key path in a tree of Map.\\n *\\n * If not set, returns UNSET.\\n * If the set value is undefined, returns UNDEFINED.\\n *\\n * @param {Map} map\\n * @param {Array} keys\\n * @return {Any|UNSET|UNDEFINED}\\n */\\n\\nfunction getIn(map, keys) {\\n  var _iteratorNormalCompletion2 = true;\\n  var _didIteratorError2 = false;\\n  var _iteratorError2 = undefined;\\n\\n  try {\\n    for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n      var key = _step2.value;\\n\\n      if (key === undefined) {\\n        key = UNDEFINED;\\n      } else if (key == null) {\\n        key = NULL;\\n      }\\n\\n      if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) === 'object') {\\n        map = map[STORE_KEY] && map[STORE_KEY].get(key);\\n      } else {\\n        map = map[key];\\n      }\\n\\n      if (map === UNSET) return UNSET;\\n    }\\n  } catch (err) {\\n    _didIteratorError2 = true;\\n    _iteratorError2 = err;\\n  } finally {\\n    try {\\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n        _iterator2.return();\\n      }\\n    } finally {\\n      if (_didIteratorError2) {\\n        throw _iteratorError2;\\n      }\\n    }\\n  }\\n\\n  return map[LEAF];\\n}\\n\\n/**\\n * Set a value at a key path in a tree of Map, creating Maps on the go.\\n *\\n * @param {Map} map\\n * @param {Array} keys\\n * @param {Any} value\\n * @return {Map}\\n */\\n\\nfunction setIn(map, keys, value) {\\n  var child = map;\\n\\n  var _iteratorNormalCompletion3 = true;\\n  var _didIteratorError3 = false;\\n  var _iteratorError3 = undefined;\\n\\n  try {\\n    for (var _iterator3 = keys[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\\n      var key = _step3.value;\\n\\n      if (key === undefined) {\\n        key = UNDEFINED;\\n      } else if (key == null) {\\n        key = NULL;\\n      }\\n\\n      if ((typeof key === 'undefined' ? 'undefined' : _typeof(key)) !== 'object') {\\n        if (!child[key]) {\\n          child[key] = {};\\n        }\\n\\n        child = child[key];\\n        continue;\\n      }\\n\\n      if (!child[STORE_KEY]) {\\n        child[STORE_KEY] = new WeakMap();\\n      }\\n\\n      if (!child[STORE_KEY].has(key)) {\\n        var newChild = {};\\n        child[STORE_KEY].set(key, newChild);\\n        child = newChild;\\n        continue;\\n      }\\n\\n      child = child[STORE_KEY].get(key);\\n    }\\n\\n    // The whole path has been created, so set the value to the bottom most map.\\n  } catch (err) {\\n    _didIteratorError3 = true;\\n    _iteratorError3 = err;\\n  } finally {\\n    try {\\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\\n        _iterator3.return();\\n      }\\n    } finally {\\n      if (_didIteratorError3) {\\n        throw _iteratorError3;\\n      }\\n    }\\n  }\\n\\n  child[LEAF] = value;\\n  return map;\\n}\\n\\n/**\\n * In DEV mode, clears the previously memoized values, globally.\\n *\\n * @return {Void}\\n */\\n\\nfunction resetMemoization() {\\n  memoizeStore = new WeakMap();\\n}\\n\\n/**\\n * In DEV mode, enable or disable the use of memoize values, globally.\\n *\\n * @param {Boolean} enabled\\n * @return {Void}\\n */\\n\\nfunction useMemoization(enabled) {\\n  ENABLED = enabled;\\n}\\n\\n/**\\n * The interface that `Document`, `Block` and `Inline` all implement, to make\\n * working with the recursive node tree easier.\\n *\\n * @type {Class}\\n */\\n\\nvar NodeInterface = function () {\\n  function NodeInterface() {\\n    classCallCheck(this, NodeInterface);\\n  }\\n\\n  createClass(NodeInterface, [{\\n    key: 'getFirstText',\\n\\n    /**\\n     * Get the first text node of a node, or the node itself.\\n     *\\n     * @return {Node|Null}\\n     */\\n\\n    value: function getFirstText() {\\n      if (this.object === 'text') {\\n        return this;\\n      }\\n\\n      var descendant = null;\\n\\n      var found = this.nodes.find(function (node) {\\n        if (node.object === 'text') return true;\\n        descendant = node.getFirstText();\\n        return !!descendant;\\n      });\\n\\n      return descendant || found;\\n    }\\n\\n    /**\\n     * Get an object mapping all the keys in the node to their paths.\\n     *\\n     * @return {Object}\\n     */\\n\\n  }, {\\n    key: 'getKeysToPathsTable',\\n    value: function getKeysToPathsTable() {\\n      var ret = defineProperty({}, this.key, []);\\n\\n      if (this.nodes) {\\n        this.nodes.forEach(function (node, i) {\\n          var nested = node.getKeysToPathsTable();\\n\\n          for (var key in nested) {\\n            var path = nested[key];\\n\\n            warning(!(key in ret), 'A node with a duplicate key of \\\"' + key + '\\\" was found! Duplicate keys are not allowed, you should use `node.regenerateKey` before inserting if you are reusing an existing node.');\\n\\n            ret[key] = [i].concat(toConsumableArray(path));\\n          }\\n        });\\n      }\\n\\n      return ret;\\n    }\\n\\n    /**\\n     * Get the last text node of a node, or the node itself.\\n     *\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getLastText',\\n    value: function getLastText() {\\n      if (this.object === 'text') {\\n        return this;\\n      }\\n\\n      var descendant = null;\\n\\n      var found = this.nodes.findLast(function (node) {\\n        if (node.object === 'text') return true;\\n        descendant = node.getLastText();\\n        return descendant;\\n      });\\n\\n      return descendant || found;\\n    }\\n\\n    /**\\n     * Get a node in the tree, or the node itself.\\n     *\\n     * @param {List|String} path\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getNode',\\n    value: function getNode(path) {\\n      path = this.resolvePath(path);\\n      if (!path) return null;\\n      if (this.object === 'text' && path.size) return null;\\n      var node = path.size ? this.getDescendant(path) : this;\\n      return node;\\n    }\\n\\n    /**\\n     * Find the path to a node.\\n     *\\n     * @param {String|List} key\\n     * @return {List}\\n     */\\n\\n  }, {\\n    key: 'getPath',\\n    value: function getPath(key) {\\n      // COMPAT: Handle passing in a path, to match other methods.\\n      if (immutable.List.isList(key)) {\\n        return key;\\n      }\\n\\n      // COMPAT: Handle a node object by iterating the descendants tree, so that\\n      // we avoid using keys for the future.\\n      if (Node.isNode(key) && this.descendants) {\\n        var _iteratorNormalCompletion = true;\\n        var _didIteratorError = false;\\n        var _iteratorError = undefined;\\n\\n        try {\\n          for (var _iterator = this.descendants()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n            var _ref = _step.value;\\n\\n            var _ref2 = slicedToArray(_ref, 2);\\n\\n            var node = _ref2[0];\\n            var _path = _ref2[1];\\n\\n            if (key === node) return _path;\\n          }\\n        } catch (err) {\\n          _didIteratorError = true;\\n          _iteratorError = err;\\n        } finally {\\n          try {\\n            if (!_iteratorNormalCompletion && _iterator.return) {\\n              _iterator.return();\\n            }\\n          } finally {\\n            if (_didIteratorError) {\\n              throw _iteratorError;\\n            }\\n          }\\n        }\\n      }\\n\\n      var dict = this.getKeysToPathsTable();\\n      var path = dict[key];\\n      return path ? immutable.List(path) : null;\\n    }\\n\\n    /**\\n     * Get the concatenated text string of a node.\\n     *\\n     * @return {String}\\n     */\\n\\n  }, {\\n    key: 'getText',\\n    value: function getText() {\\n      if (this.object === 'text') {\\n        return this.text;\\n      }\\n\\n      var text = this.nodes.reduce(function (memo, c) {\\n        return memo + c.text;\\n      }, '');\\n      return text;\\n    }\\n\\n    /**\\n     * Check if a node exists.\\n     *\\n     * @param {List|String} path\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'hasNode',\\n    value: function hasNode(path) {\\n      var node = this.getNode(path);\\n      return !!node;\\n    }\\n\\n    /**\\n     * Normalize the text node with an `editor`.\\n     *\\n     * @param {Editor} editor\\n     * @return {Function|Void}\\n     */\\n\\n  }, {\\n    key: 'normalize',\\n    value: function normalize(editor) {\\n      var normalizer = editor.run('normalizeNode', this);\\n      return normalizer;\\n    }\\n\\n    /**\\n     * Regenerate the node's key.\\n     *\\n     * @return {Node}\\n     */\\n\\n  }, {\\n    key: 'regenerateKey',\\n    value: function regenerateKey() {\\n      var key = KeyUtils.create();\\n      var node = this.set('key', key);\\n      return node;\\n    }\\n\\n    /**\\n     * Resolve a path from a path list or key string.\\n     *\\n     * An `index` can be provided, in which case paths created from a key string\\n     * will have the index pushed onto them. This is helpful in cases where you\\n     * want to accept either a `path` or a `key, index` combination for targeting\\n     * a location in the tree that doesn't exist yet, like when inserting.\\n     *\\n     * @param {List|String} value\\n     * @param {Number} index\\n     * @return {List}\\n     */\\n\\n  }, {\\n    key: 'resolvePath',\\n    value: function resolvePath(path, index) {\\n      if (typeof path === 'string') {\\n        path = this.getPath(path);\\n\\n        if (index != null) {\\n          path = path.concat(index);\\n        }\\n      } else {\\n        path = PathUtils.create(path);\\n      }\\n\\n      return path;\\n    }\\n\\n    /**\\n     * Validate the node with an `editor`.\\n     *\\n     * @param {Editor} editor\\n     * @return {Error|Void}\\n     */\\n\\n  }, {\\n    key: 'validate',\\n    value: function validate(editor) {\\n      var error = editor.run('validateNode', this);\\n      return error;\\n    }\\n  }]);\\n  return NodeInterface;\\n}();\\n\\n/**\\n * Memoize read methods.\\n */\\n\\nmemoize(NodeInterface.prototype, ['getFirstText', 'getKeysToPathsTable', 'getLastText', 'getText', 'normalize', 'validate']);\\n\\n/**\\n * Mix in the node interface.\\n */\\n\\nmixin(NodeInterface, [Block, Document, Inline, Text]);\\n\\nvar global$1 = typeof global !== \\\"undefined\\\" ? global :\\n            typeof self !== \\\"undefined\\\" ? self :\\n            typeof window !== \\\"undefined\\\" ? window : {}\\n\\nfunction identity() {\\n  return true;\\n}\\n\\n/**\\n * The interface that `Document`, `Block` and `Inline` all implement, to make\\n * working with the recursive node tree easier.\\n *\\n * @type {Class}\\n */\\n\\nvar ElementInterface = function () {\\n  function ElementInterface() {\\n    classCallCheck(this, ElementInterface);\\n  }\\n\\n  createClass(ElementInterface, [{\\n    key: 'addMark',\\n\\n\\n    /**\\n     * Add `mark` to text at `path`.\\n     *\\n     * @param {List|String} path\\n     * @param {Mark} mark\\n     * @return {Node}\\n     */\\n\\n    value: function addMark(path, mark) {\\n      path = this.resolvePath(path);\\n      var node = this.assertDescendant(path);\\n      node = node.addMark(mark);\\n      var ret = this.replaceNode(path, node);\\n      return ret;\\n    }\\n\\n    /**\\n     * Create an iteratable for all of the ancestors of the node.\\n     *\\n     * @return {Iterable}\\n     */\\n\\n  }, {\\n    key: 'ancestors',\\n    value: function ancestors(path) {\\n      var iterable = this.createIterable({\\n        path: path,\\n        direction: null,\\n        downward: false,\\n        includeTargetAncestors: true,\\n        includeRoot: true\\n      });\\n\\n      return iterable;\\n    }\\n\\n    /**\\n     * Create an iteratable for all of the blocks of a node with `options`.\\n     *\\n     * @param {Options}\\n     * @return {Iterable}\\n     */\\n\\n  }, {\\n    key: 'blocks',\\n    value: function blocks() {\\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var onlyLeaves = options.onlyLeaves,\\n          onlyRoots = options.onlyRoots,\\n          onlyTypes = options.onlyTypes,\\n          _match = options.match,\\n          rest = objectWithoutProperties(options, ['onlyLeaves', 'onlyRoots', 'onlyTypes', 'match']);\\n\\n      var iterable = this.descendants(_extends({\\n        includeDocument: false,\\n        includeInlines: false,\\n        includeTexts: false\\n      }, rest, {\\n        match: function match(node, path) {\\n          if (onlyTypes && !onlyTypes.includes(node.type)) {\\n            return false;\\n          } else if (onlyRoots && path.size !== 1) {\\n            return false;\\n          } else if (onlyLeaves && !node.isLeafBlock()) {\\n            return false;\\n          } else if (_match && !_match(node, path)) {\\n            return false;\\n          } else {\\n            return true;\\n          }\\n        }\\n      }));\\n\\n      return iterable;\\n    }\\n\\n    /**\\n     * Create an annotation with `properties` relative to the node.\\n     *\\n     * @param {Object|Annotation} properties\\n     * @return {Annotation}\\n     */\\n\\n  }, {\\n    key: 'createAnnotation',\\n    value: function createAnnotation(properties) {\\n      properties = Annotation.createProperties(properties);\\n      var annotation = this.resolveAnnotation(properties);\\n      return annotation;\\n    }\\n\\n    /**\\n     * Create a decoration with `properties` relative to the node.\\n     *\\n     * @param {Object|Decoration} properties\\n     * @return {Decoration}\\n     */\\n\\n  }, {\\n    key: 'createDecoration',\\n    value: function createDecoration(properties) {\\n      properties = Decoration.createProperties(properties);\\n      var decoration = this.resolveDecoration(properties);\\n      return decoration;\\n    }\\n\\n    /**\\n     * Create an iteratable function starting at `target` path with `options`.\\n     *\\n     * @param {Object} options (optional)\\n     * @return {Function}\\n     */\\n\\n  }, {\\n    key: 'createIterable',\\n    value: function createIterable() {\\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var _options$direction = options.direction,\\n          direction = _options$direction === undefined ? 'forward' : _options$direction,\\n          _options$downward = options.downward,\\n          downward = _options$downward === undefined ? true : _options$downward,\\n          _options$upward = options.upward,\\n          upward = _options$upward === undefined ? true : _options$upward,\\n          _options$includeBlock = options.includeBlocks,\\n          includeBlocks = _options$includeBlock === undefined ? true : _options$includeBlock,\\n          _options$includeDocum = options.includeDocument,\\n          includeDocument = _options$includeDocum === undefined ? true : _options$includeDocum,\\n          _options$includeInlin = options.includeInlines,\\n          includeInlines = _options$includeInlin === undefined ? true : _options$includeInlin,\\n          _options$includeRoot = options.includeRoot,\\n          includeRoot = _options$includeRoot === undefined ? false : _options$includeRoot,\\n          _options$includeTarge = options.includeTarget,\\n          includeTarget = _options$includeTarge === undefined ? !!options.range : _options$includeTarge,\\n          _options$includeTarge2 = options.includeTargetAncestors,\\n          includeTargetAncestors = _options$includeTarge2 === undefined ? false : _options$includeTarge2,\\n          _options$includeTexts = options.includeTexts,\\n          includeTexts = _options$includeTexts === undefined ? true : _options$includeTexts,\\n          _options$match = options.match,\\n          match = _options$match === undefined ? null : _options$match;\\n\\n\\n      var root = this;\\n      var targetPath = null;\\n      var targetRange = null;\\n\\n      // You can iterate over either a range or a path, but not both.\\n      if (options.range) {\\n        targetRange = root.resolveRange(options.range);\\n        targetPath = root.resolvePath(targetRange.start.path);\\n      } else if (options.path) {\\n        targetPath = root.resolvePath(options.path);\\n      }\\n\\n      var targetNode = targetPath && root.assertNode(targetPath);\\n      var NativeSet = typeof window === 'undefined' ? global$1.Set : window.Set;\\n\\n      // Return an object that implements the iterable interface.\\n      return defineProperty({}, Symbol.iterator, function () {\\n        var visited = new NativeSet();\\n        var startPath = targetRange && targetRange.start.path;\\n        var endPath = targetRange && targetRange.end.path;\\n        var path = targetPath;\\n        var node = targetNode;\\n        var includedTarget = false;\\n        var includedStart = false;\\n        var includingStart = false;\\n\\n        var result = function result() {\\n          // When these are nulled out we've finished iterating.\\n          if (!path || !node) {\\n            return { done: true };\\n          }\\n\\n          // We often don't want to include the root node itself.\\n          if (!includeRoot && node === root) {\\n            return next();\\n          }\\n\\n          if (!includeBlocks && node.object === 'block') {\\n            return next();\\n          }\\n\\n          if (!includeDocument && node.object === 'document') {\\n            return next();\\n          }\\n\\n          if (!includeInlines && node.object === 'inline') {\\n            return next();\\n          }\\n\\n          if (!includeTexts && node.object === 'text') {\\n            return next();\\n          }\\n\\n          if (match && !match(node, path)) {\\n            return next();\\n          }\\n\\n          return { value: [node, path], done: false };\\n        };\\n\\n        var next = function next() {\\n          if (!path || !node) {\\n            return result();\\n          }\\n\\n          // When iterating over a range, we need to include the specific\\n          // ancestors in the start path of the range manually.\\n          if (startPath && !includedStart) {\\n            if (!includingStart) {\\n              includingStart = true;\\n              path = PathUtils.create([]);\\n              node = root;\\n              return result();\\n            }\\n\\n            if (path.size === startPath.size - 1) {\\n              includedStart = true;\\n              path = targetPath;\\n              node = targetNode;\\n              return next();\\n            }\\n\\n            path = startPath.slice(0, path.size + 1);\\n            node = root.assertNode(path);\\n            return result();\\n          }\\n\\n          // Sometimes we want to include the target itself.\\n          if (includeTarget && !includedTarget) {\\n            includedTarget = true;\\n            return result();\\n          }\\n\\n          // When iterating over a range, if we get to the end path then exit.\\n          if (endPath && path.equals(endPath)) {\\n            node = null;\\n            path = null;\\n            return next();\\n          }\\n\\n          // If we're allowed to go downward, and we haven't decsended yet, do so.\\n          if (downward && node.nodes && node.nodes.size && !visited.has(node)) {\\n            visited.add(node);\\n            var nextIndex = direction === 'forward' ? 0 : node.nodes.size - 1;\\n            path = path.push(nextIndex);\\n            node = root.assertNode(path);\\n            return result();\\n          }\\n\\n          // If we're going forward...\\n          if (direction === 'forward') {\\n            var newPath = PathUtils.increment(path);\\n            var newNode = root.getNode(newPath);\\n\\n            if (newNode) {\\n              path = newPath;\\n              node = newNode;\\n              return result();\\n            }\\n          }\\n\\n          // If we're going backward...\\n          if (direction === 'backward' && path.last() !== 0) {\\n            var _newPath = PathUtils.decrement(path);\\n            var _newNode = root.getNode(_newPath);\\n\\n            if (_newNode) {\\n              path = _newPath;\\n              node = _newNode;\\n              return result();\\n            }\\n          }\\n\\n          // If we're going upward...\\n          if (upward && path.size) {\\n            path = PathUtils.lift(path);\\n            node = root.assertNode(path);\\n\\n            // Sometimes we'll have already visited the node on the way down\\n            // so we don't want to double count it.\\n            if (visited.has(node)) {\\n              return next();\\n            }\\n\\n            visited.add(node);\\n\\n            // If ancestors of the target node shouldn't be included, skip them.\\n            if (!includeTargetAncestors) {\\n              return next();\\n            } else {\\n              return result();\\n            }\\n          }\\n\\n          path = null;\\n          node = null;\\n          return next();\\n        };\\n\\n        return { next: next };\\n      });\\n    }\\n\\n    /**\\n     * Create a point with `properties` relative to the node.\\n     *\\n     * @param {Object|Point} properties\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'createPoint',\\n    value: function createPoint(properties) {\\n      properties = Point.createProperties(properties);\\n      var point = this.resolvePoint(properties);\\n      return point;\\n    }\\n\\n    /**\\n     * Create a range with `properties` relative to the node.\\n     *\\n     * @param {Object|Range} properties\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'createRange',\\n    value: function createRange(properties) {\\n      properties = Range.createProperties(properties);\\n      var range = this.resolveRange(properties);\\n      return range;\\n    }\\n\\n    /**\\n     * Create a selection with `properties` relative to the node.\\n     *\\n     * @param {Object|Selection} properties\\n     * @return {Selection}\\n     */\\n\\n  }, {\\n    key: 'createSelection',\\n    value: function createSelection(properties) {\\n      properties = Selection.createProperties(properties);\\n      var selection = this.resolveSelection(properties);\\n      return selection;\\n    }\\n\\n    /**\\n     * Create an iteratable for all of the descendants of the node.\\n     *\\n     * @param {Object} options\\n     * @return {Iterable}\\n     */\\n\\n  }, {\\n    key: 'descendants',\\n    value: function descendants(options) {\\n      var iterable = this.createIterable(_extends({ path: [] }, options));\\n      return iterable;\\n    }\\n\\n    /**\\n     * Find all of the descendants that match a `predicate`.\\n     *\\n     * @param {Function} predicate\\n     * @return {List<Node>}\\n     */\\n\\n  }, {\\n    key: 'filterDescendants',\\n    value: function filterDescendants() {\\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\\n\\n      var matches = [];\\n\\n      var _iteratorNormalCompletion = true;\\n      var _didIteratorError = false;\\n      var _iteratorError = undefined;\\n\\n      try {\\n        for (var _iterator = this.descendants()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n          var _ref2 = _step.value;\\n\\n          var _ref3 = slicedToArray(_ref2, 2);\\n\\n          var node = _ref3[0];\\n          var path = _ref3[1];\\n\\n          if (predicate(node, path)) {\\n            matches.push(node);\\n          }\\n        }\\n      } catch (err) {\\n        _didIteratorError = true;\\n        _iteratorError = err;\\n      } finally {\\n        try {\\n          if (!_iteratorNormalCompletion && _iterator.return) {\\n            _iterator.return();\\n          }\\n        } finally {\\n          if (_didIteratorError) {\\n            throw _iteratorError;\\n          }\\n        }\\n      }\\n\\n      return immutable.List(matches);\\n    }\\n\\n    /**\\n     * Find the first descendant that matches a `predicate`.\\n     *\\n     * @param {Function} predicate\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'findDescendant',\\n    value: function findDescendant() {\\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\\n      var _iteratorNormalCompletion2 = true;\\n      var _didIteratorError2 = false;\\n      var _iteratorError2 = undefined;\\n\\n      try {\\n        for (var _iterator2 = this.descendants()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n          var _ref4 = _step2.value;\\n\\n          var _ref5 = slicedToArray(_ref4, 2);\\n\\n          var node = _ref5[0];\\n          var path = _ref5[1];\\n\\n          if (predicate(node, path)) {\\n            return node;\\n          }\\n        }\\n      } catch (err) {\\n        _didIteratorError2 = true;\\n        _iteratorError2 = err;\\n      } finally {\\n        try {\\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n            _iterator2.return();\\n          }\\n        } finally {\\n          if (_didIteratorError2) {\\n            throw _iteratorError2;\\n          }\\n        }\\n      }\\n\\n      return null;\\n    }\\n\\n    /**\\n     * Iterate over all descendants, breaking if `predicate` returns false.\\n     *\\n     * @param {Function} predicate\\n     */\\n\\n  }, {\\n    key: 'forEachDescendant',\\n    value: function forEachDescendant() {\\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\\n      var _iteratorNormalCompletion3 = true;\\n      var _didIteratorError3 = false;\\n      var _iteratorError3 = undefined;\\n\\n      try {\\n        for (var _iterator3 = this.descendants()[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\\n          var _next = _step3.value;\\n\\n          var ret = predicate.apply(undefined, toConsumableArray(_next));\\n\\n          if (ret === false) {\\n            return;\\n          }\\n        }\\n      } catch (err) {\\n        _didIteratorError3 = true;\\n        _iteratorError3 = err;\\n      } finally {\\n        try {\\n          if (!_iteratorNormalCompletion3 && _iterator3.return) {\\n            _iterator3.return();\\n          }\\n        } finally {\\n          if (_didIteratorError3) {\\n            throw _iteratorError3;\\n          }\\n        }\\n      }\\n    }\\n\\n    /**\\n     * Get a set of the active marks in a `range`. Active marks are marks that are\\n     * on every text node in a given range. This is a common distinction for\\n     * highlighting toolbar buttons for example.\\n     *\\n     * TODO: this method needs to be cleaned up, it's very hard to follow and\\n     * probably doing unnecessary work.\\n     *\\n     * @param {Range} range\\n     * @return {Set<Mark>}\\n     */\\n\\n  }, {\\n    key: 'getActiveMarksAtRange',\\n    value: function getActiveMarksAtRange(range) {\\n      range = this.resolveRange(range);\\n\\n      if (range.isUnset) {\\n        return immutable.Set();\\n      }\\n\\n      if (range.isCollapsed) {\\n        var _range = range,\\n            _start = _range.start;\\n\\n        return this.getInsertMarksAtPoint(_start);\\n      }\\n\\n      var _range2 = range,\\n          start = _range2.start,\\n          end = _range2.end;\\n\\n      var startPath = start.path;\\n      var startOffset = start.offset;\\n      var endPath = end.path;\\n      var endOffset = end.offset;\\n      var startText = this.getDescendant(startPath);\\n      var endText = this.getDescendant(endPath);\\n\\n      if (!startPath.equals(endPath)) {\\n        while (!startPath.equals(endPath) && endOffset === 0) {\\n          \\n          var _texts = this.texts({\\n            path: endPath,\\n            direction: 'backward'\\n          });\\n\\n          var _texts2 = slicedToArray(_texts, 1);\\n\\n          var _texts2$ = slicedToArray(_texts2[0], 2);\\n\\n          endText = _texts2$[0];\\n          endPath = _texts2$[1];\\n\\n\\n          endOffset = endText.text.length;\\n        }\\n\\n        while (!startPath.equals(endPath) && startOffset === startText.text.length) {\\n          \\n          var _texts3 = this.texts({ path: startPath });\\n\\n          var _texts4 = slicedToArray(_texts3, 1);\\n\\n          var _texts4$ = slicedToArray(_texts4[0], 2);\\n\\n          startText = _texts4$[0];\\n          startPath = _texts4$[1];\\n\\n          startOffset = 0;\\n        }\\n      }\\n\\n      if (startPath.equals(endPath)) {\\n        return startText.marks;\\n      }\\n\\n      var startMarks = startText.marks;\\n\\n      // PERF: if start marks is empty we can return early.\\n      if (startMarks.size === 0) {\\n        return immutable.Set();\\n      }\\n\\n      var endMarks = endText.marks;\\n      var marks = startMarks.intersect(endMarks);\\n\\n      // If marks is already empty, the active marks is empty\\n      if (marks.size === 0) {\\n        return marks;\\n      }\\n\\n      \\n      var _texts5 = this.texts({ path: startPath });\\n\\n      var _texts6 = slicedToArray(_texts5, 1);\\n\\n      var _texts6$ = slicedToArray(_texts6[0], 2);\\n\\n      startText = _texts6$[0];\\n      startPath = _texts6$[1];\\n\\n\\n      while (!startPath.equals(endPath)) {\\n        if (startText.text.length !== 0) {\\n          marks = marks.intersect(startText.marks);\\n\\n          if (marks.size === 0) {\\n            return immutable.Set();\\n          }\\n        }\\n\\n        \\n        var _texts7 = this.texts({ path: startPath });\\n\\n        var _texts8 = slicedToArray(_texts7, 1);\\n\\n        var _texts8$ = slicedToArray(_texts8[0], 2);\\n\\n        startText = _texts8$[0];\\n        startPath = _texts8$[1];\\n      }\\n\\n      return marks;\\n    }\\n\\n    /**\\n     * Get a list of the ancestors of a descendant.\\n     *\\n     * @param {List|String} path\\n     * @return {List<Node>|Null}\\n     */\\n\\n  }, {\\n    key: 'getAncestors',\\n    value: function getAncestors(path) {\\n      var iterable = this.ancestors(path);\\n      var array = Array.from(iterable, function (_ref6) {\\n        var _ref7 = slicedToArray(_ref6, 1),\\n            node = _ref7[0];\\n\\n        return node;\\n      }).reverse();\\n      var list = immutable.List(array);\\n      return list;\\n    }\\n\\n    /**\\n     * Get the leaf block descendants of the node.\\n     *\\n     * @return {List<Node>}\\n     */\\n\\n  }, {\\n    key: 'getBlocks',\\n    value: function getBlocks() {\\n      var iterable = this.blocks({ onlyLeaves: true });\\n      var array = Array.from(iterable, function (_ref8) {\\n        var _ref9 = slicedToArray(_ref8, 1),\\n            node = _ref9[0];\\n\\n        return node;\\n      });\\n      var list = immutable.List(array);\\n      return list;\\n    }\\n\\n    /**\\n     * Get all of the leaf blocks that match a `type`.\\n     *\\n     * @param {String} type\\n     * @return {List<Node>}\\n     */\\n\\n  }, {\\n    key: 'getBlocksByType',\\n    value: function getBlocksByType(type) {\\n      var iterable = this.blocks({ onlyLeaves: true, onlyTypes: [type] });\\n      var array = Array.from(iterable, function (_ref10) {\\n        var _ref11 = slicedToArray(_ref10, 1),\\n            node = _ref11[0];\\n\\n        return node;\\n      });\\n      var list = immutable.List(array);\\n      return list;\\n    }\\n\\n    /**\\n     * Get a child node.\\n     *\\n     * @param {List|String} path\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getChild',\\n    value: function getChild(path) {\\n      path = this.resolvePath(path);\\n\\n      if (!path || path.size > 1) {\\n        return null;\\n      }\\n\\n      var child = this.nodes.get(path.first());\\n      return child;\\n    }\\n\\n    /**\\n     * Get closest parent of node that matches a `predicate`.\\n     *\\n     * @param {List|String} path\\n     * @param {Function} predicate\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getClosest',\\n    value: function getClosest(path, predicate) {\\n      var _iteratorNormalCompletion4 = true;\\n      var _didIteratorError4 = false;\\n      var _iteratorError4 = undefined;\\n\\n      try {\\n        for (var _iterator4 = this.ancestors(path)[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {\\n          var _ref12 = _step4.value;\\n\\n          var _ref13 = slicedToArray(_ref12, 2);\\n\\n          var n = _ref13[0];\\n          var p = _ref13[1];\\n\\n          if (predicate(n, p)) {\\n            return n;\\n          }\\n        }\\n      } catch (err) {\\n        _didIteratorError4 = true;\\n        _iteratorError4 = err;\\n      } finally {\\n        try {\\n          if (!_iteratorNormalCompletion4 && _iterator4.return) {\\n            _iterator4.return();\\n          }\\n        } finally {\\n          if (_didIteratorError4) {\\n            throw _iteratorError4;\\n          }\\n        }\\n      }\\n\\n      return null;\\n    }\\n\\n    /**\\n     * Get the closest block parent of a node.\\n     *\\n     * @param {List|String} path\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getClosestBlock',\\n    value: function getClosestBlock(path) {\\n      var closest = this.getClosest(path, function (n) {\\n        return n.object === 'block';\\n      });\\n      return closest;\\n    }\\n\\n    /**\\n     * Get the closest inline parent of a node by `path`.\\n     *\\n     * @param {List|String} path\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getClosestInline',\\n    value: function getClosestInline(path) {\\n      var closest = this.getClosest(path, function (n) {\\n        return n.object === 'inline';\\n      });\\n      return closest;\\n    }\\n\\n    /**\\n     * Get the closest void parent of a node by `path`.\\n     *\\n     * @param {List|String} path\\n     * @param {Editor} editor\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getClosestVoid',\\n    value: function getClosestVoid(path, editor) {\\n      invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `node.getClosestVoid` method takes an `editor` instead of a `value`.');\\n\\n      var closest = this.getClosest(path, function (n) {\\n        return editor.isVoid(n);\\n      });\\n      return closest;\\n    }\\n\\n    /**\\n     * Get the common ancestor of nodes `a` and `b`.\\n     *\\n     * @param {List} a\\n     * @param {List} b\\n     * @return {Node}\\n     */\\n\\n  }, {\\n    key: 'getCommonAncestor',\\n    value: function getCommonAncestor(a, b) {\\n      a = this.resolvePath(a);\\n      b = this.resolvePath(b);\\n\\n      if (!a || !b) {\\n        return null;\\n      }\\n\\n      var path = PathUtils.relate(a, b);\\n      var node = this.getNode(path);\\n      return node;\\n    }\\n\\n    /**\\n     * Get the decorations for the node from an `editor`.\\n     *\\n     * @param {Editor} editor\\n     * @return {List}\\n     */\\n\\n  }, {\\n    key: 'getDecorations',\\n    value: function getDecorations(editor) {\\n      var decorations = editor.run('decorateNode', this);\\n      decorations = Decoration.createList(decorations);\\n      return decorations;\\n    }\\n\\n    /**\\n     * Get the depth of a descendant, with optional `startAt`.\\n     *\\n     * @param {List|String} path\\n     * @param {Number} startAt\\n     * @return {Number|Null}\\n     */\\n\\n  }, {\\n    key: 'getDepth',\\n    value: function getDepth(path) {\\n      var startAt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\\n\\n      path = this.resolvePath(path);\\n\\n      if (!path) {\\n        return null;\\n      }\\n\\n      var node = this.getNode(path);\\n      var depth = node ? path.size - 1 + startAt : null;\\n      return depth;\\n    }\\n\\n    /**\\n     * Get a descendant node.\\n     *\\n     * @param {List|String} path\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getDescendant',\\n    value: function getDescendant(path) {\\n      path = this.resolvePath(path);\\n\\n      if (!path || !path.size) {\\n        return null;\\n      }\\n\\n      var node = this;\\n\\n      path.forEach(function (index) {\\n        node = node.getIn(['nodes', index]);\\n        return !!node;\\n      });\\n\\n      return node;\\n    }\\n\\n    /**\\n     * Get all of the descendant nodes in a `range`.\\n     *\\n     * @param {Range} range\\n     * @return {List<Node>}\\n     */\\n\\n  }, {\\n    key: 'getDescendantsAtRange',\\n    value: function getDescendantsAtRange(range) {\\n      var iterable = this.descendants({ range: range });\\n      var array = Array.from(iterable, function (_ref14) {\\n        var _ref15 = slicedToArray(_ref14, 1),\\n            node = _ref15[0];\\n\\n        return node;\\n      });\\n      var list = immutable.List(array);\\n      return list;\\n    }\\n\\n    /**\\n     * Get a fragment of the node at a `range`.\\n     *\\n     * @param {Range} range\\n     * @return {Document}\\n     */\\n\\n  }, {\\n    key: 'getFragmentAtRange',\\n    value: function getFragmentAtRange(range) {\\n      range = this.resolveRange(range);\\n\\n      if (range.isUnset) {\\n        return Document.create();\\n      }\\n\\n      var _range3 = range,\\n          start = _range3.start,\\n          end = _range3.end;\\n\\n      var node = this;\\n      var targetPath = end.path;\\n      var targetPosition = end.offset;\\n      var side = 'end';\\n\\n      while (targetPath.size) {\\n        var index = targetPath.last();\\n        node = node.splitNode(targetPath, targetPosition);\\n        targetPosition = index + 1;\\n        targetPath = PathUtils.lift(targetPath);\\n\\n        if (!targetPath.size && side === 'end') {\\n          targetPath = start.path;\\n          targetPosition = start.offset;\\n          side = 'start';\\n        }\\n      }\\n\\n      var startIndex = start.path.first() + 1;\\n      var endIndex = end.path.first() + 2;\\n      var nodes = node.nodes.slice(startIndex, endIndex);\\n      var fragment = Document.create({ nodes: nodes });\\n      return fragment;\\n    }\\n\\n    /**\\n     * Get the furthest ancestors of a node that matches a `predicate`.\\n     *\\n     * @param {Path} path\\n     * @param {Function} predicate\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getFurthest',\\n    value: function getFurthest(path) {\\n      var predicate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : identity;\\n\\n      var iterable = this.ancestors(path);\\n      var results = Array.from(iterable).reverse();\\n\\n      var _iteratorNormalCompletion5 = true;\\n      var _didIteratorError5 = false;\\n      var _iteratorError5 = undefined;\\n\\n      try {\\n        for (var _iterator5 = results[Symbol.iterator](), _step5; !(_iteratorNormalCompletion5 = (_step5 = _iterator5.next()).done); _iteratorNormalCompletion5 = true) {\\n          var _ref16 = _step5.value;\\n\\n          var _ref17 = slicedToArray(_ref16, 2);\\n\\n          var n = _ref17[0];\\n          var p = _ref17[1];\\n\\n          if (predicate(n, p)) {\\n            return n;\\n          }\\n        }\\n      } catch (err) {\\n        _didIteratorError5 = true;\\n        _iteratorError5 = err;\\n      } finally {\\n        try {\\n          if (!_iteratorNormalCompletion5 && _iterator5.return) {\\n            _iterator5.return();\\n          }\\n        } finally {\\n          if (_didIteratorError5) {\\n            throw _iteratorError5;\\n          }\\n        }\\n      }\\n\\n      return null;\\n    }\\n\\n    /**\\n     * Get the furthest block parent of a node.\\n     *\\n     * @param {Path} path\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getFurthestBlock',\\n    value: function getFurthestBlock(path) {\\n      var furthest = this.getFurthest(path, function (n) {\\n        return n.object === 'block';\\n      });\\n      return furthest;\\n    }\\n\\n    /**\\n     * Get the furthest child ancestor of a node at `path`.\\n     *\\n     * @param {List|String} path\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getFurthestChild',\\n    value: function getFurthestChild(path) {\\n      path = this.resolvePath(path);\\n\\n      if (!path || !path.size) {\\n        return null;\\n      }\\n\\n      var furthest = this.nodes.get(path.first());\\n      return furthest;\\n    }\\n\\n    /**\\n     * Get the furthest inline parent of a node.\\n     *\\n     * @param {Path} path\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getFurthestInline',\\n    value: function getFurthestInline(path) {\\n      var furthest = this.getFurthest(path, function (n) {\\n        return n.object === 'inline';\\n      });\\n      return furthest;\\n    }\\n\\n    /**\\n     * Get the closest inline nodes for each text node in the node.\\n     *\\n     * @return {List<Node>}\\n     */\\n\\n  }, {\\n    key: 'getInlines',\\n    value: function getInlines() {\\n      var iterable = this.inlines({ onlyLeaves: true });\\n      var array = Array.from(iterable, function (_ref18) {\\n        var _ref19 = slicedToArray(_ref18, 1),\\n            node = _ref19[0];\\n\\n        return node;\\n      });\\n      var list = immutable.List(array);\\n      return list;\\n    }\\n\\n    /**\\n     * Get all of the leaf inline nodes that match a `type`.\\n     *\\n     * @param {String} type\\n     * @return {List<Node>}\\n     */\\n\\n  }, {\\n    key: 'getInlinesByType',\\n    value: function getInlinesByType(type) {\\n      var iterable = this.inlines({ onlyLeaves: true, onlyTypes: [type] });\\n      var array = Array.from(iterable, function (_ref20) {\\n        var _ref21 = slicedToArray(_ref20, 1),\\n            node = _ref21[0];\\n\\n        return node;\\n      });\\n      var list = immutable.List(array);\\n      return list;\\n    }\\n\\n    /**\\n     * Get a set of marks that would occur on the next insert at a `point` in the\\n     * node. This mimics expected rich text editing behaviors of mark contiuation.\\n     *\\n     * @param {Point} point\\n     * @return {Set<Mark>}\\n     */\\n\\n  }, {\\n    key: 'getInsertMarksAtPoint',\\n    value: function getInsertMarksAtPoint(point) {\\n      point = this.resolvePoint(point);\\n      var _point = point,\\n          path = _point.path,\\n          offset = _point.offset;\\n\\n      var text = this.getDescendant(path);\\n\\n      // PERF: we can exit early if the offset isn't at the start of the node.\\n      if (offset !== 0) {\\n        return text.marks;\\n      }\\n\\n      var blockNode = void 0;\\n      var blockPath = void 0;\\n\\n      var _iteratorNormalCompletion6 = true;\\n      var _didIteratorError6 = false;\\n      var _iteratorError6 = undefined;\\n\\n      try {\\n        for (var _iterator6 = this.ancestors(path)[Symbol.iterator](), _step6; !(_iteratorNormalCompletion6 = (_step6 = _iterator6.next()).done); _iteratorNormalCompletion6 = true) {\\n          var entry = _step6.value;\\n\\n          var _entry = slicedToArray(entry, 2),\\n              n = _entry[0],\\n              p = _entry[1];\\n\\n          if (n.object === 'block') {\\n            blockNode = n;\\n            blockPath = p;\\n          }\\n        }\\n      } catch (err) {\\n        _didIteratorError6 = true;\\n        _iteratorError6 = err;\\n      } finally {\\n        try {\\n          if (!_iteratorNormalCompletion6 && _iterator6.return) {\\n            _iterator6.return();\\n          }\\n        } finally {\\n          if (_didIteratorError6) {\\n            throw _iteratorError6;\\n          }\\n        }\\n      }\\n\\n      var relativePath = PathUtils.drop(path, blockPath.size);\\n\\n      var _blockNode$texts = blockNode.texts({\\n        path: relativePath,\\n        direction: 'backward'\\n      }),\\n          _blockNode$texts2 = slicedToArray(_blockNode$texts, 1),\\n          previous = _blockNode$texts2[0];\\n\\n      // If there's no previous text, we're at the start of the block, so use\\n      // the current text nodes marks.\\n\\n\\n      if (!previous) {\\n        return text.marks;\\n      }\\n\\n      // Otherwise, continue with the previous text node's marks instead.\\n\\n      var _previous = slicedToArray(previous, 1),\\n          previousText = _previous[0];\\n\\n      return previousText.marks;\\n    }\\n\\n    /**\\n     * Get a set of marks that would occur on the next insert at a `range`.\\n     * This mimics expected rich text editing behaviors of mark contiuation.\\n     *\\n     * @param {Range} range\\n     * @return {Set<Mark>}\\n     */\\n\\n  }, {\\n    key: 'getInsertMarksAtRange',\\n    value: function getInsertMarksAtRange(range) {\\n      range = this.resolveRange(range);\\n      var _range4 = range,\\n          start = _range4.start;\\n\\n\\n      if (range.isUnset) {\\n        return immutable.Set();\\n      }\\n\\n      if (range.isCollapsed) {\\n        return this.getInsertMarksAtPoint(start);\\n      }\\n\\n      var text = this.getDescendant(start.path);\\n      return text.marks;\\n    }\\n\\n    /**\\n     * Get the bottom-most block descendants in a `range`.\\n     *\\n     * @param {Range} range\\n     * @return {List<Node>}\\n     */\\n\\n  }, {\\n    key: 'getLeafBlocksAtRange',\\n    value: function getLeafBlocksAtRange(range) {\\n      var iterable = this.blocks({ range: range, onlyLeaves: true });\\n      var array = Array.from(iterable, function (_ref22) {\\n        var _ref23 = slicedToArray(_ref22, 1),\\n            node = _ref23[0];\\n\\n        return node;\\n      });\\n      var list = immutable.List(array);\\n      return list;\\n    }\\n\\n    /**\\n     * Get the bottom-most inline nodes for each text node in a `range`.\\n     *\\n     * @param {Range} range\\n     * @return {List<Node>}\\n     */\\n\\n  }, {\\n    key: 'getLeafInlinesAtRange',\\n    value: function getLeafInlinesAtRange(range) {\\n      var iterable = this.inlines({ range: range, onlyLeaves: true });\\n      var array = Array.from(iterable, function (_ref24) {\\n        var _ref25 = slicedToArray(_ref24, 1),\\n            node = _ref25[0];\\n\\n        return node;\\n      });\\n      var list = immutable.List(array);\\n      return list;\\n    }\\n\\n    /**\\n     * Get an object mapping all the keys in the node to their paths.\\n     *\\n     * @return {Map}\\n     */\\n\\n  }, {\\n    key: 'getNodesToPathsMap',\\n    value: function getNodesToPathsMap() {\\n      var root = this;\\n      var map = typeof window === 'undefined' ? new global$1.Map() : new window.Map();\\n\\n      map.set(root, PathUtils.create([]));\\n\\n      root.forEachDescendant(function (node, path) {\\n        map.set(node, path);\\n      });\\n\\n      return map;\\n    }\\n\\n    /**\\n     * Get all of the marks for all of the characters of every text node.\\n     *\\n     * @return {OrderedSet<Mark>}\\n     */\\n\\n  }, {\\n    key: 'getMarks',\\n    value: function getMarks() {\\n      var iterable = this.marks();\\n      var array = Array.from(iterable, function (_ref26) {\\n        var _ref27 = slicedToArray(_ref26, 1),\\n            mark = _ref27[0];\\n\\n        return mark;\\n      });\\n      return immutable.OrderedSet(array);\\n    }\\n\\n    /**\\n     * Get a set of the marks in a `range`.\\n     *\\n     * @param {Range} range\\n     * @return {OrderedSet<Mark>}\\n     */\\n\\n  }, {\\n    key: 'getMarksAtRange',\\n    value: function getMarksAtRange(range) {\\n      var iterable = this.marks({ range: range });\\n      var array = Array.from(iterable, function (_ref28) {\\n        var _ref29 = slicedToArray(_ref28, 1),\\n            mark = _ref29[0];\\n\\n        return mark;\\n      });\\n      return immutable.OrderedSet(array);\\n    }\\n\\n    /**\\n     * Get all of the marks that match a `type`.\\n     *\\n     * @param {String} type\\n     * @return {OrderedSet<Mark>}\\n     */\\n\\n  }, {\\n    key: 'getMarksByType',\\n    value: function getMarksByType(type) {\\n      var iterable = this.marks({ onlyTypes: [type] });\\n      var array = Array.from(iterable, function (_ref30) {\\n        var _ref31 = slicedToArray(_ref30, 1),\\n            mark = _ref31[0];\\n\\n        return mark;\\n      });\\n      return immutable.OrderedSet(array);\\n    }\\n\\n    /**\\n     * Get the block node after a descendant text node by `path`.\\n     *\\n     * @param {List|String} path\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getNextBlock',\\n    value: function getNextBlock(path) {\\n      var _blocks = this.blocks({ path: path, onlyLeaves: true }),\\n          _blocks2 = slicedToArray(_blocks, 1),\\n          entry = _blocks2[0];\\n\\n      var block = entry ? entry[0] : null;\\n      return block;\\n    }\\n\\n    /**\\n     * Get the next node in the tree, returning siblings or ancestor siblings.\\n     *\\n     * @param {List|String} path\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getNextNode',\\n    value: function getNextNode(path) {\\n      var iterable = this.createIterable({ path: path, downward: false });\\n\\n      var _iterable = slicedToArray(iterable, 1),\\n          entry = _iterable[0];\\n\\n      var node = entry ? entry[0] : null;\\n      return node;\\n    }\\n\\n    /**\\n     * Get the next sibling of a node.\\n     *\\n     * @param {List|String} path\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getNextSibling',\\n    value: function getNextSibling(path) {\\n      var _siblings = this.siblings(path),\\n          _siblings2 = slicedToArray(_siblings, 1),\\n          entry = _siblings2[0];\\n\\n      var node = entry ? entry[0] : null;\\n      return node;\\n    }\\n\\n    /**\\n     * Get the text node after a descendant text node.\\n     *\\n     * @param {List|String} path\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getNextText',\\n    value: function getNextText(path) {\\n      var _texts9 = this.texts({ path: path }),\\n          _texts10 = slicedToArray(_texts9, 1),\\n          entry = _texts10[0];\\n\\n      var node = entry ? entry[0] : null;\\n      return node;\\n    }\\n\\n    /**\\n     * Get the offset for a descendant text node by `path` or `key`.\\n     *\\n     * @param {List|string} path\\n     * @return {Number}\\n     */\\n\\n  }, {\\n    key: 'getOffset',\\n    value: function getOffset(path) {\\n      path = this.resolvePath(path);\\n      this.assertDescendant(path);\\n\\n      // Calculate the offset of the nodes before the highest child.\\n      var index = path.first();\\n\\n      var offset = this.nodes.slice(0, index).reduce(function (memo, n) {\\n        return memo + n.text.length;\\n      }, 0);\\n\\n      // Recurse if need be.\\n      var ret = path.size === 1 ? offset : offset + this.nodes.get(index).getOffset(PathUtils.drop(path));\\n\\n      return ret;\\n    }\\n\\n    /**\\n     * Get the offset from a `range`.\\n     *\\n     * @param {Range} range\\n     * @return {Number}\\n     */\\n\\n  }, {\\n    key: 'getOffsetAtRange',\\n    value: function getOffsetAtRange(range) {\\n      range = this.resolveRange(range);\\n\\n      if (range.isUnset) {\\n        throw new Error('The range cannot be unset to calculcate its offset.');\\n      }\\n\\n      if (range.isExpanded) {\\n        throw new Error('The range must be collapsed to calculcate its offset.');\\n      }\\n\\n      var _range5 = range,\\n          start = _range5.start;\\n\\n      var offset = this.getOffset(start.path) + start.offset;\\n      return offset;\\n    }\\n\\n    /**\\n     * Get the parent of a descendant node.\\n     *\\n     * @param {List|String} path\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getParent',\\n    value: function getParent(path) {\\n      path = this.resolvePath(path);\\n      if (!path) return null;\\n      if (!path.size) return null;\\n      var parentPath = PathUtils.lift(path);\\n      var parent = this.getNode(parentPath);\\n      return parent;\\n    }\\n\\n    /**\\n     * Get the block node before a descendant text node by `path`.\\n     *\\n     * @param {List|String} path\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getPreviousBlock',\\n    value: function getPreviousBlock(path) {\\n      var _blocks3 = this.blocks({\\n        path: path,\\n        onlyLeaves: true,\\n        direction: 'backward'\\n      }),\\n          _blocks4 = slicedToArray(_blocks3, 1),\\n          entry = _blocks4[0];\\n\\n      var block = entry ? entry[0] : null;\\n      return block;\\n    }\\n\\n    /**\\n     * Get the previous node from a node in the tree.\\n     *\\n     * This will not only check for siblings but instead move up the tree\\n     * returning the previous ancestor if no sibling is found.\\n     *\\n     * @param {List|String} path\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getPreviousNode',\\n    value: function getPreviousNode(path) {\\n      var iterable = this.createIterable({\\n        path: path,\\n        downward: false,\\n        direction: 'backward'\\n      });\\n\\n      var _iterable2 = slicedToArray(iterable, 1),\\n          entry = _iterable2[0];\\n\\n      var node = entry ? entry[0] : null;\\n      return node;\\n    }\\n\\n    /**\\n     * Get the previous sibling of a node.\\n     *\\n     * @param {List|String} path\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getPreviousSibling',\\n    value: function getPreviousSibling(path) {\\n      var _siblings3 = this.siblings(path, { direction: 'backward' }),\\n          _siblings4 = slicedToArray(_siblings3, 1),\\n          entry = _siblings4[0];\\n\\n      var node = entry ? entry[0] : null;\\n      return node;\\n    }\\n\\n    /**\\n     * Get the text node before a descendant text node.\\n     *\\n     * @param {List|String} path\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getPreviousText',\\n    value: function getPreviousText(path) {\\n      var _texts11 = this.texts({ path: path, direction: 'backward' }),\\n          _texts12 = slicedToArray(_texts11, 1),\\n          entry = _texts12[0];\\n\\n      var node = entry ? entry[0] : null;\\n      return node;\\n    }\\n\\n    /**\\n     * Get only the root block nodes in a `range`.\\n     *\\n     * @param {Range} range\\n     * @return {List}\\n     */\\n\\n  }, {\\n    key: 'getRootBlocksAtRange',\\n    value: function getRootBlocksAtRange(range) {\\n      var iterable = this.blocks({ range: range, onlyRoots: true });\\n      var array = Array.from(iterable, function (_ref32) {\\n        var _ref33 = slicedToArray(_ref32, 1),\\n            node = _ref33[0];\\n\\n        return node;\\n      });\\n      var list = immutable.List(array);\\n      return list;\\n    }\\n\\n    /**\\n     * Get only the root inline nodes in a `range`.\\n     *\\n     * @param {Range} range\\n     * @return {List}\\n     */\\n\\n  }, {\\n    key: 'getRootInlinesAtRange',\\n    value: function getRootInlinesAtRange(range) {\\n      var iterable = this.inlines({ range: range, onlyRoots: true });\\n      var array = Array.from(iterable, function (_ref34) {\\n        var _ref35 = slicedToArray(_ref34, 1),\\n            node = _ref35[0];\\n\\n        return node;\\n      });\\n      var list = immutable.List(array);\\n      return list;\\n    }\\n\\n    /**\\n     * Get the descendent text node at an `offset`.\\n     *\\n     * @param {String} offset\\n     * @return {Node|Null}\\n     */\\n\\n  }, {\\n    key: 'getTextAtOffset',\\n    value: function getTextAtOffset(offset) {\\n      // PERF: Add a few shortcuts for the obvious cases.\\n      if (offset === 0) return this.getFirstText();\\n      if (offset === this.text.length) return this.getLastText();\\n      if (offset < 0 || offset > this.text.length) return null;\\n\\n      var length = 0;\\n\\n      var _iteratorNormalCompletion7 = true;\\n      var _didIteratorError7 = false;\\n      var _iteratorError7 = undefined;\\n\\n      try {\\n        for (var _iterator7 = this.texts()[Symbol.iterator](), _step7; !(_iteratorNormalCompletion7 = (_step7 = _iterator7.next()).done); _iteratorNormalCompletion7 = true) {\\n          var _ref36 = _step7.value;\\n\\n          var _ref37 = slicedToArray(_ref36, 1);\\n\\n          var node = _ref37[0];\\n\\n          length += node.text.length;\\n\\n          if (length > offset) {\\n            return node;\\n          }\\n        }\\n      } catch (err) {\\n        _didIteratorError7 = true;\\n        _iteratorError7 = err;\\n      } finally {\\n        try {\\n          if (!_iteratorNormalCompletion7 && _iterator7.return) {\\n            _iterator7.return();\\n          }\\n        } finally {\\n          if (_didIteratorError7) {\\n            throw _iteratorError7;\\n          }\\n        }\\n      }\\n\\n      return null;\\n    }\\n\\n    /**\\n     * Get the direction of the node's text.\\n     *\\n     * @return {String}\\n     */\\n\\n  }, {\\n    key: 'getTextDirection',\\n    value: function getTextDirection() {\\n      var dir = getDirection(this.text);\\n      return dir === 'neutral' ? null : dir;\\n    }\\n\\n    /**\\n     * Recursively get all of the child text nodes in order of appearance.\\n     *\\n     * @return {List<Node>}\\n     */\\n\\n  }, {\\n    key: 'getTexts',\\n    value: function getTexts() {\\n      var iterable = this.texts();\\n      var array = Array.from(iterable, function (_ref38) {\\n        var _ref39 = slicedToArray(_ref38, 1),\\n            node = _ref39[0];\\n\\n        return node;\\n      });\\n      var list = immutable.List(array);\\n      return list;\\n    }\\n\\n    /**\\n     * Get all of the text nodes in a `range` as a List.\\n     *\\n     * @param {Range} range\\n     * @return {List<Node>}\\n     */\\n\\n  }, {\\n    key: 'getTextsAtRange',\\n    value: function getTextsAtRange(range) {\\n      var iterable = this.texts({ range: range });\\n      var array = Array.from(iterable, function (_ref40) {\\n        var _ref41 = slicedToArray(_ref40, 1),\\n            node = _ref41[0];\\n\\n        return node;\\n      });\\n      var list = immutable.List(array);\\n      return list;\\n    }\\n\\n    /**\\n     * Check if the node has block children.\\n     *\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'hasBlockChildren',\\n    value: function hasBlockChildren() {\\n      return !!(this.nodes && this.nodes.find(function (n) {\\n        return n.object === 'block';\\n      }));\\n    }\\n\\n    /**\\n     * Check if a child node exists.\\n     *\\n     * @param {List|String} path\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'hasChild',\\n    value: function hasChild(path) {\\n      var child = this.getChild(path);\\n      return !!child;\\n    }\\n\\n    /**\\n     * Check if a node has inline children.\\n     *\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'hasInlineChildren',\\n    value: function hasInlineChildren() {\\n      return !!(this.nodes && this.nodes.find(function (n) {\\n        return n.object === 'inline' || n.object === 'text';\\n      }));\\n    }\\n\\n    /**\\n     * Recursively check if a child node exists.\\n     *\\n     * @param {List|String} path\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'hasDescendant',\\n    value: function hasDescendant(path) {\\n      var descendant = this.getDescendant(path);\\n      return !!descendant;\\n    }\\n\\n    /**\\n     * Check if a node has a void parent.\\n     *\\n     * @param {List|String} path\\n     * @param {Editor} editor\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'hasVoidParent',\\n    value: function hasVoidParent(path, editor) {\\n      invariant(!Value.isValue(editor), 'As of Slate 0.42.0, the `node.hasVoidParent` method takes an `editor` instead of a `value`.');\\n\\n      var closest = this.getClosestVoid(path, editor);\\n      return !!closest;\\n    }\\n\\n    /**\\n     * Create an iteratable for all of the inlines of a node with `options`.\\n     *\\n     * @param {Options}\\n     * @return {Iterable}\\n     */\\n\\n  }, {\\n    key: 'inlines',\\n    value: function inlines() {\\n      var _this = this;\\n\\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var onlyLeaves = options.onlyLeaves,\\n          onlyRoots = options.onlyRoots,\\n          onlyTypes = options.onlyTypes,\\n          _match2 = options.match,\\n          rest = objectWithoutProperties(options, ['onlyLeaves', 'onlyRoots', 'onlyTypes', 'match']);\\n\\n      var iterable = this.descendants(_extends({\\n        includeBlocks: false,\\n        includeTexts: false,\\n        includeDocument: false\\n      }, rest, {\\n        match: function match(node, path) {\\n          if (onlyTypes && !onlyTypes.includes(node.type)) {\\n            return false;\\n          } else if (onlyLeaves && !node.isLeafInline()) {\\n            return false;\\n          } else if (onlyRoots && _this.getParent(path).object !== 'block') {\\n            return false;\\n          } else if (_match2 && !_match2(node, path)) {\\n            return false;\\n          } else {\\n            return true;\\n          }\\n        }\\n      }));\\n\\n      return iterable;\\n    }\\n\\n    /**\\n     * Insert a `node`.\\n     *\\n     * @param {List|String} path\\n     * @param {Node} node\\n     * @return {Node}\\n     */\\n\\n  }, {\\n    key: 'insertNode',\\n    value: function insertNode(path, node) {\\n      path = this.resolvePath(path);\\n      var index = path.last();\\n      var parentPath = PathUtils.lift(path);\\n      var parent = this.assertNode(parentPath);\\n      var nodes = parent.nodes.splice(index, 0, node);\\n      parent = parent.set('nodes', nodes);\\n      var ret = this.replaceNode(parentPath, parent);\\n      return ret;\\n    }\\n\\n    /**\\n     * Insert `text` at `offset` in node by `path`.\\n     *\\n     * @param {List|String} path\\n     * @param {Number} offset\\n     * @param {String} text\\n     * @return {Node}\\n     */\\n\\n  }, {\\n    key: 'insertText',\\n    value: function insertText(path, offset, text) {\\n      path = this.resolvePath(path);\\n      var node = this.assertDescendant(path);\\n      node = node.insertText(offset, text);\\n      var ret = this.replaceNode(path, node);\\n      return ret;\\n    }\\n\\n    /**\\n     * Check whether the node is a leaf block.\\n     *\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isLeafBlock',\\n    value: function isLeafBlock() {\\n      if (this.object !== 'block') {\\n        return false;\\n      }\\n\\n      if (this.nodes.some(function (n) {\\n        return n.object === 'block';\\n      })) {\\n        return false;\\n      }\\n\\n      return true;\\n    }\\n\\n    /**\\n     * Check whether the node is a leaf inline.\\n     *\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isLeafInline',\\n    value: function isLeafInline() {\\n      if (this.object !== 'inline') {\\n        return false;\\n      }\\n\\n      if (this.nodes.some(function (n) {\\n        return n.object === 'inline';\\n      })) {\\n        return false;\\n      }\\n\\n      return true;\\n    }\\n\\n    /**\\n     * Check whether a descendant node is inside a `range` by `path`.\\n     *\\n     * @param {List|String} path\\n     * @param {Range} range\\n     * @return {Node}\\n     */\\n\\n  }, {\\n    key: 'isInRange',\\n    value: function isInRange(path, range) {\\n      path = this.resolvePath(path);\\n      range = this.resolveRange(range);\\n\\n      if (range.isUnset) {\\n        return false;\\n      }\\n\\n      var toStart = PathUtils.compare(path, range.start.path);\\n      var toEnd = PathUtils.compare(path, range.end.path);\\n      var isInRange = toStart !== -1 && toEnd !== 1;\\n      return isInRange;\\n    }\\n\\n    /**\\n     * Map all child nodes, updating them in their parents. This method is\\n     * optimized to not return a new node if no changes are made.\\n     *\\n     * @param {Function} predicate\\n     * @return {Node}\\n     */\\n\\n  }, {\\n    key: 'mapChildren',\\n    value: function mapChildren() {\\n      var _this2 = this;\\n\\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\\n      var nodes = this.nodes;\\n\\n\\n      nodes.forEach(function (node, i) {\\n        var ret = predicate(node, i, _this2.nodes);\\n        if (ret !== node) nodes = nodes.set(ret.key, ret);\\n      });\\n\\n      var ret = this.set('nodes', nodes);\\n      return ret;\\n    }\\n\\n    /**\\n     * Map all descendant nodes, updating them in their parents. This method is\\n     * optimized to not return a new node if no changes are made.\\n     *\\n     * @param {Function} predicate\\n     * @return {Node}\\n     */\\n\\n  }, {\\n    key: 'mapDescendants',\\n    value: function mapDescendants() {\\n      var _this3 = this;\\n\\n      var predicate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : identity;\\n      var nodes = this.nodes;\\n\\n\\n      nodes.forEach(function (node, index) {\\n        var ret = node;\\n        if (ret.object !== 'text') ret = ret.mapDescendants(predicate);\\n        ret = predicate(ret, index, _this3.nodes);\\n        if (ret === node) return;\\n\\n        nodes = nodes.set(index, ret);\\n      });\\n\\n      var ret = this.set('nodes', nodes);\\n      return ret;\\n    }\\n\\n    /**\\n     * Create an iteratable for all the marks in text nodes with `options`.\\n     *\\n     * @param {Options}\\n     * @return {Iterable}\\n     */\\n\\n  }, {\\n    key: 'marks',\\n    value: function marks() {\\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n      var _options$onlyTypes = options.onlyTypes,\\n          onlyTypes = _options$onlyTypes === undefined ? null : _options$onlyTypes,\\n          match = options.match,\\n          rest = objectWithoutProperties(options, ['onlyTypes', 'match']);\\n\\n      var texts = this.texts(rest);\\n\\n      return defineProperty({}, Symbol.iterator, function () {\\n        var iterator = texts[Symbol.iterator]();\\n        var node = null;\\n        var path = null;\\n        var remaining = [];\\n\\n        var next = function next() {\\n          if (remaining.length) {\\n            var mark = remaining.shift();\\n\\n            if (onlyTypes && !onlyTypes.includes(mark.type)) {\\n              return next();\\n            } else if (match && !match(mark, node, path)) {\\n              return next();\\n            }\\n\\n            return { value: [mark, node, path], done: false };\\n          }\\n\\n          var _iterator$next = iterator.next(),\\n              value = _iterator$next.value,\\n              done = _iterator$next.done;\\n\\n          if (done) {\\n            return { done: true };\\n          }\\n\\n          \\n          var _value = slicedToArray(value, 2);\\n\\n          node = _value[0];\\n          path = _value[1];\\n\\n          remaining = node.marks.toArray();\\n          return next();\\n        };\\n\\n        return { next: next };\\n      });\\n    }\\n\\n    /**\\n     * Merge a node backwards its previous sibling.\\n     *\\n     * @param {List|Key} path\\n     * @return {Node}\\n     */\\n\\n  }, {\\n    key: 'mergeNode',\\n    value: function mergeNode(path) {\\n      var b = this.assertNode(path);\\n      path = this.resolvePath(path);\\n\\n      if (path.last() === 0) {\\n        throw new Error('Unable to merge node because it has no previous sibling: ' + b);\\n      }\\n\\n      var withPath = PathUtils.decrement(path);\\n      var a = this.assertNode(withPath);\\n\\n      if (a.object !== b.object) {\\n        throw new Error('Unable to merge two different kinds of nodes: ' + a + ' and ' + b);\\n      }\\n\\n      var newNode = a.object === 'text' ? a.mergeText(b) : a.set('nodes', a.nodes.concat(b.nodes));\\n\\n      var ret = this;\\n      ret = ret.removeNode(path);\\n      ret = ret.removeNode(withPath);\\n      ret = ret.insertNode(withPath, newNode);\\n      return ret;\\n    }\\n\\n    /**\\n     * Move a node by `path` to `newPath`.\\n     *\\n     * A `newIndex` can be provided when move nodes by `key`, to account for not\\n     * being able to have a key for a location in the tree that doesn't exist yet.\\n     *\\n     * @param {List|Key} path\\n     * @param {List|Key} newPath\\n     * @param {Number} newIndex\\n     * @return {Node}\\n     */\\n\\n  }, {\\n    key: 'moveNode',\\n    value: function moveNode(path, newPath) {\\n      var newIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\\n\\n      var node = this.assertNode(path);\\n      path = this.resolvePath(path);\\n      newPath = this.resolvePath(newPath, newIndex);\\n\\n      var newParentPath = PathUtils.lift(newPath);\\n      this.assertNode(newParentPath);\\n\\n      // TODO: this is a bit hacky, re-creating the operation that led to this method being called\\n      // Alternative 1: pass the operation through from apply -> value.moveNode\\n      // Alternative 2: add a third property to the operation called \\\"transformedNewPath\\\", pass that through\\n      var op = Operation.create({\\n        type: 'move_node',\\n        path: path,\\n        newPath: newPath\\n      });\\n      newPath = PathUtils.transform(path, op).first();\\n\\n      var ret = this;\\n      ret = ret.removeNode(path);\\n      ret = ret.insertNode(newPath, node);\\n      return ret;\\n    }\\n\\n    /**\\n     * Remove `mark` from text at `path`.\\n     *\\n     * @param {List} path\\n     * @param {Mark} mark\\n     * @return {Node}\\n     */\\n\\n  }, {\\n    key: 'removeMark',\\n    value: function removeMark(path, mark) {\\n      path = this.resolvePath(path);\\n      var node = this.assertDescendant(path);\\n      node = node.removeMark(mark);\\n      var ret = this.replaceNode(path, node);\\n      return ret;\\n    }\\n\\n    /**\\n     * Remove a node.\\n     *\\n     * @param {List|String} path\\n     * @return {Node}\\n     */\\n\\n  }, {\\n    key: 'removeNode',\\n    value: function removeNode(path) {\\n      this.assertDescendant(path);\\n      path = this.resolvePath(path);\\n      var deep = path.flatMap(function (x) {\\n        return ['nodes', x];\\n      });\\n      var ret = this.deleteIn(deep);\\n      return ret;\\n    }\\n\\n    /**\\n     * Remove `text` at `offset` in node.\\n     *\\n     * @param {List|Key} path\\n     * @param {Number} offset\\n     * @param {String} text\\n     * @return {Node}\\n     */\\n\\n  }, {\\n    key: 'removeText',\\n    value: function removeText(path, offset, text) {\\n      var node = this.assertDescendant(path);\\n      node = node.removeText(offset, text.length);\\n      var ret = this.replaceNode(path, node);\\n      return ret;\\n    }\\n\\n    /**\\n     * Replace a `node` in the tree.\\n     *\\n     * @param {List|Key} path\\n     * @param {Node} node\\n     * @return {Node}\\n     */\\n\\n  }, {\\n    key: 'replaceNode',\\n    value: function replaceNode(path, node) {\\n      path = this.resolvePath(path);\\n\\n      if (!path) {\\n        throw new Error('Unable to replace a node because it could not be found in the first place: ' + path);\\n      }\\n\\n      if (!path.size) return node;\\n      this.assertNode(path);\\n      var deep = path.flatMap(function (x) {\\n        return ['nodes', x];\\n      });\\n      var ret = this.setIn(deep, node);\\n      return ret;\\n    }\\n\\n    /**\\n     * Resolve a `annotation`, relative to the node, ensuring that the keys and\\n     * offsets in the annotation exist and that they are synced with the paths.\\n     *\\n     * @param {Annotation|Object} annotation\\n     * @return {Annotation}\\n     */\\n\\n  }, {\\n    key: 'resolveAnnotation',\\n    value: function resolveAnnotation(annotation) {\\n      annotation = Annotation.create(annotation);\\n      annotation = annotation.normalize(this);\\n      return annotation;\\n    }\\n\\n    /**\\n     * Resolve a `decoration`, relative to the node, ensuring that the keys and\\n     * offsets in the decoration exist and that they are synced with the paths.\\n     *\\n     * @param {Decoration|Object} decoration\\n     * @return {Decoration}\\n     */\\n\\n  }, {\\n    key: 'resolveDecoration',\\n    value: function resolveDecoration(decoration) {\\n      decoration = Decoration.create(decoration);\\n      decoration = decoration.normalize(this);\\n      return decoration;\\n    }\\n\\n    /**\\n     * Resolve a `point`, relative to the node, ensuring that the keys and\\n     * offsets in the point exist and that they are synced with the paths.\\n     *\\n     * @param {Point|Object} point\\n     * @return {Point}\\n     */\\n\\n  }, {\\n    key: 'resolvePoint',\\n    value: function resolvePoint(point) {\\n      point = Point.create(point);\\n      point = point.normalize(this);\\n      return point;\\n    }\\n\\n    /**\\n     * Resolve a `range`, relative to the node, ensuring that the keys and\\n     * offsets in the range exist and that they are synced with the paths.\\n     *\\n     * @param {Range|Object} range\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'resolveRange',\\n    value: function resolveRange(range) {\\n      range = Range.create(range);\\n      range = range.normalize(this);\\n      return range;\\n    }\\n\\n    /**\\n     * Resolve a `selection`, relative to the node, ensuring that the keys and\\n     * offsets in the selection exist and that they are synced with the paths.\\n     *\\n     * @param {Selection|Object} selection\\n     * @return {Selection}\\n     */\\n\\n  }, {\\n    key: 'resolveSelection',\\n    value: function resolveSelection(selection) {\\n      selection = Selection.create(selection);\\n      selection = selection.normalize(this);\\n      return selection;\\n    }\\n\\n    /**\\n     * Set `properties` on a node.\\n     *\\n     * @param {List|String} path\\n     * @param {Object} properties\\n     * @return {Node}\\n     */\\n\\n  }, {\\n    key: 'setNode',\\n    value: function setNode(path, properties) {\\n      var node = this.assertNode(path);\\n      node = node.merge(properties);\\n      var ret = this.replaceNode(path, node);\\n      return ret;\\n    }\\n\\n    /**\\n     * Set `properties` on `mark` on text at `offset` and `length` in node.\\n     *\\n     * @param {List|String} path\\n     * @param {Number} offset\\n     * @param {Number} length\\n     * @param {Mark} mark\\n     * @param {Object} properties\\n     * @return {Node}\\n     */\\n\\n  }, {\\n    key: 'setMark',\\n    value: function setMark(path, properties, newProperties) {\\n      path = this.resolvePath(path);\\n      var node = this.assertDescendant(path);\\n      node = node.setMark(properties, newProperties);\\n      var ret = this.replaceNode(path, node);\\n      return ret;\\n    }\\n\\n    /**\\n     * Create an iteratable for the siblings in the tree at `path`.\\n     *\\n     * @param {List|Array} path\\n     * @return {Iterable}\\n     */\\n\\n  }, {\\n    key: 'siblings',\\n    value: function siblings(path, options) {\\n      var iterable = this.createIterable(_extends({\\n        path: path,\\n        upward: false,\\n        downward: false\\n      }, options));\\n\\n      return iterable;\\n    }\\n\\n    /**\\n     * Split a node by `path` at `position` with optional `properties` to apply\\n     * to the newly split node.\\n     *\\n     * @param {List|String} path\\n     * @param {Number} position\\n     * @param {Object} properties\\n     * @return {Node}\\n     */\\n\\n  }, {\\n    key: 'splitNode',\\n    value: function splitNode(path, position, properties) {\\n      var child = this.assertNode(path);\\n      path = this.resolvePath(path);\\n      var a = void 0;\\n      var b = void 0;\\n\\n      if (child.object === 'text') {\\n        \\n        var _child$splitText = child.splitText(position);\\n\\n        var _child$splitText2 = slicedToArray(_child$splitText, 2);\\n\\n        a = _child$splitText2[0];\\n        b = _child$splitText2[1];\\n      } else {\\n        var befores = child.nodes.take(position);\\n        var afters = child.nodes.skip(position);\\n        a = child.set('nodes', befores);\\n        b = child.set('nodes', afters).regenerateKey();\\n      }\\n\\n      if (properties && child.object !== 'text') {\\n        b = b.merge(properties);\\n      }\\n\\n      var ret = this;\\n      ret = ret.removeNode(path);\\n      ret = ret.insertNode(path, b);\\n      ret = ret.insertNode(path, a);\\n      return ret;\\n    }\\n\\n    /**\\n     * Create an iteratable for all the text node descendants.\\n     *\\n     * @param {Object} options\\n     * @return {Iterable}\\n     */\\n\\n  }, {\\n    key: 'texts',\\n    value: function texts(options) {\\n      var iterable = this.descendants(_extends({\\n        includeBlocks: false,\\n        includeInlines: false,\\n        includeDocument: false\\n      }, options));\\n\\n      return iterable;\\n    }\\n\\n    /**\\n     * Deprecated.\\n     */\\n\\n  }, {\\n    key: 'getBlocksAtRange',\\n    value: function getBlocksAtRange(range) {\\n      warning(false, 'As of slate@0.44 the `node.getBlocksAtRange` method has been renamed to `getLeafBlocksAtRange`.');\\n\\n      return this.getLeafBlocksAtRange(range);\\n    }\\n  }, {\\n    key: 'getBlocksAtRangeAsArray',\\n    value: function getBlocksAtRangeAsArray(range) {\\n      warning(false, 'As of slate@0.44 the `node.getBlocksAtRangeAsArray` method has been renamed to `getLeafBlocksAtRangeAsArray`.');\\n\\n      return this.getLeafBlocksAtRangeAsArray(range);\\n    }\\n  }, {\\n    key: 'getInlinesAtRange',\\n    value: function getInlinesAtRange(range) {\\n      warning(false, 'As of slate@0.44 the `node.getInlinesAtRange` method has been renamed to `getLeafInlinesAtRange`.');\\n\\n      return this.getLeafInlinesAtRange(range);\\n    }\\n  }, {\\n    key: 'getInlinesAtRangeAsArray',\\n    value: function getInlinesAtRangeAsArray(range) {\\n      warning(false, 'As of slate@0.44 the `node.getInlinesAtRangeAsArray` method has been renamed to `getLeafInlinesAtRangeAsArray`.');\\n\\n      return this.getLeafInlinesAtRangeAsArray(range);\\n    }\\n  }, {\\n    key: 'getNextTextAndPath',\\n    value: function getNextTextAndPath(path) {\\n      warning(false, 'As of slate@0.47, the `getNextTextAndPath` method has been renamed to `getNextTextEntry`.');\\n\\n      return this.getNextTextEntry(path);\\n    }\\n  }, {\\n    key: 'getNextDeepMatchingNodeAndPath',\\n    value: function getNextDeepMatchingNodeAndPath(path) {\\n      var iterator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\\n        return true;\\n      };\\n\\n      warning(false, 'As of slate@0.47, the `getNextDeepMatchingNodeAndPath` method is deprecated.');\\n\\n      var match = this.getNextMatchingNodeAndPath(path);\\n\\n      if (!match) return null;\\n\\n      var _match3 = slicedToArray(match, 2),\\n          nextNode = _match3[0],\\n          nextPath = _match3[1];\\n\\n      var childMatch = void 0;\\n\\n      var assign = function assign() {\\n        childMatch = nextNode.object !== 'text' && nextNode.findFirstDescendantAndPath(iterator, nextPath);\\n        return childMatch;\\n      };\\n\\n      while (assign(childMatch)) {\\n        var _childMatch = childMatch;\\n\\n        var _childMatch2 = slicedToArray(_childMatch, 2);\\n\\n        nextNode = _childMatch2[0];\\n        nextPath = _childMatch2[1];\\n      }\\n\\n      if (!nextNode) return null;\\n\\n      return iterator(nextNode) ? [nextNode, nextPath] : this.getNextDeepMatchingNodeAndPath(match[1], iterator);\\n    }\\n  }, {\\n    key: 'getPreviousTextAndPath',\\n    value: function getPreviousTextAndPath(path) {\\n      warning(false, 'As of slate@0.47, the `getPreviousTextAndPath` method has been renamed to `getPreviousTextEntry`.');\\n\\n      return this.getPreviousTextEntry(path);\\n    }\\n  }, {\\n    key: 'findFirstDescendantAndPath',\\n    value: function findFirstDescendantAndPath(iterator, pathToThisNode) {\\n      warning(false, 'As of slate@0.47, the `findFirstDescendantAndPath` method is deprecated.');\\n\\n      return this.findDescendantAndPath(iterator, pathToThisNode, false);\\n    }\\n  }, {\\n    key: 'getPreviousMatchingNodeAndPath',\\n    value: function getPreviousMatchingNodeAndPath(path) {\\n      var iterator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\\n        return true;\\n      };\\n\\n      warning(false, 'As of slate@0.47, the `getPreviousMatchingNodeAndPath` method is deprecated.');\\n\\n      if (!path) return null;\\n\\n      for (var i = path.size; i > 0; i--) {\\n        var p = path.slice(0, i);\\n        if (p.last() === 0) continue;\\n\\n        var previousPath = PathUtils.decrement(p);\\n        var previousNode = this.getNode(previousPath);\\n\\n        while (previousNode && !iterator(previousNode)) {\\n          previousPath = PathUtils.decrement(previousPath);\\n          previousNode = this.getNode(previousPath);\\n        }\\n\\n        if (previousNode) return [previousNode, previousPath];\\n      }\\n\\n      return null;\\n    }\\n  }, {\\n    key: 'getPreviousDeepMatchingNodeAndPath',\\n    value: function getPreviousDeepMatchingNodeAndPath(path) {\\n      var iterator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\\n        return true;\\n      };\\n\\n      warning(false, 'As of slate@0.47, the `getPreviousDeepMatchingNodeAndPath` method is deprecated.');\\n\\n      var match = this.getPreviousMatchingNodeAndPath(path);\\n\\n      if (!match) return null;\\n\\n      var _match4 = slicedToArray(match, 2),\\n          previousNode = _match4[0],\\n          previousPath = _match4[1];\\n\\n      var childMatch = void 0;\\n\\n      var assign = function assign() {\\n        childMatch = previousNode.object !== 'text' && previousNode.findLastDescendantAndPath(iterator, previousPath);\\n        return childMatch;\\n      };\\n\\n      while (assign(childMatch)) {\\n        var _childMatch3 = childMatch;\\n\\n        var _childMatch4 = slicedToArray(_childMatch3, 2);\\n\\n        previousNode = _childMatch4[0];\\n        previousPath = _childMatch4[1];\\n      }\\n\\n      if (!previousNode) return null;\\n\\n      return iterator(previousNode) ? [previousNode, previousPath] : this.getPreviousDeepMatchingNodeAndPath(match[1], iterator);\\n    }\\n  }, {\\n    key: 'findLastDescendantAndPath',\\n    value: function findLastDescendantAndPath(iterator, pathToThisNode) {\\n      warning(false, 'As of slate@0.47, the `findLastDescendantAndPath` method is deprecated.');\\n\\n      return this.findDescendantAndPath(iterator, pathToThisNode, true);\\n    }\\n  }, {\\n    key: 'findDescendantAndPath',\\n    value: function findDescendantAndPath(iterator) {\\n      var pathToThisNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PathUtils.create([]);\\n      var findLast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\\n\\n      warning(false, 'As of slate@0.47, the `findDescendantAndPath` method is deprecated.');\\n\\n      var found = void 0;\\n      var foundPath = void 0;\\n\\n      this.forEachDescendantWithPath(function (node, path, nodes) {\\n        if (iterator(node, path, nodes)) {\\n          found = node;\\n          foundPath = path;\\n          return false;\\n        }\\n      }, pathToThisNode, findLast);\\n\\n      return found ? [found, foundPath] : null;\\n    }\\n  }, {\\n    key: 'forEachDescendantWithPath',\\n    value: function forEachDescendantWithPath(iterator) {\\n      var path = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : PathUtils.create([]);\\n      var findLast = arguments[2];\\n\\n      warning(false, 'As of slate@0.47, the `forEachDescendantWithPath` method is deprecated.');\\n\\n      var nodes = this.nodes;\\n      var ret = void 0;\\n\\n      if (findLast) nodes = nodes.reverse();\\n\\n      nodes.forEach(function (child, i) {\\n        var childPath = path.concat(i);\\n\\n        if (iterator(child, childPath, nodes) === false) {\\n          ret = false;\\n          return false;\\n        }\\n\\n        if (child.object !== 'text') {\\n          ret = child.forEachDescendantWithPath(iterator, childPath, findLast);\\n          return ret;\\n        }\\n      });\\n\\n      return ret;\\n    }\\n  }, {\\n    key: 'getNextMatchingNodeAndPath',\\n    value: function getNextMatchingNodeAndPath(path) {\\n      var iterator = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\\n        return true;\\n      };\\n\\n      warning(false, 'As of slate@0.47, the `getNextMatchingNodeAndPath` method is deprecated.');\\n\\n      if (!path) return null;\\n\\n      for (var i = path.size; i > 0; i--) {\\n        var p = path.slice(0, i);\\n\\n        var nextPath = PathUtils.increment(p);\\n        var nextNode = this.getNode(nextPath);\\n\\n        while (nextNode && !iterator(nextNode)) {\\n          nextPath = PathUtils.increment(nextPath);\\n          nextNode = this.getNode(nextPath);\\n        }\\n\\n        if (nextNode) return [nextNode, nextPath];\\n      }\\n\\n      return null;\\n    }\\n  }, {\\n    key: 'getSelectionIndexes',\\n    value: function getSelectionIndexes(range) {\\n      var isSelected = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\\n\\n      warning(false, 'As of slate@0.47, the `getSelectionIndexes` method is deprecated.');\\n\\n      var start = range.start,\\n          end = range.end;\\n\\n      // PERF: if we're not selected, we can exit early.\\n\\n      if (!isSelected) {\\n        return null;\\n      }\\n\\n      // PERF: if we've been given an invalid selection we can exit early.\\n      if (range.isUnset) {\\n        return null;\\n      }\\n\\n      // PERF: if the start and end keys are the same, just check for the child\\n      // that contains that single key.\\n      if (start.path.equals(end.path)) {\\n        var child = this.getFurthestAncestor(start.path);\\n        var index = child ? this.nodes.indexOf(child) : null;\\n        return { start: index, end: index + 1 };\\n      }\\n\\n      // Otherwise, check all of the children...\\n      var startIndex = null;\\n      var endIndex = null;\\n\\n      this.nodes.forEach(function (child, i) {\\n        if (child.object === 'text') {\\n          if (startIndex == null && child.key === start.key) startIndex = i;\\n          if (endIndex == null && child.key === end.key) endIndex = i + 1;\\n        } else {\\n          if (startIndex == null && child.hasDescendant(start.key)) startIndex = i;\\n          if (endIndex == null && child.hasDescendant(end.key)) endIndex = i + 1;\\n        }\\n\\n        // PERF: exit early if both start and end have been found.\\n        return startIndex == null || endIndex == null;\\n      });\\n\\n      if (isSelected && startIndex == null) {\\n        startIndex = 0;\\n      }\\n\\n      if (isSelected && endIndex == null) {\\n        endIndex = this.nodes.size;\\n      }\\n\\n      if (startIndex == null) {\\n        return null;\\n      }\\n\\n      return { start: startIndex, end: endIndex };\\n    }\\n  }, {\\n    key: 'getTextsBetweenPositionsAsArray',\\n    value: function getTextsBetweenPositionsAsArray(startPath, endPath) {\\n      warning(false, 'As of slate@0.47, the `getTextsBetweenPositionsAsArray` method is deprecated.');\\n\\n      startPath = this.resolvePath(startPath);\\n      endPath = this.resolvePath(endPath);\\n\\n      return this.getTextsBetweenPathPositionsAsArray(startPath, endPath);\\n    }\\n  }, {\\n    key: 'getOrderedMarksBetweenPositions',\\n    value: function getOrderedMarksBetweenPositions(startPath, startOffset, endPath, endOffset) {\\n      warning(false, 'As of slate@0.47, the `getOrderedMarksBetweenPositions` method is deprecated.');\\n\\n      startPath = this.resolvePath(startPath);\\n      endPath = this.resolvePath(endPath);\\n      var startText = this.getDescendant(startPath);\\n\\n      // PERF: if the paths are equal, we can just use the start.\\n      if (PathUtils.isEqual(startPath, endPath)) {\\n        return startText.marks;\\n      }\\n\\n      var texts = this.getTextsBetweenPathPositionsAsArray(startPath, endPath);\\n\\n      return immutable.OrderedSet().withMutations(function (result) {\\n        texts.forEach(function (text) {\\n          result.union(text.marks);\\n        });\\n      });\\n    }\\n  }, {\\n    key: 'getTextsBetweenPathPositionsAsArray',\\n    value: function getTextsBetweenPathPositionsAsArray(startPath, endPath) {\\n      warning(false, 'As of slate@0.47, the `getTextsBetweenPathPositionsAsArray` method is deprecated.');\\n\\n      // PERF: the most common case is when the range is in a single text node,\\n      // where we can avoid a lot of iterating of the tree.\\n      if (startPath && endPath && PathUtils.isEqual(startPath, endPath)) {\\n        return [this.getDescendant(startPath)];\\n      } else if (!startPath && !endPath) {\\n        return this.getTextsAsArray();\\n      }\\n\\n      var startIndex = startPath ? startPath.get(0, 0) : 0;\\n      var endIndex = endPath ? endPath.get(0, this.nodes.size - 1) : this.nodes.size - 1;\\n\\n      var array = [];\\n\\n      this.nodes.slice(startIndex, endIndex + 1).forEach(function (node, i) {\\n        if (node.object === 'text') {\\n          array.push(node);\\n        } else {\\n          // For the node at start and end of this list, we want to provide a start and end path\\n          // For other nodes, we can just get all their text nodes, they are between the paths\\n          var childStartPath = startPath && i === 0 ? PathUtils.drop(startPath) : null;\\n          var childEndPath = endPath && i === endIndex - startIndex ? PathUtils.drop(endPath) : null;\\n\\n          array = array.concat(node.getTextsBetweenPathPositionsAsArray(childStartPath, childEndPath));\\n        }\\n      });\\n\\n      return array;\\n    }\\n  }, {\\n    key: 'getFurthestAncestor',\\n    value: function getFurthestAncestor(path) {\\n      warning(false, 'As of slate@0.47, the `getFurthestAncestor` method has been renamed to `getFurthestChild`.');\\n\\n      return this.getFurthestChild(path);\\n    }\\n  }, {\\n    key: 'getLeafBlocksAtRangeAsArray',\\n    value: function getLeafBlocksAtRangeAsArray(range) {\\n      warning(false, 'As of slate@0.47, the `getLeafBlocksAtRangeAsArray` method is deprecated.');\\n\\n      range = this.resolveRange(range);\\n      if (range.isUnset) return [];\\n\\n      var _range6 = range,\\n          start = _range6.start,\\n          end = _range6.end;\\n\\n\\n      return this.getLeafBlocksBetweenPathPositionsAsArray(start.path, end.path);\\n    }\\n  }, {\\n    key: 'getLeafBlocksBetweenPathPositionsAsArray',\\n    value: function getLeafBlocksBetweenPathPositionsAsArray(startPath, endPath) {\\n      warning(false, 'As of slate@0.47, the `getLeafBlocksBetweenPathPositionsAsArray` method is deprecated.');\\n\\n      // PERF: the most common case is when the range is in a single block node,\\n      // where we can avoid a lot of iterating of the tree.\\n      if (startPath && endPath && PathUtils.isEqual(startPath, endPath)) {\\n        return [this.getClosestBlock(startPath)];\\n      } else if (!startPath && !endPath) {\\n        return this.getBlocksAsArray();\\n      }\\n\\n      var startIndex = startPath ? startPath.get(0, 0) : 0;\\n      var endIndex = endPath ? endPath.get(0, this.nodes.size - 1) : this.nodes.size - 1;\\n\\n      var array = [];\\n\\n      this.nodes.slice(startIndex, endIndex + 1).forEach(function (node, i) {\\n        if (node.object !== 'block') {\\n          return;\\n        } else if (node.isLeafBlock()) {\\n          array.push(node);\\n        } else {\\n          var childStartPath = startPath && i === 0 ? PathUtils.drop(startPath) : null;\\n          var childEndPath = endPath && i === endIndex - startIndex ? PathUtils.drop(endPath) : null;\\n\\n          array = array.concat(node.getLeafBlocksBetweenPathPositionsAsArray(childStartPath, childEndPath));\\n        }\\n      });\\n\\n      return array;\\n    }\\n  }, {\\n    key: 'getBlocksAsArray',\\n    value: function getBlocksAsArray() {\\n      warning(false, 'As of slate@0.47, the `getBlocksAsArray` method is deprecated.');\\n\\n      var iterable = this.blocks({ onlyLeaves: true });\\n      var array = Array.from(iterable, function (_ref43) {\\n        var _ref44 = slicedToArray(_ref43, 1),\\n            node = _ref44[0];\\n\\n        return node;\\n      });\\n      return array;\\n    }\\n  }, {\\n    key: 'getBlocksByTypeAsArray',\\n    value: function getBlocksByTypeAsArray(type) {\\n      warning(false, 'As of slate@0.47, the `getBlocksByTypeAsArray` method is deprecated.');\\n\\n      var iterable = this.blocks({ onlyLeaves: true, onlyTypes: [type] });\\n      var array = Array.from(iterable, function (_ref45) {\\n        var _ref46 = slicedToArray(_ref45, 1),\\n            node = _ref46[0];\\n\\n        return node;\\n      });\\n      return array;\\n    }\\n  }, {\\n    key: 'getFurthestOnlyChildAncestor',\\n    value: function getFurthestOnlyChildAncestor(path) {\\n      warning(false, 'As of slate@0.47, the `getFurthestOnlyChildAncestor` method is deprecated.');\\n\\n      var ancestors = this.getAncestors(path);\\n      if (!ancestors) return null;\\n\\n      var furthest = ancestors.rest().reverse().takeUntil(function (p) {\\n        return p.nodes.size > 1;\\n      }).last();\\n\\n      return furthest || null;\\n    }\\n  }, {\\n    key: 'getInlinesAsArray',\\n    value: function getInlinesAsArray() {\\n      warning(false, 'As of slate@0.47, the `getInlinesAsArray` method is deprecated.');\\n\\n      var array = Array.from(this.inlines({ onlyLeaves: true }), function (_ref47) {\\n        var _ref48 = slicedToArray(_ref47, 1),\\n            node = _ref48[0];\\n\\n        return node;\\n      });\\n      return array;\\n    }\\n  }, {\\n    key: 'getInlinesByTypeAsArray',\\n    value: function getInlinesByTypeAsArray(type) {\\n      warning(false, 'As of slate@0.47, the `getInlinesByTypeAsArray` method is deprecated.');\\n\\n      var array = Array.from(this.inlines({ onlyLeaves: true, onlyTypes: [type] }), function (_ref49) {\\n        var _ref50 = slicedToArray(_ref49, 1),\\n            node = _ref50[0];\\n\\n        return node;\\n      });\\n      return array;\\n    }\\n  }, {\\n    key: 'getLeafInlinesAtRangeAsArray',\\n    value: function getLeafInlinesAtRangeAsArray(range) {\\n      var _this4 = this;\\n\\n      warning(false, 'As of slate@0.47, the `getLeafInlinesAtRangeAsArray` method is deprecated.');\\n\\n      range = this.resolveRange(range);\\n      if (range.isUnset) return [];\\n\\n      var array = this.getTextsAtRangeAsArray(range).map(function (text) {\\n        return _this4.getClosestInline(text.key);\\n      }).filter(function (exists) {\\n        return exists;\\n      });\\n\\n      return array;\\n    }\\n  }, {\\n    key: 'getOrderedMarks',\\n    value: function getOrderedMarks() {\\n      warning(false, 'As of slate@0.47, the `getOrderedMarks` method has been folded into `getMarks`, which will now return an ordered set.');\\n      return this.getMarks();\\n    }\\n  }, {\\n    key: 'getOrderedMarksAtRange',\\n    value: function getOrderedMarksAtRange(range) {\\n      warning(false, 'As of slate@0.47, the `getOrderedMarksAtRange` method has been folded into `getMarksAtRange`, which will now return an ordered set.');\\n      return this.getMarksAtRange(range);\\n    }\\n  }, {\\n    key: 'getOrderedMarksByType',\\n    value: function getOrderedMarksByType(type) {\\n      warning(false, 'As of slate@0.47, the `getOrderedMarksByType` method has been folded into `getMarksByType`, which will now return an ordered set.');\\n      return this.getMarksByType(type);\\n    }\\n  }, {\\n    key: 'getMarksByTypeAsArray',\\n    value: function getMarksByTypeAsArray(type) {\\n      warning(false, 'As of slate@0.47, the `getMarksByTypeAsArray` method is deprecated.');\\n\\n      var array = this.nodes.reduce(function (memo, node) {\\n        return node.object === 'text' ? memo.concat(node.marks.filter(function (m) {\\n          return m.type === type;\\n        })) : memo.concat(node.getMarksByTypeAsArray(type));\\n      }, []);\\n\\n      return array;\\n    }\\n  }, {\\n    key: 'getMarksAsArray',\\n    value: function getMarksAsArray() {\\n      var _ref53;\\n\\n      warning(false, 'As of slate@0.47, the `getMarksAsArray` method is deprecated.');\\n\\n      var result = [];\\n\\n      var _iteratorNormalCompletion8 = true;\\n      var _didIteratorError8 = false;\\n      var _iteratorError8 = undefined;\\n\\n      try {\\n        for (var _iterator8 = this.texts()[Symbol.iterator](), _step8; !(_iteratorNormalCompletion8 = (_step8 = _iterator8.next()).done); _iteratorNormalCompletion8 = true) {\\n          var _ref51 = _step8.value;\\n\\n          var _ref52 = slicedToArray(_ref51, 1);\\n\\n          var node = _ref52[0];\\n\\n          result.push(node.marks.toArray());\\n        }\\n\\n        // PERF: use only one concat rather than multiple for speed.\\n      } catch (err) {\\n        _didIteratorError8 = true;\\n        _iteratorError8 = err;\\n      } finally {\\n        try {\\n          if (!_iteratorNormalCompletion8 && _iterator8.return) {\\n            _iterator8.return();\\n          }\\n        } finally {\\n          if (_didIteratorError8) {\\n            throw _iteratorError8;\\n          }\\n        }\\n      }\\n\\n      var array = (_ref53 = []).concat.apply(_ref53, result);\\n      return array;\\n    }\\n  }, {\\n    key: 'getRootInlinesAtRangeAsArray',\\n    value: function getRootInlinesAtRangeAsArray(range) {\\n      var _this5 = this;\\n\\n      warning(false, 'As of slate@0.47, the `getRootInlinesAtRangeAsArray` method is deprecated.');\\n\\n      range = this.resolveRange(range);\\n      if (range.isUnset) return immutable.List();\\n\\n      var array = this.getTextsAtRangeAsArray(range).map(function (text) {\\n        return _this5.getFurthestInline(text.key);\\n      }).filter(function (exists) {\\n        return exists;\\n      });\\n\\n      return array;\\n    }\\n  }, {\\n    key: 'getTextsAsArray',\\n    value: function getTextsAsArray() {\\n      warning(false, 'As of slate@0.47, the `getTextsAsArray` method is deprecated.');\\n\\n      var iterable = this.texts();\\n      var array = Array.from(iterable, function (_ref54) {\\n        var _ref55 = slicedToArray(_ref54, 1),\\n            node = _ref55[0];\\n\\n        return node;\\n      });\\n      return array;\\n    }\\n  }, {\\n    key: 'getTextsAtRangeAsArray',\\n    value: function getTextsAtRangeAsArray(range) {\\n      warning(false, 'As of slate@0.47, the `getTextsAtRangeAsArray` method is deprecated.');\\n\\n      var iterable = this.texts({ range: range });\\n      var array = Array.from(iterable, function (_ref56) {\\n        var _ref57 = slicedToArray(_ref56, 1),\\n            node = _ref57[0];\\n\\n        return node;\\n      });\\n      return array;\\n    }\\n  }, {\\n    key: 'getMarksAtPosition',\\n    value: function getMarksAtPosition(path, offset) {\\n      warning(false, 'As of slate@0.47, the `getMarksAtPosition` method is deprecated.');\\n\\n      path = this.resolvePath(path);\\n      var text = this.getDescendant(path);\\n      var currentMarks = text.marks;\\n\\n      if (offset !== 0) {\\n        return immutable.OrderedSet(currentMarks);\\n      }\\n\\n      var closestBlock = this.getClosestBlock(path);\\n\\n      // insert mark for empty block; the empty block are often created by split node or add marks in a range including empty blocks\\n      if (closestBlock.text === '') {\\n        return immutable.OrderedSet(currentMarks);\\n      }\\n\\n      var _texts13 = this.texts({ path: path, direction: 'backward' }),\\n          _texts14 = slicedToArray(_texts13, 1),\\n          previous = _texts14[0];\\n\\n      if (!previous) {\\n        return immutable.OrderedSet();\\n      }\\n\\n      var _previous2 = slicedToArray(previous, 2),\\n          previousText = _previous2[0],\\n          previousPath = _previous2[1];\\n\\n      if (closestBlock.hasDescendant(previousPath)) {\\n        return immutable.OrderedSet(previousText.marks);\\n      }\\n\\n      return immutable.OrderedSet(currentMarks);\\n    }\\n  }, {\\n    key: 'getNodesAtRange',\\n    value: function getNodesAtRange(range) {\\n      warning(false, 'As of slate@0.47, the `getNodesAtRange` method has been renamed to `getDescendantsAtRange`.');\\n\\n      var iterable = this.descendants({ range: range });\\n      var array = Array.from(iterable, function (_ref58) {\\n        var _ref59 = slicedToArray(_ref58, 1),\\n            node = _ref59[0];\\n\\n        return node;\\n      });\\n      var list = immutable.List(array);\\n      return list;\\n    }\\n  }, {\\n    key: 'isNodeInRange',\\n    value: function isNodeInRange(path, range) {\\n      warning(false, 'As of slate@0.47, the `isNodeInRange` method has been renamed to `isInRange`.');\\n\\n      return this.isInRange(path, range);\\n    }\\n  }, {\\n    key: 'text',\\n\\n    /**\\n     * Get the concatenated text of the node.\\n     *\\n     * @return {String}\\n     */\\n\\n    get: function get$$1() {\\n      return this.getText();\\n    }\\n  }]);\\n  return ElementInterface;\\n}();\\n\\n/**\\n * Mix in assertion variants.\\n */\\n\\nvar ASSERTS = ['Child', 'Depth', 'Descendant', 'Node', 'Parent', 'Path'];\\n\\nvar _loop$1 = function _loop(method) {\\n  ElementInterface.prototype['assert' + method] = function (path) {\\n    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\\n      args[_key - 1] = arguments[_key];\\n    }\\n\\n    var ret = this['get' + method].apply(this, [path].concat(args));\\n\\n    if (ret == null) {\\n      throw new Error('`Node.assert' + method + '` could not find node with path or key: ' + path);\\n    }\\n\\n    return ret;\\n  };\\n};\\n\\nvar _iteratorNormalCompletion9 = true;\\nvar _didIteratorError9 = false;\\nvar _iteratorError9 = undefined;\\n\\ntry {\\n  for (var _iterator9 = ASSERTS[Symbol.iterator](), _step9; !(_iteratorNormalCompletion9 = (_step9 = _iterator9.next()).done); _iteratorNormalCompletion9 = true) {\\n    var method$1 = _step9.value;\\n\\n    _loop$1(method$1);\\n  }\\n\\n  /**\\n   * Memoize read methods.\\n   */\\n} catch (err) {\\n  _didIteratorError9 = true;\\n  _iteratorError9 = err;\\n} finally {\\n  try {\\n    if (!_iteratorNormalCompletion9 && _iterator9.return) {\\n      _iterator9.return();\\n    }\\n  } finally {\\n    if (_didIteratorError9) {\\n      throw _iteratorError9;\\n    }\\n  }\\n}\\n\\nmemoize(ElementInterface.prototype, ['getBlocksAsArray', 'getBlocksByTypeAsArray', 'getDecorations', 'getFragmentAtRange', 'getInlinesAsArray', 'getInlinesByTypeAsArray', 'getInsertMarksAtRange', 'getLeafBlocksAtRangeAsArray', 'getLeafBlocksAtRangeAsArray', 'getLeafInlinesAtRangeAsArray', 'getMarksAsArray', 'getMarksAtPosition', 'getMarksByTypeAsArray', 'getNextBlock', 'getNodesAtRange', 'getNodesToPathsMap', 'getOffset', 'getOffsetAtRange', 'getOrderedMarksBetweenPositions', 'getPreviousBlock', 'getRootBlocksAtRange', 'getRootInlinesAtRangeAsArray', 'getTextAtOffset', 'getTextDirection', 'getTextsAsArray', 'getTextsBetweenPathPositionsAsArray']);\\n\\n/**\\n * Mix in the element interface.\\n */\\n\\nmixin(ElementInterface, [Block, Document, Inline]);\\n\\n/**\\n * The interface that `Decoration`, `Range` and `Selection` all implement, to make\\n * working anchor and focus points easier.\\n *\\n * @type {Class}\\n */\\n\\nvar RangeInterface = function () {\\n  function RangeInterface() {\\n    classCallCheck(this, RangeInterface);\\n  }\\n\\n  createClass(RangeInterface, [{\\n    key: 'flip',\\n\\n\\n    /**\\n     * Flip the range.\\n     *\\n     * @return {Range}\\n     */\\n\\n    value: function flip() {\\n      var range = this.setPoints([this.focus, this.anchor]);\\n      return range;\\n    }\\n\\n    /**\\n     * Move the anchor and focus offsets forward `n` characters.\\n     *\\n     * @param {Number} n\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveForward',\\n    value: function moveForward(n) {\\n      return this.updatePoints(function (point) {\\n        return point.moveForward(n);\\n      });\\n    }\\n\\n    /**\\n     * Move the anchor and focus offsets backward `n` characters.\\n     *\\n     * @param {Number} n\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveBackward',\\n    value: function moveBackward(n) {\\n      return this.updatePoints(function (point) {\\n        return point.moveBackward(n);\\n      });\\n    }\\n\\n    /**\\n     * Move the anchor offset backward `n` characters.\\n     *\\n     * @param {Number} n\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveAnchorBackward',\\n    value: function moveAnchorBackward(n) {\\n      var range = this.setAnchor(this.anchor.moveBackward(n));\\n      return range;\\n    }\\n\\n    /**\\n     * Move the anchor offset forward `n` characters.\\n     *\\n     * @param {Number} n\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveAnchorForward',\\n    value: function moveAnchorForward(n) {\\n      var range = this.setAnchor(this.anchor.moveForward(n));\\n      return range;\\n    }\\n\\n    /**\\n     * Move the range's anchor point to a new `path` and `offset`.\\n     *\\n     * Optionally, the `path` can be a key string, or omitted entirely in which\\n     * case it would be the offset number.\\n     *\\n     * @param {List|String} path\\n     * @param {Number} offset\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveAnchorTo',\\n    value: function moveAnchorTo(path, offset) {\\n      var range = this.setAnchor(this.anchor.moveTo(path, offset));\\n      return range;\\n    }\\n\\n    /**\\n     * Move the range's anchor point to the start of a `node`.\\n     *\\n     * @param {Node} node\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveAnchorToStartOfNode',\\n    value: function moveAnchorToStartOfNode(node) {\\n      var range = this.setAnchor(this.anchor.moveToStartOfNode(node));\\n      return range;\\n    }\\n\\n    /**\\n     * Move the range's anchor point to the end of a `node`.\\n     *\\n     * @param {Node} node\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveAnchorToEndOfNode',\\n    value: function moveAnchorToEndOfNode(node) {\\n      var range = this.setAnchor(this.anchor.moveToEndOfNode(node));\\n      return range;\\n    }\\n\\n    /**\\n     * Move the end offset backward `n` characters.\\n     *\\n     * @param {Number} n\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveEndBackward',\\n    value: function moveEndBackward(n) {\\n      var range = this.setEnd(this.end.moveBackward(n));\\n      return range;\\n    }\\n\\n    /**\\n     * Move the end offset forward `n` characters.\\n     *\\n     * @param {Number} n\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveEndForward',\\n    value: function moveEndForward(n) {\\n      var range = this.setEnd(this.end.moveForward(n));\\n      return range;\\n    }\\n\\n    /**\\n     * Move the range's end point to a new `path` and `offset`.\\n     *\\n     * Optionally, the `path` can be a key string, or omitted entirely in which\\n     * case it would be the offset number.\\n     *\\n     * @param {List|String} path\\n     * @param {Number} offset\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveEndTo',\\n    value: function moveEndTo(path, offset) {\\n      var range = this.setEnd(this.end.moveTo(path, offset));\\n      return range;\\n    }\\n\\n    /**\\n     * Move the range's end point to the start of a `node`.\\n     *\\n     * @param {Node} node\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveEndToStartOfNode',\\n    value: function moveEndToStartOfNode(node) {\\n      var range = this.setEnd(this.end.moveToStartOfNode(node));\\n      return range;\\n    }\\n\\n    /**\\n     * Move the range's end point to the end of a `node`.\\n     *\\n     * @param {Node} node\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveEndToEndOfNode',\\n    value: function moveEndToEndOfNode(node) {\\n      var range = this.setEnd(this.end.moveToEndOfNode(node));\\n      return range;\\n    }\\n\\n    /**\\n     * Move the focus offset backward `n` characters.\\n     *\\n     * @param {Number} n\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveFocusBackward',\\n    value: function moveFocusBackward(n) {\\n      var range = this.setFocus(this.focus.moveBackward(n));\\n      return range;\\n    }\\n\\n    /**\\n     * Move the focus offset forward `n` characters.\\n     *\\n     * @param {Number} n\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveFocusForward',\\n    value: function moveFocusForward(n) {\\n      var range = this.setFocus(this.focus.moveForward(n));\\n      return range;\\n    }\\n\\n    /**\\n     * Move the range's focus point to a new `path` and `offset`.\\n     *\\n     * Optionally, the `path` can be a key string, or omitted entirely in which\\n     * case it would be the offset number.\\n     *\\n     * @param {List|String} path\\n     * @param {Number} offset\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveFocusTo',\\n    value: function moveFocusTo(path, offset) {\\n      var range = this.setFocus(this.focus.moveTo(path, offset));\\n      return range;\\n    }\\n\\n    /**\\n     * Move the range's focus point to the start of a `node`.\\n     *\\n     * @param {Node} node\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveFocusToStartOfNode',\\n    value: function moveFocusToStartOfNode(node) {\\n      var range = this.setFocus(this.focus.moveToStartOfNode(node));\\n      return range;\\n    }\\n\\n    /**\\n     * Move the range's focus point to the end of a `node`.\\n     *\\n     * @param {Node} node\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveFocusToEndOfNode',\\n    value: function moveFocusToEndOfNode(node) {\\n      var range = this.setFocus(this.focus.moveToEndOfNode(node));\\n      return range;\\n    }\\n\\n    /**\\n     * Move the start offset backward `n` characters.\\n     *\\n     * @param {Number} n\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveStartBackward',\\n    value: function moveStartBackward(n) {\\n      var range = this.setStart(this.start.moveBackward(n));\\n      return range;\\n    }\\n\\n    /**\\n     * Move the start offset forward `n` characters.\\n     *\\n     * @param {Number} n\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveStartForward',\\n    value: function moveStartForward(n) {\\n      var range = this.setStart(this.start.moveForward(n));\\n      return range;\\n    }\\n\\n    /**\\n     * Move the range's start point to a new `path` and `offset`.\\n     *\\n     * Optionally, the `path` can be a key string, or omitted entirely in which\\n     * case it would be the offset number.\\n     *\\n     * @param {List|String} path\\n     * @param {Number} offset\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveStartTo',\\n    value: function moveStartTo(path, offset) {\\n      var range = this.setStart(this.start.moveTo(path, offset));\\n      return range;\\n    }\\n\\n    /**\\n     * Move the range's start point to the start of a `node`.\\n     *\\n     * @param {Node} node\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveStartToStartOfNode',\\n    value: function moveStartToStartOfNode(node) {\\n      var range = this.setStart(this.start.moveToStartOfNode(node));\\n      return range;\\n    }\\n\\n    /**\\n     * Move the range's start point to the end of a `node`.\\n     *\\n     * @param {Node} node\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveStartToEndOfNode',\\n    value: function moveStartToEndOfNode(node) {\\n      var range = this.setStart(this.start.moveToEndOfNode(node));\\n      return range;\\n    }\\n\\n    /**\\n     * Move range's points to a new `path` and `offset`.\\n     *\\n     * @param {Number} n\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveTo',\\n    value: function moveTo(path, offset) {\\n      return this.updatePoints(function (point) {\\n        return point.moveTo(path, offset);\\n      });\\n    }\\n\\n    /**\\n     * Move the focus point to the anchor point.\\n     *\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveToAnchor',\\n    value: function moveToAnchor() {\\n      var range = this.setFocus(this.anchor);\\n      return range;\\n    }\\n\\n    /**\\n     * Move the start point to the end point.\\n     *\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveToEnd',\\n    value: function moveToEnd() {\\n      var range = this.setStart(this.end);\\n      return range;\\n    }\\n\\n    /**\\n     * Move the range's points to the end of a `node`.\\n     *\\n     * @param {Node} node\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveToEndOfNode',\\n    value: function moveToEndOfNode(node) {\\n      return this.updatePoints(function (point) {\\n        return point.moveToEndOfNode(node);\\n      });\\n    }\\n\\n    /**\\n     * Move the anchor point to the focus point.\\n     *\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveToFocus',\\n    value: function moveToFocus() {\\n      var range = this.setAnchor(this.focus);\\n      return range;\\n    }\\n\\n    /**\\n     * Move to the entire range of `start` and `end` nodes.\\n     *\\n     * @param {Node} start\\n     * @param {Node} end (optional)\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveToRangeOfNode',\\n    value: function moveToRangeOfNode(start) {\\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : start;\\n\\n      var range = this.setPoints([this.anchor.moveToStartOfNode(start), this.focus.moveToEndOfNode(end)]);\\n\\n      return range;\\n    }\\n\\n    /**\\n     * Move the end point to the start point.\\n     *\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveToStart',\\n    value: function moveToStart() {\\n      var range = this.setEnd(this.start);\\n      return range;\\n    }\\n\\n    /**\\n     * Move the range's points to the start of a `node`.\\n     *\\n     * @param {Node} node\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'moveToStartOfNode',\\n    value: function moveToStartOfNode(node) {\\n      return this.updatePoints(function (point) {\\n        return point.moveToStartOfNode(node);\\n      });\\n    }\\n\\n    /**\\n     * Normalize the range, relative to a `node`, ensuring that the anchor\\n     * and focus nodes of the range always refer to leaf text nodes.\\n     *\\n     * @param {Node} node\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'normalize',\\n    value: function normalize(node) {\\n      return this.updatePoints(function (point) {\\n        return point.normalize(node);\\n      });\\n    }\\n\\n    /**\\n     * Set the anchor point to a new `anchor`.\\n     *\\n     * @param {Point} anchor\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'setAnchor',\\n    value: function setAnchor(anchor) {\\n      var range = this.set('anchor', anchor);\\n      return range;\\n    }\\n\\n    /**\\n     * Set the end point to a new `point`.\\n     *\\n     * @param {Point} point\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'setEnd',\\n    value: function setEnd(point) {\\n      var range = this.isBackward ? this.setAnchor(point) : this.setFocus(point);\\n      return range;\\n    }\\n\\n    /**\\n     * Set the focus point to a new `focus`.\\n     *\\n     * @param {Point} focus\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'setFocus',\\n    value: function setFocus(focus) {\\n      var range = this.set('focus', focus);\\n      return range;\\n    }\\n\\n    /**\\n     * Set the anchor and focus points to new `values`.\\n     *\\n     * @param {Array<Point>} values\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'setPoints',\\n    value: function setPoints(values) {\\n      var _values = slicedToArray(values, 2),\\n          anchor = _values[0],\\n          focus = _values[1];\\n\\n      var range = this.set('anchor', anchor).set('focus', focus);\\n      return range;\\n    }\\n\\n    /**\\n     * Set the anchor and focus points with `updater` callback\\n     *\\n     * @param {Function} updater\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'updatePoints',\\n    value: function updatePoints(updater) {\\n      var anchor = this.anchor,\\n          focus = this.focus;\\n\\n      anchor = updater(anchor);\\n      focus = updater(focus);\\n      return this.merge({ anchor: anchor, focus: focus });\\n    }\\n\\n    /**\\n     * Set the start point to a new `point`.\\n     *\\n     * @param {Point} point\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'setStart',\\n    value: function setStart(point) {\\n      var range = this.isBackward ? this.setFocus(point) : this.setAnchor(point);\\n      return range;\\n    }\\n\\n    /**\\n     * Set new `properties` on the range.\\n     *\\n     * @param {Object|Range} properties\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'setProperties',\\n    value: function setProperties(properties) {\\n      properties = Range.createProperties(properties);\\n      var _properties = properties,\\n          anchor = _properties.anchor,\\n          focus = _properties.focus,\\n          props = objectWithoutProperties(_properties, ['anchor', 'focus']);\\n\\n\\n      if (anchor) {\\n        props.anchor = Point.create(anchor);\\n      }\\n\\n      if (focus) {\\n        props.focus = Point.create(focus);\\n      }\\n\\n      var range = this.merge(props);\\n      return range;\\n    }\\n\\n    /**\\n     * Return a JSON representation of the range.\\n     *\\n     * @param {Object} options\\n     * @return {Object}\\n     */\\n\\n  }, {\\n    key: 'toJSON',\\n    value: function toJSON() {\\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n      var object = {\\n        object: this.object,\\n        anchor: this.anchor.toJSON(options),\\n        focus: this.focus.toJSON(options)\\n      };\\n\\n      return object;\\n    }\\n\\n    /**\\n     * Return a `Range` instance from any range-like instance.\\n     *\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'toRange',\\n    value: function toRange() {\\n      var properties = Range.createProperties(this);\\n      var range = Range.create(properties);\\n      return range;\\n    }\\n\\n    /**\\n     * Unset the range.\\n     *\\n     * @return {Range}\\n     */\\n\\n  }, {\\n    key: 'unset',\\n    value: function unset() {\\n      var range = this.updatePoints(function (p) {\\n        return p.unset();\\n      });\\n      return range;\\n    }\\n  }, {\\n    key: 'isCollapsed',\\n\\n    /**\\n     * Check whether the range is collapsed.\\n     *\\n     * @return {Boolean}\\n     */\\n\\n    get: function get$$1() {\\n      return this.anchor === this.focus || this.anchor.key === this.focus.key && this.anchor.offset === this.focus.offset;\\n    }\\n\\n    /**\\n     * Check whether the range is expanded.\\n     *\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isExpanded',\\n    get: function get$$1() {\\n      return !this.isCollapsed;\\n    }\\n\\n    /**\\n     * Check whether the range is backward.\\n     *\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isBackward',\\n    get: function get$$1() {\\n      var isUnset = this.isUnset,\\n          anchor = this.anchor,\\n          focus = this.focus;\\n\\n\\n      if (isUnset) {\\n        return null;\\n      }\\n\\n      if (anchor.key === focus.key) {\\n        return anchor.offset > focus.offset;\\n      }\\n\\n      var isBackward = PathUtils.isBefore(focus.path, anchor.path);\\n      return isBackward;\\n    }\\n\\n    /**\\n     * Check whether the range is forward.\\n     *\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isForward',\\n    get: function get$$1() {\\n      var isBackward = this.isBackward;\\n\\n      var isForward = isBackward == null ? null : !isBackward;\\n      return isForward;\\n    }\\n\\n    /**\\n     * Check whether the range isn't set.\\n     *\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isUnset',\\n    get: function get$$1() {\\n      var anchor = this.anchor,\\n          focus = this.focus;\\n\\n      var isUnset = anchor.isUnset || focus.isUnset;\\n      return isUnset;\\n    }\\n\\n    /**\\n     * Check whether the range is set.\\n     *\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'isSet',\\n    get: function get$$1() {\\n      return !this.isUnset;\\n    }\\n\\n    /**\\n     * Get the start point.\\n     *\\n     * @return {String}\\n     */\\n\\n  }, {\\n    key: 'start',\\n    get: function get$$1() {\\n      return this.isBackward ? this.focus : this.anchor;\\n    }\\n\\n    /**\\n     * Get the end point.\\n     *\\n     * @return {String}\\n     */\\n\\n  }, {\\n    key: 'end',\\n    get: function get$$1() {\\n      return this.isBackward ? this.anchor : this.focus;\\n    }\\n  }]);\\n  return RangeInterface;\\n}();\\n\\n/**\\n * Mix in the range interface.\\n *\\n * @param {Record}\\n */\\n\\nmixin(RangeInterface, [Annotation, Decoration, Range, Selection]);\\n\\nvar index = {\\n  Annotation: Annotation,\\n  Block: Block,\\n  Change: Change,\\n  Data: Data,\\n  Decoration: Decoration,\\n  Document: Document,\\n  Editor: Editor,\\n  Inline: Inline,\\n  KeyUtils: KeyUtils,\\n  Leaf: Leaf$1,\\n  Mark: Mark,\\n  Node: Node,\\n  Operation: Operation,\\n  PathUtils: PathUtils,\\n  Point: Point,\\n  Range: Range,\\n  resetMemoization: resetMemoization,\\n  Selection: Selection,\\n  Text: Text,\\n  TextUtils: TextUtils,\\n  useMemoization: useMemoization,\\n  Value: Value\\n};\\n\\nexports.Annotation = Annotation;\\nexports.Block = Block;\\nexports.Change = Change;\\nexports.Data = Data;\\nexports.Decoration = Decoration;\\nexports.Document = Document;\\nexports.Editor = Editor;\\nexports.Inline = Inline;\\nexports.KeyUtils = KeyUtils;\\nexports.Leaf = Leaf$1;\\nexports.Mark = Mark;\\nexports.Node = Node;\\nexports.Operation = Operation;\\nexports.PathUtils = PathUtils;\\nexports.Point = Point;\\nexports.Range = Range;\\nexports.resetMemoization = resetMemoization;\\nexports.Selection = Selection;\\nexports.Text = Text;\\nexports.TextUtils = TextUtils;\\nexports.useMemoization = useMemoization;\\nexports.Value = Value;\\nexports.default = index;\\n//# sourceMappingURL=slate.js.map\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_interopDefault\",\"ex\",\"resetGenerator\",\"n\",\"generate\",\"compare\",\"path\",\"target\",\"m\",\"min\",\"i\",\"pv\",\"get\",\"tv\",\"size\",\"create$1\",\"attrs\",\"immutable\",\"List\",\"isList\",\"Array\",\"isArray\",\"Error\",\"crop\",\"a\",\"b\",\"arguments\",\"length\",\"undefined\",\"ca\",\"slice\",\"cb\",\"decrement\",\"increment\",\"index\",\"value\",\"set\",\"newPath\",\"isAbove\",\"_crop\",\"_crop2\",\"slicedToArray\",\"p\",\"t\",\"isYounger\",\"_crop9\",\"_crop10\",\"pl\",\"tl\",\"equals\",\"Math\",\"isObject\",\"type\",\"TYPES\",\"applyOperation\",\"op\",\"Operation\",\"create\",\"debug\",\"addAnnotation\",\"next\",\"annotation\",\"addMark\",\"_next\",\"_op3\",\"mark\",\"insertNode\",\"_next2\",\"_op4\",\"node\",\"insertText\",\"_next3\",\"_op5\",\"offset\",\"text\",\"marks\",\"mergeNode\",\"_next4\",\"moveNode\",\"_next5\",\"_op7\",\"removeAnnotation\",\"_next6\",\"removeMark\",\"_next7\",\"_op9\",\"removeNode\",\"_next8\",\"removeText\",\"_next9\",\"_op11\",\"setAnnotation\",\"_next10\",\"_op12\",\"properties\",\"newProperties\",\"setMark\",\"_next11\",\"_op13\",\"setNode\",\"_next12\",\"_op14\",\"setSelection\",\"_next13\",\"setProperties\",\"_next14\",\"splitNode\",\"_next15\",\"_op17\",\"position\",\"invertOperation\",\"debug$1\",\"_op2\",\"PathUtils\",\"isEqual\",\"inversePath\",\"transform\",\"first\",\"inverseNewPath\",\"inverse\",\"_inversePath\",\"_inverse\",\"_inversePath2\",\"_inverse2\",\"_inverse3\",\"_inverse4\",\"replace\",\"_inverse5\",\"_inverse6\",\"_inverse7\",\"CommandsPlugin\",\"commands\",\"onCommand\",\"command\",\"editor\",\"args\",\"fn\",\"apply\",\"concat\",\"toConsumableArray\",\"onConstruct\",\"registerCommand\",\"isSurrogate\",\"code\",\"SURROGATE_START\",\"SURROGATE_END\",\"isModifier\",\"charCodeAt\",\"isWord\",\"char\",\"remaining\",\"SPACE\",\"test\",\"CHAMELEON\",\"charAt\",\"getCharLength\",\"rest\",\"PUNCTUATION\",\"getCharOffset\",\"chars\",\"forward\",\"prev\",\"charCode\",\"modifier\",\"nextCharCode\",\"getWordOffset\",\"started\",\"l\",\"deleteExpandedAtRange\",\"range\",\"isExpanded\",\"deleteAtRange\",\"document\",\"_range\",\"end\",\"hasDescendant\",\"start\",\"moveToStart\",\"moveTo\",\"normalize\",\"shouldMerge\",\"o\",\"isValidOperation\",\"_o$newProperties\",\"anchor\",\"focus\",\"isFocused\",\"proxy\",\"method\",\"_editor$value$selecti\",\"_len39\",\"_key39\",\"selection\",\"select\",\"pointEdgeObject\",\"point\",\"edge\",\"object\",\"Point\",\"toUpperCase\",\"Edge\",\"Object\",\"getNode\",\"key\",\"pointEdgeSideObject\",\"side\",\"Side\",\"getDirectionNode\",\"pointBackward\",\"pointForward\",\"hasVoidParent\",\"previous\",\"getPreviousText\",\"isInBlock\",\"getClosestBlock\",\"block\",\"hasNode\",\"isPreviousInVoid\",\"getNextText\",\"isNextInVoid\",\"_range2\",\"pointWordBackward\",\"pointName\",\"getOffset\",\"TextUtils\",\"getWordOffsetBackward\",\"pointWordForward\",\"getWordOffsetForward\",\"QueriesPlugin\",\"queries\",\"query\",\"registerQuery\",\"onQuery\",\"ret\",\"SchemaPlugin\",\"schema\",\"validateNode\",\"matches\",\"schemaRules\",\"filter\",\"r\",\"validateRules\",\"error\",\"match\",\"failure\",\"every\",\"SlateError\",\"rules\",\"blocks\",\"inlines\",\"annotations\",\"decorations\",\"push\",\"_extends\",\"_key\",\"_key2\",\"_key3\",\"_key4\",\"isAtomic\",\"format\",\"rule\",\"find\",\"isVoid\",\"normalizeNode\",\"operations\",\"defaultNormalize\",\"child\",\"nodes\",\"removeNodeByKey\",\"forEach\",\"data\",\"setNodeByKey\",\"delete\",\"getTexts\",\"removeMarkByKey\",\"options\",\"_options$every\",\"_options$match\",\"valid\",\"fail\",\"array\",\"_iteratorNormalCompletion\",\"_didIteratorError\",\"_iteratorError\",\"_iterator\",\"Symbol\",\"iterator\",\"_step\",\"done\",\"_error\",\"err\",\"return\",\"last\",\"validateNodes\",\"validateMarks\",\"toArray\",\"getMarks\",\"_loop\",\"some\",\"def\",\"v\",\"_iteratorNormalCompletion2\",\"_didIteratorError2\",\"_iteratorError2\",\"_iterator2\",\"_step2\",\"_ret\",\"_typeof\",\"nextDef\",\"defs\",\"shift\",\"lastCount\",\"count\",\"max\",\"nextChild\",\"children\",\"validateParent\",\"validatePrevious\",\"validateNext\",\"limit\",\"lastMin\",\"_iteratorNormalCompletion3\",\"_didIteratorError3\",\"_iteratorError3\",\"_iterator3\",\"_step3\",\"parent\",\"_iteratorNormalCompletion4\",\"_didIteratorError4\",\"_iteratorError4\",\"_iterator4\",\"_step4\",\"_iteratorNormalCompletion5\",\"_didIteratorError5\",\"_iteratorError5\",\"_iterator5\",\"_step5\",\"deleteExpanded\",\"CorePlugin\",\"_options$plugins\",\"plugins\",\"Commands$1\",\"Commands$2\",\"Commands$3\",\"Commands$4\",\"Commands$5\",\"Commands$6\",\"isEmpty\",\"insertNodeByKey\",\"Text\",\"mergeNodeByKey\",\"getDirtyPaths\",\"operation\",\"ancestors\",\"getAncestors\",\"table\",\"getKeysToPathsTable\",\"paths\",\"values\",\"map\",\"_ancestors\",\"_ancestors2\",\"nextPath\",\"_ancestors3\",\"previousPath\",\"oldAncestors\",\"reduce\",\"arr\",\"newAncestors\",\"_ancestors4\",\"normalizeDirtyPaths\",\"tmp\",\"dirty\",\"withoutNormalizing\",\"pop\",\"controller\",\"assertNode\",\"iterations\",\"found\",\"getDescendant\",\"getPath\",\"registerPlugin\",\"plugin\",\"objectWithoutProperties\",\"commandsPlugin\",\"queriesPlugin\",\"schemaPlugin\",\"middleware\",\"mixin\",\"Interface\",\"Classes\",\"Class\",\"getOwnPropertyNames\",\"name\",\"hasOwnProperty\",\"desc\",\"getOwnPropertyDescriptor\",\"defineProperty\",\"prototype\",\"_name\",\"create$2\",\"TYPE\",\"is\",\"ObjectInterface\",\"classCallCheck\",\"createClass\",\"get$$1\",\"bind\",\"memoize\",\"property\",\"original\",\"_len\",\"ENABLED\",\"memoizeStore\",\"has\",\"noArgs\",\"hasArgs\",\"_memoizeStore$get\",\"takesArguments\",\"cachedValue\",\"keys\",\"UNDEFINED\",\"NULL\",\"STORE_KEY\",\"LEAF\",\"WeakMap\",\"newChild\",\"resetMemoization\",\"useMemoization\",\"enabled\",\"identity\",\"isPlainObject\",\"warning\",\"invariant\",\"Debug\",\"esrever\",\"pick\",\"omit\",\"getDirection\",\"KeyUtils\",\"setGenerator\",\"func\",\"obj\",\"constructor\",\"instance\",\"Constructor\",\"TypeError\",\"defineProperties\",\"props\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"protoProps\",\"staticProps\",\"assign\",\"source\",\"call\",\"inherits\",\"subClass\",\"superClass\",\"setPrototypeOf\",\"__proto__\",\"indexOf\",\"possibleConstructorReturn\",\"self\",\"ReferenceError\",\"_arr\",\"_n\",\"_d\",\"_e\",\"_i\",\"_s\",\"arr2\",\"from\",\"withMutations\",\"list\",\"isAfter\",\"_crop3\",\"_crop4\",\"isBefore\",\"_crop5\",\"_crop6\",\"isOlder\",\"_crop7\",\"_crop8\",\"isPath\",\"any\",\"isSibling\",\"butLast\",\"lift\",\"ancestor\",\"drop\",\"relative\",\"relate\",\"av\",\"bv\",\"pIndex\",\"pEqual\",\"pYounger\",\"pAbove\",\"np\",\"_Record\",\"getPrototypeOf\",\"isAfterPoint\",\"isUnset\",\"isAfterRange\",\"isAtEndOfRange\",\"isAtStartOfRange\",\"isBeforePoint\",\"isBeforeRange\",\"isInRange\",\"isAtEndOfNode\",\"getLastText\",\"isAtStartOfNode\",\"getFirstText\",\"isInNode\",\"moveBackward\",\"moveForward\",\"setOffset\",\"merge\",\"moveToStartOfNode\",\"moveToEndOfNode\",\"_point\",\"_point2\",\"_point3\",\"_text\",\"getTextAtOffset\",\"before\",\"setKey\",\"setPath\",\"toJSON\",\"preserveKeys\",\"unset\",\"isSet\",\"isPoint\",\"fromJSON\",\"createProperties\",\"_object$key\",\"_object$offset\",\"_object$path\",\"Record\",\"DEFAULTS\",\"Data\",\"Map\",\"isMap\",\"fromJS\",\"Mark\",\"isMark\",\"createSet\",\"elements\",\"Set\",\"_object$data\",\"isMarkSet\",\"item\",\"DEFAULTS$1\",\"Decoration\",\"decoration\",\"isDecoration\",\"Range\",\"isRange\",\"createList\",\"JSON\",\"stringify\",\"DEFAULTS$2\",\"Selection\",\"setIsFocused\",\"setMarks\",\"_properties\",\"isSelection\",\"_object$isFocused\",\"_object$marks\",\"DEFAULTS$3\",\"change\",\"inline\",\"leaf\",\"DEFAULTS$4\",\"Annotation\",\"isAnnotation\",\"createMap\",\"DEFAULTS$5\",\"Document\",\"isDocument\",\"_object$nodes\",\"Node\",\"DEFAULTS$6\",\"Inline\",\"isInline\",\"isInlineList\",\"DEFAULTS$7\",\"Leaf\",\"add\",\"addMarks\",\"union\",\"getLeaves\",\"leaves\",\"split\",\"at\",\"compile\",\"kind\",\"formats\",\"middle\",\"after\",\"_split\",\"_split2\",\"_split3\",\"_split4\",\"string\",\"remove\",\"newMark\",\"splitText\",\"one\",\"two\",\"regenerateKey\",\"mergeText\",\"other\",\"isText\",\"_object$text\",\"isTextList\",\"DEFAULTS$8\",\"isNode\",\"Block\",\"el\",\"texts\",\"isBlock\",\"isNodeList\",\"isBlockList\",\"DEFAULTS$9\",\"Value\",\"_value\",\"updatePoints\",\"mapRanges\",\"mapPoints\",\"newDocument\",\"resolvePath\",\"withPath\",\"moveAnchorTo\",\"moveFocusTo\",\"newIndex\",\"resolveAnnotation\",\"_value15\",\"resolveSelection\",\"_value17\",\"sel\",\"createSelection\",\"anns\",\"createAnnotation\",\"preserveData\",\"preserveAnnotations\",\"toObject\",\"preserveSelection\",\"getClosestInline\",\"getNextBlock\",\"getPreviousBlock\",\"getNextInline\",\"getPreviousInline\",\"getMarksAtRange\",\"getActiveMarksAtRange\",\"getLeafBlocksAtRange\",\"getFragmentAtRange\",\"getLeafInlinesAtRange\",\"getTextsAtRange\",\"isValue\",\"_object$annotations\",\"_object$document\",\"_object$selection\",\"DEFAULTS$10\",\"OPERATION_ATTRIBUTES\",\"add_mark\",\"add_annotation\",\"insert_node\",\"insert_text\",\"merge_node\",\"move_node\",\"remove_annotation\",\"remove_mark\",\"remove_node\",\"remove_text\",\"set_annotation\",\"set_mark\",\"set_node\",\"set_selection\",\"set_value\",\"split_node\",\"invert\",\"inverted\",\"json\",\"ATTRIBUTES\",\"toJS\",\"_v\",\"_v2\",\"_v3\",\"_v4\",\"_v5\",\"_v6\",\"isOperation\",\"isOperationList\",\"DEFAULTS$11\",\"Change\",\"isChange\",\"_object$operations\",\"DEFAULTS$12\",\"getCharOffsetBackward\",\"reverse\",\"getCharOffsetForward\",\"Commands$1.addMarkAtRange\",\"isCollapsed\",\"addMarkByKey\",\"Commands$1.addMarksAtRange\",\"addMarkAtRange\",\"Commands$1.deleteAtRange\",\"snapshotSelection\",\"startKey\",\"startOffset\",\"endKey\",\"endOffset\",\"isStartVoid\",\"isEndVoid\",\"startBlock\",\"endBlock\",\"isHanging\",\"prevText\",\"startVoid\",\"getClosestVoid\",\"nextText\",\"endVoid\",\"_prevText\",\"removeTextByKey\",\"startText\",\"endText\",\"startLength\",\"endLength\",\"getCommonAncestor\",\"startChild\",\"getFurthestChild\",\"endChild\",\"startParent\",\"getParent\",\"startParentIndex\",\"endParentIndex\",\"_index\",\"afters\",\"startChildIndex\",\"endChildIndex\",\"middles\",\"_parent\",\"_index2\",\"befores\",\"onlyChildAncestor\",\"_ref2\",\"moveNodeByKey\",\"Commands$1.deleteBackwardAtRange\",\"voidParent\",\"prevBlock\",\"prevVoid\",\"moveFocusBackward\",\"traversed\",\"Commands$1.deleteCharBackwardAtRange\",\"deleteBackwardAtRange\",\"Commands$1.deleteCharForwardAtRange\",\"deleteForwardAtRange\",\"Commands$1.deleteForwardAtRange\",\"_range3\",\"nextBlock\",\"_nextBlock\",\"nextVoid\",\"moveFocusForward\",\"Commands$1.deleteLineBackwardAtRange\",\"Commands$1.deleteLineForwardAtRange\",\"Commands$1.deleteWordBackwardAtRange\",\"Commands$1.deleteWordForwardAtRange\",\"wordOffset\",\"Commands$1.insertBlockAtRange\",\"startInline\",\"insertionMode\",\"getInsertionMode\",\"siblingText\",\"atEnd\",\"splitRange\",\"splitDescendantsByKey\",\"insertFragmentAtRange\",\"Commands$1.insertFragmentAtRange\",\"fragment\",\"mapDescendants\",\"isAtStart\",\"getBlocks\",\"firstChild\",\"lastChild\",\"firstBlock\",\"lastBlock\",\"insertionNode\",\"findInsertionNode\",\"insertBlockAtRange\",\"hasBlockChildren\",\"lonelyChild\",\"getFurthest\",\"lonelyParent\",\"startIndex\",\"excludingLonelyChild\",\"getNextSibling\",\"nextNodes\",\"skipUntil\",\"lastIndex\",\"findDescendant\",\"inlineChild\",\"inlineIndex\",\"documentKey\",\"ancestorTypesMatch\",\"fragmentAncestors\",\"documentAncestors\",\"fragmentNode\",\"getAncestorBlocks\",\"doc\",\"fragmentStartBlock\",\"deepestSingleBlock\",\"result\",\"matchingFragmentAncestor\",\"depthDifference\",\"fragIdx\",\"docIdx\",\"insertInlineAtRange\",\"Commands$1.insertInlineAtRange\",\"assertDescendant\",\"splitNodeByPath\",\"insertTextAtRange\",\"Commands$1.insertTextAtRange\",\"insertTextByPath\",\"removeMarkAtRange\",\"Commands$1.removeMarkAtRange\",\"setBlocksAtRange\",\"Commands$1.setBlocksAtRange\",\"sets\",\"setInlinesAtRange\",\"Commands$1.setInlinesAtRange\",\"splitBlockAtRange\",\"Commands$1.splitBlockAtRange\",\"height\",\"_range8\",\"h\",\"isBackward\",\"flip\",\"moveAnchorToStartOfNode\",\"setFocus\",\"resolveRange\",\"splitInlineAtRange\",\"Commands$1.splitInlineAtRange\",\"Infinity\",\"toggleMarkAtRange\",\"Commands$1.toggleMarkAtRange\",\"exists\",\"unwrapBlockAtRange\",\"Commands$1.unwrapBlockAtRange\",\"wrappers\",\"getClosest\",\"isSuperset\",\"toOrderedSet\",\"toList\",\"firstMatch\",\"lastMatch\",\"takeUntil\",\"firstText\",\"extra\",\"unwrapInlineAtRange\",\"Commands$1.unwrapInlineAtRange\",\"wrapBlockAtRange\",\"Commands$1.wrapBlockAtRange\",\"clear\",\"firstblock\",\"lastblock\",\"siblings\",\"p1\",\"p2\",\"indexes\",\"ind\",\"wrapInlineAtRange\",\"Commands$1.wrapInlineAtRange\",\"inlineParent\",\"wrapInlineByKey\",\"endInline\",\"endIndex\",\"startInner\",\"startInnerIndex\",\"endInner\",\"startInlines\",\"endInlines\",\"startNode\",\"endNode\",\"wrapTextAtRange\",\"Commands$1.wrapTextAtRange\",\"prefix\",\"suffix\",\"startRange\",\"endRange\",\"moveToEnd\",\"Commands$2.addMarkByPath\",\"addMarksByPath\",\"Commands$2.addMarksByPath\",\"Commands$2.replaceMarksByPath\",\"marksSet\",\"marksToApply\",\"subtract\",\"marksToRemove\",\"Commands$2.insertFragmentByPath\",\"insertNodeByPath\",\"Commands$2.insertNodeByPath\",\"Commands$2.insertTextByPath\",\"replaceMarksByPath\",\"Commands$2.mergeNodeByPath\",\"getPreviousSibling\",\"Commands$2.moveNodeByPath\",\"newParentPath\",\"Commands$2.removeMarkByPath\",\"removeMarksByPath\",\"Commands$2.removeMarksByPath\",\"intersect\",\"Commands$2.removeAllMarksByPath\",\"state\",\"pth\",\"Commands$2.removeNodeByPath\",\"Commands$2.removeTextByPath\",\"Commands$2.replaceNodeByPath\",\"newNode\",\"parentPath\",\"removeNodeByPath\",\"Commands$2.replaceTextByPath\",\"removeTextByPath\",\"Commands$2.setMarkByPath\",\"Commands$2.setNodeByPath\",\"prevProperties\",\"Commands$2.setTextByPath\",\"replaceTextByPath\",\"Commands$2.splitNodeByPath\",\"_options$target\",\"Commands$2.splitDescendantsByPath\",\"textPath\",\"textOffset\",\"lastPath\",\"splitNodeByKey\",\"ancestorPath\",\"_ref4\",\"Commands$2.unwrapInlineByPath\",\"moveToRangeOfNode\",\"Commands$2.unwrapBlockByPath\",\"Commands$2.unwrapNodeByPath\",\"parentIndex\",\"grandPath\",\"isFirst\",\"isLast\",\"moveNodeByPath\",\"updatedPath\",\"Commands$2.unwrapChildrenByPath\",\"childPath\",\"Commands$2.wrapBlockByPath\",\"Commands$2.wrapInlineByPath\",\"Commands$2.wrapNodeByPath\",\"wrapBlockByPath\",\"wrapInlineByPath\",\"COMMANDS\",\"_len3\",\"assertPath\",\"Commands$2.moveNodeByKey\",\"newKey\",\"Commands$2.splitDescendantsByKey\",\"textKey\",\"_len2\",\"splitDescendantsByPath\",\"Commands$3.save\",\"_editor$tmp\",\"save\",\"undos\",\"lastOperation\",\"lastBatch\",\"batch\",\"_batch\",\"takeLast\",\"withoutSaving\",\"redos\",\"newData\",\"setData\",\"Commands$3.redo\",\"_op\",\"Commands$3.undo\",\"Commands$3.withoutMerging\",\"Commands$3.withoutSaving\",\"Commands$4.blur\",\"Commands$4.deselect\",\"Commands$4.focus\",\"Commands$4.flip\",\"Commands$4.moveAnchorBackward\",\"Commands$4.moveAnchorWordBackward\",\"Commands$4.moveAnchorForward\",\"Commands$4.moveAnchorWordForward\",\"_len4\",\"Commands$4.moveAnchorTo\",\"_len5\",\"_key5\",\"Commands$4.moveAnchorToEndOfBlock\",\"Commands$4.moveAnchorToEndOfInline\",\"Commands$4.moveAnchorToEndOfDocument\",\"moveAnchorToEndOfNode\",\"moveToAnchor\",\"Commands$4.moveAnchorToEndOfNextBlock\",\"Commands$4.moveAnchorToEndOfNextInline\",\"Commands$4.moveAnchorToEndOfNextText\",\"Commands$4.moveAnchorToEndOfNode\",\"_len6\",\"_key6\",\"Commands$4.moveAnchorToEndOfPreviousBlock\",\"Commands$4.moveAnchorToEndOfPreviousInline\",\"Commands$4.moveAnchorToEndOfPreviousText\",\"Commands$4.moveAnchorToEndOfText\",\"Commands$4.moveAnchorToStartOfBlock\",\"Commands$4.moveAnchorToStartOfDocument\",\"Commands$4.moveAnchorToStartOfInline\",\"Commands$4.moveAnchorToStartOfNextBlock\",\"Commands$4.moveAnchorToStartOfNextInline\",\"Commands$4.moveAnchorToStartOfNextText\",\"Commands$4.moveAnchorToStartOfNode\",\"_len7\",\"_key7\",\"Commands$4.moveAnchorToStartOfPreviousBlock\",\"Commands$4.moveAnchorToStartOfPreviousInline\",\"Commands$4.moveAnchorToStartOfPreviousText\",\"Commands$4.moveAnchorToStartOfText\",\"Commands$4.moveBackward\",\"charsOffset\",\"moveAnchorBackward\",\"Commands$4.moveWordBackward\",\"_len8\",\"_key8\",\"moveFocusWordBackward\",\"moveToFocus\",\"Commands$4.moveEndBackward\",\"_len9\",\"_key9\",\"Commands$4.moveEndWordBackward\",\"_len10\",\"_key10\",\"Commands$4.moveEndForward\",\"_len11\",\"_key11\",\"Commands$4.moveEndWordForward\",\"_len12\",\"_key12\",\"Commands$4.moveEndTo\",\"_len13\",\"_key13\",\"Commands$4.moveEndToEndOfBlock\",\"Commands$4.moveEndToEndOfDocument\",\"moveEndToEndOfNode\",\"Commands$4.moveEndToEndOfInline\",\"Commands$4.moveEndToEndOfNextBlock\",\"Commands$4.moveEndToEndOfNextInline\",\"Commands$4.moveEndToEndOfNextText\",\"Commands$4.moveEndToEndOfNode\",\"_len14\",\"_key14\",\"Commands$4.moveEndToEndOfPreviousBlock\",\"Commands$4.moveEndToEndOfPreviousInline\",\"Commands$4.moveEndToEndOfPreviousText\",\"Commands$4.moveEndToEndOfText\",\"Commands$4.moveEndToStartOfBlock\",\"Commands$4.moveEndToStartOfDocument\",\"moveEndToStartOfNode\",\"Commands$4.moveEndToStartOfInline\",\"Commands$4.moveEndToStartOfNextBlock\",\"Commands$4.moveEndToStartOfNextInline\",\"Commands$4.moveEndToStartOfNextText\",\"Commands$4.moveEndToStartOfNode\",\"_len15\",\"_key15\",\"Commands$4.moveEndToStartOfPreviousBlock\",\"Commands$4.moveEndToStartOfPreviousInline\",\"Commands$4.moveEndToStartOfPreviousText\",\"Commands$4.moveEndToStartOfText\",\"Commands$4.moveFocusBackward\",\"_len16\",\"_key16\",\"Commands$4.moveFocusWordBackward\",\"_len17\",\"_key17\",\"Commands$4.moveFocusForward\",\"_len18\",\"_key18\",\"Commands$4.moveFocusWordForward\",\"_len19\",\"_key19\",\"Commands$4.moveFocusTo\",\"_len20\",\"_key20\",\"Commands$4.moveFocusToEndOfBlock\",\"Commands$4.moveFocusToEndOfDocument\",\"moveFocusToEndOfNode\",\"Commands$4.moveFocusToEndOfInline\",\"Commands$4.moveFocusToEndOfNextBlock\",\"Commands$4.moveFocusToEndOfNextInline\",\"Commands$4.moveFocusToEndOfNextText\",\"Commands$4.moveFocusToEndOfNode\",\"_len21\",\"_key21\",\"Commands$4.moveFocusToEndOfPreviousBlock\",\"Commands$4.moveFocusToEndOfPreviousInline\",\"Commands$4.moveFocusToEndOfPreviousText\",\"Commands$4.moveFocusToEndOfText\",\"Commands$4.moveFocusToStartOfBlock\",\"Commands$4.moveFocusToStartOfDocument\",\"moveFocusToStartOfNode\",\"Commands$4.moveFocusToStartOfInline\",\"Commands$4.moveFocusToStartOfNextBlock\",\"Commands$4.moveFocusToStartOfNextInline\",\"Commands$4.moveFocusToStartOfNextText\",\"Commands$4.moveFocusToStartOfNode\",\"_len22\",\"_key22\",\"Commands$4.moveFocusToStartOfPreviousBlock\",\"Commands$4.moveFocusToStartOfPreviousInline\",\"Commands$4.moveFocusToStartOfPreviousText\",\"Commands$4.moveFocusToStartOfText\",\"Commands$4.moveForward\",\"moveAnchorForward\",\"Commands$4.moveWordForward\",\"_editor$moveFocusWord\",\"_len23\",\"_key23\",\"moveFocusWordForward\",\"Commands$4.moveStartBackward\",\"_len24\",\"_key24\",\"Commands$4.moveStartWordBackward\",\"_len25\",\"_key25\",\"Commands$4.moveStartForward\",\"_len26\",\"_key26\",\"Commands$4.moveStartWordForward\",\"_len27\",\"_key27\",\"Commands$4.moveStartTo\",\"_len28\",\"_key28\",\"Commands$4.moveStartToEndOfBlock\",\"Commands$4.moveStartToEndOfDocument\",\"moveStartToEndOfNode\",\"Commands$4.moveStartToEndOfInline\",\"Commands$4.moveStartToEndOfNextBlock\",\"Commands$4.moveStartToEndOfNextInline\",\"Commands$4.moveStartToEndOfNextText\",\"Commands$4.moveStartToEndOfNode\",\"_len29\",\"_key29\",\"Commands$4.moveStartToEndOfPreviousBlock\",\"Commands$4.moveStartToEndOfPreviousInline\",\"Commands$4.moveStartToEndOfPreviousText\",\"Commands$4.moveStartToEndOfText\",\"Commands$4.moveStartToStartOfBlock\",\"Commands$4.moveStartToStartOfDocument\",\"moveStartToStartOfNode\",\"Commands$4.moveStartToStartOfInline\",\"Commands$4.moveStartToStartOfNextBlock\",\"Commands$4.moveStartToStartOfNextInline\",\"Commands$4.moveStartToStartOfNextText\",\"Commands$4.moveStartToStartOfNode\",\"_len30\",\"_key30\",\"Commands$4.moveStartToStartOfPreviousBlock\",\"Commands$4.moveStartToStartOfPreviousInline\",\"Commands$4.moveStartToStartOfPreviousText\",\"Commands$4.moveStartToStartOfText\",\"Commands$4.moveTo\",\"_len31\",\"_key31\",\"Commands$4.moveToAnchor\",\"Commands$4.moveToEnd\",\"Commands$4.moveToEndOfBlock\",\"moveEndToEndOfBlock\",\"Commands$4.moveToEndOfDocument\",\"Commands$4.moveToEndOfInline\",\"moveEndToEndOfInline\",\"Commands$4.moveToEndOfNextBlock\",\"moveEndToEndOfNextBlock\",\"Commands$4.moveToEndOfNextInline\",\"moveEndToEndOfNextInline\",\"Commands$4.moveToEndOfNextText\",\"moveEndToEndOfNextText\",\"Commands$4.moveToEndOfNode\",\"_len32\",\"_key32\",\"Commands$4.moveToEndOfPreviousBlock\",\"moveStartToEndOfPreviousBlock\",\"Commands$4.moveToEndOfPreviousInline\",\"moveStartToEndOfPreviousInline\",\"Commands$4.moveToEndOfPreviousText\",\"moveStartToEndOfPreviousText\",\"Commands$4.moveToEndOfText\",\"moveEndToEndOfText\",\"Commands$4.moveToFocus\",\"Commands$4.moveToRangeOfDocument\",\"Commands$4.moveToRangeOfNode\",\"_len33\",\"_key33\",\"Commands$4.moveToStart\",\"Commands$4.moveToStartOfBlock\",\"moveStartToStartOfBlock\",\"Commands$4.moveToStartOfDocument\",\"Commands$4.moveToStartOfInline\",\"moveStartToStartOfInline\",\"Commands$4.moveToStartOfNextBlock\",\"moveEndToStartOfNextBlock\",\"Commands$4.moveToStartOfNextInline\",\"moveEndToStartOfNextInline\",\"Commands$4.moveToStartOfNextText\",\"moveEndToStartOfNextText\",\"Commands$4.moveToStartOfNode\",\"_len34\",\"_key34\",\"Commands$4.moveToStartOfPreviousBlock\",\"moveStartToStartOfPreviousBlock\",\"Commands$4.moveToStartOfPreviousInline\",\"moveStartToStartOfPreviousInline\",\"Commands$4.moveToStartOfPreviousText\",\"moveStartToStartOfPreviousText\",\"Commands$4.moveToStartOfText\",\"moveStartToStartOfText\",\"Commands$4.select\",\"_options$snapshot\",\"snapshot\",\"k\",\"skip\",\"Commands$4.setAnchor\",\"_len35\",\"_key35\",\"Commands$4.setEnd\",\"_len36\",\"_key36\",\"Commands$4.setFocus\",\"_len37\",\"_key37\",\"Commands$4.setStart\",\"_len38\",\"_key38\",\"Commands$4.snapshotSelection\",\"withoutMerging\",\"Commands$5.setData\",\"Commands$5.addAnnotation\",\"Commands$5.removeAnnotation\",\"Commands$5.setAnnotation\",\"Commands$5.setAnnotations\",\"_Error\",\"_this\",\"captureStackTrace\",\"stack\",\"Commands$6.addMark\",\"_marks\",\"_sel\",\"Commands$6.addMarks\",\"Commands$6.delete\",\"Commands$6.deleteBackward\",\"Commands$6.deleteCharBackward\",\"deleteCharBackwardAtRange\",\"Commands$6.deleteLineBackward\",\"deleteLineBackwardAtRange\",\"Commands$6.deleteWordBackward\",\"deleteWordBackwardAtRange\",\"Commands$6.deleteForward\",\"Commands$6.deleteCharForward\",\"deleteCharForwardAtRange\",\"Commands$6.deleteLineForward\",\"deleteLineForwardAtRange\",\"Commands$6.deleteWordForward\",\"deleteWordForwardAtRange\",\"Commands$6.insertBlock\",\"Commands$6.insertFragment\",\"_ref\",\"newTexts\",\"includes\",\"fragmentLength\",\"Commands$6.insertInline\",\"Commands$6.insertText\",\"getInsertMarksAtRange\",\"Commands$6.removeMark\",\"_marks2\",\"_sel2\",\"Commands$6.replaceMark\",\"oldMark\",\"Commands$6.setBlocks\",\"Commands$6.setInlines\",\"Commands$6.splitBlock\",\"depth\",\"Commands$6.splitInline\",\"Commands$6.toggleMark\",\"activeMarks\",\"Commands$6.unwrapBlock\",\"Commands$6.unwrapInline\",\"Commands$6.wrapBlock\",\"Commands$6.wrapInline\",\"Commands$6.wrapText\",\"moveStartBackward\",\"moveEndBackward\",\"isForward\",\"debug$2\",\"Editor\",\"_options$controller\",\"_options$construct\",\"construct\",\"_attrs$onChange\",\"onChange\",\"_attrs$plugins\",\"_attrs$readOnly\",\"readOnly\",\"_attrs$value\",\"flushing\",\"core\",\"run\",\"setReadOnly\",\"setValue\",\"newDirtyPaths\",\"transformed\",\"pathIndex\",\"dirtyPaths\",\"dirtyPath\",\"join\",\"Promise\",\"resolve\",\"then\",\"flush\",\"hasCommand\",\"__command\",\"hasQuery\",\"__query\",\"moveToStartOfDocument\",\"_this2\",\"_this3\",\"fns\",\"overrides\",\"_options$normalize\",\"applyOperations\",\"_this4\",\"setOperationFlag\",\"getFlag\",\"unsetOperationFlag\",\"withoutNormalization\",\"Leaf$1\",\"updateMark\",\"newMarks\",\"collection\",\"set$$1\",\"isLeaf\",\"createLeaves\",\"invalid\",\"cache\",\"findLast\",\"firstLeaf\",\"unshift\",\"splitLeaves\",\"left\",\"right\",\"of\",\"take\",\"isLeafList\",\"DEFAULTS$13\",\"entries\",\"camel\",\"toLowerCase\",\"ModelInterface\",\"NodeInterface\",\"descendant\",\"nested\",\"descendants\",\"_path\",\"dict\",\"getText\",\"memo\",\"c\",\"normalizer\",\"validate\",\"global$1\",\"window\",\"ElementInterface\",\"replaceNode\",\"createIterable\",\"iterable\",\"direction\",\"downward\",\"includeTargetAncestors\",\"includeRoot\",\"onlyLeaves\",\"onlyRoots\",\"onlyTypes\",\"_match\",\"includeDocument\",\"includeInlines\",\"includeTexts\",\"isLeafBlock\",\"createDecoration\",\"resolveDecoration\",\"_options$direction\",\"_options$downward\",\"_options$upward\",\"upward\",\"_options$includeBlock\",\"includeBlocks\",\"_options$includeDocum\",\"_options$includeInlin\",\"_options$includeRoot\",\"_options$includeTarge\",\"includeTarget\",\"_options$includeTarge2\",\"_options$includeTexts\",\"root\",\"targetPath\",\"targetRange\",\"targetNode\",\"NativeSet\",\"visited\",\"startPath\",\"endPath\",\"includedTarget\",\"includedStart\",\"includingStart\",\"nextIndex\",\"_newPath\",\"_newNode\",\"createPoint\",\"resolvePoint\",\"createRange\",\"filterDescendants\",\"predicate\",\"_ref3\",\"_ref5\",\"forEachDescendant\",\"getInsertMarksAtPoint\",\"_texts\",\"_texts2\",\"_texts2$\",\"_texts3\",\"_texts4\",\"_texts4$\",\"startMarks\",\"_texts5\",\"_texts6\",\"_texts6$\",\"_texts7\",\"_texts8\",\"_texts8$\",\"_ref6\",\"_ref7\",\"_ref8\",\"_ref9\",\"getBlocksByType\",\"_ref10\",\"_ref11\",\"getChild\",\"_ref13\",\"closest\",\"getDecorations\",\"getDepth\",\"startAt\",\"getIn\",\"getDescendantsAtRange\",\"_ref14\",\"_ref15\",\"targetPosition\",\"results\",\"_ref17\",\"getFurthestBlock\",\"furthest\",\"getFurthestInline\",\"getInlines\",\"_ref18\",\"_ref19\",\"getInlinesByType\",\"_ref20\",\"_ref21\",\"blockPath\",\"blockNode\",\"_iteratorNormalCompletion6\",\"_didIteratorError6\",\"_iteratorError6\",\"_iterator6\",\"_step6\",\"_entry\",\"relativePath\",\"_blockNode$texts\",\"_blockNode$texts2\",\"_previous\",\"previousText\",\"_ref22\",\"_ref23\",\"_ref24\",\"_ref25\",\"getNodesToPathsMap\",\"_ref26\",\"_ref27\",\"OrderedSet\",\"_ref28\",\"_ref29\",\"getMarksByType\",\"_ref30\",\"_ref31\",\"_blocks\",\"entry\",\"_blocks2\",\"getNextNode\",\"_iterable\",\"_siblings\",\"_siblings2\",\"_texts9\",\"_texts10\",\"getOffsetAtRange\",\"_blocks3\",\"_blocks4\",\"getPreviousNode\",\"_iterable2\",\"_siblings3\",\"_siblings4\",\"_texts11\",\"_texts12\",\"getRootBlocksAtRange\",\"_ref32\",\"_ref33\",\"getRootInlinesAtRange\",\"_ref34\",\"_ref35\",\"_iteratorNormalCompletion7\",\"_didIteratorError7\",\"_iteratorError7\",\"_iterator7\",\"_step7\",\"_ref37\",\"getTextDirection\",\"dir\",\"_ref38\",\"_ref39\",\"_ref40\",\"_ref41\",\"hasChild\",\"hasInlineChildren\",\"_match2\",\"isLeafInline\",\"splice\",\"toStart\",\"toEnd\",\"mapChildren\",\"_options$onlyTypes\",\"_iterator$next\",\"deep\",\"flatMap\",\"x\",\"deleteIn\",\"setIn\",\"_child$splitText\",\"_child$splitText2\",\"getBlocksAtRange\",\"getBlocksAtRangeAsArray\",\"getLeafBlocksAtRangeAsArray\",\"getInlinesAtRange\",\"getInlinesAtRangeAsArray\",\"getLeafInlinesAtRangeAsArray\",\"getNextTextAndPath\",\"getNextTextEntry\",\"getNextDeepMatchingNodeAndPath\",\"getNextMatchingNodeAndPath\",\"_match3\",\"nextNode\",\"childMatch\",\"findFirstDescendantAndPath\",\"_childMatch2\",\"getPreviousTextAndPath\",\"getPreviousTextEntry\",\"pathToThisNode\",\"findDescendantAndPath\",\"getPreviousMatchingNodeAndPath\",\"previousNode\",\"getPreviousDeepMatchingNodeAndPath\",\"_match4\",\"findLastDescendantAndPath\",\"_childMatch4\",\"foundPath\",\"forEachDescendantWithPath\",\"getSelectionIndexes\",\"isSelected\",\"getFurthestAncestor\",\"getTextsBetweenPositionsAsArray\",\"getTextsBetweenPathPositionsAsArray\",\"getOrderedMarksBetweenPositions\",\"getTextsAsArray\",\"childStartPath\",\"childEndPath\",\"getLeafBlocksBetweenPathPositionsAsArray\",\"_range6\",\"getBlocksAsArray\",\"_ref43\",\"_ref44\",\"getBlocksByTypeAsArray\",\"_ref45\",\"_ref46\",\"getFurthestOnlyChildAncestor\",\"getInlinesAsArray\",\"_ref47\",\"_ref48\",\"getInlinesByTypeAsArray\",\"_ref49\",\"_ref50\",\"getTextsAtRangeAsArray\",\"getOrderedMarks\",\"getOrderedMarksAtRange\",\"getOrderedMarksByType\",\"getMarksByTypeAsArray\",\"getMarksAsArray\",\"_ref53\",\"_iteratorNormalCompletion8\",\"_didIteratorError8\",\"_iteratorError8\",\"_iterator8\",\"_step8\",\"_ref52\",\"getRootInlinesAtRangeAsArray\",\"_this5\",\"_ref54\",\"_ref55\",\"_ref56\",\"_ref57\",\"getMarksAtPosition\",\"currentMarks\",\"closestBlock\",\"_texts13\",\"_texts14\",\"_previous2\",\"getNodesAtRange\",\"_ref58\",\"_ref59\",\"isNodeInRange\",\"ASSERTS\",\"_loop$1\",\"_iteratorNormalCompletion9\",\"_didIteratorError9\",\"_iteratorError9\",\"_iterator9\",\"_step9\",\"RangeInterface\",\"setPoints\",\"setAnchor\",\"setEnd\",\"moveEndForward\",\"moveEndTo\",\"setStart\",\"moveStartForward\",\"moveStartTo\",\"_values\",\"updater\",\"toRange\",\"default\"]\n}\n"]