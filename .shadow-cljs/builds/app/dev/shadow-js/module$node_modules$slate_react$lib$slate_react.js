["^ ","~:resource-id",["~:shadow.build.npm/resource","node_modules/slate-react/lib/slate-react.js"],"~:js","shadow$provide.module$node_modules$slate_react$lib$slate_react=function(global,require,module,exports){function _interopDefault(ex){return ex&&\"object\"===typeof ex&&\"default\"in ex?ex[\"default\"]:ex}function getRelativeRange(node,index,range){if(range.isUnset)return null;var child=node.nodes.get(index),_range=range;node=_range.start;_range=_range.end;var startPath=node.path,endPath=_range.path,startIndex=startPath.first(),endIndex=endPath.first();if(startIndex===index)node=node.setPath(startPath.rest());\nelse if(startIndex<index&&index<=endIndex)if(\"text\"===child.object)node=node.moveTo(slate.PathUtils.create([index]),0).setKey(child.key);else{startPath=child.texts();startPath=slicedToArray(startPath,1)[0];startPath=slicedToArray(startPath,2);var firstNode=startPath[0];node=node.moveTo(startPath[1],0).setKey(firstNode.key)}else node=null;endIndex===index?_range=_range.setPath(endPath.rest()):startIndex<=index&&index<endIndex?\"text\"===child.object?(endPath=child.text.length,_range=_range.moveTo(slate.PathUtils.create([index]),\nendPath).setKey(child.key)):(index=child.texts({direction:\"backward\"}),index=slicedToArray(index,1)[0],index=slicedToArray(index,2),child=index[0],_range=_range.moveTo(index[1],child.text.length).setKey(child.key)):_range=null;if(!node||!_range)return null;range=range.setAnchor(node);return range=range.setFocus(_range)}function scrollToSelection(selection){if(!IS_IOS_11&&selection.anchorNode){var window=getWindow(selection.anchorNode);var scroller=selection.anchorNode.parentNode;for(var scroller$jscomp$0=\nvoid 0;!scroller$jscomp$0&&scroller.parentNode;){var overflowY=window.getComputedStyle(scroller).overflowY;if(OVERFLOWS.includes(overflowY)){scroller$jscomp$0=scroller;break}scroller=scroller.parentNode}scroller=scroller$jscomp$0?scroller$jscomp$0:window.document.body;scroller$jscomp$0=scroller===window.document.body||scroller===window.document.documentElement;overflowY=isBackward(selection);var range=selection.getRangeAt(0).cloneRange();range.collapse(overflowY);selection=range.getBoundingClientRect();\nslateDevEnvironment.IS_SAFARI&&range.collapsed&&0===selection.top&&0===selection.height&&(0===range.startOffset?range.setEnd(range.endContainer,1):range.setStart(range.startContainer,range.startOffset-1),selection=range.getBoundingClientRect(),0===selection.top&&0===selection.height&&range.getClientRects().length&&(selection=range.getClientRects()[0]));var scrollerTop=0,scrollerLeft=0,scrollerBordersY=0,scrollerBordersX=0,scrollerPaddingTop=0,scrollerPaddingBottom=0,scrollerPaddingLeft=0,scrollerPaddingRight=\n0;if(scroller$jscomp$0){range=window.innerHeight;var yOffset=window.pageYOffset;var xOffset=window.pageXOffset;overflowY=window.innerWidth}else{overflowY=scroller.offsetWidth;range=scroller.offsetHeight;yOffset=scroller.scrollTop;xOffset=scroller.scrollLeft;scrollerTop=window.getComputedStyle(scroller);scrollerBordersY=scrollerTop.borderTopWidth;var borderBottomWidth=scrollerTop.borderBottomWidth;scrollerBordersX=scrollerTop.borderLeftWidth;var borderRightWidth=scrollerTop.borderRightWidth;scrollerPaddingTop=\nscrollerTop.paddingTop;scrollerPaddingBottom=scrollerTop.paddingBottom;scrollerPaddingLeft=scrollerTop.paddingLeft;scrollerPaddingRight=scrollerTop.paddingRight;scrollerLeft=scroller.getBoundingClientRect();scrollerTop=scrollerLeft.top+parseInt(scrollerBordersY,10);scrollerLeft=scrollerLeft.left+parseInt(scrollerBordersX,10);scrollerBordersY=parseInt(scrollerBordersY,10)+parseInt(borderBottomWidth,10);scrollerBordersX=parseInt(scrollerBordersX,10)+parseInt(borderRightWidth,10);scrollerPaddingTop=\nparseInt(scrollerPaddingTop,10);scrollerPaddingBottom=parseInt(scrollerPaddingBottom,10);scrollerPaddingLeft=parseInt(scrollerPaddingLeft,10);scrollerPaddingRight=parseInt(scrollerPaddingRight,10)}scrollerTop=selection.top+yOffset-scrollerTop;scrollerLeft=selection.left+xOffset-scrollerLeft;borderRightWidth=xOffset;borderBottomWidth=yOffset;scrollerLeft<xOffset?borderRightWidth=scrollerLeft-scrollerPaddingLeft:scrollerLeft+selection.width+scrollerBordersX>xOffset+overflowY&&(borderRightWidth=scrollerLeft+\nscrollerBordersX+scrollerPaddingRight-overflowY);scrollerTop<yOffset?borderBottomWidth=scrollerTop-scrollerPaddingTop:scrollerTop+selection.height+scrollerBordersY>yOffset+range&&(borderBottomWidth=scrollerTop+scrollerBordersY+scrollerPaddingBottom+selection.height-range);scroller$jscomp$0?window.scrollTo(borderRightWidth,borderBottomWidth):(scroller.scrollTop=borderBottomWidth,scroller.scrollLeft=borderRightWidth)}}function removeAllRanges(domSelection){slateDevEnvironment.IS_IE?(domSelection=window.document.body.createTextRange(),\ndomSelection.collapse(),domSelection.select()):domSelection.removeAllRanges()}function EditorPropsPlugin(){var options=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{};return PROPS.reduce(function(memo,prop){prop in options&&(memo[prop]=options[prop]);return memo},{})}function Rendering(){return{decorateNode:function(){return[]},renderAnnotation:function(_ref){return React.createElement(\"span\",_ref.attributes,_ref.children)},renderBlock:function(_ref2){var children=_ref2.children;return React.createElement(\"div\",\n_extends({},_ref2.attributes,{style:{position:\"relative\"}}),children)},renderDecoration:function(_ref3){return React.createElement(\"span\",_ref3.attributes,_ref3.children)},renderDocument:function(_ref4){return _ref4.children},renderEditor:function(_ref5){return _ref5.children},renderInline:function(_ref6){var children=_ref6.children;return React.createElement(\"span\",_extends({},_ref6.attributes,{style:{position:\"relative\"}}),children)},renderMark:function(_ref7){return React.createElement(\"span\",\n_ref7.attributes,_ref7.children)}}}function CommandsPlugin(){return{commands:{reconcileNode:function(editor,node){var value=editor.value,document=value.document;value=value.selection;var path=document.getPath(node.key),domElement=editor.findDOMNode(path),block=document.getClosestBlock(path),text=node.text;domElement=domElement.textContent;block=block.nodes.last()===node;var lastChar=domElement.charAt(domElement.length-1);block&&\"\\n\"===lastChar&&(domElement=domElement.slice(0,-1));text!==domElement&&\n(value=value.moveAnchorTo(path,0).moveFocusTo(path,text.length),value=document.resolveRange(value),editor.insertTextAtRange(value,domElement,node.marks))},reconcileDOMNode:function(editor,domNode){domNode=domNode.parentElement.closest(\"[data-key]\");domNode=editor.findNode(domNode);editor.reconcileNode(domNode)}}}}function QueriesPlugin(){return{queries:{findDOMNode:function(editor,path){path=slate.PathUtils.create(path);return(editor=editor.tmp.contentRef.current)?path.size?function search(instance,\np){if(!instance)return null;if(!p.size)return instance.ref?instance.ref.current||null:instance||null;var index=p.first();p=p.rest();return search(instance.tmp.nodeRefs[index],p)}(editor.tmp.nodeRef.current,path):editor.ref.current||null:null},findDOMPoint:function(editor,point){var el=editor.findDOMNode(point.path);editor=0;if(!el)return null;var texts=Array.from(el.querySelectorAll(SELECTORS.STRING+\", \"+SELECTORS.ZERO_WIDTH));el=!0;var _didIteratorError=!1,_iteratorError=void 0;try{for(var _iterator=\ntexts[Symbol.iterator](),_step;!(el=(_step=_iterator.next()).done);el=!0){var text=_step.value,node=text.childNodes[0],domLength=node.textContent.length;texts=domLength;text.hasAttribute(DATA_ATTRS.LENGTH)&&(texts=parseInt(text.getAttribute(DATA_ATTRS.LENGTH),10));texts=editor+texts;if(point.offset<=texts)return{node:node,offset:Math.min(domLength,Math.max(0,point.offset-editor))};editor=texts}}catch(err){_didIteratorError=!0,_iteratorError=err}finally{try{!el&&_iterator.return&&_iterator.return()}finally{if(_didIteratorError)throw _iteratorError;\n}}return null},findDOMRange:function(editor,range){var focus=range.focus,isBackward$$1=range.isBackward,isCollapsed=range.isCollapsed;range=editor.findDOMPoint(range.anchor);isCollapsed=isCollapsed?range:editor.findDOMPoint(focus);if(!range||!isCollapsed)return null;editor=getWindow(range.node).document.createRange();focus=isBackward$$1?isCollapsed:range;isBackward$$1=isBackward$$1?range:isCollapsed;editor.setStart(focus.node,focus.offset);editor.setEnd(isBackward$$1.node,isBackward$$1.offset);return editor},\nfindEventRange:function(editor,event){event.nativeEvent&&(event=event.nativeEvent);var _event=event,x=_event.clientX,y=_event.clientY,target=_event.target;if(null==x||null==y)return null;_event=editor.value.document;event=editor.findPath(event.target);if(!event)return null;var node=_event.getNode(event);if(editor.isVoid(node))return editor=target.getBoundingClientRect(),y=\"inline\"===node.object?x-editor.left<editor.left+editor.width-x:y-editor.top<editor.top+editor.height-y,editor=_event.createRange(),\nx=y?\"moveToEndOfNode\":\"moveToStartOfNode\",(y=_event[y?\"getPreviousText\":\"getNextText\"](event))?editor[x](y):null;_event=getWindow(target);event=void 0;if(_event.document.caretRangeFromPoint)event=_event.document.caretRangeFromPoint(x,y);else if(_event.document.caretPositionFromPoint)x=_event.document.caretPositionFromPoint(x,y),event=_event.document.createRange(),event.setStart(x.offsetNode,x.offset),event.setEnd(x.offsetNode,x.offset);else if(_event.document.body.createTextRange){event=_event.document.body.createTextRange();\ntry{event.moveToPoint(x,y)}catch(error){return null}}return editor.findRange(event)},findNode:function(editor,element){return(element=editor.findPath(element))?editor.value.document.getNode(element):null},findPath:function(editor,element){editor=editor.tmp.contentRef.current;var nodeElement=element;nodeElement.hasAttribute(DATA_ATTRS.KEY)||(nodeElement=nodeElement.closest(SELECTORS.KEY));return nodeElement&&nodeElement.getAttribute(DATA_ATTRS.KEY)?nodeElement===editor.ref.current?slate.PathUtils.create([]):\n(element=function search(instance,p){if(nodeElement===instance)return p;if(!instance.ref)return null;if(nodeElement===instance.ref.current)return p;if(!instance.tmp)return null;instance=instance.tmp.nodeRefs;var keys=Object.keys(instance),_iteratorNormalCompletion2=!0,_didIteratorError2=!1,_iteratorError2=void 0;try{for(var _iterator2=keys[Symbol.iterator](),_step2;!(_iteratorNormalCompletion2=(_step2=_iterator2.next()).done);_iteratorNormalCompletion2=!0){var i=_step2.value,ref=instance[i],n=parseInt(i,\n10),_path=search(ref,[].concat(toConsumableArray(p),[n]));if(_path)return _path}}catch(err){_didIteratorError2=!0,_iteratorError2=err}finally{try{!_iteratorNormalCompletion2&&_iterator2.return&&_iterator2.return()}finally{if(_didIteratorError2)throw _iteratorError2;}}return null}(editor.tmp.nodeRef.current,[]))?slate.PathUtils.create(element):null:null},findPoint:function(editor,nativeNode,nativeOffset){var _normalizeNodeAndOffs=normalizeNodeAndOffset(nativeNode,nativeOffset);nativeOffset=_normalizeNodeAndOffs.node;\nvar nearestOffset=_normalizeNodeAndOffs.offset,window=getWindow(nativeNode);nativeNode=nativeOffset.parentNode;var leafNode=nativeNode.closest(SELECTORS.LEAF),offset=_normalizeNodeAndOffs=void 0,node=void 0;if(leafNode)_normalizeNodeAndOffs=leafNode.closest(SELECTORS.TEXT),offset=window.document.createRange(),offset.setStart(_normalizeNodeAndOffs,0),offset.setEnd(nativeOffset,nearestOffset),nativeOffset=offset.cloneContents(),nearestOffset=nativeOffset.querySelectorAll(SELECTORS.ZERO_WIDTH),Array.from(nearestOffset).forEach(function(el){el.parentNode.removeChild(el)}),\noffset=nativeOffset.textContent.length,node=_normalizeNodeAndOffs;else{nativeOffset=nativeNode.closest(SELECTORS.VOID);if(!nativeOffset)return null;leafNode=nativeOffset.querySelector(SELECTORS.LEAF);if(!leafNode)return null;_normalizeNodeAndOffs=leafNode.closest(SELECTORS.TEXT);node=leafNode;offset=node.textContent.length}offset===node.textContent.length&&nativeNode.hasAttribute(DATA_ATTRS.ZERO_WIDTH)&&offset--;return(nativeNode=editor.findPath(_normalizeNodeAndOffs))?editor.value.document.createPoint({path:nativeNode,\noffset:offset}):null},findRange:function(editor,domRange){var el=domRange.anchorNode||domRange.startContainer;if(!el)return null;el=getWindow(el);if(domRange instanceof el.Range||el.StaticRange&&domRange instanceof el.StaticRange)domRange={anchorNode:domRange.startContainer,anchorOffset:domRange.startOffset,focusNode:domRange.endContainer,focusOffset:domRange.endOffset};var _domRange=domRange;el=_domRange.focusNode;var focusOffset=_domRange.focusOffset,isCollapsed=_domRange.isCollapsed;domRange=editor.value;\n_domRange=editor.findPoint(_domRange.anchorNode,_domRange.anchorOffset);editor=isCollapsed?_domRange:editor.findPoint(el,focusOffset);return _domRange&&editor?domRange.document.createRange({anchor:_domRange,focus:editor}):null},findSelection:function(editor,domSelection){var value=editor.value,document=value.document;if(!domSelection.rangeCount)return null;domSelection=editor.findRange(domSelection);if(!domSelection)return null;var _range2=domSelection,anchor=_range2.anchor;_range2=_range2.focus;\nvar anchorText=document.getNode(anchor.path),focusText=document.getNode(_range2.path),anchorInline=document.getClosestInline(anchor.path),focusInline=document.getClosestInline(_range2.path),focusBlock=document.getClosestBlock(_range2.path),anchorBlock=document.getClosestBlock(anchor.path);anchorBlock&&!editor.isVoid(anchorBlock)&&0===anchor.offset&&focusBlock&&editor.isVoid(focusBlock)&&0!==_range2.offset&&(domSelection=domSelection.setFocus(_range2.setOffset(0)));anchorInline&&!editor.isVoid(anchorInline)&&\nanchor.offset===anchorText.text.length&&(anchorInline=document.getClosestBlock(anchor.path),anchorText=document.getDepth(anchorInline.key),focusBlock=slate.PathUtils.drop(anchor.path,anchorText),anchorInline=anchorInline.texts({path:focusBlock}),anchorInline=slicedToArray(anchorInline,1)[0])&&(anchorInline=slicedToArray(anchorInline,2)[1],anchor=anchor.path.slice(0,anchorText).concat(anchorInline),domSelection=domSelection.moveAnchorTo(anchor,0));focusInline&&!editor.isVoid(focusInline)&&_range2.offset===\nfocusText.text.length&&(anchor=document.getClosestBlock(_range2.path),editor=document.getDepth(anchor.key),focusText=slate.PathUtils.drop(_range2.path,editor),anchor=anchor.texts({path:focusText}),anchor=slicedToArray(anchor,1)[0])&&(anchor=slicedToArray(anchor,2)[1],_range2=_range2.path.slice(0,editor).concat(anchor),domSelection=domSelection.moveFocusTo(_range2,0));document=document.createSelection(domSelection);document=document.setIsFocused(!0);return document=document.set(\"marks\",value.selection.marks)}}}}\nfunction normalizeNodeAndOffset(node,offset){if(1===node.nodeType&&node.childNodes.length){var isLast=offset===node.childNodes.length,direction=isLast?\"backward\":\"forward\";for(node=getEditableChild(node,isLast?offset-1:offset,direction);1===node.nodeType&&node.childNodes.length;)node=getEditableChild(node,isLast?node.childNodes.length-1:0,direction);offset=isLast?node.textContent.length:0}return{node:node,offset:offset}}function getEditableChild(parent,index,direction){parent=parent.childNodes;for(var child=\nparent[index],i=index,triedForward=!1,triedBackward=!1;(8===child.nodeType||1===child.nodeType&&0===child.childNodes.length||1===child.nodeType&&\"false\"===child.getAttribute(\"contenteditable\"))&&(!triedForward||!triedBackward);)i>=parent.length?(triedForward=!0,i=index-1,direction=\"backward\"):0>i?(triedBackward=!0,i=index+1,direction=\"forward\"):(child=parent[i],\"forward\"===direction&&i++,\"backward\"===direction&&i--);return child||null}function renderSync(editor,fn){flushControlled(function(){fn();\neditor.controller.flush()})}function fixTextAndOffset(prevText){for(var isLastNode=2<arguments.length&&void 0!==arguments[2]?arguments[2]:!1,nextOffset=1<arguments.length&&void 0!==arguments[1]?arguments[1]:0,nextText=prevText,index=0;-1!==index;){index=nextText.indexOf(ZERO_WIDTH_SPACE,index);if(-1===index)break;nextOffset>index&&nextOffset--;nextText=\"\"+nextText.slice(0,index)+nextText.slice(index+1)}index=nextText.charAt(nextText.length-1);isLastNode&&\"\\n\"===index&&(nextText=nextText.slice(0,-1));\nisLastNode=nextText.length;nextOffset>isLastNode&&(nextOffset=isLastNode);return{text:nextText,offset:nextOffset}}function CompositionManager(editor){function clearAction(){debug$3(\"clearAction\");last.diff=null;last.domNode=null}function applyDiff(){debug$3(\"applyDiff\");var diff$$1=last.diff;if(null!=diff$$1){debug$3(\"applyDiff:run\");var document=editor.value.document,entire=editor.value.selection.moveAnchorTo(diff$$1.path,diff$$1.start).moveFocusTo(diff$$1.path,diff$$1.end);entire=document.resolveRange(entire);\neditor.insertTextAtRange(entire,diff$$1.insertText)}}function splitBlock(){debug$3(\"splitBlock\");renderSync(editor,function(){applyDiff();last.range?editor.select(last.range):debug$3(\"splitBlock:NO-SELECTION\");editor.splitBlock().focus().restoreDOM();clearAction()})}function mergeBlock(){debug$3(\"mergeBlock\");win.requestAnimationFrame(function(){renderSync(editor,function(){applyDiff();editor.select(last.range).deleteBackward().focus().restoreDOM();clearAction()})})}function startAction(){onSelectTimeoutId&&\n(window.cancelAnimationFrame(onSelectTimeoutId),onSelectTimeoutId=null);isFlushing=!0;startActionFrameId&&window.cancelAnimationFrame(startActionFrameId);startActionFrameId=window.requestAnimationFrame(function(){0<bufferedMutations.length&&flushAction(bufferedMutations);startActionFrameId=null;bufferedMutations=[];isFlushing=!1})}function flushAction(mutations){debug$3(\"flushAction\",mutations.length,mutations);if(last.range&&!last.range.isCollapsed)renderSync(editor,function(){editor.select(last.range).deleteBackward().focus().restoreDOM()});\nelse if(1<mutations.length&&mutations.find(function(m){if(\"childList\"!==m.type||0===m.addedNodes.length)return!1;m=m.addedNodes[0];if(m.nodeType===window.Node.TEXT_NODE&&\"\\n\"===m.textContent)return!0;if(m.nodeType!==window.Node.ELEMENT_NODE)return!1;m=m.dataset.key;return null==m?!1:!!editor.value.document.getClosestBlock(m)}))splitBlock();else{var firstMutation=mutations[0];\"characterData\"===firstMutation.type?resolveDOMNode(firstMutation.target.parentNode):\"childList\"===firstMutation.type&&(0<firstMutation.removedNodes.length?\n1===mutations.length?removeNode(firstMutation.removedNodes[0]):mergeBlock():0<firstMutation.addedNodes.length&&splitBlock())}}function resolveDOMNode(domNode){debug$3(\"resolveDOMNode\");var document=editor.value.document,key=domNode.closest(\"[data-key]\").dataset.key,path=document.getPath(key),block=document.getClosestBlock(key);key=document.getDescendant(key);document=key.text;block=block.nodes.last()===key;domNode=fixTextAndOffset(domNode.textContent,0,block).text;if(domNode===document)last.diff=\nnull;else{if(document===domNode)block=null;else{c:{block=Math.min(document.length,domNode.length);for(key=0;key<block;key++)if(document.charAt(key)!==domNode.charAt(key)){block=key;break c}block=document.length!==domNode.length?block:null}c:{key=document.length;for(var nextLength=domNode.length,length=Math.min(key,nextLength,Math.min(document.length-block,domNode.length-block)),i=0;i<length;i++){var prevChar=document.charAt(key-i-1),nextChar=domNode.charAt(nextLength-i-1);if(prevChar!==nextChar){key=\ni;break c}}key=document.length!==domNode.length?length:null}block={start:block,end:key,total:block+key}}null==block?document=null:(domNode=domNode.slice(block.start,domNode.length-block.end),key=document.slice(block.start,document.length-block.end),document={start:block.start,end:document.length-block.end,cursor:block.start+domNode.length,insertText:domNode,removeText:key});last.diff={path:path,start:document.start,end:document.end,insertText:document.insertText};debug$3(\"resolveDOMNode:diff\",last.diff)}}\nfunction removeNode(domNode){debug$3(\"removeNode\");if(domNode.nodeType===window.Node.ELEMENT_NODE){var value=editor.value,document=value.document;value=value.selection;domNode=editor.findNode(domNode);var nodeSelection=document.resolveRange(value.moveToRangeOfNode(domNode));renderSync(editor,function(){editor.select(nodeSelection).delete().restoreDOM()})}}var observer=new window.MutationObserver(function(mutations){var _bufferedMutations;debug$3(\"flush\");(_bufferedMutations=bufferedMutations).push.apply(_bufferedMutations,\ntoConsumableArray(mutations));startAction()}),win=null,last={rootEl:null,diff:null,range:null,domNode:null},onSelectTimeoutId=null,bufferedMutations=[],startActionFrameId=null,isFlushing=!1;return{clearDiff:function(){debug$3(\"clearDIff\");last.diff=null},connect:function(){debug$3(\"connect\",{rootEl:rootEl});var rootEl=editor.findDOMNode([]);last.rootEl!==rootEl&&(debug$3(\"connect:run\"),win=getWindow(rootEl),observer.observe(rootEl,{childList:!0,characterData:!0,attributes:!0,subtree:!0,characterDataOldValue:!0}))},\ndisconnect:function(){debug$3(\"disconnect\");observer.disconnect();last.rootEl=null},onKeyDown:startAction,onCompositionStart:function(){debug$3(\"onCompositionStart\")},onCompositionEnd:function(){debug$3(\"onCompositionEnd\");window.setTimeout(function(){last.diff&&(debug$3(\"onCompositionEnd:applyDiff\"),renderSync(editor,function(){applyDiff();var domRange=win.getSelection().getRangeAt(0),fix=fixTextAndOffset(domRange.startContainer.textContent,domRange.startOffset);domRange=editor.findRange({anchorNode:domRange.startContainer,\nanchorOffset:0,focusNode:domRange.startContainer,focusOffset:0,isCollapsed:!0}).moveTo(fix.offset);editor.select(domRange).focus().restoreDOM()}));clearAction()},20)},onSelect:function(event){debug$3(\"onSelect:try\");event=event.nativeEvent?event.nativeEvent:event;window.cancelAnimationFrame(onSelectTimeoutId);onSelectTimeoutId=null;isFlushing||(onSelectTimeoutId=window.requestAnimationFrame(function(){debug$3(\"onSelect:save-selection\");var domSelection=getWindow(event.target).getSelection(),range=\neditor.findRange(domSelection),anchorFix=fixTextAndOffset(domSelection.anchorNode.textContent,domSelection.anchorOffset),focusFix=fixTextAndOffset(domSelection.focusNode.textContent,domSelection.focusOffset);range.anchor.offset!==anchorFix.offset&&(range=range.set(\"anchor\",range.anchor.set(\"offset\",anchorFix.offset)));range.focus.offset!==focusFix.offset&&(range=range.set(\"focus\",range.focus.set(\"offset\",focusFix.offset)));debug$3(\"onSelect:save-data\",{domSelection:{anchorNode:domSelection.anchorNode,\nanchorOffset:domSelection.anchorOffset,focusNode:domSelection.focusNode,focusOffset:domSelection.focusOffset},range:range.toJS()});domSelection.isCollapsed&&last.node!==domSelection.anchorNode&&null!=last.diff&&(debug$3(\"onSelect:applyDiff\",last.diff),applyDiff(),editor.select(range),clearAction());last.range=range;last.node=domSelection.anchorNode}))}}}function AndroidPlugin(_ref){var observer=new CompositionManager(_ref.editor);return{onComponentDidMount:function(){observer.connect()},onComponentDidUpdate:function(){observer.connect()},\nonComponentWillUnmount:function(){observer.disconnect()},onCompositionEnd:function(){observer.onCompositionEnd()},onCompositionStart:function(){observer.onCompositionStart()},onRender:function(){observer.disconnect();observer.clearDiff()},onSelect:function(event){var window=getWindow(event.target),domSelection=window.getSelection(),anchorNode=domSelection.anchorNode;if(null!=anchorNode){var dataset=anchorNode.parentElement.dataset;dataset&&\"n\"===dataset.slateZeroWidth&&1===anchorNode.textContent.length&&\n0!==domSelection.anchorOffset&&(window=window.document.createRange(),window.setStart(anchorNode,0),window.setEnd(anchorNode,0),domSelection.removeAllRanges(),domSelection.addRange(window))}observer.onSelect(event)}}}function NoopPlugin(){var plugin={},_iteratorNormalCompletion=!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _iterator=EVENT_HANDLERS[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=!0)plugin[_step.value]=function(event,\neditor,next){}}catch(err){_didIteratorError=!0,_iteratorError=err}finally{try{!_iteratorNormalCompletion&&_iterator.return&&_iterator.return()}finally{if(_didIteratorError)throw _iteratorError;}}return plugin}function cloneFragment(event,editor){var callback=2<arguments.length&&void 0!==arguments[2]?arguments[2]:function(){};invariant(!slate.Value.isValue(editor),\"As of Slate 0.42.0, the `cloneFragment` utility takes an `editor` instead of a `value`.\");var window=getWindow(event.target),native=window.getSelection(),\nvalue=editor.value,document=value.document,fragment=value.fragment,selection=value.selection;value=selection.end;var startVoid=document.getClosestVoid(selection.start.path,editor),endVoid=document.getClosestVoid(value.path,editor);if(!native.isCollapsed||startVoid){value=Base64.serializeNode(fragment);var range=native.getRangeAt(0);selection=range.cloneContents();var attach=selection.childNodes[0];selection.childNodes.forEach(function(node){node.textContent&&\"\"!==node.textContent.trim()&&(attach=\nnode)});if(endVoid){var r=range.cloneRange();if(document=document.getPath(endVoid.key))selection=editor.findDOMNode(document),r.setEndAfter(selection),selection=r.cloneContents()}startVoid&&(attach=selection.childNodes[0].childNodes[1].firstChild);[].slice.call(selection.querySelectorAll(SELECTORS.ZERO_WIDTH)).forEach(function(zw){var isNewline=\"n\"===zw.getAttribute(DATA_ATTRS.ZERO_WIDTH);zw.textContent=isNewline?\"\\n\":\"\"});3===attach.nodeType&&(document=window.document.createElement(\"span\"),document.style.whiteSpace=\n\"pre\",document.appendChild(attach),selection.appendChild(document),attach=document);attach.setAttribute(DATA_ATTRS.FRAGMENT,value);fragment=slate.Value.create({document:fragment});fragment=Plain.serialize(fragment);var div=window.document.createElement(\"div\");div.appendChild(selection);if(event.clipboardData&&event.clipboardData.setData&&!slateDevEnvironment.IS_IE)event.preventDefault(),event.clipboardData.setData(TEXT,fragment),event.clipboardData.setData(FRAGMENT,value),event.clipboardData.setData(HTML,\ndiv.innerHTML),callback();else{var editorEl=event.target.closest(SELECTORS.EDITOR);div.setAttribute(\"contenteditable\",!0);div.style.position=\"absolute\";div.style.left=\"-9999px\";editorEl.appendChild(div);native.selectAllChildren(div);window.requestAnimationFrame(function(){editorEl.removeChild(div);removeAllRanges(native);native.addRange(range);callback()})}}}function getEventTransfer(event){!slateDevEnvironment.IS_IE&&event.nativeEvent&&(event=event.nativeEvent);event=event.dataTransfer||event.clipboardData;\nvar fragment=getType(event,FRAGMENT$1),node=getType(event,NODE),html=getType(event,HTML$1),rich=getType(event,RICH),text=getType(event,TEXT$1),files=void 0;if(!fragment&&html&&~html.indexOf(\" \"+DATA_ATTRS.FRAGMENT+'\\x3d\"')){var matches=FRAGMENT_MATCHER.exec(html);(matches=slicedToArray(matches,2)[1])&&(fragment=matches)}text&&(matches=getEmbeddedTypes(text),matches[FRAGMENT$1]&&(fragment=matches[FRAGMENT$1]),matches[NODE]&&(node=matches[NODE]),matches[TEXT$1]&&(text=matches[TEXT$1]));fragment&&(fragment=\nBase64.deserializeNode(fragment));node&&(node=Base64.deserializeNode(node));try{event.items&&event.items.length?files=Array.from(event.items).map(function(item){return\"file\"===item.kind?item.getAsFile():null}).filter(function(exists){return exists}):event.files&&event.files.length&&(files=Array.from(event.files))}catch(err){event.files&&event.files.length&&(files=Array.from(event.files))}event={files:files,fragment:fragment,html:html,node:node,rich:rich,text:text};event.type=event.fragment?\"fragment\":\nevent.node?\"node\":event.rich&&event.html?\"html\":event.rich&&event.text?\"text\":event.files&&event.files.length?\"files\":event.html?\"html\":event.text?\"text\":\"unknown\";return event}function getEmbeddedTypes(text){if(\"SLATE-DATA-EMBED::\"!==text.substring(0,18))return{TEXT:text};try{return JSON.parse(text.substring(18))}catch(err){throw Error(\"Unable to parse custom Slate drag event data.\");}}function getType(transfer,type){return transfer.types&&transfer.types.length?-1!==Array.from(transfer.types).indexOf(type)?\ntransfer.getData(type)||null:null:type===TEXT$1?transfer.getData(\"Text\")||null:null}function setEventTransfer(event,type,content){type=TRANSFER_TYPES[type.toUpperCase()];if(!type)throw Error('Cannot set unknown transfer type \"'+type+'\".');event.nativeEvent&&(event=event.nativeEvent);event=event.dataTransfer||event.clipboardData;try{event.setData(type,content),event.setData(\"text\",event.getData(\"text\"))}catch(err){var text=event.getData(TEXT$2),obj={};if(\"SLATE-DATA-EMBED::\"===text.substring(0,18))try{obj=\nJSON.parse(text.substring(18))}catch(e){throw Error(\"Failed to parse Slate data from `DataTransfer` object.\");}else obj[TEXT$2]=text;obj[type]=content;content=\"SLATE-DATA-EMBED::\"+JSON.stringify(obj);event.setData(TEXT$2,content)}}function AfterPlugin(){var isDraggingInternally=null,isMouseDown=!1;return{onBeforeInput:function(event,editor,next){var value=editor.value;if(event.nativeEvent)return event.preventDefault(),editor.insertText(event.data),next();var _event$getTargetRange=event.getTargetRanges(),\ntargetRange=slicedToArray(_event$getTargetRange,1)[0];if(!targetRange)return next();debug$4(\"onBeforeInput\",{event:event});event.preventDefault();var document=value.document;_event$getTargetRange=value.selection;targetRange=editor.findRange(targetRange);switch(event.inputType){case \"deleteByDrag\":case \"deleteByCut\":case \"deleteContent\":case \"deleteContentBackward\":case \"deleteContentForward\":editor.deleteAtRange(targetRange);break;case \"deleteWordBackward\":editor.deleteWordBackwardAtRange(targetRange);\nbreak;case \"deleteWordForward\":editor.deleteWordForwardAtRange(targetRange);break;case \"deleteSoftLineBackward\":case \"deleteHardLineBackward\":editor.deleteLineBackwardAtRange(targetRange);break;case \"deleteSoftLineForward\":case \"deleteHardLineForward\":editor.deleteLineForwardAtRange(targetRange);break;case \"insertLineBreak\":case \"insertParagraph\":document.hasVoidParent(_event$getTargetRange.start.path,editor)?editor.moveToStartOfNextText():editor.splitBlockAtRange(targetRange);break;case \"insertFromYank\":case \"insertReplacementText\":case \"insertText\":event=\nnull==event.data?event.dataTransfer.getData(\"text/plain\"):event.data,null!=event&&(editor.insertTextAtRange(targetRange,event,_event$getTargetRange.marks),_event$getTargetRange.marks&&value.document!==editor.value.document&&editor.select({marks:null}))}next()},onBlur:function(event,editor,next){debug$4(\"onBlur\",{event:event});editor.blur();next()},onClick:function(event,editor,next){if(editor.readOnly)return next();var document=editor.value.document,path=editor.findPath(event.target);if(!path)return next();\ndebug$4(\"onClick\",{event:event});event=document.getNode(path);document=document.getAncestors(path);event&&(editor.isVoid(event)||document.some(function(a){return editor.isVoid(a)}))&&editor.focus().moveToEndOfNode(event);next()},onCopy:function(event,editor,next){debug$4(\"onCopy\",{event:event});cloneFragment(event,editor);next()},onCut:function(event,editor,next){debug$4(\"onCut\",{event:event});cloneFragment(event,editor,function(){var value=editor.value,document=value.document,selection=value.selection;\nvalue=selection.end;var voidPath=void 0;if(selection.isCollapsed){selection=!0;var _didIteratorError=!1,_iteratorError=void 0;try{for(var _iterator=document.ancestors(value.path)[Symbol.iterator](),_step;!(selection=(_step=_iterator.next()).done);selection=!0){var _ref2=slicedToArray(_step.value,2),path=_ref2[1];if(editor.isVoid(_ref2[0])){voidPath=path;break}}}catch(err){_didIteratorError=!0,_iteratorError=err}finally{try{!selection&&_iterator.return&&_iterator.return()}finally{if(_didIteratorError)throw _iteratorError;\n}}}voidPath?editor.removeNodeByKey(voidPath):editor.delete()});next()},onDragEnd:function(event,editor,next){debug$4(\"onDragEnd\",{event:event});isDraggingInternally=null;next()},onDragStart:function(event,editor,next){debug$4(\"onDragStart\",{event:event});isDraggingInternally=!0;var value=editor.value,document=value.document,path=editor.findPath(event.target),node=document.getNode(path);document=document.getAncestors(path);document=node&&(editor.isVoid(node)||document.some(function(a){return editor.isVoid(a)}));\nvalue=value.blocks.some(function(block){return block===node});document&&!value&&editor.moveToRangeOfNode(node);value=Base64.serializeNode(editor.value.fragment);setEventTransfer(event,\"fragment\",value);next()},onDrop:function(event,editor,next){var value=editor.value,document=value.document,selection=value.selection,window=getWindow(event.target),target=editor.findEventRange(event);if(!target)return next();debug$4(\"onDrop\",{event:event});var transfer=getEventTransfer(event);event=transfer.type;value=\ntransfer.fragment;transfer=transfer.text;editor.focus();var el=editor.findDOMNode(target.focus.path);el&&el.dispatchEvent(new MouseEvent(\"mouseup\",{view:window,bubbles:!0,cancelable:!0}));editor.select(target);isDraggingInternally&&editor.deleteAtRange(selection);if(\"text\"===event||\"html\"===event){selection=target.anchor;if(window=document.hasVoidParent(selection.path,editor)){target=selection.path;for(selection=document.getNode(selection.path);window;){window=document.texts({path:target});window=\nslicedToArray(window,1)[0];if(!window)break;window=slicedToArray(window,2);selection=window[0];target=window[1];window=document.hasVoidParent(target,editor)}selection&&editor.moveToStartOfNode(selection)}transfer&&transfer.split(\"\\n\").forEach(function(line,i){0<i&&editor.splitBlock();editor.insertText(line)})}\"fragment\"===event&&editor.insertFragment(value);next()},onFocus:function(event,editor,next){debug$4(\"onFocus\",{event:event});!isMouseDown||slateDevEnvironment.IS_IE||slateDevEnvironment.IS_EDGE?\neditor.focus():editor.deselect().focus();next()},onInput:function(event,editor,next){debug$4(\"onInput\");event=getWindow(event.target).getSelection();var selection=editor.findSelection(event);selection?editor.select(selection):editor.blur();editor.reconcileDOMNode(event.anchorNode);next()},onKeyDown:function(event,editor,next){debug$4(\"onKeyDown\",{event:event});var value=editor.value,document=value.document,selection=value.selection,start=selection.start;value=document.hasVoidParent(start.path,editor);\nif(Hotkeys.isSplitBlock(event)&&!slateDevEnvironment.IS_IOS)return value?editor.moveToStartOfNextText():editor.splitBlock();if(Hotkeys.isDeleteBackward(event)&&!slateDevEnvironment.IS_IOS)return editor.deleteCharBackward();if(Hotkeys.isDeleteForward(event)&&!slateDevEnvironment.IS_IOS)return editor.deleteCharForward();if(Hotkeys.isDeleteLineBackward(event))return editor.deleteLineBackward();if(Hotkeys.isDeleteLineForward(event))return editor.deleteLineForward();if(Hotkeys.isDeleteWordBackward(event))return editor.deleteWordBackward();\nif(Hotkeys.isDeleteWordForward(event))return editor.deleteWordForward();if(Hotkeys.isRedo(event))return editor.redo();if(Hotkeys.isUndo(event))return editor.undo();if(Hotkeys.isMoveLineBackward(event))return event.preventDefault(),editor.moveToStartOfBlock();if(Hotkeys.isMoveLineForward(event))return event.preventDefault(),editor.moveToEndOfBlock();if(Hotkeys.isExtendLineBackward(event))return event.preventDefault(),editor.moveFocusToStartOfBlock();if(Hotkeys.isExtendLineForward(event))return event.preventDefault(),\neditor.moveFocusToEndOfBlock();if(Hotkeys.isMoveBackward(event))return event.preventDefault(),selection.isCollapsed?editor.moveBackward():editor.moveToStart();if(Hotkeys.isMoveForward(event))return event.preventDefault(),selection.isCollapsed?editor.moveForward():editor.moveToEnd();if(Hotkeys.isMoveWordBackward(event))return event.preventDefault(),editor.moveWordBackward();if(Hotkeys.isMoveWordForward(event))return event.preventDefault(),editor.moveWordForward();if(Hotkeys.isExtendBackward(event)){selection=\ndocument.getNode(start.path);var _document$texts3=document.texts({path:start.path,direction:\"backward\"});_document$texts3=slicedToArray(_document$texts3,1)[0];var isPrevInVoid=!1;_document$texts3&&(_document$texts3=slicedToArray(_document$texts3,2)[1],isPrevInVoid=document.hasVoidParent(_document$texts3,editor));if(value||isPrevInVoid||\"\"===selection.text)return event.preventDefault(),editor.moveFocusBackward()}if(Hotkeys.isExtendForward(event)&&(selection=document.getNode(start.path),start=document.texts({path:start.path}),\nstart=slicedToArray(start,1)[0],_document$texts3=!1,start&&(start=slicedToArray(start,2)[1],_document$texts3=document.hasVoidParent(start,editor)),value||_document$texts3||\"\"===selection.text))return event.preventDefault(),editor.moveFocusForward();next()},onMouseDown:function(event,editor,next){debug$4(\"onMouseDown\",{event:event});isMouseDown=!0;next()},onMouseUp:function(event,editor,next){debug$4(\"onMouseUp\",{event:event});isMouseDown=!1;next()},onPaste:function(event,editor,next){debug$4(\"onPaste\",\n{event:event});var value=editor.value;event=getEventTransfer(event);var type=event.type,fragment=event.fragment;event=event.text;\"fragment\"===type&&editor.insertFragment(fragment);if(\"text\"===type||\"html\"===type){if(!event)return next();type=value.document;fragment=value.selection;value=value.startBlock;if(editor.isVoid(value))return next();type=type.getInsertMarksAtRange(fragment);value=Plain.deserialize(event,{defaultBlock:value,defaultMarks:type}).document;editor.insertFragment(value)}next()},\nonSelect:function(event,editor,next){debug$4(\"onSelect\",{event:event});event=getWindow(event.target).getSelection();(event=editor.findSelection(event))?editor.select(event):editor.blur();isMouseDown=!1;next()}}}function BeforePlugin(){var activeElement=null,compositionCount=0,isComposing=!1,isCopying=!1,isDragging=!1,isUserActionPerformed=!1;return{onBeforeInput:function(event,editor,next){var isSynthetic=!!event.nativeEvent;editor.readOnly||(isUserActionPerformed=!0,isSynthetic&&slateDevEnvironment.HAS_INPUT_EVENTS_LEVEL_2||\n(debug$5(\"onBeforeInput\",{event:event}),next()))},onBlur:function(event,editor,next){if(!isCopying&&!editor.readOnly){var relatedTarget=event.relatedTarget,window=getWindow(event.target);if(activeElement!==window.document.activeElement){if(relatedTarget){window=editor.findDOMNode([]);if(relatedTarget===window||relatedTarget.hasAttribute(DATA_ATTRS.SPACER))return;var node=editor.findNode(relatedTarget);if(window.contains(relatedTarget)&&node&&!editor.isVoid(node))return}debug$5(\"onBlur\",{event:event});\nnext()}}},onClick:function(event,editor,next){debug$5(\"onClick\",{event:event});isUserActionPerformed=!0;next()},onCompositionEnd:function(event,editor,next){var n=compositionCount;isUserActionPerformed=!0;window.requestAnimationFrame(function(){compositionCount>n||(isComposing=!1)});debug$5(\"onCompositionEnd\",{event:event});next()},onCompositionStart:function(event,editor,next){isComposing=!0;compositionCount++;var selection=editor.value.selection;isUserActionPerformed=!0;selection.isCollapsed||editor.delete();\ndebug$5(\"onCompositionStart\",{event:event});next()},onCopy:function(event,editor,next){editor=getWindow(event.target);isCopying=!0;editor.requestAnimationFrame(function(){return isCopying=!1});debug$5(\"onCopy\",{event:event});next()},onCut:function(event,editor,next){editor.readOnly||(editor=getWindow(event.target),isCopying=!0,editor.requestAnimationFrame(function(){return isCopying=!1}),debug$5(\"onCut\",{event:event}),next())},onDragEnd:function(event,editor,next){isDragging=!1;debug$5(\"onDragEnd\",\n{event:event});next()},onDragEnter:function(event,editor,next){debug$5(\"onDragEnter\",{event:event});next()},onDragExit:function(event,editor,next){debug$5(\"onDragExit\",{event:event});next()},onDragLeave:function(event,editor,next){debug$5(\"onDragLeave\",{event:event});next()},onDragOver:function(event,editor,next){var node=editor.findNode(event.target);node&&!editor.isVoid(node)||event.preventDefault();slateDevEnvironment.IS_IE&&event.preventDefault();isDragging||(isDragging=!0,slateDevEnvironment.IS_IE||\n(event.nativeEvent.dataTransfer.dropEffect=\"move\"));debug$5(\"onDragOver\",{event:event});next()},onDragStart:function(event,editor,next){isDragging=!0;debug$5(\"onDragStart\",{event:event});next()},onDrop:function(event,editor,next){editor.readOnly||(isUserActionPerformed=!0,event.preventDefault(),debug$5(\"onDrop\",{event:event}),next())},onFocus:function(event,editor,next){isCopying||editor.readOnly||(editor=editor.findDOMNode([]),activeElement=getWindow(event.target).document.activeElement,slateDevEnvironment.IS_FIREFOX&&\nevent.target!==editor?editor.focus():(debug$5(\"onFocus\",{event:event}),next()))},onInput:function(event,editor,next){isComposing||editor.value.selection.isBlurred||(isUserActionPerformed=!0,debug$5(\"onInput\",{event:event}),next())},onKeyDown:function(event,editor,next){editor.readOnly||(isComposing?Hotkeys.isCompose(event)&&event.preventDefault():(!slateDevEnvironment.IS_IOS&&(Hotkeys.isBold(event)||Hotkeys.isDeleteBackward(event)||Hotkeys.isDeleteForward(event)||Hotkeys.isDeleteLineBackward(event)||\nHotkeys.isDeleteLineForward(event)||Hotkeys.isDeleteWordBackward(event)||Hotkeys.isDeleteWordForward(event)||Hotkeys.isItalic(event)||Hotkeys.isRedo(event)||Hotkeys.isSplitBlock(event)||Hotkeys.isTransposeCharacter(event)||Hotkeys.isUndo(event))&&event.preventDefault(),isUserActionPerformed=!0,debug$5(\"onKeyDown\",{event:event}),next()))},onPaste:function(event,editor,next){editor.readOnly||(isUserActionPerformed=!0,event.preventDefault(),debug$5(\"onPaste\",{event:event}),next())},onSelect:function(event,\neditor,next){isCopying||isComposing||editor.readOnly||(activeElement=getWindow(event.target).document.activeElement,isUserActionPerformed=!0,debug$5(\"onSelect\",{event:event}),next())},queries:{userActionPerformed:function(){return isUserActionPerformed}},commands:{clearUserActionPerformed:function(){isUserActionPerformed=!1;return null}}}}function DOMPlugin(){var options=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},_options$plugins=options.plugins;_options$plugins=void 0===_options$plugins?\n[]:_options$plugins;var beforePlugin=BeforePlugin(),afterPlugin=AfterPlugin();options=slateDevEnvironment.IS_ANDROID?[AndroidPlugin(options),NoopPlugin(options)]:[];return[].concat(options,[beforePlugin],toConsumableArray(_options$plugins),[afterPlugin])}function RestoreDOMPlugin(){return{commands:{restoreDOM:function(editor){editor=editor.tmp.contentRef.current.tmp;editor.contentKey+=1}}}}function stringifyEvent(event){event=event.nativeEvent||event;switch(event.type){case \"keydown\":return event.type+\n\" \"+JSON.stringify(event.key);case \"input\":case \"beforeinput\":case \"textInput\":return event.type+\":\"+event.inputType+\" \"+JSON.stringify(event.data);default:return event.type}}function DebugEventsPlugin(){var plugin={},_iteratorNormalCompletion=!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _iterator=EVENT_HANDLERS[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=!0)plugin[_step.value]=function(event,editor,next){event=stringifyEvent(event);\ndebug$6(event);next()}}catch(err){_didIteratorError=!0,_iteratorError=err}finally{try{!_iteratorNormalCompletion&&_iterator.return&&_iterator.return()}finally{if(_didIteratorError)throw _iteratorError;}}return plugin}function DebugBatchEventsPlugin(){function dumpEvents(){debug$7(\"\\n\"+events.join(\"\\n\"));events.length=0}var startDate=null,timeoutId=null,events=[],plugin={},_iteratorNormalCompletion=!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _iterator=EVENT_HANDLERS[Symbol.iterator](),\n_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=!0)plugin[_step.value]=function(event,editor,next){0===events.length&&(startDate=new Date);event=stringifyEvent(event);events.push(\"- \"+(new Date-startDate)+\" - \"+event);clearTimeout(timeoutId);timeoutId=setTimeout(dumpEvents,2E3);next()}}catch(err){_didIteratorError=!0,_iteratorError=err}finally{try{!_iteratorNormalCompletion&&_iterator.return&&_iterator.return()}finally{if(_didIteratorError)throw _iteratorError;\n}}return plugin}function normalizeNode(node){if(node.nodeType===window.Node.TEXT_NODE)return node.textContent;if(node.nodeType===window.Node.ELEMENT_NODE){var outerHTML=node.outerHTML,innerHTML=node.innerHTML;return null==outerHTML?JSON.stringify(node.textContent):outerHTML.slice(0,outerHTML.indexOf(innerHTML))}return\"Node(type\\x3d\"+node.nodeType}function DebugMutationsPlugin(){function start(event,editor,next){event=editor.findDOMNode([]);if(event===prevRootEl)return next();debug$8(\"start\");observer.observe(event,\n{childList:!0,characterData:!0,attributes:!0,subtree:!0,characterDataOldValue:!0});prevRootEl=event;next()}var observer=new window.MutationObserver(function(mutations){mutations=Array.from(mutations).map(function(mutationRecord){var object={};MUTATION_PROPERTIES.forEach(function(key){var value=mutationRecord[key];null!=value&&(value instanceof window.NodeList?0!==value.length&&(object[key]=Array.from(value).map(normalizeNode).join(\", \")):(value instanceof window.Node&&(value=normalizeNode(value)),\nobject[key]=value))});return object});debug$8.apply(void 0,[mutations.length+\" Mutations\"].concat(toConsumableArray(mutations)))}),prevRootEl=null;return{onComponentDidMount:start,onComponentDidUpdate:start,onComponentWillUnmount:function(event,editor,next){debug$8(\"stop\");observer.disconnect();prevRootEl=null;next()}}}function ReactPlugin(){var options=0<arguments.length&&void 0!==arguments[0]?arguments[0]:{},_options$placeholder=options.placeholder,placeholder=void 0===_options$placeholder?\"\":_options$placeholder;\n_options$placeholder=Debug.enabled(\"slate:events\")?DebugEventsPlugin(options):null;var debugBatchEventsPlugin=Debug.enabled(\"slate:batch-events\")?DebugBatchEventsPlugin(options):null,debugMutationsPlugin=Debug.enabled(\"slate:mutations\")?DebugMutationsPlugin(options):null,renderingPlugin=Rendering(options),commandsPlugin=CommandsPlugin(options),queriesPlugin=QueriesPlugin(options),editorPropsPlugin=EditorPropsPlugin(options);options=DOMPlugin(options);var restoreDomPlugin=RestoreDOMPlugin();placeholder=\nslateDevEnvironment.IS_ANDROID?null:PlaceholderPlugin({placeholder:placeholder,when:function(editor,node){return\"document\"===node.object&&\"\"===node.text&&1===node.nodes.size&&1===Array.from(node.texts()).length}});return[_options$placeholder,debugBatchEventsPlugin,debugMutationsPlugin,editorPropsPlugin,options,restoreDomPlugin,placeholder,renderingPlugin,commandsPlugin,queriesPlugin]}function findDOMNode(key){var win=1<arguments.length&&void 0!==arguments[1]?arguments[1]:window;warning(!1,\"As of slate-react@0.22 the `findDOMNode(key)` helper is deprecated in favor of `editor.findDOMNode(path)`.\");\nslate.Node.isNode(key)&&(key=key.key);win=win.document.querySelector(\"[\"+DATA_ATTRS.KEY+'\\x3d\"'+key+'\"]');if(!win)throw Error('Unable to find a DOM node for \"'+key+'\". This is often because of forgetting to add `props.attributes` to a custom component.');return win}function findDOMPoint(point){var win=1<arguments.length&&void 0!==arguments[1]?arguments[1]:window;warning(!1,\"As of slate-react@0.22 the `findDOMPoint(point)` helper is deprecated in favor of `editor.findDOMPoint(point)`.\");var el=findDOMNode(point.key,\nwin);win=0;var texts=Array.from(el.querySelectorAll(SELECTORS.STRING+\", \"+SELECTORS.ZERO_WIDTH));el=!0;var _didIteratorError=!1,_iteratorError=void 0;try{for(var _iterator=texts[Symbol.iterator](),_step;!(el=(_step=_iterator.next()).done);el=!0){var text=_step.value,node=text.childNodes[0],domLength=node.textContent.length;texts=domLength;text.hasAttribute(DATA_ATTRS.LENGTH)&&(texts=parseInt(text.getAttribute(DATA_ATTRS.LENGTH),10));texts=win+texts;if(point.offset<=texts)return{node:node,offset:Math.min(domLength,\nMath.max(0,point.offset-win))};win=texts}}catch(err){_didIteratorError=!0,_iteratorError=err}finally{try{!el&&_iterator.return&&_iterator.return()}finally{if(_didIteratorError)throw _iteratorError;}}return null}function findDOMRange(range){var win=1<arguments.length&&void 0!==arguments[1]?arguments[1]:window;warning(!1,\"As of slate-react@0.22 the `findDOMRange(range)` helper is deprecated in favor of `editor.findDOMRange(range)`.\");var focus=range.focus,isBackward$$1=range.isBackward,isCollapsed=\nrange.isCollapsed,domAnchor=findDOMPoint(range.anchor,win);focus=isCollapsed?domAnchor:findDOMPoint(focus,win);if(!domAnchor||!focus)return null;win=win.document.createRange();isCollapsed=isBackward$$1?focus:domAnchor;isBackward$$1=isBackward$$1?domAnchor:focus;win.setStart(isCollapsed.node,isCollapsed.offset);win.setEnd(isBackward$$1.node,isBackward$$1.offset);return win}function findNode(element,editor){warning(!1,\"As of slate-react@0.22 the `findNode(element)` helper is deprecated in favor of `editor.findNode(element)`.\");\ninvariant(!slate.Value.isValue(editor),\"As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.\");element=element.closest(SELECTORS.KEY);return element?(element=element.getAttribute(DATA_ATTRS.KEY))?editor.value.document.getNode(element)||null:null:null}function findPath(element,editor){warning(!1,\"As of slate-react@0.22 the `findPath(element)` helper is deprecated in favor of `editor.findPath(element)`.\");return(element=findNode(element,editor))?editor.value.document.getPath(element):\nnull}function findPoint(nativeNode,nativeOffset,editor){warning(!1,\"As of slate-react@0.22 the `findPoint(node, offset)` helper is deprecated in favor of `editor.findPoint(node, offset)`.\");invariant(!slate.Value.isValue(editor),\"As of Slate 0.42.0, the `findPoint` utility takes an `editor` instead of a `value`.\");var node=nativeNode,offset=nativeOffset;if(1===node.nodeType&&node.childNodes.length){var direction=(nativeOffset=offset===node.childNodes.length)?\"backward\":\"forward\";for(node=getEditableChild$1(node,\nnativeOffset?offset-1:offset,direction);1===node.nodeType&&node.childNodes.length;)node=getEditableChild$1(node,nativeOffset?node.childNodes.length-1:0,direction);offset=nativeOffset?node.textContent.length:0}nativeOffset=node;direction=getWindow(nativeNode);nativeNode=nativeOffset.parentNode;if(node=nativeNode.closest(SELECTORS.LEAF)){direction=direction.document.createRange();var textNode=node.closest(SELECTORS.TEXT);direction.setStart(textNode,0);direction.setEnd(nativeOffset,offset);offset=textNode;\nnativeOffset=direction.cloneContents();direction=nativeOffset.querySelectorAll(\"[\"+DATA_ATTRS.ZERO_WIDTH+\"]\");nativeOffset=nativeOffset.textContent.length-direction.length}else{node=nativeNode.closest(SELECTORS.VOID);if(!node)return null;node=node.querySelector(SELECTORS.LEAF);if(!node)return null;offset=node;nativeOffset=offset.textContent.length}nativeOffset===offset.textContent.length&&nativeNode.hasAttribute(DATA_ATTRS.ZERO_WIDTH)&&nativeOffset--;nativeNode=node.getAttribute(DATA_ATTRS.OFFSET_KEY);\nif(!nativeNode)return null;nativeNode=OffsetKey.parse(nativeNode).key;editor=editor.value;return editor.document.hasDescendant(nativeNode)?editor.document.createPoint({key:nativeNode,offset:nativeOffset}):null}function getEditableChild$1(parent,index,direction){parent=parent.childNodes;for(var child=parent[index],i=index,triedForward=!1,triedBackward=!1;(8===child.nodeType||1===child.nodeType&&0===child.childNodes.length||1===child.nodeType&&\"false\"===child.getAttribute(\"contenteditable\"))&&(!triedForward||\n!triedBackward);)i>=parent.length?(triedForward=!0,i=index-1,direction=\"backward\"):0>i?(triedBackward=!0,i=index+1,direction=\"forward\"):(child=parent[i],\"forward\"===direction&&i++,\"backward\"===direction&&i--);return child||null}function findRange(native,editor){warning(!1,\"As of slate-react@0.22 the `findRange(selection)` helper is deprecated in favor of `editor.findRange(selection)`.\");invariant(!slate.Value.isValue(editor),\"As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.\");\nvar el=native.anchorNode||native.startContainer;if(!el)return null;el=getWindow(el);if(native instanceof el.Range||el.StaticRange&&native instanceof el.StaticRange)native={anchorNode:native.startContainer,anchorOffset:native.startOffset,focusNode:native.endContainer,focusOffset:native.endOffset};var _native=native;el=_native.focusNode;var focusOffset=_native.focusOffset,isCollapsed=_native.isCollapsed;native=editor.value;_native=findPoint(_native.anchorNode,_native.anchorOffset,editor);editor=isCollapsed?\n_native:findPoint(el,focusOffset,editor);return _native&&editor?native.document.createRange({anchor:_native,focus:editor}):null}function getEventRange(event,editor){warning(!1,\"As of slate-react@0.22 the `getEventRange(event, editor)` helper is deprecated in favor of `editor.findEventRange(event)`.\");invariant(!slate.Value.isValue(editor),\"As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.\");event.nativeEvent&&(event=event.nativeEvent);var _event=event,x=_event.clientX,\ny=_event.clientY,target=_event.target;if(null==x||null==y)return null;_event=editor.value.document;event=findPath(event.target,editor);if(!event)return null;var node=_event.getNode(event);if(editor.isVoid(node))return editor=target.getBoundingClientRect(),y=\"inline\"===node.object?x-editor.left<editor.left+editor.width-x:y-editor.top<editor.top+editor.height-y,editor=_event.createRange(),x=y?\"moveToEndOfNode\":\"moveToStartOfNode\",(y=_event[y?\"getPreviousText\":\"getNextText\"](event))?editor[x](y):null;\n_event=getWindow(target);event=void 0;if(_event.document.caretRangeFromPoint)event=_event.document.caretRangeFromPoint(x,y);else if(_event.document.caretPositionFromPoint)x=_event.document.caretPositionFromPoint(x,y),event=_event.document.createRange(),event.setStart(x.offsetNode,x.offset),event.setEnd(x.offsetNode,x.offset);else if(_event.document.body.createTextRange){event=_event.document.body.createTextRange();try{event.moveToPoint(x,y)}catch(error){return null}}return(editor=findRange(event,\neditor))?editor:null}Object.defineProperty(exports,\"__esModule\",{value:!0});var React=_interopDefault(require(\"module$node_modules$react$index\")),Types=_interopDefault(require(\"module$node_modules$prop_types$index\")),SlateTypes=_interopDefault(require(\"module$node_modules$slate_prop_types$lib$slate_prop_types\")),ImmutableTypes=_interopDefault(require(\"module$node_modules$react_immutable_proptypes$dist$ImmutablePropTypes\")),Debug=_interopDefault(require(\"module$node_modules$debug$src$browser\")),warning=\n_interopDefault(require(\"module$node_modules$tiny_warning$dist$tiny_warning_cjs\")),slate=require(\"module$node_modules$slate$lib$slate\"),getWindow=_interopDefault(require(\"module$node_modules$get_window$index\")),isBackward=_interopDefault(require(\"module$node_modules$selection_is_backward$index\")),slateDevEnvironment=require(\"module$node_modules$slate_dev_environment$lib$slate_dev_environment\"),throttle=_interopDefault(require(\"module$node_modules$lodash$throttle\")),omit=_interopDefault(require(\"module$node_modules$lodash$omit\")),\nimmutable=require(\"module$node_modules$immutable$dist$immutable\"),Hotkeys=_interopDefault(require(\"module$node_modules$slate_hotkeys$lib$slate_hotkeys\")),ReactDOM=_interopDefault(require(\"module$node_modules$react_dom$index\")),Base64=_interopDefault(require(\"module$node_modules$slate_base64_serializer$lib$slate_base64_serializer\")),Plain=_interopDefault(require(\"module$node_modules$slate_plain_serializer$lib$slate_plain_serializer\")),invariant=_interopDefault(require(\"module$node_modules$tiny_invariant$dist$tiny_invariant_cjs\")),\nPlaceholderPlugin=_interopDefault(require(\"module$node_modules$slate_react_placeholder$lib$slate_react_placeholder\")),memoizeOne=_interopDefault(require(\"module$node_modules$memoize_one$dist$memoize_one_cjs\")),EVENT_HANDLERS=\"onBeforeInput onBlur onClick onContextMenu onCompositionEnd onCompositionStart onCopy onCut onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onInput onFocus onKeyDown onKeyUp onMouseDown onMouseUp onPaste onSelect\".split(\" \"),DATA_ATTRS={EDITOR:\"data-slate-editor\",\nFRAGMENT:\"data-slate-fragment\",KEY:\"data-key\",LEAF:\"data-slate-leaf\",LENGTH:\"data-slate-length\",OBJECT:\"data-slate-object\",OFFSET_KEY:\"data-offset-key\",SPACER:\"data-slate-spacer\",STRING:\"data-slate-string\",TEXT:\"data-slate-object\",VOID:\"data-slate-void\",ZERO_WIDTH:\"data-slate-zero-width\"},SELECTORS={BLOCK:\"[\"+DATA_ATTRS.OBJECT+'\\x3d\"block\"]',EDITOR:\"[\"+DATA_ATTRS.EDITOR+\"]\",INLINE:\"[\"+DATA_ATTRS.OBJECT+'\\x3d\"inline\"]',KEY:\"[\"+DATA_ATTRS.KEY+\"]\",LEAF:\"[\"+DATA_ATTRS.LEAF+\"]\",OBJECT:\"[\"+DATA_ATTRS.OBJECT+\n\"]\",STRING:\"[\"+DATA_ATTRS.STRING+\"]\",TEXT:\"[\"+DATA_ATTRS.OBJECT+'\\x3d\"text\"]',VOID:\"[\"+DATA_ATTRS.VOID+\"]\",ZERO_WIDTH:\"[\"+DATA_ATTRS.ZERO_WIDTH+\"]\"},classCallCheck=function(instance,Constructor){if(!(instance instanceof Constructor))throw new TypeError(\"Cannot call a class as a function\");},createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||!1;descriptor.configurable=!0;\"value\"in descriptor&&\n(descriptor.writable=!0);Object.defineProperty(target,descriptor.key,descriptor)}}return function(Constructor,protoProps,staticProps){protoProps&&defineProperties(Constructor.prototype,protoProps);staticProps&&defineProperties(Constructor,staticProps);return Constructor}}(),defineProperty=function(obj,key,value){key in obj?Object.defineProperty(obj,key,{value:value,enumerable:!0,configurable:!0,writable:!0}):obj[key]=value;return obj},_extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=\narguments[i],key;for(key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target},inherits=function(subClass,superClass){if(\"function\"!==typeof superClass&&null!==superClass)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof superClass);subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:!1,writable:!0,configurable:!0}});superClass&&(Object.setPrototypeOf?Object.setPrototypeOf(subClass,\nsuperClass):subClass.__proto__=superClass)},possibleConstructorReturn=function(self,call){if(!self)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!call||\"object\"!==typeof call&&\"function\"!==typeof call?self:call},slicedToArray=function(){return function(arr,i){if(Array.isArray(arr))return arr;if(Symbol.iterator in Object(arr)){var _arr=[],_n=!0,_d=!1,_e=void 0;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done)&&(_arr.push(_s.value),!i||\n_arr.length!==i);_n=!0);}catch(err){_d=!0,_e=err}finally{try{if(!_n&&_i[\"return\"])_i[\"return\"]()}finally{if(_d)throw _e;}}return _arr}throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");}}(),toConsumableArray=function(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++)arr2[i]=arr[i];return arr2}return Array.from(arr)},PARSER=/^([\\w-]+)(?::(\\d+))?$/,OffsetKey={parse:function(string){var matches=PARSER.exec(string);if(!matches)throw Error('Invalid offset key string \"'+\nstring+'\".');string=slicedToArray(matches,3);return{key:string[1],index:parseInt(string[2],10)}},stringify:function(object){return object.key+\":\"+object.index}},TextString=function(_ref){var _ref$text=_ref.text;_ref$text=void 0===_ref$text?\"\":_ref$text;_ref=_ref.isTrailing;_ref=void 0===_ref?!1:_ref;return React.createElement(\"span\",defineProperty({},DATA_ATTRS.STRING,!0),_ref$text,_ref?\"\\n\":null)},ZeroWidthString=function(_ref3){var _ref4,_ref3$length=_ref3.length;_ref3$length=void 0===_ref3$length?\n0:_ref3$length;_ref3=_ref3.isLineBreak;_ref3=void 0===_ref3?!1:_ref3;return React.createElement(\"span\",(_ref4={},defineProperty(_ref4,DATA_ATTRS.ZERO_WIDTH,_ref3?\"n\":\"z\"),defineProperty(_ref4,DATA_ATTRS.LENGTH,_ref3$length),_ref4),\"﻿\",_ref3?React.createElement(\"br\",null):null)},Leaf=function(props){var _attrs,marks=props.marks,annotations=props.annotations,decorations=props.decorations,node=props.node,index=props.index,offset=props.offset,text=props.text,editor=props.editor,parent=props.parent,block=\nprops.block,leaves=props.leaves;props=OffsetKey.stringify({key:node.key,index:index});editor.query(\"isVoid\",parent)?index=React.createElement(ZeroWidthString,{length:parent.text.length}):\"\"===text&&\"block\"===parent.object&&\"\"===parent.text&&parent.nodes.last()===node?index=React.createElement(ZeroWidthString,{isLineBreak:!0}):\"\"===text?index=React.createElement(ZeroWidthString,null):(parent=block.getLastText(),block=text.charAt(text.length-1),index=index===leaves.size-1,index=node===parent&&index&&\n\"\\n\"===block?React.createElement(TextString,{isTrailing:!0,text:text}):React.createElement(TextString,{text:text}));node={editor:editor,marks:marks,annotations:annotations,decorations:decorations,node:node,offset:offset,text:text};offset=!0;text=!1;leaves=void 0;try{for(var _iterator=marks[Symbol.iterator](),_step;!(offset=(_step=_iterator.next()).done);offset=!0){var ret=editor.run(\"renderMark\",_extends({},node,{mark:_step.value,children:index,attributes:defineProperty({},DATA_ATTRS.OBJECT,\"mark\")}));\nret&&(index=ret)}}catch(err){text=!0,leaves=err}finally{try{!offset&&_iterator.return&&_iterator.return()}finally{if(text)throw leaves;}}marks=!0;_iterator=!1;_step=void 0;try{for(var _iterator2=decorations[Symbol.iterator](),_step2;!(marks=(_step2=_iterator2.next()).done);marks=!0)(ret=editor.run(\"renderDecoration\",_extends({},node,{decoration:_step2.value,children:index,attributes:defineProperty({},DATA_ATTRS.OBJECT,\"decoration\")})))&&(index=ret)}catch(err$29){_iterator=!0,_step=err$29}finally{try{!marks&&\n_iterator2.return&&_iterator2.return()}finally{if(_iterator)throw _step;}}decorations=!0;_iterator2=!1;_step2=void 0;try{for(var _iterator3=annotations[Symbol.iterator](),_step3;!(decorations=(_step3=_iterator3.next()).done);decorations=!0)(ret=editor.run(\"renderAnnotation\",_extends({},node,{annotation:_step3.value,children:index,attributes:defineProperty({},DATA_ATTRS.OBJECT,\"annotation\")})))&&(index=ret)}catch(err$30){_iterator2=!0,_step2=err$30}finally{try{!decorations&&_iterator3.return&&_iterator3.return()}finally{if(_iterator2)throw _step2;\n}}annotations=(_attrs={},defineProperty(_attrs,DATA_ATTRS.LEAF,!0),defineProperty(_attrs,DATA_ATTRS.OFFSET_KEY,props),_attrs);return React.createElement(\"span\",annotations,index)};Leaf.propTypes={annotations:ImmutableTypes.list.isRequired,block:SlateTypes.block.isRequired,decorations:ImmutableTypes.list.isRequired,editor:Types.object.isRequired,index:Types.number.isRequired,leaves:Types.object.isRequired,marks:SlateTypes.marks.isRequired,node:SlateTypes.node.isRequired,offset:Types.number.isRequired,\nparent:SlateTypes.node.isRequired,text:Types.string.isRequired};var MemoizedLeaf=React.memo(Leaf,function(prev,next){return next.block===prev.block&&next.index===prev.index&&next.marks===prev.marks&&next.parent===prev.parent&&next.text===prev.text&&next.annotations.equals(prev.annotations)&&next.decorations.equals(prev.decorations)}),Text=React.forwardRef(function(props,ref){var _ref,block=props.block,node=props.node,parent=props.parent,editor=props.editor,style=props.style,key=node.key,leaves=node.getLeaves(props.annotations,\nprops.decorations),at=0;return React.createElement(\"span\",_extends({ref:ref,style:style},(_ref={},defineProperty(_ref,DATA_ATTRS.OBJECT,node.object),defineProperty(_ref,DATA_ATTRS.KEY,key),_ref)),leaves.map(function(leaf,index){var text=leaf.text,offset=at;at+=text.length;return React.createElement(MemoizedLeaf,{key:node.key+\"-\"+index,block:block,editor:editor,index:index,annotations:leaf.annotations,decorations:leaf.decorations,marks:leaf.marks,node:node,offset:offset,parent:parent,leaves:leaves,\ntext:text})}))});Text.propTypes={annotations:ImmutableTypes.map.isRequired,block:SlateTypes.block,decorations:ImmutableTypes.list.isRequired,editor:Types.object.isRequired,node:SlateTypes.node.isRequired,parent:SlateTypes.node.isRequired,style:Types.object};var MemoizedText=React.memo(Text,function(prev,next){return next.node===prev.node&&\"block\"===next.parent.object&&prev.parent.nodes.last()===prev.node&&next.parent.nodes.last()!==next.node&&next.annotations.equals(prev.annotations)&&next.decorations.equals(prev.decorations)}),\ndebug=Debug(\"slate:void\"),Void=function(_React$Component){function Void(){var _ref,_temp,_this,_ret;classCallCheck(this,Void);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];return _ret=(_temp=(_this=possibleConstructorReturn(this,(_ref=Void.__proto__||Object.getPrototypeOf(Void)).call.apply(_ref,[this].concat(args))),_this),_initialiseProps.call(_this),_temp),possibleConstructorReturn(_this,_ret)}inherits(Void,_React$Component);createClass(Void,[{key:\"render\",\nvalue:function(){var _attrs,props=this.props,children=props.children,node=props.node,readOnly=props.readOnly,Tag=\"block\"===node.object?\"div\":\"span\",spacerAttrs=defineProperty({},DATA_ATTRS.SPACER,!0);spacerAttrs=React.createElement(Tag,_extends({style:{height:\"0\",color:\"transparent\",outline:\"none\",position:\"absolute\"}},spacerAttrs),this.renderText());children=React.createElement(Tag,{contentEditable:readOnly?null:!1},children);this.debug(\"render\",{props:props});props=(_attrs={},defineProperty(_attrs,\nDATA_ATTRS.VOID,!0),defineProperty(_attrs,DATA_ATTRS.KEY,node.key),_attrs);return React.createElement(Tag,_extends({contentEditable:readOnly||\"block\"===node.object?null:!1},props),readOnly?null:spacerAttrs,children)}}]);return Void}(React.Component);Void.propTypes={block:SlateTypes.block,children:Types.any.isRequired,editor:Types.object.isRequired,node:SlateTypes.node.isRequired,parent:SlateTypes.node.isRequired,readOnly:Types.bool.isRequired};var _initialiseProps=function(){var _this2=this;this.debug=\nfunction(message){for(var _len2=arguments.length,args=Array(1<_len2?_len2-1:0),_key2=1;_key2<_len2;_key2++)args[_key2-1]=arguments[_key2];_len2=_this2.props.node;debug.apply(void 0,[message,_len2.key+\" (\"+_len2.type+\")\"].concat(args))};this.renderText=function(){var _props=_this2.props,annotations=_props.annotations,block=_props.block,decorations=_props.decorations,node=_props.node,readOnly=_props.readOnly,editor=_props.editor;_props=_props.textRef;var child=node.getFirstText();return React.createElement(MemoizedText,\n{ref:_props,annotations:annotations,block:\"block\"===node.object?node:block,decorations:decorations,editor:editor,key:child.key,node:child,parent:node,readOnly:readOnly})}},debug$1=Debug(\"slate:node\"),Node$jscomp$0=function(_React$Component){function Node(){var _ref,_temp,_this,_ret;classCallCheck(this,Node);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];return _ret=(_temp=(_this=possibleConstructorReturn(this,(_ref=Node.__proto__||Object.getPrototypeOf(Node)).call.apply(_ref,\n[this].concat(args))),_this),_initialiseProps$1.call(_this),_temp),possibleConstructorReturn(_this,_ret)}inherits(Node,_React$Component);createClass(Node,[{key:\"shouldComponentUpdate\",value:function(nextProps){var props=this.props,shouldUpdate=props.editor.run(\"shouldNodeComponentUpdate\",props,nextProps);if(null!=shouldUpdate){warning(!1,'As of slate-react@0.22 the `shouldNodeComponentUpdate` middleware is deprecated. You can pass specific values down the tree using React\\'s built-in \"context\" construct instead.');\nif(shouldUpdate)return!0;warning(!1!==shouldUpdate,\"Returning false in `shouldNodeComponentUpdate` does not disable Slate's internal `shouldComponentUpdate` logic. If you want to prevent updates, use React's `shouldComponentUpdate` instead.\")}return nextProps.readOnly!==props.readOnly||nextProps.node!==props.node||!nextProps.selection&&props.selection||nextProps.selection&&!props.selection||nextProps.selection&&props.selection&&!nextProps.selection.equals(props.selection)||!nextProps.annotations.equals(props.annotations)||\n!nextProps.decorations.equals(props.decorations)?!0:!1}},{key:\"render\",value:function(){var _this2=this,_attributes;this.debug(\"render\",this);var _props=this.props,annotations=_props.annotations,block=_props.block,decorations=_props.decorations,editor=_props.editor,node=_props.node,parent=_props.parent,readOnly=_props.readOnly,selection=_props.selection,newDecorations=node.getDecorations(editor);_props=node.nodes.toArray().map(function(child,i){var Component=\"text\"===child.object?MemoizedText:Node,\nsel=selection&&getRelativeRange(node,i,selection),decs=newDecorations.concat(decorations).map(function(d){return getRelativeRange(node,i,d)}).filter(function(d){return d}),anns=annotations.map(function(a){return getRelativeRange(node,i,a)}).filter(function(a){return a});return React.createElement(Component,{block:\"block\"===node.object?node:block,editor:editor,annotations:anns,decorations:decs,selection:sel,key:child.key,node:child,parent:node,readOnly:readOnly,ref:function(_ref2){_ref2?_this2.tmp.nodeRefs[i]=\n_ref2:delete _this2.tmp.nodeRefs[i]}})});var attributes=(_attributes={},defineProperty(_attributes,DATA_ATTRS.OBJECT,node.object),defineProperty(_attributes,DATA_ATTRS.KEY,node.key),defineProperty(_attributes,\"ref\",this.ref),_attributes);node.isLeafBlock()&&\"rtl\"===node.getTextDirection()&&(attributes.dir=\"rtl\");_attributes=void 0;\"block\"===node.object?_attributes=\"renderBlock\":\"document\"===node.object?_attributes=\"renderDocument\":\"inline\"===node.object&&(_attributes=\"renderInline\");parent=editor.run(_attributes,\n{attributes:attributes,children:_props,editor:editor,isFocused:!!selection&&selection.isFocused,isSelected:!!selection,node:node,parent:parent,readOnly:readOnly});return editor.isVoid(node)?React.createElement(Void,_extends({},this.props,{textRef:function(ref){ref?_this2.tmp.nodeRefs[0]=ref:delete _this2.tmp.nodeRefs[0]}}),parent):parent}}]);return Node}(React.Component);Node$jscomp$0.propTypes={annotations:ImmutableTypes.map.isRequired,block:SlateTypes.block,decorations:ImmutableTypes.list.isRequired,\neditor:Types.object.isRequired,node:SlateTypes.node.isRequired,parent:SlateTypes.node,readOnly:Types.bool.isRequired,selection:SlateTypes.selection};var _initialiseProps$1=function(){var _this3=this;this.tmp={nodeRefs:{}};this.ref=React.createRef();this.debug=function(message){for(var _len2=arguments.length,args=Array(1<_len2?_len2-1:0),_key2=1;_key2<_len2;_key2++)args[_key2-1]=arguments[_key2];_len2=_this3.props.node;debug$1.apply(void 0,[message,_len2.key+\" (\"+_len2.type+\")\"].concat(args))}},OVERFLOWS=\n[\"auto\",\"overlay\",\"scroll\"],IS_IOS_11=slateDevEnvironment.IS_IOS&&!!window.navigator.userAgent.match(/os 11_/i),FIREFOX_NODE_TYPE_ACCESS_ERROR=/Permission denied to access property \"nodeType\"/,debug$2=Debug(\"slate:content\");debug$2.update=Debug(\"slate:update\");var Content=function(_React$Component){function Content(){var _ref,_temp,_this,_ret;classCallCheck(this,Content);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];return _ret=(_temp=(_this=possibleConstructorReturn(this,\n(_ref=Content.__proto__||Object.getPrototypeOf(Content)).call.apply(_ref,[this].concat(args))),_this),_this.tmp={isUpdatingSelection:!1,nodeRef:React.createRef(),nodeRefs:{},contentKey:0,nativeSelection:{}},_this.ref=React.createRef(),_this.setRef=function(el){_this.ref.current=el;_this.props.editor.el=el},_this.handlers=EVENT_HANDLERS.reduce(function(obj,handler){obj[handler]=function(event){return _this.onEvent(handler,event)};return obj},{}),_this.updateSelection=function(){var editor=_this.props.editor,\nselection=editor.value.selection,isBackward$$1=selection.isBackward,window=getWindow(_this.ref.current),native=window.getSelection(),activeElement=window.document.activeElement;debug$2.update.enabled&&debug$2.update(\"updateSelection\",{selection:selection.toJSON()});if(native){var rangeCount=native.rangeCount,anchorNode=native.anchorNode,updated=!1;selection.isBlurred&&activeElement===_this.ref.current&&(_this.ref.current.blur(),updated=!0);var propsToCompare=\"anchorNode anchorOffset focusNode focusOffset isCollapsed rangeCount type\".split(\" \"),\nselectionsEqual=!0,_iteratorNormalCompletion=!0,_didIteratorError=!1,_iteratorError=void 0;try{for(var _iterator=propsToCompare[Symbol.iterator](),_step;!(_iteratorNormalCompletion=(_step=_iterator.next()).done);_iteratorNormalCompletion=!0){var prop=_step.value;_this.tmp.nativeSelection[prop]!==native[prop]&&(selectionsEqual=!1)}}catch(err){_didIteratorError=!0,_iteratorError=err}finally{try{!_iteratorNormalCompletion&&_iterator.return&&_iterator.return()}finally{if(_didIteratorError)throw _iteratorError;\n}}selection.isUnset&&rangeCount&&_this.isInEditor(anchorNode)&&selectionsEqual&&(removeAllRanges(native),updated=!0);selection.isFocused&&activeElement!==_this.ref.current&&(_this.ref.current.focus({preventScroll:!0}),updated=!0);if(selection.isFocused&&selection.isSet){updated=!!native.rangeCount&&native.getRangeAt(0);rangeCount=editor.findDOMRange(selection);if(!rangeCount){warning(!1,\"Unable to find a native DOM range from the current selection.\");return}anchorNode=rangeCount.startContainer;propsToCompare=\nrangeCount.startOffset;selectionsEqual=rangeCount.endContainer;_iteratorNormalCompletion=rangeCount.endOffset;if(updated&&(anchorNode===updated.startContainer&&propsToCompare===updated.startOffset&&selectionsEqual===updated.endContainer&&_iteratorNormalCompletion===updated.endOffset||anchorNode===updated.endContainer&&propsToCompare===updated.endOffset&&selectionsEqual===updated.startContainer&&_iteratorNormalCompletion===updated.startOffset))return;updated=!0;_this.tmp.isUpdatingSelection=!0;removeAllRanges(native);\nnative.setBaseAndExtent?isBackward$$1?native.setBaseAndExtent(rangeCount.endContainer,rangeCount.endOffset,rangeCount.startContainer,rangeCount.startOffset):native.setBaseAndExtent(rangeCount.startContainer,rangeCount.startOffset,rangeCount.endContainer,rangeCount.endOffset):native.addRange(rangeCount);!0===editor.userActionPerformed()&&scrollToSelection(native);setTimeout(function(){slateDevEnvironment.IS_FIREFOX&&_this.ref.current&&_this.ref.current.focus();_this.tmp.isUpdatingSelection=!1;debug$2.update(\"updateSelection:setTimeout\",\n{anchorOffset:window.getSelection().anchorOffset})})}updated&&(debug$2.enabled||debug$2.update.enabled)&&(debug$2(\"updateSelection\",{selection:selection,native:native,activeElement:activeElement}),debug$2.update(\"updateSelection:applied\",{selection:selection.toJSON(),native:{anchorOffset:native.anchorOffset,focusOffset:native.focusOffset}}))}},_this.isInEditor=function(target){var el=void 0;try{if(8===target.nodeType)return!1;el=3===target.nodeType?target.parentNode:target}catch(err){if(slateDevEnvironment.IS_FIREFOX&&\nFIREFOX_NODE_TYPE_ACCESS_ERROR.test(err.message))return!1;throw err;}return el.isContentEditable&&(el===_this.ref.current||el.closest(SELECTORS.EDITOR)===_this.ref.current)},_this.onNativeSelectionChange=throttle(function(event){if(!_this.props.readOnly){var window=getWindow(event.target),activeElement=window.document.activeElement;window=window.getSelection();debug$2.update(\"onNativeSelectionChange\",{anchorOffset:window.anchorOffset});activeElement===_this.ref.current&&(_this.tmp.nativeSelection=\n{anchorNode:window.anchorNode,anchorOffset:window.anchorOffset,focusNode:window.focusNode,focusOffset:window.focusOffset,isCollapsed:window.isCollapsed,rangeCount:window.rangeCount,type:window.type},_this.props.onEvent(\"onSelect\",event))}},100),_temp),possibleConstructorReturn(_this,_ret)}inherits(Content,_React$Component);createClass(Content,[{key:\"componentDidCatch\",value:function(error,info){debug$2(\"componentDidCatch\",{error:error,info:info});this.setState({})}},{key:\"componentDidMount\",value:function(){getWindow(this.ref.current).document.addEventListener(\"selectionchange\",\nthis.onNativeSelectionChange);slateDevEnvironment.HAS_INPUT_EVENTS_LEVEL_2&&this.ref.current.addEventListener(\"beforeinput\",this.handlers.onBeforeInput);this.updateSelection();this.props.onEvent(\"onComponentDidMount\")}},{key:\"componentWillUnmount\",value:function(){var window=getWindow(this.ref.current);window&&window.document.removeEventListener(\"selectionchange\",this.onNativeSelectionChange);slateDevEnvironment.HAS_INPUT_EVENTS_LEVEL_2&&this.ref.current.removeEventListener(\"beforeinput\",this.handlers.onBeforeInput);\nthis.props.onEvent(\"onComponentWillUnmount\")}},{key:\"componentDidUpdate\",value:function(){debug$2.update(\"componentDidUpdate\");this.updateSelection();this.props.editor.clearUserActionPerformed();this.props.onEvent(\"onComponentDidUpdate\")}},{key:\"onEvent\",value:function(handler,event){debug$2(\"onEvent\",handler);var nativeEvent=event.nativeEvent||event;nativeEvent=\"keydown\"===event.type&&(Hotkeys.isUndo(nativeEvent)||Hotkeys.isRedo(nativeEvent));if(!this.tmp.isUpdatingSelection&&!nativeEvent||\"onSelect\"!==\nhandler&&\"onBlur\"!==handler&&\"onFocus\"!==handler){if(!slateDevEnvironment.IS_ANDROID&&\"onSelect\"===handler){var editor=this.props.editor;nativeEvent=editor.value.selection;var domSelection=getWindow(event.target).getSelection();if((editor=editor.findRange(domSelection))&&editor.equals(nativeEvent.toRange())){this.updateSelection();return}}if(\"onDragEnd\"!==handler&&\"onDragEnter\"!==handler&&\"onDragExit\"!==handler&&\"onDragLeave\"!==handler&&\"onDragOver\"!==handler&&\"onDragStart\"!==handler&&\"onDrop\"!==\nhandler||event.target.closest(SELECTORS.EDITOR)===this.ref.current)if(\"onBeforeInput\"!==handler&&\"onBlur\"!==handler&&\"onCompositionEnd\"!==handler&&\"onCompositionStart\"!==handler&&\"onCopy\"!==handler&&\"onCut\"!==handler&&\"onFocus\"!==handler&&\"onInput\"!==handler&&\"onKeyDown\"!==handler&&\"onKeyUp\"!==handler&&\"onPaste\"!==handler&&\"onSelect\"!==handler||this.isInEditor(event.target))this.props.onEvent(handler,event)}}},{key:\"render\",value:function(){var _data,props=this.props,handlers=this.handlers,id=props.id,\nclassName=props.className,readOnly=props.readOnly,editor=props.editor,tabIndex=props.tabIndex,role=props.role,spellCheck=props.spellCheck,value=editor.value,Container=props.tagName,document=value.document,selection=value.selection,style=_extends({outline:\"none\",whiteSpace:\"pre-wrap\",wordWrap:\"break-word\"},readOnly?{}:{WebkitUserModify:\"read-write-plaintext-only\"},props.style);debug$2(\"render\",{props:props});debug$2.update(\"render\",this.tmp.contentKey,document.text);this.props.onEvent(\"onRender\");\nvar data=(_data={},defineProperty(_data,DATA_ATTRS.EDITOR,!0),defineProperty(_data,DATA_ATTRS.KEY,document.key),_data);_data=omit(this.props,Object.keys(Content.propTypes));return React.createElement(Container,_extends({},_data,{key:this.tmp.contentKey},handlers,data,{ref:this.setRef,contentEditable:readOnly?null:!0,suppressContentEditableWarning:!0,id:id,className:className,autoCorrect:props.autoCorrect?\"on\":\"off\",spellCheck:spellCheck,style:style,role:readOnly?null:role||\"textbox\",tabIndex:tabIndex,\n\"data-gramm\":_data[\"data-gramm\"]?void 0:!1}),React.createElement(Node$jscomp$0,{annotations:value.annotations,block:null,decorations:immutable.List(),editor:editor,node:document,parent:null,readOnly:readOnly,selection:selection,ref:this.tmp.nodeRef}))}}]);return Content}(React.Component);Content.propTypes={autoCorrect:Types.bool.isRequired,className:Types.string,contentKey:Types.number,editor:Types.object.isRequired,id:Types.string,onEvent:Types.func.isRequired,readOnly:Types.bool.isRequired,role:Types.string,\nspellCheck:Types.bool.isRequired,style:Types.object,tabIndex:Types.number,tagName:Types.string};Content.defaultProps={style:{},tagName:\"div\"};var PROPS=[].concat(toConsumableArray(EVENT_HANDLERS),\"commands decorateNode queries renderAnnotation renderBlock renderDecoration renderDocument renderEditor renderInline renderMark schema\".split(\" \")),debug$3=Debug(\"slate:composition-manager\"),ZERO_WIDTH_SPACE=String.fromCharCode(65279),flushControlled=ReactDOM.unstable_flushControlled,TRANSFER_TYPES={FRAGMENT:\"application/x-slate-fragment\",\nHTML:\"text/html\",NODE:\"application/x-slate-node\",RICH:\"text/rtf\",TEXT:\"text/plain\"},FRAGMENT=TRANSFER_TYPES.FRAGMENT,HTML=TRANSFER_TYPES.HTML,TEXT=TRANSFER_TYPES.TEXT,FRAGMENT$1=TRANSFER_TYPES.FRAGMENT,HTML$1=TRANSFER_TYPES.HTML,NODE=TRANSFER_TYPES.NODE,RICH=TRANSFER_TYPES.RICH,TEXT$1=TRANSFER_TYPES.TEXT,FRAGMENT_MATCHER=/ data-slate-fragment=\"([^\\s\"]+)\"/,TEXT$2=TRANSFER_TYPES.TEXT,debug$4=Debug(\"slate:after\"),debug$5=Debug(\"slate:before\"),debug$6=Debug(\"slate:events\"),debug$7=Debug(\"slate:batch-events\"),\ndebug$8=Debug(\"slate:mutations\"),MUTATION_PROPERTIES=\"type oldValue target addedNodes removedNodes attributeName attributeNamespace nextSibling previousSibling\".split(\" \"),debug$9=Debug(\"slate:editor\"),Editor$jscomp$0=function(_React$Component){function Editor(){var _ref,_temp,_this,_ret;classCallCheck(this,Editor);for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++)args[_key]=arguments[_key];return _ret=(_temp=(_this=possibleConstructorReturn(this,(_ref=Editor.__proto__||Object.getPrototypeOf(Editor)).call.apply(_ref,\n[this].concat(args))),_this),_this.state={value:_this.props.defaultValue,contentKey:0},_this.tmp={mounted:!1,change:null,resolves:0,updates:0,contentRef:React.createRef()},_this.resolveController=memoizeOne(function(JSCompiler_OptimizeArgumentsArray_p2,JSCompiler_OptimizeArgumentsArray_p3,JSCompiler_OptimizeArgumentsArray_p4,JSCompiler_OptimizeArgumentsArray_p5,JSCompiler_OptimizeArgumentsArray_p6,JSCompiler_OptimizeArgumentsArray_p7){warning(5>_this.tmp.resolves||_this.tmp.resolves!==_this.tmp.updates,\n\"A Slate \\x3cEditor\\x3e component is re-resolving the `plugins`, `schema`, `commands`, `queries` or `placeholder` prop on each update, which leads to poor performance. This is often due to passing in a new references for these props with each render by declaring them inline in your render function. Do not do this! Declare them outside your render function, or memoize them instead.\");_this.tmp.resolves++;JSCompiler_OptimizeArgumentsArray_p2=JSCompiler_OptimizeArgumentsArray_p7(_extends({},_this.props,\n{editor:_this,value:_this.props.value||_this.state.value}));_this.controller=new slate.Editor({plugins:[JSCompiler_OptimizeArgumentsArray_p2],onChange:function(change){_this.tmp.mounted?_this.handleChange(change):_this.tmp.change=change}},{controller:_this,construct:!1});_this.controller.run(\"onConstruct\")}),_temp),possibleConstructorReturn(_this,_ret)}inherits(Editor,_React$Component);createClass(Editor,[{key:\"componentDidMount\",value:function(){this.tmp.mounted=!0;this.tmp.updates++;this.props.autoFocus&&\nthis.focus();this.tmp.change&&(this.handleChange(this.tmp.change),this.tmp.change=null)}},{key:\"componentDidUpdate\",value:function(){this.tmp.updates++;this.tmp.change&&(this.handleChange(this.tmp.change),this.tmp.change=null)}},{key:\"componentWillUnmount\",value:function(){this.tmp.mounted=!1}},{key:\"render\",value:function(){var _this2=this;debug$9(\"render\",this);var _props=this.props;this.resolveController(_props.plugins,_props.schema,_props.commands,_props.queries,_props.placeholder,ReactPlugin);\nvar _props2=this.props,options=_props2.options;_props=_props2.readOnly;var valueFromState=this.state.value;valueFromState=_props2.value||valueFromState;_props2=this.state.contentKey;this.controller.setReadOnly(_props);this.controller.setValue(valueFromState,options);var _props3=this.props;options=_props3.autoCorrect;valueFromState=_props3.className;var id=_props3.id,role=_props3.role,spellCheck=_props3.spellCheck,tabIndex=_props3.tabIndex,style=_props3.style;_props3=_props3.tagName;var domProps=omit(this.props,\nObject.keys(Editor.propTypes));_props=React.createElement(Content,_extends({},domProps,{ref:this.tmp.contentRef,autoCorrect:options,className:valueFromState,contentKey:_props2,editor:this,id:id,onEvent:function(handler,event){return _this2.run(handler,event)},readOnly:_props,role:role,spellCheck:spellCheck,style:style,tabIndex:tabIndex,tagName:_props3}));return this.controller.run(\"renderEditor\",_extends({},this.props,{editor:this,children:_props}))}},{key:\"handleChange\",value:function(change){var onChange=\nthis.props.onChange;this.state.value&&this.setState({value:change.value});onChange(change)}},{key:\"applyOperation\",value:function(){var _controller;return(_controller=this.controller).applyOperation.apply(_controller,arguments)}},{key:\"command\",value:function(){var _controller2;return(_controller2=this.controller).command.apply(_controller2,arguments)}},{key:\"hasCommand\",value:function(){var _controller3;return(_controller3=this.controller).hasCommand.apply(_controller3,arguments)}},{key:\"hasQuery\",\nvalue:function(){var _controller4;return(_controller4=this.controller).hasQuery.apply(_controller4,arguments)}},{key:\"normalize\",value:function(){var _controller5;return(_controller5=this.controller).normalize.apply(_controller5,arguments)}},{key:\"query\",value:function(){var _controller6;return(_controller6=this.controller).query.apply(_controller6,arguments)}},{key:\"registerCommand\",value:function(){var _controller7;return(_controller7=this.controller).registerCommand.apply(_controller7,arguments)}},\n{key:\"registerQuery\",value:function(){var _controller8;return(_controller8=this.controller).registerQuery.apply(_controller8,arguments)}},{key:\"run\",value:function(){var _controller9;return(_controller9=this.controller).run.apply(_controller9,arguments)}},{key:\"withoutNormalizing\",value:function(){var _controller10;return(_controller10=this.controller).withoutNormalizing.apply(_controller10,arguments)}},{key:\"call\",value:function(){var _controller11;return(_controller11=this.controller).call.apply(_controller11,\narguments)}},{key:\"change\",value:function(){var _controller12;return(_controller12=this.controller).change.apply(_controller12,arguments)}},{key:\"onChange\",value:function(){var _controller13;return(_controller13=this.controller).onChange.apply(_controller13,arguments)}},{key:\"applyOperations\",value:function(){var _controller14;return(_controller14=this.controller).applyOperations.apply(_controller14,arguments)}},{key:\"setOperationFlag\",value:function(){var _controller15;return(_controller15=this.controller).setOperationFlag.apply(_controller15,\narguments)}},{key:\"getFlag\",value:function(){var _controller16;return(_controller16=this.controller).getFlag.apply(_controller16,arguments)}},{key:\"unsetOperationFlag\",value:function(){var _controller17;return(_controller17=this.controller).unsetOperationFlag.apply(_controller17,arguments)}},{key:\"withoutNormalization\",value:function(){var _controller18;return(_controller18=this.controller).withoutNormalization.apply(_controller18,arguments)}},{key:\"operations\",get:function(){return this.controller.operations}},\n{key:\"readOnly\",get:function(){return this.controller.readOnly}},{key:\"value\",get:function(){return this.controller.value}},{key:\"editor\",get:function(){return this.controller.editor}},{key:\"schema\",get:function(){invariant(!1,\"As of Slate 0.42, the `editor.schema` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.\")}},{key:\"stack\",get:function(){invariant(!1,\"As of Slate 0.42, the `editor.stack` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.\")}}]);\nreturn Editor}(React.Component);Editor$jscomp$0.propTypes=_extends({autoCorrect:Types.bool,autoFocus:Types.bool,className:Types.string,defaultValue:SlateTypes.value,id:Types.string,onChange:Types.func,options:Types.object,placeholder:Types.any,plugins:Types.array,readOnly:Types.bool,role:Types.string,schema:Types.object,spellCheck:Types.bool,style:Types.object,tabIndex:Types.number,value:SlateTypes.value},EVENT_HANDLERS.reduce(function(obj,handler){obj[handler]=Types.func;return obj},{}),\"decorateNode renderAnnotation renderBlock renderDecoration renderDocument renderEditor renderInline renderMark\".split(\" \").reduce(function(obj,\nhandler){obj[handler]=Types.func;return obj},{}));Editor$jscomp$0.defaultProps={autoFocus:!1,autoCorrect:!0,onChange:function(){},options:{},placeholder:\"\",plugins:[],readOnly:!1,schema:{},spellCheck:!0};var index$jscomp$0={Editor:Editor$jscomp$0,cloneFragment:cloneFragment,findDOMNode:findDOMNode,findDOMPoint:findDOMPoint,findDOMRange:findDOMRange,findNode:findNode,findPath:findPath,findPoint:findPoint,findRange:findRange,getEventRange:getEventRange,getEventTransfer:getEventTransfer,setEventTransfer:setEventTransfer,\nReactPlugin:ReactPlugin};exports.Editor=Editor$jscomp$0;exports.cloneFragment=cloneFragment;exports.findDOMNode=findDOMNode;exports.findDOMPoint=findDOMPoint;exports.findDOMRange=findDOMRange;exports.findNode=findNode;exports.findPath=findPath;exports.findPoint=findPoint;exports.findRange=findRange;exports.getEventRange=getEventRange;exports.getEventTransfer=getEventTransfer;exports.setEventTransfer=setEventTransfer;exports.ReactPlugin=ReactPlugin;exports.default=index$jscomp$0}","~:source","shadow$provide[\"module$node_modules$slate_react$lib$slate_react\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\n\nvar React = _interopDefault(require('react'));\nvar Types = _interopDefault(require('prop-types'));\nvar SlateTypes = _interopDefault(require('slate-prop-types'));\nvar ImmutableTypes = _interopDefault(require('react-immutable-proptypes'));\nvar Debug = _interopDefault(require('debug'));\nvar warning = _interopDefault(require('tiny-warning'));\nvar slate = require('slate');\nvar getWindow = _interopDefault(require('get-window'));\nvar isBackward = _interopDefault(require('selection-is-backward'));\nvar slateDevEnvironment = require('slate-dev-environment');\nvar throttle = _interopDefault(require('lodash/throttle'));\nvar omit = _interopDefault(require('lodash/omit'));\nvar immutable = require('immutable');\nvar Hotkeys = _interopDefault(require('slate-hotkeys'));\nvar ReactDOM = _interopDefault(require('react-dom'));\nvar Base64 = _interopDefault(require('slate-base64-serializer'));\nvar Plain = _interopDefault(require('slate-plain-serializer'));\nvar invariant = _interopDefault(require('tiny-invariant'));\nvar PlaceholderPlugin = _interopDefault(require('slate-react-placeholder'));\nvar memoizeOne = _interopDefault(require('memoize-one'));\n\n/**\n * Event handlers used by Slate plugins.\n *\n * @type {Array}\n */\n\nvar EVENT_HANDLERS = ['onBeforeInput', 'onBlur', 'onClick', 'onContextMenu', 'onCompositionEnd', 'onCompositionStart', 'onCopy', 'onCut', 'onDragEnd', 'onDragEnter', 'onDragExit', 'onDragLeave', 'onDragOver', 'onDragStart', 'onDrop', 'onInput', 'onFocus', 'onKeyDown', 'onKeyUp', 'onMouseDown', 'onMouseUp', 'onPaste', 'onSelect'];\n\n/**\n * Other handlers used by Slate plugins.\n *\n * @type {Array}\n */\n\nvar OTHER_HANDLERS = ['decorateNode', 'renderAnnotation', 'renderBlock', 'renderDecoration', 'renderDocument', 'renderEditor', 'renderInline', 'renderMark'];\n\n/**\n * DOM data attribute strings that refer to Slate concepts.\n *\n * @type {String}\n */\n\nvar DATA_ATTRS = {\n  EDITOR: 'data-slate-editor',\n  FRAGMENT: 'data-slate-fragment',\n  KEY: 'data-key',\n  LEAF: 'data-slate-leaf',\n  LENGTH: 'data-slate-length',\n  OBJECT: 'data-slate-object',\n  OFFSET_KEY: 'data-offset-key',\n  SPACER: 'data-slate-spacer',\n  STRING: 'data-slate-string',\n  TEXT: 'data-slate-object',\n  VOID: 'data-slate-void',\n  ZERO_WIDTH: 'data-slate-zero-width'\n};\n\n/**\n * DOM selector strings that refer to Slate concepts.\n *\n * @type {String}\n */\n\nvar SELECTORS = {\n  BLOCK: '[' + DATA_ATTRS.OBJECT + '=\"block\"]',\n  EDITOR: '[' + DATA_ATTRS.EDITOR + ']',\n  INLINE: '[' + DATA_ATTRS.OBJECT + '=\"inline\"]',\n  KEY: '[' + DATA_ATTRS.KEY + ']',\n  LEAF: '[' + DATA_ATTRS.LEAF + ']',\n  OBJECT: '[' + DATA_ATTRS.OBJECT + ']',\n  STRING: '[' + DATA_ATTRS.STRING + ']',\n  TEXT: '[' + DATA_ATTRS.OBJECT + '=\"text\"]',\n  VOID: '[' + DATA_ATTRS.VOID + ']',\n  ZERO_WIDTH: '[' + DATA_ATTRS.ZERO_WIDTH + ']'\n};\n\nvar classCallCheck = function (instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n};\n\nvar createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\n\n\n\n\nvar defineProperty = function (obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n};\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\n\n\nvar inherits = function (subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n};\n\n\n\n\n\n\n\n\n\n\n\nvar possibleConstructorReturn = function (self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n};\n\n\n\n\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/**\n * Offset key parser regex.\n *\n * @type {RegExp}\n */\n\nvar PARSER = /^([\\w-]+)(?::(\\d+))?$/;\n\n/**\n * Parse an offset key `string`.\n *\n * @param {String} string\n * @return {Object}\n */\n\nfunction parse(string) {\n  var matches = PARSER.exec(string);\n\n  if (!matches) {\n    throw new Error(\"Invalid offset key string \\\"\" + string + \"\\\".\");\n  }\n\n  var _matches = slicedToArray(matches, 3),\n      original = _matches[0],\n      key = _matches[1],\n      index = _matches[2]; // eslint-disable-line no-unused-vars\n\n\n  return {\n    key: key,\n    index: parseInt(index, 10)\n  };\n}\n\n/**\n * Stringify an offset key `object`.\n *\n * @param {Object} object\n *   @property {String} key\n *   @property {Number} index\n * @return {String}\n */\n\nfunction stringify(object) {\n  return object.key + \":\" + object.index;\n}\n\n/**\n * Export.\n *\n * @type {Object}\n */\n\nvar OffsetKey = {\n  parse: parse,\n  stringify: stringify\n};\n\n/**\n * Leaf strings with text in them.\n *\n * @type {Component}\n */\n\nvar TextString = function TextString(_ref) {\n  var _ref$text = _ref.text,\n      text = _ref$text === undefined ? '' : _ref$text,\n      _ref$isTrailing = _ref.isTrailing,\n      isTrailing = _ref$isTrailing === undefined ? false : _ref$isTrailing;\n\n  return React.createElement(\n    'span',\n    defineProperty({}, DATA_ATTRS.STRING, true),\n    text,\n    isTrailing ? '\\n' : null\n  );\n};\n\n/**\n * Leaf strings without text, render as zero-width strings.\n *\n * @type {Component}\n */\n\nvar ZeroWidthString = function ZeroWidthString(_ref3) {\n  var _ref4;\n\n  var _ref3$length = _ref3.length,\n      length = _ref3$length === undefined ? 0 : _ref3$length,\n      _ref3$isLineBreak = _ref3.isLineBreak,\n      isLineBreak = _ref3$isLineBreak === undefined ? false : _ref3$isLineBreak;\n\n  return React.createElement(\n    'span',\n    (_ref4 = {}, defineProperty(_ref4, DATA_ATTRS.ZERO_WIDTH, isLineBreak ? 'n' : 'z'), defineProperty(_ref4, DATA_ATTRS.LENGTH, length), _ref4),\n    '\\uFEFF',\n    isLineBreak ? React.createElement('br', null) : null\n  );\n};\n\n/**\n * Individual leaves in a text node with unique formatting.\n *\n * @type {Component}\n */\n\nvar Leaf = function Leaf(props) {\n  var _attrs;\n\n  var marks = props.marks,\n      annotations = props.annotations,\n      decorations = props.decorations,\n      node = props.node,\n      index = props.index,\n      offset = props.offset,\n      text = props.text,\n      editor = props.editor,\n      parent = props.parent,\n      block = props.block,\n      leaves = props.leaves;\n\n\n  var offsetKey = OffsetKey.stringify({\n    key: node.key,\n    index: index\n  });\n\n  var children = void 0;\n\n  if (editor.query('isVoid', parent)) {\n    // COMPAT: Render text inside void nodes with a zero-width space.\n    // So the node can contain selection but the text is not visible.\n    children = React.createElement(ZeroWidthString, { length: parent.text.length });\n  } else if (text === '' && parent.object === 'block' && parent.text === '' && parent.nodes.last() === node) {\n    // COMPAT: If this is the last text node in an empty block, render a zero-\n    // width space that will convert into a line break when copying and pasting\n    // to support expected plain text.\n    children = React.createElement(ZeroWidthString, { isLineBreak: true });\n  } else if (text === '') {\n    // COMPAT: If the text is empty, it's because it's on the edge of an inline\n    // node, so we render a zero-width space so that the selection can be\n    // inserted next to it still.\n    children = React.createElement(ZeroWidthString, null);\n  } else {\n    // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\n    // so we need to add an extra trailing new lines to prevent that.\n    var lastText = block.getLastText();\n    var lastChar = text.charAt(text.length - 1);\n    var isLastText = node === lastText;\n    var isLastLeaf = index === leaves.size - 1;\n\n    if (isLastText && isLastLeaf && lastChar === '\\n') {\n      children = React.createElement(TextString, { isTrailing: true, text: text });\n    } else {\n      children = React.createElement(TextString, { text: text });\n    }\n  }\n\n  var renderProps = {\n    editor: editor,\n    marks: marks,\n    annotations: annotations,\n    decorations: decorations,\n    node: node,\n    offset: offset,\n    text: text\n\n    // COMPAT: Having the `data-` attributes on these leaf elements ensures that\n    // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\n    // contenteditable behaviors. (2019/05/08)\n  };var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = marks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var mark = _step.value;\n\n      var ret = editor.run('renderMark', _extends({}, renderProps, {\n        mark: mark,\n        children: children,\n        attributes: defineProperty({}, DATA_ATTRS.OBJECT, 'mark')\n      }));\n\n      if (ret) {\n        children = ret;\n      }\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion2 = true;\n  var _didIteratorError2 = false;\n  var _iteratorError2 = undefined;\n\n  try {\n    for (var _iterator2 = decorations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n      var decoration = _step2.value;\n\n      var ret = editor.run('renderDecoration', _extends({}, renderProps, {\n        decoration: decoration,\n        children: children,\n        attributes: defineProperty({}, DATA_ATTRS.OBJECT, 'decoration')\n      }));\n\n      if (ret) {\n        children = ret;\n      }\n    }\n  } catch (err) {\n    _didIteratorError2 = true;\n    _iteratorError2 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\n        _iterator2.return();\n      }\n    } finally {\n      if (_didIteratorError2) {\n        throw _iteratorError2;\n      }\n    }\n  }\n\n  var _iteratorNormalCompletion3 = true;\n  var _didIteratorError3 = false;\n  var _iteratorError3 = undefined;\n\n  try {\n    for (var _iterator3 = annotations[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n      var annotation = _step3.value;\n\n      var ret = editor.run('renderAnnotation', _extends({}, renderProps, {\n        annotation: annotation,\n        children: children,\n        attributes: defineProperty({}, DATA_ATTRS.OBJECT, 'annotation')\n      }));\n\n      if (ret) {\n        children = ret;\n      }\n    }\n  } catch (err) {\n    _didIteratorError3 = true;\n    _iteratorError3 = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\n        _iterator3.return();\n      }\n    } finally {\n      if (_didIteratorError3) {\n        throw _iteratorError3;\n      }\n    }\n  }\n\n  var attrs = (_attrs = {}, defineProperty(_attrs, DATA_ATTRS.LEAF, true), defineProperty(_attrs, DATA_ATTRS.OFFSET_KEY, offsetKey), _attrs);\n\n  return React.createElement(\n    'span',\n    attrs,\n    children\n  );\n};\n\n/**\n * Prop types.\n *\n * @type {Object}\n */\n\nLeaf.propTypes = {\n  annotations: ImmutableTypes.list.isRequired,\n  block: SlateTypes.block.isRequired,\n  decorations: ImmutableTypes.list.isRequired,\n  editor: Types.object.isRequired,\n  index: Types.number.isRequired,\n  leaves: Types.object.isRequired,\n  marks: SlateTypes.marks.isRequired,\n  node: SlateTypes.node.isRequired,\n  offset: Types.number.isRequired,\n  parent: SlateTypes.node.isRequired,\n  text: Types.string.isRequired\n\n  /**\n   * A memoized version of `Leaf` that updates less frequently.\n   *\n   * @type {Component}\n   */\n\n};var MemoizedLeaf = React.memo(Leaf, function (prev, next) {\n  return next.block === prev.block && next.index === prev.index && next.marks === prev.marks && next.parent === prev.parent && next.text === prev.text && next.annotations.equals(prev.annotations) && next.decorations.equals(prev.decorations);\n});\n\n/**\n * Text node.\n *\n * @type {Component}\n */\n\nvar Text = React.forwardRef(function (props, ref) {\n  var _ref;\n\n  var annotations = props.annotations,\n      block = props.block,\n      decorations = props.decorations,\n      node = props.node,\n      parent = props.parent,\n      editor = props.editor,\n      style = props.style;\n  var key = node.key;\n\n  var leaves = node.getLeaves(annotations, decorations);\n  var at = 0;\n\n  return React.createElement(\n    'span',\n    _extends({\n      ref: ref,\n      style: style\n    }, (_ref = {}, defineProperty(_ref, DATA_ATTRS.OBJECT, node.object), defineProperty(_ref, DATA_ATTRS.KEY, key), _ref)),\n    leaves.map(function (leaf, index) {\n      var text = leaf.text;\n\n      var offset = at;\n      at += text.length;\n\n      return React.createElement(MemoizedLeaf, {\n        key: node.key + '-' + index,\n        block: block,\n        editor: editor,\n        index: index,\n        annotations: leaf.annotations,\n        decorations: leaf.decorations,\n        marks: leaf.marks,\n        node: node,\n        offset: offset,\n        parent: parent,\n        leaves: leaves,\n        text: text\n      });\n    })\n  );\n});\n\n/**\n * Prop types.\n *\n * @type {Object}\n */\n\nText.propTypes = {\n  annotations: ImmutableTypes.map.isRequired,\n  block: SlateTypes.block,\n  decorations: ImmutableTypes.list.isRequired,\n  editor: Types.object.isRequired,\n  node: SlateTypes.node.isRequired,\n  parent: SlateTypes.node.isRequired,\n  style: Types.object\n\n  /**\n   * A memoized version of `Text` that updates less frequently.\n   *\n   * @type {Component}\n   */\n\n};var MemoizedText = React.memo(Text, function (prev, next) {\n  return (\n    // PERF: There are cases where it will have\n    // changed, but it's properties will be exactly the same (eg. copy-paste)\n    // which this won't catch. But that's rare and not a drag on performance, so\n    // for simplicity we just let them through.\n    next.node === prev.node &&\n    // If the node parent is a block node, and it was the last child of the\n    // block, re-render to cleanup extra `\\n`.\n    next.parent.object === 'block' && prev.parent.nodes.last() === prev.node && next.parent.nodes.last() !== next.node &&\n    // The formatting hasn't changed.\n    next.annotations.equals(prev.annotations) && next.decorations.equals(prev.decorations)\n  );\n});\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug = Debug('slate:void');\n\n/**\n * Void.\n *\n * @type {Component}\n */\n\nvar Void = function (_React$Component) {\n  inherits(Void, _React$Component);\n\n  function Void() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Void);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Void.__proto__ || Object.getPrototypeOf(Void)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps.call(_this), _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  createClass(Void, [{\n    key: 'render',\n\n\n    /**\n     * Render.\n     *\n     * @return {Element}\n     */\n\n    value: function render() {\n      var _attrs;\n\n      var props = this.props;\n      var children = props.children,\n          node = props.node,\n          readOnly = props.readOnly;\n\n      var Tag = node.object === 'block' ? 'div' : 'span';\n      var style = {\n        height: '0',\n        color: 'transparent',\n        outline: 'none',\n        position: 'absolute'\n      };\n\n      var spacerAttrs = defineProperty({}, DATA_ATTRS.SPACER, true);\n\n      var spacer = React.createElement(\n        Tag,\n        _extends({ style: style }, spacerAttrs),\n        this.renderText()\n      );\n\n      var content = React.createElement(\n        Tag,\n        { contentEditable: readOnly ? null : false },\n        children\n      );\n\n      this.debug('render', { props: props });\n\n      var attrs = (_attrs = {}, defineProperty(_attrs, DATA_ATTRS.VOID, true), defineProperty(_attrs, DATA_ATTRS.KEY, node.key), _attrs);\n\n      return React.createElement(\n        Tag,\n        _extends({\n          contentEditable: readOnly || node.object === 'block' ? null : false\n        }, attrs),\n        readOnly ? null : spacer,\n        content\n      );\n    }\n\n    /**\n     * Render the void node's text node, which will catch the cursor when it the\n     * void node is navigated to with the arrow keys.\n     *\n     * Having this text node there means the browser continues to manage the\n     * selection natively, so it keeps track of the right offset when moving\n     * across the block.\n     *\n     * @return {Element}\n     */\n\n  }]);\n  return Void;\n}(React.Component);\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nVoid.propTypes = {\n  block: SlateTypes.block,\n  children: Types.any.isRequired,\n  editor: Types.object.isRequired,\n  node: SlateTypes.node.isRequired,\n  parent: SlateTypes.node.isRequired,\n  readOnly: Types.bool.isRequired };\n\nvar _initialiseProps = function _initialiseProps() {\n  var _this2 = this;\n\n  this.debug = function (message) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    var node = _this2.props.node;\n    var key = node.key,\n        type = node.type;\n\n    var id = key + ' (' + type + ')';\n    debug.apply(undefined, [message, '' + id].concat(args));\n  };\n\n  this.renderText = function () {\n    var _props = _this2.props,\n        annotations = _props.annotations,\n        block = _props.block,\n        decorations = _props.decorations,\n        node = _props.node,\n        readOnly = _props.readOnly,\n        editor = _props.editor,\n        textRef = _props.textRef;\n\n    var child = node.getFirstText();\n    return React.createElement(MemoizedText, {\n      ref: textRef,\n      annotations: annotations,\n      block: node.object === 'block' ? node : block,\n      decorations: decorations,\n      editor: editor,\n      key: child.key,\n      node: child,\n      parent: node,\n      readOnly: readOnly\n    });\n  };\n};\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug$1 = Debug('slate:node');\n\n/**\n * Node.\n *\n * @type {Component}\n */\n\nvar Node = function (_React$Component) {\n  inherits(Node, _React$Component);\n\n  function Node() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Node);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Node.__proto__ || Object.getPrototypeOf(Node)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps$1.call(_this), _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Temporary values.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * A ref for the contenteditable DOM node.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Debug.\n   *\n   * @param {String} message\n   * @param {Mixed} ...args\n   */\n\n  createClass(Node, [{\n    key: 'shouldComponentUpdate',\n\n\n    /**\n     * Should the node update?\n     *\n     * @param {Object} nextProps\n     * @param {Object} value\n     * @return {Boolean}\n     */\n\n    value: function shouldComponentUpdate(nextProps) {\n      var props = this.props;\n      var editor = props.editor;\n\n      var shouldUpdate = editor.run('shouldNodeComponentUpdate', props, nextProps);\n      var n = nextProps;\n      var p = props;\n\n      // If the `Component` has a custom logic to determine whether the component\n      // needs to be updated or not, return true if it returns true. If it returns\n      // false, we need to ignore it, because it shouldn't be allowed it.\n      if (shouldUpdate != null) {\n        warning(false, 'As of slate-react@0.22 the `shouldNodeComponentUpdate` middleware is deprecated. You can pass specific values down the tree using React\\'s built-in \"context\" construct instead.');\n\n        if (shouldUpdate) {\n          return true;\n        }\n\n        warning(shouldUpdate !== false, \"Returning false in `shouldNodeComponentUpdate` does not disable Slate's internal `shouldComponentUpdate` logic. If you want to prevent updates, use React's `shouldComponentUpdate` instead.\");\n      }\n\n      // If the `readOnly` status has changed, re-render in case there is any\n      // user-land logic that depends on it, like nested editable contents.\n      if (n.readOnly !== p.readOnly) {\n        return true;\n      }\n\n      // If the node has changed, update. PERF: There are cases where it will have\n      // changed, but it's properties will be exactly the same (eg. copy-paste)\n      // which this won't catch. But that's rare and not a drag on performance, so\n      // for simplicity we just let them through.\n      if (n.node !== p.node) {\n        return true;\n      }\n\n      // If the selection value of the node or of some of its children has changed,\n      // re-render in case there is any user-land logic depends on it to render.\n      // if the node is selected update it, even if it was already selected: the\n      // selection value of some of its children could have been changed and they\n      // need to be rendered again.\n      if (!n.selection && p.selection || n.selection && !p.selection || n.selection && p.selection && !n.selection.equals(p.selection)) {\n        return true;\n      }\n\n      // If the annotations have changed, update.\n      if (!n.annotations.equals(p.annotations)) {\n        return true;\n      }\n\n      // If the decorations have changed, update.\n      if (!n.decorations.equals(p.decorations)) {\n        return true;\n      }\n\n      // Otherwise, don't update.\n      return false;\n    }\n\n    /**\n     * Render.\n     *\n     * @return {Element}\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this,\n          _attributes;\n\n      this.debug('render', this);\n      var _props = this.props,\n          annotations = _props.annotations,\n          block = _props.block,\n          decorations = _props.decorations,\n          editor = _props.editor,\n          node = _props.node,\n          parent = _props.parent,\n          readOnly = _props.readOnly,\n          selection = _props.selection;\n\n\n      var newDecorations = node.getDecorations(editor);\n      var children = node.nodes.toArray().map(function (child, i) {\n        var Component = child.object === 'text' ? MemoizedText : Node;\n        var sel = selection && getRelativeRange(node, i, selection);\n\n        var decs = newDecorations.concat(decorations).map(function (d) {\n          return getRelativeRange(node, i, d);\n        }).filter(function (d) {\n          return d;\n        });\n\n        var anns = annotations.map(function (a) {\n          return getRelativeRange(node, i, a);\n        }).filter(function (a) {\n          return a;\n        });\n\n        return React.createElement(Component, {\n          block: node.object === 'block' ? node : block,\n          editor: editor,\n          annotations: anns,\n          decorations: decs,\n          selection: sel,\n          key: child.key,\n          node: child,\n          parent: node,\n          readOnly: readOnly\n          // COMPAT: We use this map of refs to lookup a DOM node down the\n          // tree of components by path.\n          , ref: function ref(_ref2) {\n            if (_ref2) {\n              _this2.tmp.nodeRefs[i] = _ref2;\n            } else {\n              delete _this2.tmp.nodeRefs[i];\n            }\n          }\n        });\n      });\n\n      // Attributes that the developer must mix into the element in their\n      // custom node renderer component.\n      var attributes = (_attributes = {}, defineProperty(_attributes, DATA_ATTRS.OBJECT, node.object), defineProperty(_attributes, DATA_ATTRS.KEY, node.key), defineProperty(_attributes, 'ref', this.ref), _attributes);\n\n      // If it's a block node with inline children, add the proper `dir` attribute\n      // for text direction.\n      if (node.isLeafBlock()) {\n        var direction = node.getTextDirection();\n        if (direction === 'rtl') attributes.dir = 'rtl';\n      }\n\n      var render = void 0;\n\n      if (node.object === 'block') {\n        render = 'renderBlock';\n      } else if (node.object === 'document') {\n        render = 'renderDocument';\n      } else if (node.object === 'inline') {\n        render = 'renderInline';\n      }\n\n      var element = editor.run(render, {\n        attributes: attributes,\n        children: children,\n        editor: editor,\n        isFocused: !!selection && selection.isFocused,\n        isSelected: !!selection,\n        node: node,\n        parent: parent,\n        readOnly: readOnly\n      });\n\n      return editor.isVoid(node) ? React.createElement(\n        Void,\n        _extends({}, this.props, {\n          textRef: function textRef(ref) {\n            if (ref) {\n              _this2.tmp.nodeRefs[0] = ref;\n            } else {\n              delete _this2.tmp.nodeRefs[0];\n            }\n          }\n        }),\n        element\n      ) : element;\n    }\n  }]);\n  return Node;\n}(React.Component);\n\n/**\n * Return a `range` relative to a child at `index`.\n *\n * @param {Range} range\n * @param {Number} index\n * @return {Range}\n */\n\nNode.propTypes = {\n  annotations: ImmutableTypes.map.isRequired,\n  block: SlateTypes.block,\n  decorations: ImmutableTypes.list.isRequired,\n  editor: Types.object.isRequired,\n  node: SlateTypes.node.isRequired,\n  parent: SlateTypes.node,\n  readOnly: Types.bool.isRequired,\n  selection: SlateTypes.selection };\n\nvar _initialiseProps$1 = function _initialiseProps() {\n  var _this3 = this;\n\n  this.tmp = {\n    nodeRefs: {} };\n  this.ref = React.createRef();\n\n  this.debug = function (message) {\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    var node = _this3.props.node;\n    var key = node.key,\n        type = node.type;\n\n    debug$1.apply(undefined, [message, key + ' (' + type + ')'].concat(args));\n  };\n};\n\nfunction getRelativeRange(node, index, range) {\n  if (range.isUnset) {\n    return null;\n  }\n\n  var child = node.nodes.get(index);\n  var _range = range,\n      start = _range.start,\n      end = _range.end;\n  var _start = start,\n      startPath = _start.path;\n  var _end = end,\n      endPath = _end.path;\n\n  var startIndex = startPath.first();\n  var endIndex = endPath.first();\n\n  if (startIndex === index) {\n    start = start.setPath(startPath.rest());\n  } else if (startIndex < index && index <= endIndex) {\n    if (child.object === 'text') {\n      start = start.moveTo(slate.PathUtils.create([index]), 0).setKey(child.key);\n    } else {\n      var _child$texts = child.texts(),\n          _child$texts2 = slicedToArray(_child$texts, 1),\n          first = _child$texts2[0];\n\n      var _first = slicedToArray(first, 2),\n          firstNode = _first[0],\n          firstPath = _first[1];\n\n      start = start.moveTo(firstPath, 0).setKey(firstNode.key);\n    }\n  } else {\n    start = null;\n  }\n\n  if (endIndex === index) {\n    end = end.setPath(endPath.rest());\n  } else if (startIndex <= index && index < endIndex) {\n    if (child.object === 'text') {\n      var length = child.text.length;\n      end = end.moveTo(slate.PathUtils.create([index]), length).setKey(child.key);\n    } else {\n      var _child$texts3 = child.texts({ direction: 'backward' }),\n          _child$texts4 = slicedToArray(_child$texts3, 1),\n          last = _child$texts4[0];\n\n      var _last = slicedToArray(last, 2),\n          lastNode = _last[0],\n          lastPath = _last[1];\n\n      end = end.moveTo(lastPath, lastNode.text.length).setKey(lastNode.key);\n    }\n  } else {\n    end = null;\n  }\n\n  if (!start || !end) {\n    return null;\n  }\n\n  range = range.setAnchor(start);\n  range = range.setFocus(end);\n  return range;\n}\n\n/**\n * CSS overflow values that would cause scrolling.\n *\n * @type {Array}\n */\n\nvar OVERFLOWS = ['auto', 'overlay', 'scroll'];\n\n/**\n * Detect whether we are running IOS version 11\n */\n\nvar IS_IOS_11 = slateDevEnvironment.IS_IOS && !!window.navigator.userAgent.match(/os 11_/i);\n\n/**\n * Find the nearest parent with scrolling, or window.\n *\n * @param {el} Element\n */\n\nfunction findScrollContainer(el, window) {\n  var parent = el.parentNode;\n  var scroller = void 0;\n\n  while (!scroller) {\n    if (!parent.parentNode) break;\n\n    var style = window.getComputedStyle(parent);\n    var overflowY = style.overflowY;\n\n\n    if (OVERFLOWS.includes(overflowY)) {\n      scroller = parent;\n      break;\n    }\n\n    parent = parent.parentNode;\n  }\n\n  // COMPAT: Because Chrome does not allow doucment.body.scrollTop, we're\n  // assuming that window.scrollTo() should be used if the scrollable element\n  // turns out to be document.body or document.documentElement. This will work\n  // unless body is intentionally set to scrollable by restricting its height\n  // (e.g. height: 100vh).\n  if (!scroller) {\n    return window.document.body;\n  }\n\n  return scroller;\n}\n\n/**\n * Scroll the current selection's focus point into view if needed.\n *\n * @param {Selection} selection\n */\n\nfunction scrollToSelection(selection) {\n  if (IS_IOS_11) return;\n  if (!selection.anchorNode) return;\n\n  var window = getWindow(selection.anchorNode);\n  var scroller = findScrollContainer(selection.anchorNode, window);\n  var isWindow = scroller === window.document.body || scroller === window.document.documentElement;\n  var backward = isBackward(selection);\n\n  var range = selection.getRangeAt(0).cloneRange();\n  range.collapse(backward);\n  var cursorRect = range.getBoundingClientRect();\n\n  // COMPAT: range.getBoundingClientRect() returns 0s in Safari when range is\n  // collapsed. Expanding the range by 1 is a relatively effective workaround\n  // for vertical scroll, although horizontal may be off by 1 character.\n  // https://bugs.webkit.org/show_bug.cgi?id=138949\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=435438\n  if (slateDevEnvironment.IS_SAFARI) {\n    if (range.collapsed && cursorRect.top === 0 && cursorRect.height === 0) {\n      if (range.startOffset === 0) {\n        range.setEnd(range.endContainer, 1);\n      } else {\n        range.setStart(range.startContainer, range.startOffset - 1);\n      }\n\n      cursorRect = range.getBoundingClientRect();\n\n      if (cursorRect.top === 0 && cursorRect.height === 0) {\n        if (range.getClientRects().length) {\n          cursorRect = range.getClientRects()[0];\n        }\n      }\n    }\n  }\n\n  var width = void 0;\n  var height = void 0;\n  var yOffset = void 0;\n  var xOffset = void 0;\n  var scrollerTop = 0;\n  var scrollerLeft = 0;\n  var scrollerBordersY = 0;\n  var scrollerBordersX = 0;\n  var scrollerPaddingTop = 0;\n  var scrollerPaddingBottom = 0;\n  var scrollerPaddingLeft = 0;\n  var scrollerPaddingRight = 0;\n\n  if (isWindow) {\n    var innerWidth = window.innerWidth,\n        innerHeight = window.innerHeight,\n        pageYOffset = window.pageYOffset,\n        pageXOffset = window.pageXOffset;\n\n    width = innerWidth;\n    height = innerHeight;\n    yOffset = pageYOffset;\n    xOffset = pageXOffset;\n  } else {\n    var offsetWidth = scroller.offsetWidth,\n        offsetHeight = scroller.offsetHeight,\n        scrollTop = scroller.scrollTop,\n        scrollLeft = scroller.scrollLeft;\n\n    var _window$getComputedSt = window.getComputedStyle(scroller),\n        borderTopWidth = _window$getComputedSt.borderTopWidth,\n        borderBottomWidth = _window$getComputedSt.borderBottomWidth,\n        borderLeftWidth = _window$getComputedSt.borderLeftWidth,\n        borderRightWidth = _window$getComputedSt.borderRightWidth,\n        paddingTop = _window$getComputedSt.paddingTop,\n        paddingBottom = _window$getComputedSt.paddingBottom,\n        paddingLeft = _window$getComputedSt.paddingLeft,\n        paddingRight = _window$getComputedSt.paddingRight;\n\n    var scrollerRect = scroller.getBoundingClientRect();\n    width = offsetWidth;\n    height = offsetHeight;\n    scrollerTop = scrollerRect.top + parseInt(borderTopWidth, 10);\n    scrollerLeft = scrollerRect.left + parseInt(borderLeftWidth, 10);\n\n    scrollerBordersY = parseInt(borderTopWidth, 10) + parseInt(borderBottomWidth, 10);\n\n    scrollerBordersX = parseInt(borderLeftWidth, 10) + parseInt(borderRightWidth, 10);\n\n    scrollerPaddingTop = parseInt(paddingTop, 10);\n    scrollerPaddingBottom = parseInt(paddingBottom, 10);\n    scrollerPaddingLeft = parseInt(paddingLeft, 10);\n    scrollerPaddingRight = parseInt(paddingRight, 10);\n    yOffset = scrollTop;\n    xOffset = scrollLeft;\n  }\n\n  var cursorTop = cursorRect.top + yOffset - scrollerTop;\n  var cursorLeft = cursorRect.left + xOffset - scrollerLeft;\n\n  var x = xOffset;\n  var y = yOffset;\n\n  if (cursorLeft < xOffset) {\n    // selection to the left of viewport\n    x = cursorLeft - scrollerPaddingLeft;\n  } else if (cursorLeft + cursorRect.width + scrollerBordersX > xOffset + width) {\n    // selection to the right of viewport\n    x = cursorLeft + scrollerBordersX + scrollerPaddingRight - width;\n  }\n\n  if (cursorTop < yOffset) {\n    // selection above viewport\n    y = cursorTop - scrollerPaddingTop;\n  } else if (cursorTop + cursorRect.height + scrollerBordersY > yOffset + height) {\n    // selection below viewport\n    y = cursorTop + scrollerBordersY + scrollerPaddingBottom + cursorRect.height - height;\n  }\n\n  if (isWindow) {\n    window.scrollTo(x, y);\n  } else {\n    scroller.scrollTop = y;\n    scroller.scrollLeft = x;\n  }\n}\n\n/**\n * Cross-browser remove all ranges from a `domSelection`.\n *\n * @param {Selection} domSelection\n */\n\nfunction removeAllRanges(domSelection) {\n  // COMPAT: In IE 11, if the selection contains nested tables, then\n  // `removeAllRanges` will throw an error.\n  if (slateDevEnvironment.IS_IE) {\n    var range = window.document.body.createTextRange();\n    range.collapse();\n    range.select();\n  } else {\n    domSelection.removeAllRanges();\n  }\n}\n\nvar FIREFOX_NODE_TYPE_ACCESS_ERROR = /Permission denied to access property \"nodeType\"/;\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug$2 = Debug('slate:content');\n\n/**\n * Separate debug to easily see when the DOM has updated either by render or\n * changing selection.\n *\n * @type {Function}\n */\n\ndebug$2.update = Debug('slate:update');\n\n/**\n * Content.\n *\n * @type {Component}\n */\n\nvar Content = function (_React$Component) {\n  inherits(Content, _React$Component);\n\n  function Content() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Content);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Content.__proto__ || Object.getPrototypeOf(Content)).call.apply(_ref, [this].concat(args))), _this), _this.tmp = {\n      isUpdatingSelection: false,\n      nodeRef: React.createRef(),\n      nodeRefs: {},\n      contentKey: 0,\n      nativeSelection: {} // Native selection object stored to check if `onNativeSelectionChange` has triggered yet\n\n\n      /**\n       * A ref for the contenteditable DOM node.\n       *\n       * @type {Object}\n       */\n\n    }, _this.ref = React.createRef(), _this.setRef = function (el) {\n      _this.ref.current = el;\n      _this.props.editor.el = el;\n    }, _this.handlers = EVENT_HANDLERS.reduce(function (obj, handler) {\n      obj[handler] = function (event) {\n        return _this.onEvent(handler, event);\n      };\n      return obj;\n    }, {}), _this.updateSelection = function () {\n      var editor = _this.props.editor;\n      var value = editor.value;\n      var selection = value.selection;\n      var isBackward$$1 = selection.isBackward;\n\n      var window = getWindow(_this.ref.current);\n      var native = window.getSelection();\n      var activeElement = window.document.activeElement;\n\n\n      if (debug$2.update.enabled) {\n        debug$2.update('updateSelection', { selection: selection.toJSON() });\n      }\n\n      // COMPAT: In Firefox, there's a but where `getSelection` can return `null`.\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=827585 (2018/11/07)\n      if (!native) {\n        return;\n      }\n\n      var rangeCount = native.rangeCount,\n          anchorNode = native.anchorNode;\n\n      var updated = false;\n\n      // If the Slate selection is blurred, but the DOM's active element is still\n      // the editor, we need to blur it.\n      if (selection.isBlurred && activeElement === _this.ref.current) {\n        _this.ref.current.blur();\n        updated = true;\n      }\n\n      // If the Slate selection is unset, but the DOM selection has a range\n      // selected in the editor, we need to remove the range.\n      // However we should _not_ remove the range if the selection as\n      // reported by `getSelection` is not equal to `this.tmp.nativeSelection`\n      // as this suggests `onNativeSelectionChange` has not triggered yet (which can occur in Firefox)\n      // See: https://github.com/ianstormtaylor/slate/pull/2995\n\n      var propsToCompare = ['anchorNode', 'anchorOffset', 'focusNode', 'focusOffset', 'isCollapsed', 'rangeCount', 'type'];\n\n      var selectionsEqual = true;\n\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = propsToCompare[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var prop = _step.value;\n\n          if (_this.tmp.nativeSelection[prop] !== native[prop]) {\n            selectionsEqual = false;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      if (selection.isUnset && rangeCount && _this.isInEditor(anchorNode) && selectionsEqual) {\n        removeAllRanges(native);\n        updated = true;\n      }\n\n      // If the Slate selection is focused, but the DOM's active element is not\n      // the editor, we need to focus it. We prevent scrolling because we handle\n      // scrolling to the correct selection.\n      if (selection.isFocused && activeElement !== _this.ref.current) {\n        _this.ref.current.focus({ preventScroll: true });\n        updated = true;\n      }\n\n      // Otherwise, figure out which DOM nodes should be selected...\n      if (selection.isFocused && selection.isSet) {\n        var current = !!native.rangeCount && native.getRangeAt(0);\n        var range = editor.findDOMRange(selection);\n\n        if (!range) {\n          warning(false, 'Unable to find a native DOM range from the current selection.');\n\n          return;\n        }\n\n        var startContainer = range.startContainer,\n            startOffset = range.startOffset,\n            endContainer = range.endContainer,\n            endOffset = range.endOffset;\n\n        // If the new range matches the current selection, there is nothing to fix.\n        // COMPAT: The native `Range` object always has it's \"start\" first and \"end\"\n        // last in the DOM. It has no concept of \"backwards/forwards\", so we have\n        // to check both orientations here. (2017/10/31)\n\n        if (current) {\n          if (startContainer === current.startContainer && startOffset === current.startOffset && endContainer === current.endContainer && endOffset === current.endOffset || startContainer === current.endContainer && startOffset === current.endOffset && endContainer === current.startContainer && endOffset === current.startOffset) {\n            return;\n          }\n        }\n\n        // Otherwise, set the `isUpdatingSelection` flag and update the selection.\n        updated = true;\n        _this.tmp.isUpdatingSelection = true;\n        removeAllRanges(native);\n\n        // COMPAT: IE 11 does not support `setBaseAndExtent`. (2018/11/07)\n        if (native.setBaseAndExtent) {\n          // COMPAT: Since the DOM range has no concept of backwards/forwards\n          // we need to check and do the right thing here.\n          if (isBackward$$1) {\n            native.setBaseAndExtent(range.endContainer, range.endOffset, range.startContainer, range.startOffset);\n          } else {\n            native.setBaseAndExtent(range.startContainer, range.startOffset, range.endContainer, range.endOffset);\n          }\n        } else {\n          native.addRange(range);\n        }\n\n        // Only scroll to selection when a user action is performed\n        if (editor.userActionPerformed() === true) {\n          // Scroll to the selection, in case it's out of view.\n          scrollToSelection(native);\n        }\n\n        // Then unset the `isUpdatingSelection` flag after a delay, to ensure that\n        // it is still set when selection-related events from updating it fire.\n        setTimeout(function () {\n          // COMPAT: In Firefox, it's not enough to create a range, you also need\n          // to focus the contenteditable element too. (2016/11/16)\n          if (slateDevEnvironment.IS_FIREFOX && _this.ref.current) {\n            _this.ref.current.focus();\n          }\n\n          _this.tmp.isUpdatingSelection = false;\n\n          debug$2.update('updateSelection:setTimeout', {\n            anchorOffset: window.getSelection().anchorOffset\n          });\n        });\n      }\n\n      if (updated && (debug$2.enabled || debug$2.update.enabled)) {\n        debug$2('updateSelection', { selection: selection, native: native, activeElement: activeElement });\n\n        debug$2.update('updateSelection:applied', {\n          selection: selection.toJSON(),\n          native: {\n            anchorOffset: native.anchorOffset,\n            focusOffset: native.focusOffset\n          }\n        });\n      }\n    }, _this.isInEditor = function (target) {\n      var el = void 0;\n\n      try {\n        // COMPAT: In Firefox, sometimes the node can be comment which doesn't\n        // have .closest and it crashes.\n        if (target.nodeType === 8) {\n          return false;\n        }\n\n        // COMPAT: Text nodes don't have `isContentEditable` property. So, when\n        // `target` is a text node use its parent node for check.\n        el = target.nodeType === 3 ? target.parentNode : target;\n      } catch (err) {\n        // COMPAT: In Firefox, `target.nodeType` will throw an error if target is\n        // originating from an internal \"restricted\" element (e.g. a stepper\n        // arrow on a number input)\n        // see github.com/ianstormtaylor/slate/issues/1819\n        if (slateDevEnvironment.IS_FIREFOX && FIREFOX_NODE_TYPE_ACCESS_ERROR.test(err.message)) {\n          return false;\n        }\n\n        throw err;\n      }\n\n      return el.isContentEditable && (el === _this.ref.current || el.closest(SELECTORS.EDITOR) === _this.ref.current);\n    }, _this.onNativeSelectionChange = throttle(function (event) {\n      if (_this.props.readOnly) return;\n\n      var window = getWindow(event.target);\n      var activeElement = window.document.activeElement;\n\n\n      var native = window.getSelection();\n\n      debug$2.update('onNativeSelectionChange', {\n        anchorOffset: native.anchorOffset\n      });\n\n      if (activeElement !== _this.ref.current) return;\n\n      _this.tmp.nativeSelection = {\n        anchorNode: native.anchorNode,\n        anchorOffset: native.anchorOffset,\n        focusNode: native.focusNode,\n        focusOffset: native.focusOffset,\n        isCollapsed: native.isCollapsed,\n        rangeCount: native.rangeCount,\n        type: native.type\n      };\n\n      _this.props.onEvent('onSelect', event);\n    }, 100), _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  createClass(Content, [{\n    key: 'componentDidCatch',\n\n\n    /**\n     * An error boundary. If there is a render error, we increment `errorKey`\n     * which is part of the container `key` which forces a re-render from\n     * scratch.\n     *\n     * @param {Error} error\n     * @param {String} info\n     */\n\n    value: function componentDidCatch(error, info) {\n      debug$2('componentDidCatch', { error: error, info: info });\n      // The call to `setState` is required despite not setting a value.\n      // Without this call, React will not try to recreate the component tree.\n      this.setState({});\n    }\n\n    /**\n     * Temporary values.\n     *\n     * @type {Object}\n     */\n\n    /**\n     * Set both `this.ref` and `editor.el`\n     *\n     * @type {DOMElement}\n     */\n\n    /**\n     * Create a set of bound event handlers.\n     *\n     * @type {Object}\n     */\n\n  }, {\n    key: 'componentDidMount',\n\n\n    /**\n     * When the editor first mounts in the DOM we need to:\n     *\n     *   - Add native DOM event listeners.\n     *   - Update the selection, in case it starts focused.\n     */\n\n    value: function componentDidMount() {\n      var window = getWindow(this.ref.current);\n\n      window.document.addEventListener('selectionchange', this.onNativeSelectionChange);\n\n      // COMPAT: Restrict scope of `beforeinput` to clients that support the\n      // Input Events Level 2 spec, since they are preventable events.\n      if (slateDevEnvironment.HAS_INPUT_EVENTS_LEVEL_2) {\n        this.ref.current.addEventListener('beforeinput', this.handlers.onBeforeInput);\n      }\n\n      this.updateSelection();\n\n      this.props.onEvent('onComponentDidMount');\n    }\n\n    /**\n     * When unmounting, remove DOM event listeners.\n     */\n\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      var window = getWindow(this.ref.current);\n\n      if (window) {\n        window.document.removeEventListener('selectionchange', this.onNativeSelectionChange);\n      }\n\n      if (slateDevEnvironment.HAS_INPUT_EVENTS_LEVEL_2) {\n        this.ref.current.removeEventListener('beforeinput', this.handlers.onBeforeInput);\n      }\n\n      this.props.onEvent('onComponentWillUnmount');\n    }\n\n    /**\n     * On update, update the selection.\n     */\n\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      debug$2.update('componentDidUpdate');\n\n      this.updateSelection();\n      this.props.editor.clearUserActionPerformed();\n\n      this.props.onEvent('onComponentDidUpdate');\n    }\n\n    /**\n     * Update the native DOM selection to reflect the internal model.\n     */\n\n    /**\n     * Check if an event `target` is fired from within the contenteditable\n     * element. This should be false for edits happening in non-contenteditable\n     * children, such as void nodes and other nested Slate editors.\n     *\n     * @param {Element} target\n     * @return {Boolean}\n     */\n\n  }, {\n    key: 'onEvent',\n\n\n    /**\n     * On `event` with `handler`.\n     *\n     * @param {String} handler\n     * @param {Event} event\n     */\n\n    value: function onEvent(handler, event) {\n      debug$2('onEvent', handler);\n\n      var nativeEvent = event.nativeEvent || event;\n      var isUndoRedo = event.type === 'keydown' && (Hotkeys.isUndo(nativeEvent) || Hotkeys.isRedo(nativeEvent));\n\n      // Ignore `onBlur`, `onFocus` and `onSelect` events generated\n      // programmatically while updating selection.\n      if ((this.tmp.isUpdatingSelection || isUndoRedo) && (handler === 'onSelect' || handler === 'onBlur' || handler === 'onFocus')) {\n        return;\n      }\n\n      // COMPAT: There are situations where a select event will fire with a new\n      // native selection that resolves to the same internal position. In those\n      // cases we don't need to trigger any changes, since our internal model is\n      // already up to date, but we do want to update the native selection again\n      // to make sure it is in sync. (2017/10/16)\n      //\n      // ANDROID: The updateSelection causes issues in Android when you are\n      // at the end of a block. The selection ends up to the left of the inserted\n      // character instead of to the right. This behavior continues even if\n      // you enter more than one character. (2019/01/03)\n      if (!slateDevEnvironment.IS_ANDROID && handler === 'onSelect') {\n        var editor = this.props.editor;\n        var value = editor.value;\n        var selection = value.selection;\n\n        var window = getWindow(event.target);\n        var domSelection = window.getSelection();\n        var range = editor.findRange(domSelection);\n\n        if (range && range.equals(selection.toRange())) {\n          this.updateSelection();\n          return;\n        }\n      }\n\n      // Don't handle drag and drop events coming from embedded editors.\n      if (handler === 'onDragEnd' || handler === 'onDragEnter' || handler === 'onDragExit' || handler === 'onDragLeave' || handler === 'onDragOver' || handler === 'onDragStart' || handler === 'onDrop') {\n        var closest = event.target.closest(SELECTORS.EDITOR);\n\n        if (closest !== this.ref.current) {\n          return;\n        }\n      }\n\n      // Some events require being in editable in the editor, so if the event\n      // target isn't, ignore them.\n      if (handler === 'onBeforeInput' || handler === 'onBlur' || handler === 'onCompositionEnd' || handler === 'onCompositionStart' || handler === 'onCopy' || handler === 'onCut' || handler === 'onFocus' || handler === 'onInput' || handler === 'onKeyDown' || handler === 'onKeyUp' || handler === 'onPaste' || handler === 'onSelect') {\n        if (!this.isInEditor(event.target)) {\n          return;\n        }\n      }\n\n      this.props.onEvent(handler, event);\n    }\n\n    /**\n     * On native `selectionchange` event, trigger the `onSelect` handler. This is\n     * needed to account for React's `onSelect` being non-standard and not firing\n     * until after a selection has been released. This causes issues in situations\n     * where another change happens while a selection is being made.\n     *\n     * @param {Event} event\n     */\n\n  }, {\n    key: 'render',\n\n\n    /**\n     * Render the editor content.\n     *\n     * @return {Element}\n     */\n\n    value: function render() {\n      var _data;\n\n      var props = this.props,\n          handlers = this.handlers;\n      var id = props.id,\n          className = props.className,\n          readOnly = props.readOnly,\n          editor = props.editor,\n          tabIndex = props.tabIndex,\n          role = props.role,\n          tagName = props.tagName,\n          spellCheck = props.spellCheck;\n      var value = editor.value;\n\n      var Container = tagName;\n      var document = value.document,\n          selection = value.selection;\n\n\n      var style = _extends({\n        // Prevent the default outline styles.\n        outline: 'none',\n        // Preserve adjacent whitespace and new lines.\n        whiteSpace: 'pre-wrap',\n        // Allow words to break if they are too long.\n        wordWrap: 'break-word'\n      }, readOnly ? {} : { WebkitUserModify: 'read-write-plaintext-only' }, props.style);\n\n      // console.log('rerender content', this.tmp.contentKey, document.text)\n\n      debug$2('render', { props: props });\n      debug$2.update('render', this.tmp.contentKey, document.text);\n\n      this.props.onEvent('onRender');\n\n      var data = (_data = {}, defineProperty(_data, DATA_ATTRS.EDITOR, true), defineProperty(_data, DATA_ATTRS.KEY, document.key), _data);\n\n      var domProps = omit(this.props, Object.keys(Content.propTypes));\n\n      return React.createElement(\n        Container,\n        _extends({}, domProps, {\n          key: this.tmp.contentKey\n        }, handlers, data, {\n          ref: this.setRef,\n          contentEditable: readOnly ? null : true,\n          suppressContentEditableWarning: true,\n          id: id,\n          className: className,\n          autoCorrect: props.autoCorrect ? 'on' : 'off',\n          spellCheck: spellCheck,\n          style: style,\n          role: readOnly ? null : role || 'textbox',\n          tabIndex: tabIndex\n          // COMPAT: The Grammarly Chrome extension works by changing the DOM out\n          // from under `contenteditable` elements, which leads to weird behaviors\n          // so we have to disable it like this. (2017/04/24)\n\n          // just the existence of the flag is disabling the extension irrespective of its value\n          , 'data-gramm': domProps['data-gramm'] ? undefined : false\n        }),\n        React.createElement(Node, {\n          annotations: value.annotations,\n          block: null,\n          decorations: immutable.List(),\n          editor: editor,\n          node: document,\n          parent: null,\n          readOnly: readOnly,\n          selection: selection,\n          ref: this.tmp.nodeRef\n        })\n      );\n    }\n  }]);\n  return Content;\n}(React.Component);\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nContent.propTypes = {\n  autoCorrect: Types.bool.isRequired,\n  className: Types.string,\n  contentKey: Types.number,\n  editor: Types.object.isRequired,\n  id: Types.string,\n  onEvent: Types.func.isRequired,\n  readOnly: Types.bool.isRequired,\n  role: Types.string,\n  spellCheck: Types.bool.isRequired,\n  style: Types.object,\n  tabIndex: Types.number,\n  tagName: Types.string };\nContent.defaultProps = {\n  style: {},\n  tagName: 'div' };\n\n/**\n * Props that can be defined by plugins.\n *\n * @type {Array}\n */\n\nvar PROPS = [].concat(toConsumableArray(EVENT_HANDLERS), ['commands', 'decorateNode', 'queries', 'renderAnnotation', 'renderBlock', 'renderDecoration', 'renderDocument', 'renderEditor', 'renderInline', 'renderMark', 'schema']);\n\n/**\n * The top-level editor props in a plugin.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction EditorPropsPlugin() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n  var plugin = PROPS.reduce(function (memo, prop) {\n    if (prop in options) memo[prop] = options[prop];\n    return memo;\n  }, {});\n\n  return plugin;\n}\n\n/**\n * The default rendering behavior for the React plugin.\n *\n * @return {Object}\n */\n\nfunction Rendering() {\n  return {\n    decorateNode: function decorateNode() {\n      return [];\n    },\n    renderAnnotation: function renderAnnotation(_ref) {\n      var attributes = _ref.attributes,\n          children = _ref.children;\n\n      return React.createElement(\n        'span',\n        attributes,\n        children\n      );\n    },\n    renderBlock: function renderBlock(_ref2) {\n      var attributes = _ref2.attributes,\n          children = _ref2.children;\n\n      return React.createElement(\n        'div',\n        _extends({}, attributes, { style: { position: 'relative' } }),\n        children\n      );\n    },\n    renderDecoration: function renderDecoration(_ref3) {\n      var attributes = _ref3.attributes,\n          children = _ref3.children;\n\n      return React.createElement(\n        'span',\n        attributes,\n        children\n      );\n    },\n    renderDocument: function renderDocument(_ref4) {\n      var children = _ref4.children;\n\n      return children;\n    },\n    renderEditor: function renderEditor(_ref5) {\n      var children = _ref5.children;\n\n      return children;\n    },\n    renderInline: function renderInline(_ref6) {\n      var attributes = _ref6.attributes,\n          children = _ref6.children;\n\n      return React.createElement(\n        'span',\n        _extends({}, attributes, { style: { position: 'relative' } }),\n        children\n      );\n    },\n    renderMark: function renderMark(_ref7) {\n      var attributes = _ref7.attributes,\n          children = _ref7.children;\n\n      return React.createElement(\n        'span',\n        attributes,\n        children\n      );\n    }\n  };\n}\n\n/**\n * A set of commands for the React plugin.\n *\n * @return {Object}\n */\n\nfunction CommandsPlugin() {\n  /**\n   * Takes a `node`, find the matching `domNode` and uses it to set the text\n   * in the `node`.\n   *\n   * @param {Editor} editor\n   * @param {Node} node\n   */\n\n  function reconcileNode(editor, node) {\n    var value = editor.value;\n    var document = value.document,\n        selection = value.selection;\n\n    var path = document.getPath(node.key);\n\n    var domElement = editor.findDOMNode(path);\n    var block = document.getClosestBlock(path);\n\n    // Get text information\n    var text = node.text;\n    var domText = domElement.textContent;\n\n\n    var isLastNode = block.nodes.last() === node;\n    var lastChar = domText.charAt(domText.length - 1);\n\n    // COMPAT: If this is the last leaf, and the DOM text ends in a new line,\n    // we will have added another new line in <Leaf>'s render method to account\n    // for browsers collapsing a single trailing new lines, so remove it.\n    if (isLastNode && lastChar === '\\n') {\n      domText = domText.slice(0, -1);\n    }\n\n    // If the text is no different, abort.\n    if (text === domText) return;\n\n    var entire = selection.moveAnchorTo(path, 0).moveFocusTo(path, text.length);\n\n    entire = document.resolveRange(entire);\n\n    // Change the current value to have the leaf's text replaced.\n    editor.insertTextAtRange(entire, domText, node.marks);\n    return;\n  }\n\n  /**\n   * Takes text from the `domNode` and uses it to set the text in the matching\n   * `node` in Slate.\n   *\n   * @param {Editor} editor\n   * @param {DOMNode} domNode\n   */\n\n  function reconcileDOMNode(editor, domNode) {\n    var domElement = domNode.parentElement.closest('[data-key]');\n    var node = editor.findNode(domElement);\n    editor.reconcileNode(node);\n  }\n\n  return {\n    commands: {\n      reconcileNode: reconcileNode,\n      reconcileDOMNode: reconcileDOMNode\n    }\n  };\n}\n\n/**\n * A set of queries for the React plugin.\n *\n * @return {Object}\n */\n\nfunction QueriesPlugin() {\n  /**\n   * Find the native DOM element for a node at `path`.\n   *\n   * @param {Editor} editor\n   * @param {Array|List} path\n   * @return {DOMNode|Null}\n   */\n\n  function findDOMNode(editor, path) {\n    path = slate.PathUtils.create(path);\n    var content = editor.tmp.contentRef.current;\n\n    if (!content) {\n      return null;\n    }\n\n    if (!path.size) {\n      return content.ref.current || null;\n    }\n\n    var search = function search(instance, p) {\n      if (!instance) {\n        return null;\n      }\n\n      if (!p.size) {\n        if (instance.ref) {\n          return instance.ref.current || null;\n        } else {\n          return instance || null;\n        }\n      }\n\n      var index = p.first();\n      var rest = p.rest();\n      var ref = instance.tmp.nodeRefs[index];\n      return search(ref, rest);\n    };\n\n    var document = content.tmp.nodeRef.current;\n    var el = search(document, path);\n    return el;\n  }\n\n  /**\n   * Find a native DOM selection point from a Slate `point`.\n   *\n   * @param {Editor} editor\n   * @param {Point} point\n   * @return {Object|Null}\n   */\n\n  function findDOMPoint(editor, point) {\n    var el = editor.findDOMNode(point.path);\n    var start = 0;\n\n    if (!el) {\n      return null;\n    }\n\n    // For each leaf, we need to isolate its content, which means filtering to its\n    // direct text and zero-width spans. (We have to filter out any other siblings\n    // that may have been rendered alongside them.)\n    var texts = Array.from(el.querySelectorAll(SELECTORS.STRING + ', ' + SELECTORS.ZERO_WIDTH));\n\n    var _iteratorNormalCompletion = true;\n    var _didIteratorError = false;\n    var _iteratorError = undefined;\n\n    try {\n      for (var _iterator = texts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n        var text = _step.value;\n\n        var node = text.childNodes[0];\n        var domLength = node.textContent.length;\n        var slateLength = domLength;\n\n        if (text.hasAttribute(DATA_ATTRS.LENGTH)) {\n          slateLength = parseInt(text.getAttribute(DATA_ATTRS.LENGTH), 10);\n        }\n\n        var end = start + slateLength;\n\n        if (point.offset <= end) {\n          var offset = Math.min(domLength, Math.max(0, point.offset - start));\n          return { node: node, offset: offset };\n        }\n\n        start = end;\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (!_iteratorNormalCompletion && _iterator.return) {\n          _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Find a native DOM range from a Slate `range`.\n   *\n   * @param {Editor} editor\n   * @param {Range} range\n   * @return {DOMRange|Null}\n   */\n\n  function findDOMRange(editor, range) {\n    var anchor = range.anchor,\n        focus = range.focus,\n        isBackward$$1 = range.isBackward,\n        isCollapsed = range.isCollapsed;\n\n    var domAnchor = editor.findDOMPoint(anchor);\n    var domFocus = isCollapsed ? domAnchor : editor.findDOMPoint(focus);\n\n    if (!domAnchor || !domFocus) {\n      return null;\n    }\n\n    var window = getWindow(domAnchor.node);\n    var r = window.document.createRange();\n    var start = isBackward$$1 ? domFocus : domAnchor;\n    var end = isBackward$$1 ? domAnchor : domFocus;\n    r.setStart(start.node, start.offset);\n    r.setEnd(end.node, end.offset);\n    return r;\n  }\n\n  /**\n   * Find a Slate node from a native DOM `element`.\n   *\n   * @param {Editor} editor\n   * @param {Element} element\n   * @return {List|Null}\n   */\n\n  function findNode(editor, element) {\n    var path = editor.findPath(element);\n\n    if (!path) {\n      return null;\n    }\n\n    var value = editor.value;\n    var document = value.document;\n\n    var node = document.getNode(path);\n    return node;\n  }\n\n  /**\n   * Get the target range from a DOM `event`.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @return {Range}\n   */\n\n  function findEventRange(editor, event) {\n    if (event.nativeEvent) {\n      event = event.nativeEvent;\n    }\n\n    var _event = event,\n        x = _event.clientX,\n        y = _event.clientY,\n        target = _event.target;\n\n    if (x == null || y == null) return null;\n\n    var value = editor.value;\n    var document = value.document;\n\n    var path = editor.findPath(event.target);\n    if (!path) return null;\n\n    var node = document.getNode(path);\n\n    // If the drop target is inside a void node, move it into either the next or\n    // previous node, depending on which side the `x` and `y` coordinates are\n    // closest to.\n    if (editor.isVoid(node)) {\n      var rect = target.getBoundingClientRect();\n      var isPrevious = node.object === 'inline' ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n\n      var _range = document.createRange();\n      var move = isPrevious ? 'moveToEndOfNode' : 'moveToStartOfNode';\n      var entry = document[isPrevious ? 'getPreviousText' : 'getNextText'](path);\n\n      if (entry) {\n        return _range[move](entry);\n      }\n\n      return null;\n    }\n\n    // Else resolve a range from the caret position where the drop occured.\n    var window = getWindow(target);\n    var native = void 0;\n\n    // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n    if (window.document.caretRangeFromPoint) {\n      native = window.document.caretRangeFromPoint(x, y);\n    } else if (window.document.caretPositionFromPoint) {\n      var position = window.document.caretPositionFromPoint(x, y);\n      native = window.document.createRange();\n      native.setStart(position.offsetNode, position.offset);\n      native.setEnd(position.offsetNode, position.offset);\n    } else if (window.document.body.createTextRange) {\n      // COMPAT: In IE, `caretRangeFromPoint` and\n      // `caretPositionFromPoint` don't exist. (2018/07/11)\n      native = window.document.body.createTextRange();\n\n      try {\n        native.moveToPoint(x, y);\n      } catch (error) {\n        // IE11 will raise an `unspecified error` if `moveToPoint` is\n        // called during a dropEvent.\n        return null;\n      }\n    }\n\n    // Resolve a Slate range from the DOM range.\n    var range = editor.findRange(native);\n    return range;\n  }\n\n  /**\n   * Find the path of a native DOM `element` by searching React refs.\n   *\n   * @param {Editor} editor\n   * @param {Element} element\n   * @return {List|Null}\n   */\n\n  function findPath(editor, element) {\n    var content = editor.tmp.contentRef.current;\n    var nodeElement = element;\n\n    // If element does not have a key, it is likely a string or\n    // mark, return the closest parent Node that can be looked up.\n    if (!nodeElement.hasAttribute(DATA_ATTRS.KEY)) {\n      nodeElement = nodeElement.closest(SELECTORS.KEY);\n    }\n\n    if (!nodeElement || !nodeElement.getAttribute(DATA_ATTRS.KEY)) {\n      return null;\n    }\n\n    if (nodeElement === content.ref.current) {\n      return slate.PathUtils.create([]);\n    }\n\n    var search = function search(instance, p) {\n      if (nodeElement === instance) {\n        return p;\n      }\n\n      if (!instance.ref) {\n        return null;\n      }\n\n      if (nodeElement === instance.ref.current) {\n        return p;\n      }\n\n      // If there's no `tmp` then we're at a leaf node without success.\n      if (!instance.tmp) {\n        return null;\n      }\n\n      var nodeRefs = instance.tmp.nodeRefs;\n\n      var keys = Object.keys(nodeRefs);\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var i = _step2.value;\n\n          var ref = nodeRefs[i];\n          var n = parseInt(i, 10);\n          var _path = search(ref, [].concat(toConsumableArray(p), [n]));\n\n          if (_path) {\n            return _path;\n          }\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      return null;\n    };\n\n    var document = content.tmp.nodeRef.current;\n    var path = search(document, []);\n\n    if (!path) {\n      return null;\n    }\n\n    return slate.PathUtils.create(path);\n  }\n\n  /**\n   * Find a Slate point from a DOM selection's `nativeNode` and `nativeOffset`.\n   *\n   * @param {Editor} editor\n   * @param {Element} nativeNode\n   * @param {Number} nativeOffset\n   * @return {Point}\n   */\n\n  function findPoint(editor, nativeNode, nativeOffset) {\n    var _normalizeNodeAndOffs = normalizeNodeAndOffset(nativeNode, nativeOffset),\n        nearestNode = _normalizeNodeAndOffs.node,\n        nearestOffset = _normalizeNodeAndOffs.offset;\n\n    var window = getWindow(nativeNode);\n    var parentNode = nearestNode.parentNode;\n\n    var leafNode = parentNode.closest(SELECTORS.LEAF);\n    var textNode = void 0;\n    var offset = void 0;\n    var node = void 0;\n\n    // Calculate how far into the text node the `nearestNode` is, so that we can\n    // determine what the offset relative to the text node is.\n    if (leafNode) {\n      textNode = leafNode.closest(SELECTORS.TEXT);\n      var range = window.document.createRange();\n      range.setStart(textNode, 0);\n      range.setEnd(nearestNode, nearestOffset);\n      var contents = range.cloneContents();\n      var zeroWidths = contents.querySelectorAll(SELECTORS.ZERO_WIDTH);\n\n      Array.from(zeroWidths).forEach(function (el) {\n        el.parentNode.removeChild(el);\n      });\n\n      // COMPAT: Edge has a bug where Range.prototype.toString() will convert \\n\n      // into \\r\\n. The bug causes a loop when slate-react attempts to reposition\n      // its cursor to match the native position. Use textContent.length instead.\n      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n      offset = contents.textContent.length;\n      node = textNode;\n    } else {\n      // For void nodes, the element with the offset key will be a cousin, not an\n      // ancestor, so find it by going down from the nearest void parent.\n      var voidNode = parentNode.closest(SELECTORS.VOID);\n\n      if (!voidNode) {\n        return null;\n      }\n\n      leafNode = voidNode.querySelector(SELECTORS.LEAF);\n\n      if (!leafNode) {\n        return null;\n      }\n\n      textNode = leafNode.closest(SELECTORS.TEXT);\n      node = leafNode;\n      offset = node.textContent.length;\n    }\n\n    // COMPAT: If the parent node is a Slate zero-width space, this is because the\n    // text node should have no characters. However, during IME composition the\n    // ASCII characters will be prepended to the zero-width space, so subtract 1\n    // from the offset to account for the zero-width space character.\n    if (offset === node.textContent.length && parentNode.hasAttribute(DATA_ATTRS.ZERO_WIDTH)) {\n      offset--;\n    }\n\n    // COMPAT: If someone is clicking from one Slate editor into another, the\n    // select event fires twice, once for the old editor's `element` first, and\n    // then afterwards for the correct `element`. (2017/03/03)\n    var path = editor.findPath(textNode);\n\n    if (!path) {\n      return null;\n    }\n\n    var value = editor.value;\n    var document = value.document;\n\n    var point = document.createPoint({ path: path, offset: offset });\n    return point;\n  }\n\n  /**\n   * Find a Slate range from a DOM range or selection.\n   *\n   * @param {Editor} editor\n   * @param {Selection} domRange\n   * @return {Range}\n   */\n\n  function findRange(editor, domRange) {\n    var el = domRange.anchorNode || domRange.startContainer;\n\n    if (!el) {\n      return null;\n    }\n\n    var window = getWindow(el);\n\n    // If the `domRange` object is a DOM `Range` or `StaticRange` object, change it\n    // into something that looks like a DOM `Selection` instead.\n    if (domRange instanceof window.Range || window.StaticRange && domRange instanceof window.StaticRange) {\n      domRange = {\n        anchorNode: domRange.startContainer,\n        anchorOffset: domRange.startOffset,\n        focusNode: domRange.endContainer,\n        focusOffset: domRange.endOffset\n      };\n    }\n\n    var _domRange = domRange,\n        anchorNode = _domRange.anchorNode,\n        anchorOffset = _domRange.anchorOffset,\n        focusNode = _domRange.focusNode,\n        focusOffset = _domRange.focusOffset,\n        isCollapsed = _domRange.isCollapsed;\n    var value = editor.value;\n\n    var anchor = editor.findPoint(anchorNode, anchorOffset);\n    var focus = isCollapsed ? anchor : editor.findPoint(focusNode, focusOffset);\n\n    if (!anchor || !focus) {\n      return null;\n    }\n\n    var document = value.document;\n\n    var range = document.createRange({\n      anchor: anchor,\n      focus: focus\n    });\n\n    return range;\n  }\n\n  /**\n   * Find a Slate selection from a DOM selection.\n   *\n   * @param {Editor} editor\n   * @param {Selection} domSelection\n   * @return {Range}\n   */\n\n  function findSelection(editor, domSelection) {\n    var value = editor.value;\n    var document = value.document;\n\n    // If there are no ranges, the editor was blurred natively.\n\n    if (!domSelection.rangeCount) {\n      return null;\n    }\n\n    // Otherwise, determine the Slate selection from the native one.\n    var range = editor.findRange(domSelection);\n\n    if (!range) {\n      return null;\n    }\n\n    var _range2 = range,\n        anchor = _range2.anchor,\n        focus = _range2.focus;\n\n    var anchorText = document.getNode(anchor.path);\n    var focusText = document.getNode(focus.path);\n    var anchorInline = document.getClosestInline(anchor.path);\n    var focusInline = document.getClosestInline(focus.path);\n    var focusBlock = document.getClosestBlock(focus.path);\n    var anchorBlock = document.getClosestBlock(anchor.path);\n\n    // COMPAT: If the anchor point is at the start of a non-void, and the\n    // focus point is inside a void node with an offset that isn't `0`, set\n    // the focus offset to `0`. This is due to void nodes <span>'s being\n    // positioned off screen, resulting in the offset always being greater\n    // than `0`. Since we can't know what it really should be, and since an\n    // offset of `0` is less destructive because it creates a hanging\n    // selection, go with `0`. (2017/09/07)\n    if (anchorBlock && !editor.isVoid(anchorBlock) && anchor.offset === 0 && focusBlock && editor.isVoid(focusBlock) && focus.offset !== 0) {\n      range = range.setFocus(focus.setOffset(0));\n    }\n\n    // COMPAT: If the selection is at the end of a non-void inline node, and\n    // there is a node after it, put it in the node after instead. This\n    // standardizes the behavior, since it's indistinguishable to the user.\n    if (anchorInline && !editor.isVoid(anchorInline) && anchor.offset === anchorText.text.length) {\n      var block = document.getClosestBlock(anchor.path);\n      var depth = document.getDepth(block.key);\n      var relativePath = slate.PathUtils.drop(anchor.path, depth);\n\n      var _block$texts = block.texts({ path: relativePath }),\n          _block$texts2 = slicedToArray(_block$texts, 1),\n          next = _block$texts2[0];\n\n      if (next) {\n        var _next = slicedToArray(next, 2),\n            nextPath = _next[1];\n\n        var absolutePath = anchor.path.slice(0, depth).concat(nextPath);\n        range = range.moveAnchorTo(absolutePath, 0);\n      }\n    }\n\n    if (focusInline && !editor.isVoid(focusInline) && focus.offset === focusText.text.length) {\n      var _block = document.getClosestBlock(focus.path);\n      var _depth = document.getDepth(_block.key);\n      var _relativePath = slate.PathUtils.drop(focus.path, _depth);\n\n      var _block$texts3 = _block.texts({ path: _relativePath }),\n          _block$texts4 = slicedToArray(_block$texts3, 1),\n          _next2 = _block$texts4[0];\n\n      if (_next2) {\n        var _next3 = slicedToArray(_next2, 2),\n            _nextPath = _next3[1];\n\n        var _absolutePath = focus.path.slice(0, _depth).concat(_nextPath);\n        range = range.moveFocusTo(_absolutePath, 0);\n      }\n    }\n\n    var selection = document.createSelection(range);\n\n    // COMPAT: Ensure that the `isFocused` argument is set.\n    selection = selection.setIsFocused(true);\n\n    // COMPAT: Preserve the marks, since we have no way of knowing what the DOM\n    // selection's marks were. They will be cleared automatically by the\n    // `select` command if the selection moves.\n    selection = selection.set('marks', value.selection.marks);\n\n    return selection;\n  }\n\n  return {\n    queries: {\n      findDOMNode: findDOMNode,\n      findDOMPoint: findDOMPoint,\n      findDOMRange: findDOMRange,\n      findEventRange: findEventRange,\n      findNode: findNode,\n      findPath: findPath,\n      findPoint: findPoint,\n      findRange: findRange,\n      findSelection: findSelection\n    }\n  };\n}\n\n/**\n * From a DOM selection's `node` and `offset`, normalize so that it always\n * refers to a text node.\n *\n * @param {Element} node\n * @param {Number} offset\n * @return {Object}\n */\n\nfunction normalizeNodeAndOffset(node, offset) {\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (node.nodeType === 1 && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var direction = isLast ? 'backward' : 'forward';\n    var index = isLast ? offset - 1 : offset;\n    node = getEditableChild(node, index, direction);\n\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (node.nodeType === 1 && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild(node, i, direction);\n    }\n\n    // Determine the new offset inside the text node.\n    offset = isLast ? node.textContent.length : 0;\n  }\n\n  // Return the node and offset.\n  return { node: node, offset: offset };\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n *\n * @param {Element} parent\n * @param {Number} index\n * @param {String} direction ('forward' or 'backward')\n * @return {Element|Null}\n */\n\nfunction getEditableChild(parent, index, direction) {\n  var childNodes = parent.childNodes;\n\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false;\n\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (child.nodeType === 8 || child.nodeType === 1 && child.childNodes.length === 0 || child.nodeType === 1 && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) break;\n\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n\n    child = childNodes[i];\n    if (direction === 'forward') i++;\n    if (direction === 'backward') i--;\n  }\n\n  return child || null;\n}\n\n/**\n * Returns the number of characters that are the same at the beginning of the\n * String.\n *\n * @param {String} prev\n * @param {String} next\n */\n\nfunction getDiffStart(prev, next) {\n  var length = Math.min(prev.length, next.length);\n\n  for (var i = 0; i < length; i++) {\n    if (prev.charAt(i) !== next.charAt(i)) return i;\n  }\n\n  if (prev.length !== next.length) return length;\n  return null;\n}\n\n/**\n * Returns the number of characters that are the same at the end of the String\n * up to `max`. Max prevents double-counting characters when there are\n * multiple duplicate characters around the diff area.\n *\n * @param {String} prev\n * @param {String} next\n * @param {Number} max\n */\n\nfunction getDiffEnd(prev, next, max) {\n  var prevLength = prev.length;\n  var nextLength = next.length;\n  var length = Math.min(prevLength, nextLength, max);\n\n  for (var i = 0; i < length; i++) {\n    var prevChar = prev.charAt(prevLength - i - 1);\n    var nextChar = next.charAt(nextLength - i - 1);\n    if (prevChar !== nextChar) return i;\n  }\n\n  if (prev.length !== next.length) return length;\n  return null;\n}\n\n/**\n * Takes two strings and returns an object representing two offsets. The\n * first, `start` represents the number of characters that are the same at\n * the front of the String. The `end` represents the number of characters\n * that are the same at the end of the String.\n *\n * Returns null if they are identical.\n *\n * @param {String} prev\n * @param {String} next\n */\n\nfunction getDiffOffsets(prev, next) {\n  if (prev === next) return null;\n  var start = getDiffStart(prev, next);\n  var maxEnd = Math.min(prev.length - start, next.length - start);\n  var end = getDiffEnd(prev, next, maxEnd);\n  return { start: start, end: end, total: start + end };\n}\n\n/**\n * Takes a text string and returns a slice from the string at the given offses\n *\n * @param {String} text\n * @param {Object} offsets\n */\n\nfunction sliceText(text, offsets) {\n  return text.slice(offsets.start, text.length - offsets.end);\n}\n\n/**\n * Takes two strings and returns a smart diff that can be used to describe the\n * change in a way that can be used as operations like inserting, removing or\n * replacing text.\n *\n * @param {String} prev\n * @param {String} next\n */\n\nfunction diff(prev, next) {\n  var offsets = getDiffOffsets(prev, next);\n  if (offsets == null) return null;\n  var insertText = sliceText(next, offsets);\n  var removeText = sliceText(prev, offsets);\n  return {\n    start: offsets.start,\n    end: prev.length - offsets.end,\n    cursor: offsets.start + insertText.length,\n    insertText: insertText,\n    removeText: removeText\n  };\n}\n\n/**\n * @type {Debug}\n */\n\nvar debug$3 = Debug('slate:composition-manager');\n\n/**\n * Unicode String for a ZERO_WIDTH_SPACE\n *\n * @type {String}\n */\n\nvar ZERO_WIDTH_SPACE = String.fromCharCode(65279);\n\n/**\n * https://github.com/facebook/draft-js/commit/cda13cb8ff9c896cdb9ff832d1edeaa470d3b871\n */\n\nvar flushControlled = ReactDOM.unstable_flushControlled;\n\nfunction renderSync(editor, fn) {\n  flushControlled(function () {\n    fn();\n    editor.controller.flush();\n  });\n}\n\n/**\n * Takes text from a dom node and an offset within that text and returns an\n * object with fixed text and fixed offset which removes zero width spaces\n * and adjusts the offset.\n *\n * Optionally, if an `isLastNode` argument is passed in, it will also remove\n * a trailing newline.\n *\n * @param {String} text\n * @param {Number} offset\n * @param {Boolean} isLastNode\n */\n\nfunction fixTextAndOffset(prevText) {\n  var prevOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var isLastNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  var nextOffset = prevOffset;\n  var nextText = prevText;\n  var index = 0;\n\n  while (index !== -1) {\n    index = nextText.indexOf(ZERO_WIDTH_SPACE, index);\n    if (index === -1) break;\n    if (nextOffset > index) nextOffset--;\n    nextText = '' + nextText.slice(0, index) + nextText.slice(index + 1);\n  }\n\n  // remove the last newline if we are in the last node of a block\n  var lastChar = nextText.charAt(nextText.length - 1);\n\n  if (isLastNode && lastChar === '\\n') {\n    nextText = nextText.slice(0, -1);\n  }\n\n  var maxOffset = nextText.length;\n\n  if (nextOffset > maxOffset) nextOffset = maxOffset;\n  return { text: nextText, offset: nextOffset };\n}\n\n/**\n * Based loosely on:\n *\n * https://github.com/facebook/draft-js/blob/master/src/component/handlers/composition/DOMObserver.js\n * https://github.com/ProseMirror/prosemirror-view/blob/master/src/domobserver.js\n *\n * But is an analysis mainly for `backspace` and `enter` as we handle\n * compositions as a single operation.\n *\n * @param {} element\n */\n\nfunction CompositionManager(editor) {\n  /**\n   * A MutationObserver that flushes to the method `flush`\n   *\n   * @type {MutationObserver}\n   */\n\n  var observer = new window.MutationObserver(flush);\n\n  var win = null;\n\n  /**\n   * Object that keeps track of the most recent state\n   *\n   * @type {Range}\n   */\n\n  var last = {\n    rootEl: null, // root element that MutationObserver is attached to\n    diff: null, // last text node diff between Slate and DOM\n    range: null, // last range selected\n    domNode: null // last DOM node the cursor was in\n\n\n    /**\n     * Connect the MutationObserver to a specific editor root element\n     */\n\n  };function connect() {\n    debug$3('connect', { rootEl: rootEl });\n\n    var rootEl = editor.findDOMNode([]);\n\n    if (last.rootEl === rootEl) return;\n\n    debug$3('connect:run');\n\n    win = getWindow(rootEl);\n\n    observer.observe(rootEl, {\n      childList: true,\n      characterData: true,\n      attributes: true,\n      subtree: true,\n      characterDataOldValue: true\n    });\n  }\n\n  function disconnect() {\n    debug$3('disconnect');\n    observer.disconnect();\n    last.rootEl = null;\n  }\n\n  function clearDiff() {\n    debug$3('clearDIff');\n    last.diff = null;\n  }\n\n  /**\n   * Clear the `last` properties related to an action only\n   */\n\n  function clearAction() {\n    debug$3('clearAction');\n    last.diff = null;\n    last.domNode = null;\n  }\n\n  /**\n   * Apply the last `diff`\n   *\n   * We don't want to apply the `diff` at the time it is created because we\n   * may be in a composition. There are a few things that trigger the applying\n   * of the saved diff. Sometimeson its own and sometimes immediately before\n   * doing something else with the Editor.\n   *\n   * - `onCompositionEnd` event\n   * - `onSelect` event only when the user has moved into a different node\n   * - The user hits `enter`\n   * - The user hits `backspace` and removes an inline node\n   * - The user hits `backspace` and merges two blocks\n   */\n\n  function applyDiff() {\n    debug$3('applyDiff');\n    var diff$$1 = last.diff;\n\n    if (diff$$1 == null) return;\n    debug$3('applyDiff:run');\n    var document = editor.value.document;\n\n\n    var entire = editor.value.selection.moveAnchorTo(diff$$1.path, diff$$1.start).moveFocusTo(diff$$1.path, diff$$1.end);\n\n    entire = document.resolveRange(entire);\n\n    editor.insertTextAtRange(entire, diff$$1.insertText);\n  }\n\n  /**\n   * Handle `enter` that splits block\n   */\n\n  function splitBlock() {\n    debug$3('splitBlock');\n\n    renderSync(editor, function () {\n      applyDiff();\n\n      if (last.range) {\n        editor.select(last.range);\n      } else {\n        debug$3('splitBlock:NO-SELECTION');\n      }\n\n      editor.splitBlock().focus().restoreDOM();\n\n      clearAction();\n    });\n  }\n\n  /**\n   * Handle `backspace` that merges blocks\n   */\n\n  function mergeBlock() {\n    debug$3('mergeBlock');\n\n    /**\n     * The delay is required because hitting `enter`, `enter` then `backspace`\n     * in a word results in the cursor being one position to the right in\n     * Android 9.\n     *\n     * Slate sets the position to `0` and we even check it immediately after\n     * setting it and it is correct, but somewhere Android moves it to the right.\n     *\n     * This happens only when using the virtual keyboard. Hitting enter on a\n     * hardware keyboard does not trigger this bug.\n     *\n     * The call to `focus` is required because when we switch examples then\n     * merge a block, we lose focus in Android 9 (possibly others).\n     */\n\n    win.requestAnimationFrame(function () {\n      renderSync(editor, function () {\n        applyDiff();\n\n        editor.select(last.range).deleteBackward().focus().restoreDOM();\n\n        clearAction();\n      });\n    });\n  }\n\n  /**\n   * The requestId used to the save selection\n   *\n   * @type {Any}\n   */\n\n  var onSelectTimeoutId = null;\n\n  var bufferedMutations = [];\n  var startActionFrameId = null;\n  var isFlushing = false;\n\n  /**\n   * Mark the beginning of an action. The action happens when the\n   * `requestAnimationFrame` expires.\n   *\n   * If `startAction` is called again, it pushes the `action` to a new\n   * `requestAnimationFrame` and cancels the old one.\n   */\n\n  function startAction() {\n    if (onSelectTimeoutId) {\n      window.cancelAnimationFrame(onSelectTimeoutId);\n      onSelectTimeoutId = null;\n    }\n\n    isFlushing = true;\n\n    if (startActionFrameId) window.cancelAnimationFrame(startActionFrameId);\n\n    startActionFrameId = window.requestAnimationFrame(function () {\n      if (bufferedMutations.length > 0) {\n        flushAction(bufferedMutations);\n      }\n\n      startActionFrameId = null;\n      bufferedMutations = [];\n      isFlushing = false;\n    });\n  }\n\n  /**\n   * Handle MutationObserver flush\n   *\n   * @param {MutationList} mutations\n   */\n\n  function flush(mutations) {\n    var _bufferedMutations;\n\n    debug$3('flush');\n    (_bufferedMutations = bufferedMutations).push.apply(_bufferedMutations, toConsumableArray(mutations));\n    startAction();\n  }\n\n  /**\n   * Handle a `requestAnimationFrame` long batch of mutations.\n   *\n   * @param {Array} mutations\n   */\n\n  function flushAction(mutations) {\n    debug$3('flushAction', mutations.length, mutations);\n\n    // If there is an expanded collection, delete it\n    if (last.range && !last.range.isCollapsed) {\n      renderSync(editor, function () {\n        editor.select(last.range).deleteBackward().focus().restoreDOM();\n      });\n      return;\n    }\n\n    if (mutations.length > 1) {\n      // check if one of the mutations matches the signature of an `enter`\n      // which we use to signify a `splitBlock`\n      var splitBlockMutation = mutations.find(function (m) {\n        if (m.type !== 'childList') return false;\n        if (m.addedNodes.length === 0) return false;\n        var addedNode = m.addedNodes[0];\n\n        // If a text node is created anywhere with a newline in it, it's an\n        // enter\n        if (addedNode.nodeType === window.Node.TEXT_NODE && addedNode.textContent === '\\n') return true;\n\n        // If an element is created with a key that matches a block in our\n        // document, that means the mutation is splitting an existing block\n        // by creating a new element with the same key.\n        if (addedNode.nodeType !== window.Node.ELEMENT_NODE) return false;\n        var dataset = addedNode.dataset;\n        var key = dataset.key;\n        if (key == null) return false;\n        var block = editor.value.document.getClosestBlock(key);\n        return !!block;\n      });\n\n      if (splitBlockMutation) {\n        splitBlock();\n        return;\n      }\n    }\n\n    // If we haven't matched a more specific mutation already, these general\n    // mutation catchers will try and determine what the user was trying to\n    // do.\n\n    var firstMutation = mutations[0];\n\n    if (firstMutation.type === 'characterData') {\n      resolveDOMNode(firstMutation.target.parentNode);\n    } else if (firstMutation.type === 'childList') {\n      if (firstMutation.removedNodes.length > 0) {\n        if (mutations.length === 1) {\n          removeNode(firstMutation.removedNodes[0]);\n        } else {\n          mergeBlock();\n        }\n      } else if (firstMutation.addedNodes.length > 0) {\n        splitBlock();\n      }\n    }\n  }\n\n  /**\n   * Takes a DOM Node and resolves it against Slate's Document.\n   *\n   * Saves the changes to `last.diff` which can be applied later using\n   * `applyDiff()`\n   *\n   * @param {DOMNode} domNode\n   */\n\n  function resolveDOMNode(domNode) {\n    debug$3('resolveDOMNode');\n\n    var value = editor.value;\n    var document = value.document;\n\n\n    var dataElement = domNode.closest('[data-key]');\n    var key = dataElement.dataset.key;\n    var path = document.getPath(key);\n    var block = document.getClosestBlock(key);\n    var node = document.getDescendant(key);\n    var prevText = node.text;\n\n    // COMPAT: If this is the last leaf, and the DOM text ends in a new line,\n    // we will have added another new line in <Leaf>'s render method to account\n    // for browsers collapsing a single trailing new lines, so remove it.\n    var isLastNode = block.nodes.last() === node;\n\n    var fix = fixTextAndOffset(domNode.textContent, 0, isLastNode);\n\n    var nextText = fix.text;\n\n    // If the text is no different, there is no diff.\n    if (nextText === prevText) {\n      last.diff = null;\n      return;\n    }\n\n    var diff$$1 = diff(prevText, nextText);\n\n    last.diff = {\n      path: path,\n      start: diff$$1.start,\n      end: diff$$1.end,\n      insertText: diff$$1.insertText\n    };\n\n    debug$3('resolveDOMNode:diff', last.diff);\n  }\n\n  /**\n   * Remove an Inline DOM Node.\n   *\n   * Happens when you delete the last character in an Inline DOM Node\n   */\n\n  function removeNode(domNode) {\n    debug$3('removeNode');\n    if (domNode.nodeType !== window.Node.ELEMENT_NODE) return;\n    var value = editor.value;\n    var document = value.document,\n        selection = value.selection;\n\n    var node = editor.findNode(domNode);\n    var nodeSelection = document.resolveRange(selection.moveToRangeOfNode(node));\n\n    renderSync(editor, function () {\n      editor.select(nodeSelection).delete().restoreDOM();\n    });\n  }\n\n  /**\n   * handle `onCompositionStart`\n   */\n\n  function onCompositionStart() {\n    debug$3('onCompositionStart');\n  }\n\n  /**\n   * handle `onCompositionEnd`\n   */\n\n  function onCompositionEnd() {\n    debug$3('onCompositionEnd');\n\n    /**\n     * The timing on the `setTimeout` with `20` ms is sensitive.\n     *\n     * It cannot use `requestAnimationFrame` because it is too short.\n     *\n     * Android 9, for example, when you type `it ` the space will first trigger\n     * a `compositionEnd` for the `it` part before the mutation for the ` `.\n     * This means that we end up with `it` if we trigger too soon because it\n     * is on the wrong value.\n     */\n\n    window.setTimeout(function () {\n      if (last.diff) {\n        debug$3('onCompositionEnd:applyDiff');\n\n        renderSync(editor, function () {\n          applyDiff();\n\n          var domRange = win.getSelection().getRangeAt(0);\n          var domText = domRange.startContainer.textContent;\n          var offset = domRange.startOffset;\n\n          var fix = fixTextAndOffset(domText, offset);\n\n          var range = editor.findRange({\n            anchorNode: domRange.startContainer,\n            anchorOffset: 0,\n            focusNode: domRange.startContainer,\n            focusOffset: 0,\n            isCollapsed: true\n          }).moveTo(fix.offset);\n\n          /**\n           * We must call `restoreDOM` even though this is applying a `diff` which\n           * should not require it. But if you type `it me. no.` on a blank line\n           * with a block following it, the next line will merge with the this\n           * line. A mysterious `keydown` with `input` of backspace appears in the\n           * event stream which the user not React caused.\n           *\n           * `focus` is required as well because otherwise we lose focus on hitting\n           * `enter` in such a scenario.\n           */\n\n          editor.select(range).focus().restoreDOM();\n        });\n      }\n\n      clearAction();\n    }, 20);\n  }\n\n  /**\n   * Handle `onSelect` event\n   *\n   * Save the selection after a `requestAnimationFrame`\n   *\n   * - If we're not in the middle of flushing mutations\n   * - and cancel save if a mutation runs before the `requestAnimationFrame`\n   */\n\n  function onSelect(event) {\n    debug$3('onSelect:try');\n\n    // Event can be Synthetic React or native. Grab only the native one so\n    // that we don't have to call `event.perist` for performance.\n    event = event.nativeEvent ? event.nativeEvent : event;\n\n    window.cancelAnimationFrame(onSelectTimeoutId);\n    onSelectTimeoutId = null;\n\n    // Don't capture the last selection if the selection was made during the\n    // flushing of DOM mutations. This means it is all part of one user action.\n    if (isFlushing) return;\n\n    onSelectTimeoutId = window.requestAnimationFrame(function () {\n      debug$3('onSelect:save-selection');\n\n      var domSelection = getWindow(event.target).getSelection();\n      var range = editor.findRange(domSelection);\n\n      var anchorFix = fixTextAndOffset(domSelection.anchorNode.textContent, domSelection.anchorOffset);\n\n      var focusFix = fixTextAndOffset(domSelection.focusNode.textContent, domSelection.focusOffset);\n\n      if (range.anchor.offset !== anchorFix.offset) {\n        range = range.set('anchor', range.anchor.set('offset', anchorFix.offset));\n      }\n\n      if (range.focus.offset !== focusFix.offset) {\n        range = range.set('focus', range.focus.set('offset', focusFix.offset));\n      }\n\n      debug$3('onSelect:save-data', {\n        domSelection: normalizeDOMSelection(domSelection),\n        range: range.toJS()\n      });\n\n      // If the `domSelection` has moved into a new node, then reconcile with\n      // `applyDiff`\n      if (domSelection.isCollapsed && last.node !== domSelection.anchorNode && last.diff != null) {\n        debug$3('onSelect:applyDiff', last.diff);\n        applyDiff();\n        editor.select(range);\n        clearAction();\n      }\n\n      last.range = range;\n      last.node = domSelection.anchorNode;\n    });\n  }\n\n  return {\n    clearDiff: clearDiff,\n    connect: connect,\n    disconnect: disconnect,\n    onKeyDown: startAction,\n    onCompositionStart: onCompositionStart,\n    onCompositionEnd: onCompositionEnd,\n    onSelect: onSelect\n  };\n}\n\nfunction normalizeDOMSelection(selection) {\n  return {\n    anchorNode: selection.anchorNode,\n    anchorOffset: selection.anchorOffset,\n    focusNode: selection.focusNode,\n    focusOffset: selection.focusOffset\n  };\n}\n\n/**\n * Fixes a selection within the DOM when the cursor is in Slate's special\n * zero-width block. Slate handles empty blocks in a special manner and the\n * cursor can end up either before or after the non-breaking space. This\n * causes different behavior in Android and so we make sure the seleciton is\n * always before the zero-width space.\n *\n * @param {Window} window\n */\n\nfunction fixSelectionInZeroWidthBlock(window) {\n  var domSelection = window.getSelection();\n  var anchorNode = domSelection.anchorNode;\n\n  if (anchorNode == null) return;\n  var dataset = anchorNode.parentElement.dataset;\n\n  var isZeroWidth = dataset ? dataset.slateZeroWidth === 'n' : false;\n\n  if (isZeroWidth && anchorNode.textContent.length === 1 && domSelection.anchorOffset !== 0) {\n    var range = window.document.createRange();\n    range.setStart(anchorNode, 0);\n    range.setEnd(anchorNode, 0);\n    domSelection.removeAllRanges();\n    domSelection.addRange(range);\n  }\n}\n\n/**\n * Android Plugin\n *\n * @param {Editor} options.editor\n */\n\nfunction AndroidPlugin(_ref) {\n  var editor = _ref.editor;\n\n  var observer = new CompositionManager(editor);\n\n  /**\n   * handle `onCompositionStart`\n   */\n\n  function onCompositionStart() {\n    observer.onCompositionStart();\n  }\n\n  /**\n   * handle `onCompositionEnd`\n   */\n\n  function onCompositionEnd() {\n    observer.onCompositionEnd();\n  }\n\n  /**\n   * handle `onSelect`\n   *\n   * @param {Event} event\n   */\n\n  function onSelect(event) {\n    var window = getWindow(event.target);\n    fixSelectionInZeroWidthBlock(window);\n    observer.onSelect(event);\n  }\n\n  /**\n   * handle `onComponentDidMount`\n   */\n\n  function onComponentDidMount() {\n    observer.connect();\n  }\n\n  /**\n   * handle `onComponentDidUpdate`\n   */\n\n  function onComponentDidUpdate() {\n    observer.connect();\n  }\n\n  /**\n   * handle `onComponentWillUnmount`\n   *\n   * @param {Event} event\n   */\n\n  function onComponentWillUnmount() {\n    observer.disconnect();\n  }\n\n  /**\n   * handle `onRender`\n   *\n   * @param {Event} event\n   */\n\n  function onRender() {\n    observer.disconnect();\n\n    // We don't want the `diff` from a previous render to apply to a\n    // potentially different value (e.g. when we switch examples)\n    observer.clearDiff();\n  }\n\n  return {\n    onComponentDidMount: onComponentDidMount,\n    onComponentDidUpdate: onComponentDidUpdate,\n    onComponentWillUnmount: onComponentWillUnmount,\n    onCompositionEnd: onCompositionEnd,\n    onCompositionStart: onCompositionStart,\n    onRender: onRender,\n    onSelect: onSelect\n  };\n}\n\n/**\n * This plugin prevents events from going any further and is useful in dev.\n *\n * The purpose is to see how the editor events and mutations behave without\n * the noise of the editor also adding its own events and mutations.\n *\n * IMPORTANT:\n *\n * This plugin is detached (i.e. there is no way to turn it on in Slate).\n * You must hard code it into `plugins/react/index`.\n *\n * @return {Object}\n */\n\nfunction NoopPlugin() {\n  /**\n   * Plugin Object\n   *\n   * @type {Object}\n   */\n\n  var plugin = {};\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = EVENT_HANDLERS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var eventName = _step.value;\n\n      plugin[eventName] = function (event, editor, next) {};\n    }\n\n    /**\n     * Return the plugin.\n     *\n     * @type {Object}\n     */\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return plugin;\n}\n\n/**\n * The transfer types that Slate recognizes.\n *\n * @type {Object}\n */\n\nvar TRANSFER_TYPES = {\n  FRAGMENT: 'application/x-slate-fragment',\n  HTML: 'text/html',\n  NODE: 'application/x-slate-node',\n  RICH: 'text/rtf',\n  TEXT: 'text/plain'\n};\n\nvar FRAGMENT = TRANSFER_TYPES.FRAGMENT;\nvar HTML = TRANSFER_TYPES.HTML;\nvar TEXT = TRANSFER_TYPES.TEXT;\n\n/**\n * Prepares a Slate document fragment to be copied to the clipboard.\n *\n * @param {Event} event\n * @param {Editor} editor\n */\n\nfunction cloneFragment(event, editor) {\n  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {\n    return undefined;\n  };\n\n  invariant(!slate.Value.isValue(editor), 'As of Slate 0.42.0, the `cloneFragment` utility takes an `editor` instead of a `value`.');\n\n  var window = getWindow(event.target);\n  var native = window.getSelection();\n  var value = editor.value;\n  var document = value.document,\n      fragment = value.fragment,\n      selection = value.selection;\n  var start = selection.start,\n      end = selection.end;\n\n  var startVoid = document.getClosestVoid(start.path, editor);\n  var endVoid = document.getClosestVoid(end.path, editor);\n\n  // If the selection is collapsed, and it isn't inside a void node, abort.\n  if (native.isCollapsed && !startVoid) return;\n\n  // Create a fake selection so that we can add a Base64-encoded copy of the\n  // fragment to the HTML, to decode on future pastes.\n  var encoded = Base64.serializeNode(fragment);\n  var range = native.getRangeAt(0);\n  var contents = range.cloneContents();\n  var attach = contents.childNodes[0];\n\n  // Make sure attach is a non-empty node, since empty nodes will not get copied\n  contents.childNodes.forEach(function (node) {\n    if (node.textContent && node.textContent.trim() !== '') {\n      attach = node;\n    }\n  });\n\n  // COMPAT: If the end node is a void node, we need to move the end of the\n  // range from the void node's spacer span, to the end of the void node's\n  // content, since the spacer is before void's content in the DOM.\n  if (endVoid) {\n    var r = range.cloneRange();\n    var path = document.getPath(endVoid.key);\n\n    if (path) {\n      var node = editor.findDOMNode(path);\n      r.setEndAfter(node);\n      contents = r.cloneContents();\n    }\n  }\n\n  // COMPAT: If the start node is a void node, we need to attach the encoded\n  // fragment to the void node's content node instead of the spacer, because\n  // attaching it to empty `<div>/<span>` nodes will end up having it erased by\n  // most browsers. (2018/04/27)\n  if (startVoid) {\n    attach = contents.childNodes[0].childNodes[1].firstChild;\n  }\n\n  // Remove any zero-width space spans from the cloned DOM so that they don't\n  // show up elsewhere when pasted.\n  [].slice.call(contents.querySelectorAll(SELECTORS.ZERO_WIDTH)).forEach(function (zw) {\n    var isNewline = zw.getAttribute(DATA_ATTRS.ZERO_WIDTH) === 'n';\n    zw.textContent = isNewline ? '\\n' : '';\n  });\n\n  // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\n  // in the HTML, and can be used for intra-Slate pasting. If it's a text\n  // node, wrap it in a `<span>` so we have something to set an attribute on.\n  if (attach.nodeType === 3) {\n    var span = window.document.createElement('span');\n\n    // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\n    // then leading and trailing spaces will be ignored. (2017/09/21)\n    span.style.whiteSpace = 'pre';\n\n    span.appendChild(attach);\n    contents.appendChild(span);\n    attach = span;\n  }\n\n  attach.setAttribute(DATA_ATTRS.FRAGMENT, encoded);\n\n  //  Creates value from only the selected blocks\n  //  Then gets plaintext for clipboard with proper linebreaks for BLOCK elements\n  //  Via Plain serializer\n  var valFromSelection = slate.Value.create({ document: fragment });\n  var plainText = Plain.serialize(valFromSelection);\n\n  // Add the phony content to a div element. This is needed to copy the\n  // contents into the html clipboard register.\n  var div = window.document.createElement('div');\n  div.appendChild(contents);\n\n  // For browsers supporting it, we set the clipboard registers manually,\n  // since the result is more predictable.\n  // COMPAT: IE supports the setData method, but only in restricted sense.\n  // IE doesn't support arbitrary MIME types or common ones like 'text/plain';\n  // it only accepts \"Text\" (which gets mapped to 'text/plain') and \"Url\"\n  // (mapped to 'text/url-list'); so, we should only enter block if !IS_IE\n  if (event.clipboardData && event.clipboardData.setData && !slateDevEnvironment.IS_IE) {\n    event.preventDefault();\n    event.clipboardData.setData(TEXT, plainText);\n    event.clipboardData.setData(FRAGMENT, encoded);\n    event.clipboardData.setData(HTML, div.innerHTML);\n    callback();\n    return;\n  }\n\n  // COMPAT: For browser that don't support the Clipboard API's setData method,\n  // we must rely on the browser to natively copy what's selected.\n  // So we add the div (containing our content) to the DOM, and select it.\n  var editorEl = event.target.closest(SELECTORS.EDITOR);\n  div.setAttribute('contenteditable', true);\n  div.style.position = 'absolute';\n  div.style.left = '-9999px';\n  editorEl.appendChild(div);\n  native.selectAllChildren(div);\n\n  // Revert to the previous selection right after copying.\n  window.requestAnimationFrame(function () {\n    editorEl.removeChild(div);\n    removeAllRanges(native);\n    native.addRange(range);\n    callback();\n  });\n}\n\n/**\n * Transfer types.\n *\n * @type {String}\n */\n\nvar FRAGMENT$1 = TRANSFER_TYPES.FRAGMENT;\nvar HTML$1 = TRANSFER_TYPES.HTML;\nvar NODE = TRANSFER_TYPES.NODE;\nvar RICH = TRANSFER_TYPES.RICH;\nvar TEXT$1 = TRANSFER_TYPES.TEXT;\n\n/**\n * Fragment matching regexp for HTML nodes.\n *\n * @type {RegExp}\n */\n\nvar FRAGMENT_MATCHER = / data-slate-fragment=\"([^\\s\"]+)\"/;\n\n/**\n * Get the transfer data from an `event`.\n *\n * @param {Event} event\n * @return {Object}\n */\n\nfunction getEventTransfer(event) {\n  // COMPAT: IE 11 doesn't populate nativeEvent with either\n  // dataTransfer or clipboardData. We'll need to use the base event\n  // object (2018/14/6)\n  if (!slateDevEnvironment.IS_IE && event.nativeEvent) {\n    event = event.nativeEvent;\n  }\n\n  var transfer = event.dataTransfer || event.clipboardData;\n  var fragment = getType(transfer, FRAGMENT$1);\n  var node = getType(transfer, NODE);\n  var html = getType(transfer, HTML$1);\n  var rich = getType(transfer, RICH);\n  var text = getType(transfer, TEXT$1);\n  var files = void 0;\n\n  // If there isn't a fragment, but there is HTML, check to see if the HTML is\n  // actually an encoded fragment.\n  if (!fragment && html && ~html.indexOf(' ' + DATA_ATTRS.FRAGMENT + '=\"')) {\n    var matches = FRAGMENT_MATCHER.exec(html);\n\n    var _matches = slicedToArray(matches, 2),\n        full = _matches[0],\n        encoded = _matches[1]; // eslint-disable-line no-unused-vars\n\n\n    if (encoded) fragment = encoded;\n  }\n\n  // COMPAT: Edge doesn't handle custom data types\n  // These will be embedded in text/plain in this case (2017/7/12)\n  if (text) {\n    var embeddedTypes = getEmbeddedTypes(text);\n\n    if (embeddedTypes[FRAGMENT$1]) fragment = embeddedTypes[FRAGMENT$1];\n    if (embeddedTypes[NODE]) node = embeddedTypes[NODE];\n    if (embeddedTypes[TEXT$1]) text = embeddedTypes[TEXT$1];\n  }\n\n  // Decode a fragment or node if they exist.\n  if (fragment) fragment = Base64.deserializeNode(fragment);\n  if (node) node = Base64.deserializeNode(node);\n\n  // COMPAT: Edge sometimes throws 'NotSupportedError'\n  // when accessing `transfer.items` (2017/7/12)\n  try {\n    // Get and normalize files if they exist.\n    if (transfer.items && transfer.items.length) {\n      files = Array.from(transfer.items).map(function (item) {\n        return item.kind === 'file' ? item.getAsFile() : null;\n      }).filter(function (exists) {\n        return exists;\n      });\n    } else if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files);\n    }\n  } catch (err) {\n    if (transfer.files && transfer.files.length) {\n      files = Array.from(transfer.files);\n    }\n  }\n\n  // Determine the type of the data.\n  var data = { files: files, fragment: fragment, html: html, node: node, rich: rich, text: text };\n  data.type = getTransferType(data);\n  return data;\n}\n\n/**\n * Takes text input, checks whether contains embedded data\n * and returns object with original text +/- additional data\n *\n * @param {String} text\n * @return {Object}\n */\n\nfunction getEmbeddedTypes(text) {\n  var prefix = 'SLATE-DATA-EMBED::';\n\n  if (text.substring(0, prefix.length) !== prefix) {\n    return { TEXT: text };\n  }\n\n  // Attempt to parse, if fails then just standard text/plain\n  // Otherwise, already had data embedded\n  try {\n    return JSON.parse(text.substring(prefix.length));\n  } catch (err) {\n    throw new Error('Unable to parse custom Slate drag event data.');\n  }\n}\n\n/**\n * Get the type of a transfer from its `data`.\n *\n * @param {Object} data\n * @return {String}\n */\n\nfunction getTransferType(data) {\n  if (data.fragment) return 'fragment';\n  if (data.node) return 'node';\n\n  // COMPAT: Microsoft Word adds an image of the selected text to the data.\n  // Since files are preferred over HTML or text, this would cause the type to\n  // be considered `files`. But it also adds rich text data so we can check\n  // for that and properly set the type to `html` or `text`. (2016/11/21)\n  if (data.rich && data.html) return 'html';\n  if (data.rich && data.text) return 'text';\n\n  if (data.files && data.files.length) return 'files';\n  if (data.html) return 'html';\n  if (data.text) return 'text';\n  return 'unknown';\n}\n\n/**\n * Get one of types `TYPES.FRAGMENT`, `TYPES.NODE`, `text/html`, `text/rtf` or\n * `text/plain` from transfers's `data` if possible, otherwise return null.\n *\n * @param {Object} transfer\n * @param {String} type\n * @return {String}\n */\n\nfunction getType(transfer, type) {\n  if (!transfer.types || !transfer.types.length) {\n    // COMPAT: In IE 11, there is no `types` field but `getData('Text')`\n    // is supported`. (2017/06/23)\n    return type === TEXT$1 ? transfer.getData('Text') || null : null;\n  }\n\n  // COMPAT: In Edge, transfer.types doesn't respond to `indexOf`. (2017/10/25)\n  var types = Array.from(transfer.types);\n\n  return types.indexOf(type) !== -1 ? transfer.getData(type) || null : null;\n}\n\n/**\n * The default plain text transfer type.\n *\n * @type {String}\n */\n\nvar TEXT$2 = TRANSFER_TYPES.TEXT;\n\n/**\n * Set data with `type` and `content` on an `event`.\n *\n * COMPAT: In Edge, custom types throw errors, so embed all non-standard\n * types in text/plain compound object. (2017/7/12)\n *\n * @param {Event} event\n * @param {String} type\n * @param {String} content\n */\n\nfunction setEventTransfer(event, type, content) {\n  var mime = TRANSFER_TYPES[type.toUpperCase()];\n\n  if (!mime) {\n    throw new Error('Cannot set unknown transfer type \"' + mime + '\".');\n  }\n\n  if (event.nativeEvent) {\n    event = event.nativeEvent;\n  }\n\n  var transfer = event.dataTransfer || event.clipboardData;\n\n  try {\n    transfer.setData(mime, content);\n    // COMPAT: Safari needs to have the 'text' (and not 'text/plain') value in dataTransfer\n    // to display the cursor while dragging internally.\n    transfer.setData('text', transfer.getData('text'));\n  } catch (err) {\n    var prefix = 'SLATE-DATA-EMBED::';\n    var text = transfer.getData(TEXT$2);\n    var obj = {};\n\n    // If the existing plain text data is prefixed, it's Slate JSON data.\n    if (text.substring(0, prefix.length) === prefix) {\n      try {\n        obj = JSON.parse(text.substring(prefix.length));\n      } catch (e) {\n        throw new Error('Failed to parse Slate data from `DataTransfer` object.');\n      }\n    } else {\n      // Otherwise, it's just set it as is.\n      obj[TEXT$2] = text;\n    }\n\n    obj[mime] = content;\n    var string = '' + prefix + JSON.stringify(obj);\n    transfer.setData(TEXT$2, string);\n  }\n}\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug$4 = Debug('slate:after');\n\n/**\n * A plugin that adds the \"after\" browser-specific logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction AfterPlugin() {\n  var isDraggingInternally = null;\n  var isMouseDown = false;\n\n  /**\n   * On before input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBeforeInput(event, editor, next) {\n    var value = editor.value;\n\n    var isSynthetic = !!event.nativeEvent;\n\n    // If the event is synthetic, it's React's polyfill of `beforeinput` that\n    // isn't a true `beforeinput` event with meaningful information. It only\n    // gets triggered for character insertions, so we can just insert directly.\n    if (isSynthetic) {\n      event.preventDefault();\n      editor.insertText(event.data);\n      return next();\n    }\n\n    // Otherwise, we can use the information in the `beforeinput` event to\n    // figure out the exact change that will occur, and prevent it.\n\n    var _event$getTargetRange = event.getTargetRanges(),\n        _event$getTargetRange2 = slicedToArray(_event$getTargetRange, 1),\n        targetRange = _event$getTargetRange2[0];\n\n    if (!targetRange) return next();\n\n    debug$4('onBeforeInput', { event: event });\n\n    event.preventDefault();\n\n    var document = value.document,\n        selection = value.selection;\n\n    var range = editor.findRange(targetRange);\n\n    switch (event.inputType) {\n      case 'deleteByDrag':\n      case 'deleteByCut':\n      case 'deleteContent':\n      case 'deleteContentBackward':\n      case 'deleteContentForward':\n        {\n          editor.deleteAtRange(range);\n          break;\n        }\n\n      case 'deleteWordBackward':\n        {\n          editor.deleteWordBackwardAtRange(range);\n          break;\n        }\n\n      case 'deleteWordForward':\n        {\n          editor.deleteWordForwardAtRange(range);\n          break;\n        }\n\n      case 'deleteSoftLineBackward':\n      case 'deleteHardLineBackward':\n        {\n          editor.deleteLineBackwardAtRange(range);\n          break;\n        }\n\n      case 'deleteSoftLineForward':\n      case 'deleteHardLineForward':\n        {\n          editor.deleteLineForwardAtRange(range);\n          break;\n        }\n\n      case 'insertLineBreak':\n      case 'insertParagraph':\n        {\n          var hasVoidParent = document.hasVoidParent(selection.start.path, editor);\n\n          if (hasVoidParent) {\n            editor.moveToStartOfNextText();\n          } else {\n            editor.splitBlockAtRange(range);\n          }\n\n          break;\n        }\n\n      case 'insertFromYank':\n      case 'insertReplacementText':\n      case 'insertText':\n        {\n          // COMPAT: `data` should have the text for the `insertText` input type\n          // and `dataTransfer` should have the text for the\n          // `insertReplacementText` input type, but Safari uses `insertText` for\n          // spell check replacements and sets `data` to `null`. (2018/08/09)\n          var text = event.data == null ? event.dataTransfer.getData('text/plain') : event.data;\n\n          if (text == null) break;\n\n          editor.insertTextAtRange(range, text, selection.marks);\n\n          // If the text was successfully inserted, and the selection had marks\n          // on it, unset the selection's marks.\n          if (selection.marks && value.document !== editor.value.document) {\n            editor.select({ marks: null });\n          }\n\n          break;\n        }\n    }\n\n    next();\n  }\n\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBlur(event, editor, next) {\n    debug$4('onBlur', { event: event });\n    editor.blur();\n    next();\n  }\n\n  /**\n   * On click.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onClick(event, editor, next) {\n    if (editor.readOnly) return next();\n\n    var value = editor.value;\n    var document = value.document;\n\n    var path = editor.findPath(event.target);\n    if (!path) return next();\n\n    debug$4('onClick', { event: event });\n\n    var node = document.getNode(path);\n    var ancestors = document.getAncestors(path);\n    var isVoid = node && (editor.isVoid(node) || ancestors.some(function (a) {\n      return editor.isVoid(a);\n    }));\n\n    if (isVoid) {\n      // COMPAT: In Chrome & Safari, selections that are at the zero offset of\n      // an inline node will be automatically replaced to be at the last offset\n      // of a previous inline node, which screws us up, so we always want to set\n      // it to the end of the node. (2016/11/29)\n      editor.focus().moveToEndOfNode(node);\n    }\n\n    next();\n  }\n\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCopy(event, editor, next) {\n    debug$4('onCopy', { event: event });\n    cloneFragment(event, editor);\n    next();\n  }\n\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCut(event, editor, next) {\n    debug$4('onCut', { event: event });\n\n    // Once the fake cut content has successfully been added to the clipboard,\n    // delete the content in the current selection.\n    cloneFragment(event, editor, function () {\n      // If user cuts a void block node or a void inline node,\n      // manually removes it since selection is collapsed in this case.\n      var value = editor.value;\n      var document = value.document,\n          selection = value.selection;\n      var end = selection.end,\n          isCollapsed = selection.isCollapsed;\n\n      var voidPath = void 0;\n\n      if (isCollapsed) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = document.ancestors(end.path)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var _ref = _step.value;\n\n            var _ref2 = slicedToArray(_ref, 2);\n\n            var node = _ref2[0];\n            var path = _ref2[1];\n\n            if (editor.isVoid(node)) {\n              voidPath = path;\n              break;\n            }\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator.return) {\n              _iterator.return();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      }\n\n      if (voidPath) {\n        editor.removeNodeByKey(voidPath);\n      } else {\n        editor.delete();\n      }\n    });\n\n    next();\n  }\n\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragEnd(event, editor, next) {\n    debug$4('onDragEnd', { event: event });\n    isDraggingInternally = null;\n    next();\n  }\n\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragStart(event, editor, next) {\n    debug$4('onDragStart', { event: event });\n\n    isDraggingInternally = true;\n\n    var value = editor.value;\n    var document = value.document;\n\n    var path = editor.findPath(event.target);\n    var node = document.getNode(path);\n    var ancestors = document.getAncestors(path);\n    var isVoid = node && (editor.isVoid(node) || ancestors.some(function (a) {\n      return editor.isVoid(a);\n    }));\n    var selectionIncludesNode = value.blocks.some(function (block) {\n      return block === node;\n    });\n\n    // If a void block is dragged and is not selected, select it (necessary for local drags).\n    if (isVoid && !selectionIncludesNode) {\n      editor.moveToRangeOfNode(node);\n    }\n\n    var fragment = editor.value.fragment;\n    var encoded = Base64.serializeNode(fragment);\n    setEventTransfer(event, 'fragment', encoded);\n    next();\n  }\n\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDrop(event, editor, next) {\n    var value = editor.value;\n    var document = value.document,\n        selection = value.selection;\n\n    var window = getWindow(event.target);\n    var target = editor.findEventRange(event);\n\n    if (!target) {\n      return next();\n    }\n\n    debug$4('onDrop', { event: event });\n\n    var transfer = getEventTransfer(event);\n    var type = transfer.type,\n        fragment = transfer.fragment,\n        text = transfer.text;\n\n\n    editor.focus();\n\n    // COMPAT: React's onSelect event breaks after an onDrop event\n    // has fired in a node: https://github.com/facebook/react/issues/11379.\n    // Until this is fixed in React, we dispatch a mouseup event on that\n    // DOM node, since that will make it go back to normal.\n    var el = editor.findDOMNode(target.focus.path);\n\n    if (el) {\n      el.dispatchEvent(new MouseEvent('mouseup', {\n        view: window,\n        bubbles: true,\n        cancelable: true\n      }));\n    }\n\n    var draggedRange = selection;\n\n    editor.select(target);\n\n    if (isDraggingInternally) {\n      editor.deleteAtRange(draggedRange);\n    }\n\n    if (type === 'text' || type === 'html') {\n      var anchor = target.anchor;\n\n      var hasVoidParent = document.hasVoidParent(anchor.path, editor);\n\n      if (hasVoidParent) {\n        var p = anchor.path;\n        var n = document.getNode(anchor.path);\n\n        while (hasVoidParent) {\n          var _document$texts = document.texts({ path: p }),\n              _document$texts2 = slicedToArray(_document$texts, 1),\n              nxt = _document$texts2[0];\n\n          if (!nxt) {\n            break;\n          }\n\n          \n          var _nxt = slicedToArray(nxt, 2);\n\n          n = _nxt[0];\n          p = _nxt[1];\n\n          hasVoidParent = document.hasVoidParent(p, editor);\n        }\n\n        if (n) editor.moveToStartOfNode(n);\n      }\n\n      if (text) {\n        text.split('\\n').forEach(function (line, i) {\n          if (i > 0) editor.splitBlock();\n          editor.insertText(line);\n        });\n      }\n    }\n\n    if (type === 'fragment') {\n      editor.insertFragment(fragment);\n    }\n\n    next();\n  }\n\n  /**\n   * On focus.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onFocus(event, editor, next) {\n    debug$4('onFocus', { event: event });\n\n    // COMPAT: If the focus event is a mouse-based one, it will be shortly\n    // followed by a `selectionchange`, so we need to deselect here to prevent\n    // the old selection from being set by the `updateSelection` of `<Content>`,\n    // preventing the `selectionchange` from firing. (2018/11/07)\n    if (isMouseDown && !slateDevEnvironment.IS_IE && !slateDevEnvironment.IS_EDGE) {\n      editor.deselect().focus();\n    } else {\n      editor.focus();\n    }\n\n    next();\n  }\n\n  /**\n   * On input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onInput(event, editor, next) {\n    debug$4('onInput');\n\n    var window = getWindow(event.target);\n    var domSelection = window.getSelection();\n    var selection = editor.findSelection(domSelection);\n\n    if (selection) {\n      editor.select(selection);\n    } else {\n      editor.blur();\n    }\n\n    var anchorNode = domSelection.anchorNode;\n\n    editor.reconcileDOMNode(anchorNode);\n\n    next();\n  }\n\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onKeyDown(event, editor, next) {\n    debug$4('onKeyDown', { event: event });\n\n    var value = editor.value;\n    var document = value.document,\n        selection = value.selection;\n    var start = selection.start;\n\n    var hasVoidParent = document.hasVoidParent(start.path, editor);\n\n    // COMPAT: In iOS, some of these hotkeys are handled in the\n    // `onNativeBeforeInput` handler of the `<Content>` component in order to\n    // preserve native autocorrect behavior, so they shouldn't be handled here.\n    if (Hotkeys.isSplitBlock(event) && !slateDevEnvironment.IS_IOS) {\n      return hasVoidParent ? editor.moveToStartOfNextText() : editor.splitBlock();\n    }\n\n    if (Hotkeys.isDeleteBackward(event) && !slateDevEnvironment.IS_IOS) {\n      return editor.deleteCharBackward();\n    }\n\n    if (Hotkeys.isDeleteForward(event) && !slateDevEnvironment.IS_IOS) {\n      return editor.deleteCharForward();\n    }\n\n    if (Hotkeys.isDeleteLineBackward(event)) {\n      return editor.deleteLineBackward();\n    }\n\n    if (Hotkeys.isDeleteLineForward(event)) {\n      return editor.deleteLineForward();\n    }\n\n    if (Hotkeys.isDeleteWordBackward(event)) {\n      return editor.deleteWordBackward();\n    }\n\n    if (Hotkeys.isDeleteWordForward(event)) {\n      return editor.deleteWordForward();\n    }\n\n    if (Hotkeys.isRedo(event)) {\n      return editor.redo();\n    }\n\n    if (Hotkeys.isUndo(event)) {\n      return editor.undo();\n    }\n\n    // COMPAT: Certain browsers don't handle the selection updates properly. In\n    // Chrome, the selection isn't properly extended. And in Firefox, the\n    // selection isn't properly collapsed. (2017/10/17)\n    if (Hotkeys.isMoveLineBackward(event)) {\n      event.preventDefault();\n      return editor.moveToStartOfBlock();\n    }\n\n    if (Hotkeys.isMoveLineForward(event)) {\n      event.preventDefault();\n      return editor.moveToEndOfBlock();\n    }\n\n    if (Hotkeys.isExtendLineBackward(event)) {\n      event.preventDefault();\n      return editor.moveFocusToStartOfBlock();\n    }\n\n    if (Hotkeys.isExtendLineForward(event)) {\n      event.preventDefault();\n      return editor.moveFocusToEndOfBlock();\n    }\n\n    // COMPAT: If a void node is selected, or a zero-width text node adjacent to\n    // an inline is selected, we need to handle these hotkeys manually because\n    // browsers won't know what to do.\n    if (Hotkeys.isMoveBackward(event)) {\n      event.preventDefault();\n\n      if (!selection.isCollapsed) {\n        return editor.moveToStart();\n      }\n\n      return editor.moveBackward();\n    }\n\n    if (Hotkeys.isMoveForward(event)) {\n      event.preventDefault();\n\n      if (!selection.isCollapsed) {\n        return editor.moveToEnd();\n      }\n\n      return editor.moveForward();\n    }\n\n    if (Hotkeys.isMoveWordBackward(event)) {\n      event.preventDefault();\n      return editor.moveWordBackward();\n    }\n\n    if (Hotkeys.isMoveWordForward(event)) {\n      event.preventDefault();\n      return editor.moveWordForward();\n    }\n\n    if (Hotkeys.isExtendBackward(event)) {\n      var startText = document.getNode(start.path);\n\n      var _document$texts3 = document.texts({\n        path: start.path,\n        direction: 'backward'\n      }),\n          _document$texts4 = slicedToArray(_document$texts3, 1),\n          prevEntry = _document$texts4[0];\n\n      var isPrevInVoid = false;\n\n      if (prevEntry) {\n        var _prevEntry = slicedToArray(prevEntry, 2),\n            prevPath = _prevEntry[1];\n\n        isPrevInVoid = document.hasVoidParent(prevPath, editor);\n      }\n\n      if (hasVoidParent || isPrevInVoid || startText.text === '') {\n        event.preventDefault();\n        return editor.moveFocusBackward();\n      }\n    }\n\n    if (Hotkeys.isExtendForward(event)) {\n      var _startText = document.getNode(start.path);\n\n      var _document$texts5 = document.texts({ path: start.path }),\n          _document$texts6 = slicedToArray(_document$texts5, 1),\n          nextEntry = _document$texts6[0];\n\n      var isNextInVoid = false;\n\n      if (nextEntry) {\n        var _nextEntry = slicedToArray(nextEntry, 2),\n            nextPath = _nextEntry[1];\n\n        isNextInVoid = document.hasVoidParent(nextPath, editor);\n      }\n\n      if (hasVoidParent || isNextInVoid || _startText.text === '') {\n        event.preventDefault();\n        return editor.moveFocusForward();\n      }\n    }\n\n    next();\n  }\n\n  /**\n   * On mouse down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onMouseDown(event, editor, next) {\n    debug$4('onMouseDown', { event: event });\n    isMouseDown = true;\n    next();\n  }\n\n  /**\n   * On mouse up.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onMouseUp(event, editor, next) {\n    debug$4('onMouseUp', { event: event });\n    isMouseDown = false;\n    next();\n  }\n\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onPaste(event, editor, next) {\n    debug$4('onPaste', { event: event });\n\n    var value = editor.value;\n\n    var transfer = getEventTransfer(event);\n    var type = transfer.type,\n        fragment = transfer.fragment,\n        text = transfer.text;\n\n\n    if (type === 'fragment') {\n      editor.insertFragment(fragment);\n    }\n\n    if (type === 'text' || type === 'html') {\n      if (!text) return next();\n      var document = value.document,\n          selection = value.selection,\n          startBlock = value.startBlock;\n\n      if (editor.isVoid(startBlock)) return next();\n\n      var defaultBlock = startBlock;\n      var defaultMarks = document.getInsertMarksAtRange(selection);\n      var frag = Plain.deserialize(text, { defaultBlock: defaultBlock, defaultMarks: defaultMarks }).document;\n      editor.insertFragment(frag);\n    }\n\n    next();\n  }\n\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onSelect(event, editor, next) {\n    debug$4('onSelect', { event: event });\n    var window = getWindow(event.target);\n    var domSelection = window.getSelection();\n    var selection = editor.findSelection(domSelection);\n\n    if (selection) {\n      editor.select(selection);\n    } else {\n      editor.blur();\n    }\n\n    // COMPAT: reset the `isMouseDown` state here in case a `mouseup` event\n    // happens outside the editor. This is needed for `onFocus` handling.\n    isMouseDown = false;\n\n    next();\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onBeforeInput: onBeforeInput,\n    onBlur: onBlur,\n    onClick: onClick,\n    onCopy: onCopy,\n    onCut: onCut,\n    onDragEnd: onDragEnd,\n    onDragStart: onDragStart,\n    onDrop: onDrop,\n    onFocus: onFocus,\n    onInput: onInput,\n    onKeyDown: onKeyDown,\n    onMouseDown: onMouseDown,\n    onMouseUp: onMouseUp,\n    onPaste: onPaste,\n    onSelect: onSelect\n  };\n}\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug$5 = Debug('slate:before');\n\n/**\n * A plugin that adds the \"before\" browser-specific logic to the editor.\n *\n * @return {Object}\n */\n\nfunction BeforePlugin() {\n  var activeElement = null;\n  var compositionCount = 0;\n  var isComposing = false;\n  var isCopying = false;\n  var isDragging = false;\n  var isUserActionPerformed = false;\n\n  /**\n   * On before input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBeforeInput(event, editor, next) {\n    var isSynthetic = !!event.nativeEvent;\n    if (editor.readOnly) return;\n    isUserActionPerformed = true;\n\n    // COMPAT: If the browser supports Input Events Level 2, we will have\n    // attached a custom handler for the real `beforeinput` events, instead of\n    // allowing React's synthetic polyfill, so we need to ignore synthetics.\n    if (isSynthetic && slateDevEnvironment.HAS_INPUT_EVENTS_LEVEL_2) return;\n\n    debug$5('onBeforeInput', { event: event });\n    next();\n  }\n\n  /**\n   * On blur.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onBlur(event, editor, next) {\n    if (isCopying) return;\n    if (editor.readOnly) return;\n\n    var relatedTarget = event.relatedTarget,\n        target = event.target;\n\n    var window = getWindow(target);\n\n    // COMPAT: If the current `activeElement` is still the previous one, this is\n    // due to the window being blurred when the tab itself becomes unfocused, so\n    // we want to abort early to allow to editor to stay focused when the tab\n    // becomes focused again.\n    if (activeElement === window.document.activeElement) return;\n\n    // COMPAT: The `relatedTarget` can be null when the new focus target is not\n    // a \"focusable\" element (eg. a `<div>` without `tabindex` set).\n    if (relatedTarget) {\n      var el = editor.findDOMNode([]);\n\n      // COMPAT: The event should be ignored if the focus is returning to the\n      // editor from an embedded editable element (eg. an <input> element inside\n      // a void node).\n      if (relatedTarget === el) return;\n\n      // COMPAT: The event should be ignored if the focus is moving from the\n      // editor to inside a void node's spacer element.\n      if (relatedTarget.hasAttribute(DATA_ATTRS.SPACER)) return;\n\n      // COMPAT: The event should be ignored if the focus is moving to a non-\n      // editable section of an element that isn't a void node (eg. a list item\n      // of the check list example).\n      var node = editor.findNode(relatedTarget);\n\n      if (el.contains(relatedTarget) && node && !editor.isVoid(node)) {\n        return;\n      }\n    }\n\n    debug$5('onBlur', { event: event });\n    next();\n  }\n\n  /**\n   * On composition end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCompositionEnd(event, editor, next) {\n    var n = compositionCount;\n    isUserActionPerformed = true;\n\n    // The `count` check here ensures that if another composition starts\n    // before the timeout has closed out this one, we will abort unsetting the\n    // `isComposing` flag, since a composition is still in affect.\n    window.requestAnimationFrame(function () {\n      if (compositionCount > n) return;\n      isComposing = false;\n    });\n\n    debug$5('onCompositionEnd', { event: event });\n    next();\n  }\n\n  /**\n   * On click.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onClick(event, editor, next) {\n    debug$5('onClick', { event: event });\n    isUserActionPerformed = true;\n    next();\n  }\n\n  /**\n   * On composition start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCompositionStart(event, editor, next) {\n    isComposing = true;\n    compositionCount++;\n\n    var value = editor.value;\n    var selection = value.selection;\n\n    isUserActionPerformed = true;\n\n    if (!selection.isCollapsed) {\n      // https://github.com/ianstormtaylor/slate/issues/1879\n      // When composition starts and the current selection is not collapsed, the\n      // second composition key-down would drop the text wrapping <spans> which\n      // resulted on crash in content.updateSelection after composition ends\n      // (because it cannot find <span> nodes in DOM). This is a workaround that\n      // erases selection as soon as composition starts and preventing <spans>\n      // to be dropped.\n      editor.delete();\n    }\n\n    debug$5('onCompositionStart', { event: event });\n    next();\n  }\n\n  /**\n   * On copy.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCopy(event, editor, next) {\n    var window = getWindow(event.target);\n    isCopying = true;\n    window.requestAnimationFrame(function () {\n      return isCopying = false;\n    });\n\n    debug$5('onCopy', { event: event });\n    next();\n  }\n\n  /**\n   * On cut.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onCut(event, editor, next) {\n    if (editor.readOnly) return;\n\n    var window = getWindow(event.target);\n    isCopying = true;\n    window.requestAnimationFrame(function () {\n      return isCopying = false;\n    });\n\n    debug$5('onCut', { event: event });\n    next();\n  }\n\n  /**\n   * On drag end.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragEnd(event, editor, next) {\n    isDragging = false;\n    debug$5('onDragEnd', { event: event });\n    next();\n  }\n\n  /**\n   * On drag enter.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragEnter(event, editor, next) {\n    debug$5('onDragEnter', { event: event });\n    next();\n  }\n\n  /**\n   * On drag exit.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragExit(event, editor, next) {\n    debug$5('onDragExit', { event: event });\n    next();\n  }\n\n  /**\n   * On drag leave.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragLeave(event, editor, next) {\n    debug$5('onDragLeave', { event: event });\n    next();\n  }\n\n  /**\n   * On drag over.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragOver(event, editor, next) {\n    // If the target is inside a void node, and only in this case,\n    // call `preventDefault` to signal that drops are allowed.\n    // When the target is editable, dropping is already allowed by\n    // default, and calling `preventDefault` hides the cursor.\n    var node = editor.findNode(event.target);\n\n    if (!node || editor.isVoid(node)) {\n      event.preventDefault();\n    }\n\n    // COMPAT: IE won't call onDrop on contentEditables unless the\n    // default dragOver is prevented:\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/913982/\n    // (2018/07/11)\n    if (slateDevEnvironment.IS_IE) {\n      event.preventDefault();\n    }\n\n    // If a drag is already in progress, don't do this again.\n    if (!isDragging) {\n      isDragging = true;\n\n      // COMPAT: IE will raise an `unspecified error` if dropEffect is\n      // set. (2018/07/11)\n      if (!slateDevEnvironment.IS_IE) {\n        event.nativeEvent.dataTransfer.dropEffect = 'move';\n      }\n    }\n\n    debug$5('onDragOver', { event: event });\n    next();\n  }\n\n  /**\n   * On drag start.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDragStart(event, editor, next) {\n    isDragging = true;\n    debug$5('onDragStart', { event: event });\n    next();\n  }\n\n  /**\n   * On drop.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onDrop(event, editor, next) {\n    if (editor.readOnly) return;\n    isUserActionPerformed = true;\n\n    // Prevent default so the DOM's value isn't corrupted.\n    event.preventDefault();\n\n    debug$5('onDrop', { event: event });\n    next();\n  }\n\n  /**\n   * On focus.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onFocus(event, editor, next) {\n    if (isCopying) return;\n    if (editor.readOnly) return;\n\n    var el = editor.findDOMNode([]);\n\n    // Save the new `activeElement`.\n    var window = getWindow(event.target);\n    activeElement = window.document.activeElement;\n\n    // COMPAT: If the editor has nested editable elements, the focus can go to\n    // those elements. In Firefox, this must be prevented because it results in\n    // issues with keyboard navigation. (2017/03/30)\n    if (slateDevEnvironment.IS_FIREFOX && event.target !== el) {\n      el.focus();\n      return;\n    }\n\n    debug$5('onFocus', { event: event });\n    next();\n  }\n\n  /**\n   * On input.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onInput(event, editor, next) {\n    if (isComposing) return;\n    if (editor.value.selection.isBlurred) return;\n    isUserActionPerformed = true;\n    debug$5('onInput', { event: event });\n    next();\n  }\n\n  /**\n   * On key down.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onKeyDown(event, editor, next) {\n    if (editor.readOnly) return;\n\n    // When composing, we need to prevent all hotkeys from executing while\n    // typing. However, certain characters also move the selection before\n    // we're able to handle it, so prevent their default behavior.\n    if (isComposing) {\n      if (Hotkeys.isCompose(event)) event.preventDefault();\n      return;\n    }\n\n    // Certain hotkeys have native editing behaviors in `contenteditable`\n    // elements which will editor the DOM and cause our value to be out of sync,\n    // so they need to always be prevented.\n    if (!slateDevEnvironment.IS_IOS && (Hotkeys.isBold(event) || Hotkeys.isDeleteBackward(event) || Hotkeys.isDeleteForward(event) || Hotkeys.isDeleteLineBackward(event) || Hotkeys.isDeleteLineForward(event) || Hotkeys.isDeleteWordBackward(event) || Hotkeys.isDeleteWordForward(event) || Hotkeys.isItalic(event) || Hotkeys.isRedo(event) || Hotkeys.isSplitBlock(event) || Hotkeys.isTransposeCharacter(event) || Hotkeys.isUndo(event))) {\n      event.preventDefault();\n    }\n\n    isUserActionPerformed = true;\n    debug$5('onKeyDown', { event: event });\n    next();\n  }\n\n  /**\n   * On paste.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onPaste(event, editor, next) {\n    if (editor.readOnly) return;\n    isUserActionPerformed = true;\n\n    // Prevent defaults so the DOM state isn't corrupted.\n    event.preventDefault();\n\n    debug$5('onPaste', { event: event });\n    next();\n  }\n\n  /**\n   * On select.\n   *\n   * @param {Event} event\n   * @param {Editor} editor\n   * @param {Function} next\n   */\n\n  function onSelect(event, editor, next) {\n    if (isCopying) return;\n    if (isComposing) return;\n\n    if (editor.readOnly) return;\n\n    // Save the new `activeElement`.\n    var window = getWindow(event.target);\n    activeElement = window.document.activeElement;\n    isUserActionPerformed = true;\n\n    debug$5('onSelect', { event: event });\n    next();\n  }\n\n  function userActionPerformed() {\n    return isUserActionPerformed;\n  }\n\n  function clearUserActionPerformed() {\n    isUserActionPerformed = false;\n    return null;\n  }\n\n  /**\n   * Return the plugin.\n   *\n   * @type {Object}\n   */\n\n  return {\n    onBeforeInput: onBeforeInput,\n    onBlur: onBlur,\n    onClick: onClick,\n    onCompositionEnd: onCompositionEnd,\n    onCompositionStart: onCompositionStart,\n    onCopy: onCopy,\n    onCut: onCut,\n    onDragEnd: onDragEnd,\n    onDragEnter: onDragEnter,\n    onDragExit: onDragExit,\n    onDragLeave: onDragLeave,\n    onDragOver: onDragOver,\n    onDragStart: onDragStart,\n    onDrop: onDrop,\n    onFocus: onFocus,\n    onInput: onInput,\n    onKeyDown: onKeyDown,\n    onPaste: onPaste,\n    onSelect: onSelect,\n    queries: { userActionPerformed: userActionPerformed },\n    commands: { clearUserActionPerformed: clearUserActionPerformed }\n  };\n}\n\n/**\n * A plugin that adds the browser-specific logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction DOMPlugin() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _options$plugins = options.plugins,\n      plugins = _options$plugins === undefined ? [] : _options$plugins;\n\n  var beforePlugin = BeforePlugin();\n  var afterPlugin = AfterPlugin();\n\n  // COMPAT: Add Android specific handling separately before it gets to the\n  // other plugins because it is specific (other browser don't need it) and\n  // finicky (it has to come before other plugins to work).\n  var androidPlugins = slateDevEnvironment.IS_ANDROID ? [AndroidPlugin(options), NoopPlugin(options)] : [];\n\n  return [].concat(androidPlugins, [beforePlugin], toConsumableArray(plugins), [afterPlugin]);\n}\n\nfunction RestoreDOMPlugin() {\n  /**\n   * Makes sure that on the next Content `render` the DOM is restored.\n   * This gets us around issues where the DOM is in a different state than\n   * React's virtual DOM and would crash.\n   *\n   * @param {Editor} editor\n   */\n\n  function restoreDOM(editor) {\n    var tmp = editor.tmp.contentRef.current.tmp;\n    tmp.contentKey = tmp.contentKey + 1;\n  }\n\n  return {\n    commands: {\n      restoreDOM: restoreDOM\n    }\n  };\n}\n\n/**\n * Takes a React Synthetic Event or a DOM Event and turns it into a String that\n * is easy to log. It's succinct and keeps info to a bare minimum.\n *\n * @param {Event} event\n */\n\nfunction stringifyEvent(event) {\n  var e = event.nativeEvent || event;\n\n  switch (e.type) {\n    case 'keydown':\n      return e.type + ' ' + JSON.stringify(e.key);\n    case 'input':\n    case 'beforeinput':\n    case 'textInput':\n      return e.type + ':' + e.inputType + ' ' + JSON.stringify(e.data);\n    default:\n      return e.type;\n  }\n}\n\n/**\n * Debug events function.\n *\n * @type {Function}\n */\n\nvar debug$6 = Debug('slate:events');\n\n/**\n * A plugin that sends short easy to digest debug info about each event to\n * browser.\n *\n * @return {Object}\n */\n\nfunction DebugEventsPlugin() {\n  /**\n   * Plugin Object\n   *\n   * @type {Object}\n   */\n\n  var plugin = {};\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = EVENT_HANDLERS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var eventName = _step.value;\n\n      plugin[eventName] = function (event, editor, next) {\n        var s = stringifyEvent(event);\n        debug$6(s);\n        next();\n      };\n    }\n\n    /**\n     * Return the plugin.\n     *\n     * @type {Object}\n     */\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return plugin;\n}\n\n/**\n * Constants\n */\n\nvar INTERVAL = 2000;\n\n/**\n * Debug events function.\n *\n * @type {Function}\n */\n\nvar debug$7 = Debug('slate:batch-events');\n\n/**\n * A plugin that sends short easy to digest debug info about each event to\n * browser.\n *\n * @return {Object}\n */\n\nfunction DebugBatchEventsPlugin() {\n  /**\n   * When the batch started\n   *\n   * @type {Date}\n   */\n\n  var startDate = null;\n\n  /**\n   * The timeoutId used to cancel the timeout\n   *\n   * @type {Any}\n   */\n\n  var timeoutId = null;\n\n  /**\n   * An array of events not yet dumped with `debug`\n   *\n   * @type {Array}\n   */\n\n  var events = [];\n\n  /**\n   * Send all events to debug\n   *\n   * Note: Formatted so it can easily be cut and pasted as text for analysis or\n   * documentation.\n   */\n\n  function dumpEvents() {\n    debug$7('\\n' + events.join('\\n'));\n    events.length = 0;\n  }\n\n  /**\n   * Push an event on to the Array of events for debugging in a batch\n   *\n   * @param {Event} event\n   */\n\n  function pushEvent(event) {\n    if (events.length === 0) {\n      startDate = new Date();\n    }\n\n    var s = stringifyEvent(event);\n    var now = new Date();\n    events.push('- ' + (now - startDate) + ' - ' + s);\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(dumpEvents, INTERVAL);\n  }\n\n  /**\n   * Plugin Object\n   *\n   * @type {Object}\n   */\n\n  var plugin = {};\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = EVENT_HANDLERS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var eventName = _step.value;\n\n      plugin[eventName] = function (event, editor, next) {\n        pushEvent(event);\n        next();\n      };\n    }\n\n    /**\n     * Return the plugin.\n     *\n     * @type {Object}\n     */\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return plugin;\n}\n\n/**\n * Debug mutations function.\n *\n * @type {Function}\n */\n\nvar debug$8 = Debug('slate:mutations');\n\n/**\n * Properties on a MutationRecord\n *\n * @type {Object}\n */\n\nvar MUTATION_PROPERTIES = ['type', 'oldValue', 'target', 'addedNodes', 'removedNodes', 'attributeName', 'attributeNamespace', 'nextSibling', 'previousSibling'];\n\n/**\n * Takes a DOM node and returns an easily readable version of it.\n *\n * @param {DOMNode} node\n */\n\nfunction normalizeNode(node) {\n  if (node.nodeType === window.Node.TEXT_NODE) {\n    return node.textContent;\n  } else if (node.nodeType === window.Node.ELEMENT_NODE) {\n    var outerHTML = node.outerHTML,\n        innerHTML = node.innerHTML;\n\n    if (outerHTML == null) return JSON.stringify(node.textContent);\n    return outerHTML.slice(0, outerHTML.indexOf(innerHTML));\n  } else {\n    return 'Node(type=' + node.nodeType;\n  }\n}\n\n/**\n * A plugin that sends short easy to digest debug info about each dom mutation\n * to browser.\n *\n * More information about mutations here:\n *\n * <https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver>\n * <https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord>\n *\n * @param {Object} options\n */\n\nfunction DebugMutationsPlugin() {\n  var observer = new window.MutationObserver(function (mutations) {\n    var array = Array.from(mutations).map(function (mutationRecord) {\n      var object = {};\n\n      // Only add properties that provide meaningful values to the object\n      // to make the debug info easier to read\n      MUTATION_PROPERTIES.forEach(function (key) {\n        var value = mutationRecord[key];\n        if (value == null) return;\n\n        // Make NodeList easier to read\n        if (value instanceof window.NodeList) {\n          if (value.length === 0) return;\n\n          object[key] = Array.from(value).map(normalizeNode).join(', ');\n          return;\n        }\n\n        // Make Node easier to read\n        if (value instanceof window.Node) {\n          value = normalizeNode(value);\n        }\n\n        object[key] = value;\n      });\n\n      return object;\n    });\n\n    // The first argument must not be the array as `debug` renders the first\n    // argument in a different way than the rest\n    debug$8.apply(undefined, [array.length + ' Mutations'].concat(toConsumableArray(array)));\n  });\n\n  /**\n   * The previously observed DOM node\n   *\n   * @type {DOMNode}\n   */\n\n  var prevRootEl = null;\n\n  /**\n   * Start observing the DOM node for mutations if it isn't being observed\n   */\n\n  function start(event, editor, next) {\n    var rootEl = editor.findDOMNode([]);\n\n    if (rootEl === prevRootEl) return next();\n\n    debug$8('start');\n\n    observer.observe(rootEl, {\n      childList: true,\n      characterData: true,\n      attributes: true,\n      subtree: true,\n      characterDataOldValue: true\n    });\n\n    prevRootEl = rootEl;\n\n    next();\n  }\n\n  /**\n   * Stop observing the DOM node for mutations\n   */\n\n  function stop(event, editor, next) {\n    debug$8('stop');\n\n    observer.disconnect();\n    prevRootEl = null;\n    next();\n  }\n\n  return {\n    onComponentDidMount: start,\n    onComponentDidUpdate: start,\n    onComponentWillUnmount: stop\n  };\n}\n\n/**\n * A plugin that adds the React-specific rendering logic to the editor.\n *\n * @param {Object} options\n * @return {Object}\n */\n\nfunction ReactPlugin() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var _options$placeholder = options.placeholder,\n      placeholder = _options$placeholder === undefined ? '' : _options$placeholder;\n\n  var debugEventsPlugin = Debug.enabled('slate:events') ? DebugEventsPlugin(options) : null;\n  var debugBatchEventsPlugin = Debug.enabled('slate:batch-events') ? DebugBatchEventsPlugin(options) : null;\n  var debugMutationsPlugin = Debug.enabled('slate:mutations') ? DebugMutationsPlugin(options) : null;\n  var renderingPlugin = Rendering(options);\n  var commandsPlugin = CommandsPlugin(options);\n  var queriesPlugin = QueriesPlugin(options);\n  var editorPropsPlugin = EditorPropsPlugin(options);\n  var domPlugin = DOMPlugin(options);\n  var restoreDomPlugin = RestoreDOMPlugin();\n\n  // Disable placeholder for Android because it messes with reconciliation\n  // and doesn't disappear until composition is complete.\n  // e.g. In empty, type \"h\" and autocomplete on Android 9 and deletes all text.\n  var placeholderPlugin = slateDevEnvironment.IS_ANDROID ? null : PlaceholderPlugin({\n    placeholder: placeholder,\n    when: function when(editor, node) {\n      return node.object === 'document' && node.text === '' && node.nodes.size === 1 && Array.from(node.texts()).length === 1;\n    }\n  });\n\n  return [debugEventsPlugin, debugBatchEventsPlugin, debugMutationsPlugin, editorPropsPlugin, domPlugin, restoreDomPlugin, placeholderPlugin, renderingPlugin, commandsPlugin, queriesPlugin];\n}\n\n/**\n * Debug.\n *\n * @type {Function}\n */\n\nvar debug$9 = Debug('slate:editor');\n\n/**\n * Editor.\n *\n * @type {Component}\n */\n\nvar Editor = function (_React$Component) {\n  inherits(Editor, _React$Component);\n\n  function Editor() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    classCallCheck(this, Editor);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Editor.__proto__ || Object.getPrototypeOf(Editor)).call.apply(_ref, [this].concat(args))), _this), _this.state = { value: _this.props.defaultValue, contentKey: 0\n\n      /**\n       * Temporary values.\n       *\n       * @type {Object}\n       */\n\n    }, _this.tmp = {\n      mounted: false,\n      change: null,\n      resolves: 0,\n      updates: 0,\n      contentRef: React.createRef()\n\n      /**\n       * When the component first mounts, flush a queued change if one exists.\n       */\n\n    }, _this.resolveController = memoizeOne(function () {\n      var TheReactPlugin = arguments[5];\n\n      // If we've resolved a few times already, and it's exactly in line with\n      // the updates, then warn the user that they may be doing something wrong.\n      warning(_this.tmp.resolves < 5 || _this.tmp.resolves !== _this.tmp.updates, 'A Slate <Editor> component is re-resolving the `plugins`, `schema`, `commands`, `queries` or `placeholder` prop on each update, which leads to poor performance. This is often due to passing in a new references for these props with each render by declaring them inline in your render function. Do not do this! Declare them outside your render function, or memoize them instead.');\n\n      _this.tmp.resolves++;\n      var react = TheReactPlugin(_extends({}, _this.props, {\n        editor: _this,\n        value: _this.props.value || _this.state.value\n      }));\n\n      var onChange = function onChange(change) {\n        if (_this.tmp.mounted) {\n          _this.handleChange(change);\n        } else {\n          _this.tmp.change = change;\n        }\n      };\n\n      _this.controller = new slate.Editor({ plugins: [react], onChange: onChange }, { controller: _this, construct: false });\n\n      _this.controller.run('onConstruct');\n    }), _temp), possibleConstructorReturn(_this, _ret);\n  }\n  /**\n   * Property types.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Default properties.\n   *\n   * @type {Object}\n   */\n\n  /**\n   * Initial state.\n   *\n   * @type {Object}\n   */\n\n  createClass(Editor, [{\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      this.tmp.mounted = true;\n      this.tmp.updates++;\n\n      if (this.props.autoFocus) {\n        this.focus();\n      }\n\n      if (this.tmp.change) {\n        this.handleChange(this.tmp.change);\n        this.tmp.change = null;\n      }\n    }\n\n    /**\n     * When the component updates, flush a queued change if one exists.\n     */\n\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate() {\n      this.tmp.updates++;\n\n      if (this.tmp.change) {\n        this.handleChange(this.tmp.change);\n        this.tmp.change = null;\n      }\n    }\n\n    /**\n     * When the component unmounts, make sure async commands don't trigger react updates.\n     */\n\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      this.tmp.mounted = false;\n    }\n\n    /**\n     * Render the editor.\n     *\n     * @return {Element}\n     */\n\n  }, {\n    key: 'render',\n    value: function render() {\n      var _this2 = this;\n\n      debug$9('render', this);\n\n      // Re-resolve the controller if needed based on memoized props.\n      var _props = this.props,\n          commands = _props.commands,\n          placeholder = _props.placeholder,\n          plugins = _props.plugins,\n          queries = _props.queries,\n          schema = _props.schema;\n\n\n      this.resolveController(plugins, schema, commands, queries, placeholder, ReactPlugin);\n\n      // Set the current props on the controller.\n      var _props2 = this.props,\n          options = _props2.options,\n          readOnly = _props2.readOnly,\n          valueFromProps = _props2.value;\n      var valueFromState = this.state.value;\n\n      var value = valueFromProps || valueFromState;\n      var contentKey = this.state.contentKey;\n\n      this.controller.setReadOnly(readOnly);\n      this.controller.setValue(value, options);\n\n      var _props3 = this.props,\n          autoCorrect = _props3.autoCorrect,\n          className = _props3.className,\n          id = _props3.id,\n          role = _props3.role,\n          spellCheck = _props3.spellCheck,\n          tabIndex = _props3.tabIndex,\n          style = _props3.style,\n          tagName = _props3.tagName;\n\n\n      var domProps = omit(this.props, Object.keys(Editor.propTypes));\n\n      var children = React.createElement(Content, _extends({}, domProps, {\n        ref: this.tmp.contentRef,\n        autoCorrect: autoCorrect,\n        className: className,\n        contentKey: contentKey,\n        editor: this,\n        id: id,\n        onEvent: function onEvent(handler, event) {\n          return _this2.run(handler, event);\n        },\n        readOnly: readOnly,\n        role: role,\n        spellCheck: spellCheck,\n        style: style,\n        tabIndex: tabIndex,\n        tagName: tagName\n      }));\n\n      // Render the editor's children with the controller.\n      var element = this.controller.run('renderEditor', _extends({}, this.props, {\n        editor: this,\n        children: children\n      }));\n\n      return element;\n    }\n\n    /**\n     * Resolve an editor controller from the passed-in props. This method takes\n     * all of the props as individual arguments to be able to properly memoize\n     * against anything that could change and invalidate the old editor.\n     *\n     * @param {Array} plugins\n     * @param {Object} schema\n     * @param {Object} commands\n     * @param {Object} queries\n     * @param {String} placeholder\n     * @return {Editor}\n     */\n\n  }, {\n    key: 'handleChange',\n    value: function handleChange(change) {\n      var onChange = this.props.onChange;\n      var value = this.state.value;\n\n\n      if (value) {\n        // Syncing value inside this component since parent does not want control of it (defaultValue was used)\n        this.setState({ value: change.value });\n      }\n\n      onChange(change);\n    }\n\n    /**\n     * Mimic the API of the `Editor` controller, so that this component instance\n     * can be passed in its place to plugins.\n     */\n\n  }, {\n    key: 'applyOperation',\n    value: function applyOperation() {\n      var _controller;\n\n      return (_controller = this.controller).applyOperation.apply(_controller, arguments);\n    }\n  }, {\n    key: 'command',\n    value: function command() {\n      var _controller2;\n\n      return (_controller2 = this.controller).command.apply(_controller2, arguments);\n    }\n  }, {\n    key: 'hasCommand',\n    value: function hasCommand() {\n      var _controller3;\n\n      return (_controller3 = this.controller).hasCommand.apply(_controller3, arguments);\n    }\n  }, {\n    key: 'hasQuery',\n    value: function hasQuery() {\n      var _controller4;\n\n      return (_controller4 = this.controller).hasQuery.apply(_controller4, arguments);\n    }\n  }, {\n    key: 'normalize',\n    value: function normalize() {\n      var _controller5;\n\n      return (_controller5 = this.controller).normalize.apply(_controller5, arguments);\n    }\n  }, {\n    key: 'query',\n    value: function query() {\n      var _controller6;\n\n      return (_controller6 = this.controller).query.apply(_controller6, arguments);\n    }\n  }, {\n    key: 'registerCommand',\n    value: function registerCommand() {\n      var _controller7;\n\n      return (_controller7 = this.controller).registerCommand.apply(_controller7, arguments);\n    }\n  }, {\n    key: 'registerQuery',\n    value: function registerQuery() {\n      var _controller8;\n\n      return (_controller8 = this.controller).registerQuery.apply(_controller8, arguments);\n    }\n  }, {\n    key: 'run',\n    value: function run() {\n      var _controller9;\n\n      return (_controller9 = this.controller).run.apply(_controller9, arguments);\n    }\n  }, {\n    key: 'withoutNormalizing',\n    value: function withoutNormalizing() {\n      var _controller10;\n\n      return (_controller10 = this.controller).withoutNormalizing.apply(_controller10, arguments);\n    }\n\n    /**\n     * Deprecated.\n     */\n\n  }, {\n    key: 'call',\n    value: function call() {\n      var _controller11;\n\n      return (_controller11 = this.controller).call.apply(_controller11, arguments);\n    }\n  }, {\n    key: 'change',\n    value: function change() {\n      var _controller12;\n\n      return (_controller12 = this.controller).change.apply(_controller12, arguments);\n    }\n  }, {\n    key: 'onChange',\n    value: function onChange() {\n      var _controller13;\n\n      return (_controller13 = this.controller).onChange.apply(_controller13, arguments);\n    }\n  }, {\n    key: 'applyOperations',\n    value: function applyOperations() {\n      var _controller14;\n\n      return (_controller14 = this.controller).applyOperations.apply(_controller14, arguments);\n    }\n  }, {\n    key: 'setOperationFlag',\n    value: function setOperationFlag() {\n      var _controller15;\n\n      return (_controller15 = this.controller).setOperationFlag.apply(_controller15, arguments);\n    }\n  }, {\n    key: 'getFlag',\n    value: function getFlag() {\n      var _controller16;\n\n      return (_controller16 = this.controller).getFlag.apply(_controller16, arguments);\n    }\n  }, {\n    key: 'unsetOperationFlag',\n    value: function unsetOperationFlag() {\n      var _controller17;\n\n      return (_controller17 = this.controller).unsetOperationFlag.apply(_controller17, arguments);\n    }\n  }, {\n    key: 'withoutNormalization',\n    value: function withoutNormalization() {\n      var _controller18;\n\n      return (_controller18 = this.controller).withoutNormalization.apply(_controller18, arguments);\n    }\n  }, {\n    key: 'operations',\n    get: function get$$1() {\n      return this.controller.operations;\n    }\n  }, {\n    key: 'readOnly',\n    get: function get$$1() {\n      return this.controller.readOnly;\n    }\n  }, {\n    key: 'value',\n    get: function get$$1() {\n      return this.controller.value;\n    }\n  }, {\n    key: 'editor',\n    get: function get$$1() {\n      return this.controller.editor;\n    }\n  }, {\n    key: 'schema',\n    get: function get$$1() {\n      invariant(false, 'As of Slate 0.42, the `editor.schema` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.');\n    }\n  }, {\n    key: 'stack',\n    get: function get$$1() {\n      invariant(false, 'As of Slate 0.42, the `editor.stack` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.');\n    }\n  }]);\n  return Editor;\n}(React.Component);\n\n/**\n * Export.\n *\n * @type {Component}\n */\n\nEditor.propTypes = _extends({\n  autoCorrect: Types.bool,\n  autoFocus: Types.bool,\n  className: Types.string,\n  defaultValue: SlateTypes.value,\n  id: Types.string,\n  onChange: Types.func,\n  options: Types.object,\n  placeholder: Types.any,\n  plugins: Types.array,\n  readOnly: Types.bool,\n  role: Types.string,\n  schema: Types.object,\n  spellCheck: Types.bool,\n  style: Types.object,\n  tabIndex: Types.number,\n  value: SlateTypes.value\n}, EVENT_HANDLERS.reduce(function (obj, handler) {\n  obj[handler] = Types.func;\n  return obj;\n}, {}), OTHER_HANDLERS.reduce(function (obj, handler) {\n  obj[handler] = Types.func;\n  return obj;\n}, {}));\nEditor.defaultProps = {\n  autoFocus: false,\n  autoCorrect: true,\n  onChange: function onChange() {},\n  options: {},\n  placeholder: '',\n  plugins: [],\n  readOnly: false,\n  schema: {},\n  spellCheck: true };\n\n/**\n * Find the DOM node for a `key`.\n *\n * @param {String|Node} key\n * @param {Window} win (optional)\n * @return {Element}\n */\n\nfunction findDOMNode(key) {\n  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n\n  warning(false, 'As of slate-react@0.22 the `findDOMNode(key)` helper is deprecated in favor of `editor.findDOMNode(path)`.');\n\n  if (slate.Node.isNode(key)) {\n    key = key.key;\n  }\n\n  var el = win.document.querySelector('[' + DATA_ATTRS.KEY + '=\"' + key + '\"]');\n\n  if (!el) {\n    throw new Error('Unable to find a DOM node for \"' + key + '\". This is often because of forgetting to add `props.attributes` to a custom component.');\n  }\n\n  return el;\n}\n\n/**\n * Find a native DOM selection point from a Slate `point`.\n *\n * @param {Point} point\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\nfunction findDOMPoint(point) {\n  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n\n  warning(false, 'As of slate-react@0.22 the `findDOMPoint(point)` helper is deprecated in favor of `editor.findDOMPoint(point)`.');\n\n  var el = findDOMNode(point.key, win);\n  var start = 0;\n\n  // For each leaf, we need to isolate its content, which means filtering to its\n  // direct text and zero-width spans. (We have to filter out any other siblings\n  // that may have been rendered alongside them.)\n  var texts = Array.from(el.querySelectorAll(SELECTORS.STRING + ', ' + SELECTORS.ZERO_WIDTH));\n\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = texts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var text = _step.value;\n\n      var node = text.childNodes[0];\n      var domLength = node.textContent.length;\n      var slateLength = domLength;\n\n      if (text.hasAttribute(DATA_ATTRS.LENGTH)) {\n        slateLength = parseInt(text.getAttribute(DATA_ATTRS.LENGTH), 10);\n      }\n\n      var end = start + slateLength;\n\n      if (point.offset <= end) {\n        var offset = Math.min(domLength, Math.max(0, point.offset - start));\n        return { node: node, offset: offset };\n      }\n\n      start = end;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return null;\n}\n\n/**\n * Find a native DOM range Slate `range`.\n *\n * @param {Range} range\n * @param {Window} win (optional)\n * @return {Object|Null}\n */\n\nfunction findDOMRange(range) {\n  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\n\n  warning(false, 'As of slate-react@0.22 the `findDOMRange(range)` helper is deprecated in favor of `editor.findDOMRange(range)`.');\n\n  var anchor = range.anchor,\n      focus = range.focus,\n      isBackward$$1 = range.isBackward,\n      isCollapsed = range.isCollapsed;\n\n  var domAnchor = findDOMPoint(anchor, win);\n  var domFocus = isCollapsed ? domAnchor : findDOMPoint(focus, win);\n\n  if (!domAnchor || !domFocus) return null;\n\n  var r = win.document.createRange();\n  var start = isBackward$$1 ? domFocus : domAnchor;\n  var end = isBackward$$1 ? domAnchor : domFocus;\n  r.setStart(start.node, start.offset);\n  r.setEnd(end.node, end.offset);\n  return r;\n}\n\n/**\n * Find a Slate node from a DOM `element`.\n *\n * @param {Element} element\n * @param {Editor} editor\n * @return {Node|Null}\n */\n\nfunction findNode(element, editor) {\n  warning(false, 'As of slate-react@0.22 the `findNode(element)` helper is deprecated in favor of `editor.findNode(element)`.');\n\n  invariant(!slate.Value.isValue(editor), 'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.');\n\n  var closest = element.closest(SELECTORS.KEY);\n  if (!closest) return null;\n\n  var key = closest.getAttribute(DATA_ATTRS.KEY);\n  if (!key) return null;\n\n  var value = editor.value;\n  var document = value.document;\n\n  var node = document.getNode(key);\n  return node || null;\n}\n\n/**\n * Find a Slate path from a DOM `element`.\n *\n * @param {Element} element\n * @param {Editor} editor\n * @return {List|Null}\n */\n\nfunction findPath(element, editor) {\n  warning(false, 'As of slate-react@0.22 the `findPath(element)` helper is deprecated in favor of `editor.findPath(element)`.');\n\n  var node = findNode(element, editor);\n\n  if (!node) {\n    return null;\n  }\n\n  var value = editor.value;\n  var document = value.document;\n\n  var path = document.getPath(node);\n  return path;\n}\n\n/**\n * Find a Slate point from a DOM selection's `nativeNode` and `nativeOffset`.\n *\n * @param {Element} nativeNode\n * @param {Number} nativeOffset\n * @param {Editor} editor\n * @return {Point}\n */\n\nfunction findPoint(nativeNode, nativeOffset, editor) {\n  warning(false, 'As of slate-react@0.22 the `findPoint(node, offset)` helper is deprecated in favor of `editor.findPoint(node, offset)`.');\n\n  invariant(!slate.Value.isValue(editor), 'As of Slate 0.42.0, the `findPoint` utility takes an `editor` instead of a `value`.');\n\n  var _normalizeNodeAndOffs = normalizeNodeAndOffset$1(nativeNode, nativeOffset),\n      nearestNode = _normalizeNodeAndOffs.node,\n      nearestOffset = _normalizeNodeAndOffs.offset;\n\n  var window = getWindow(nativeNode);\n  var parentNode = nearestNode.parentNode;\n\n  var rangeNode = parentNode.closest(SELECTORS.LEAF);\n  var offset = void 0;\n  var node = void 0;\n\n  // Calculate how far into the text node the `nearestNode` is, so that we can\n  // determine what the offset relative to the text node is.\n  if (rangeNode) {\n    var range = window.document.createRange();\n    var textNode = rangeNode.closest(SELECTORS.TEXT);\n    range.setStart(textNode, 0);\n    range.setEnd(nearestNode, nearestOffset);\n    node = textNode;\n\n    // COMPAT: Edge has a bug where Range.prototype.toString() will convert \\n\n    // into \\r\\n. The bug causes a loop when slate-react attempts to reposition\n    // its cursor to match the native position. Use textContent.length instead.\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\n    var fragment = range.cloneContents();\n    var zeroWidthNodes = fragment.querySelectorAll('[' + DATA_ATTRS.ZERO_WIDTH + ']');\n    offset = fragment.textContent.length - zeroWidthNodes.length;\n  } else {\n    // For void nodes, the element with the offset key will be a cousin, not an\n    // ancestor, so find it by going down from the nearest void parent.\n    var voidNode = parentNode.closest(SELECTORS.VOID);\n    if (!voidNode) return null;\n    rangeNode = voidNode.querySelector(SELECTORS.LEAF);\n    if (!rangeNode) return null;\n    node = rangeNode;\n    offset = node.textContent.length;\n  }\n\n  // COMPAT: If the parent node is a Slate zero-width space, this is because the\n  // text node should have no characters. However, during IME composition the\n  // ASCII characters will be prepended to the zero-width space, so subtract 1\n  // from the offset to account for the zero-width space character.\n  if (offset === node.textContent.length && parentNode.hasAttribute(DATA_ATTRS.ZERO_WIDTH)) {\n    offset--;\n  }\n\n  // Get the string value of the offset key attribute.\n  var offsetKey = rangeNode.getAttribute(DATA_ATTRS.OFFSET_KEY);\n  if (!offsetKey) return null;\n\n  var _OffsetKey$parse = OffsetKey.parse(offsetKey),\n      key = _OffsetKey$parse.key;\n\n  // COMPAT: If someone is clicking from one Slate editor into another, the\n  // select event fires twice, once for the old editor's `element` first, and\n  // then afterwards for the correct `element`. (2017/03/03)\n\n\n  var value = editor.value;\n\n  if (!value.document.hasDescendant(key)) return null;\n\n  var point = value.document.createPoint({ key: key, offset: offset });\n  return point;\n}\n\n/**\n * From a DOM selection's `node` and `offset`, normalize so that it always\n * refers to a text node.\n *\n * @param {Element} node\n * @param {Number} offset\n * @return {Object}\n */\n\nfunction normalizeNodeAndOffset$1(node, offset) {\n  // If it's an element node, its offset refers to the index of its children\n  // including comment nodes, so try to find the right text child node.\n  if (node.nodeType === 1 && node.childNodes.length) {\n    var isLast = offset === node.childNodes.length;\n    var direction = isLast ? 'backward' : 'forward';\n    var index = isLast ? offset - 1 : offset;\n    node = getEditableChild$1(node, index, direction);\n\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\n    // can be either text nodes, or other void DOM nodes.\n    while (node.nodeType === 1 && node.childNodes.length) {\n      var i = isLast ? node.childNodes.length - 1 : 0;\n      node = getEditableChild$1(node, i, direction);\n    }\n\n    // Determine the new offset inside the text node.\n    offset = isLast ? node.textContent.length : 0;\n  }\n\n  // Return the node and offset.\n  return { node: node, offset: offset };\n}\n\n/**\n * Get the nearest editable child at `index` in a `parent`, preferring\n * `direction`.\n *\n * @param {Element} parent\n * @param {Number} index\n * @param {String} direction ('forward' or 'backward')\n * @return {Element|Null}\n */\n\nfunction getEditableChild$1(parent, index, direction) {\n  var childNodes = parent.childNodes;\n\n  var child = childNodes[index];\n  var i = index;\n  var triedForward = false;\n  var triedBackward = false;\n\n  // While the child is a comment node, or an element node with no children,\n  // keep iterating to find a sibling non-void, non-comment node.\n  while (child.nodeType === 8 || child.nodeType === 1 && child.childNodes.length === 0 || child.nodeType === 1 && child.getAttribute('contenteditable') === 'false') {\n    if (triedForward && triedBackward) break;\n\n    if (i >= childNodes.length) {\n      triedForward = true;\n      i = index - 1;\n      direction = 'backward';\n      continue;\n    }\n\n    if (i < 0) {\n      triedBackward = true;\n      i = index + 1;\n      direction = 'forward';\n      continue;\n    }\n\n    child = childNodes[i];\n    if (direction === 'forward') i++;\n    if (direction === 'backward') i--;\n  }\n\n  return child || null;\n}\n\n/**\n * Find a Slate range from a DOM `native` selection.\n *\n * @param {Selection} native\n * @param {Editor} editor\n * @return {Range}\n */\n\nfunction findRange(native, editor) {\n  warning(false, 'As of slate-react@0.22 the `findRange(selection)` helper is deprecated in favor of `editor.findRange(selection)`.');\n\n  invariant(!slate.Value.isValue(editor), 'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.');\n\n  var el = native.anchorNode || native.startContainer;\n  if (!el) return null;\n\n  var window = getWindow(el);\n\n  // If the `native` object is a DOM `Range` or `StaticRange` object, change it\n  // into something that looks like a DOM `Selection` instead.\n  if (native instanceof window.Range || window.StaticRange && native instanceof window.StaticRange) {\n    native = {\n      anchorNode: native.startContainer,\n      anchorOffset: native.startOffset,\n      focusNode: native.endContainer,\n      focusOffset: native.endOffset\n    };\n  }\n\n  var _native = native,\n      anchorNode = _native.anchorNode,\n      anchorOffset = _native.anchorOffset,\n      focusNode = _native.focusNode,\n      focusOffset = _native.focusOffset,\n      isCollapsed = _native.isCollapsed;\n  var value = editor.value;\n\n  var anchor = findPoint(anchorNode, anchorOffset, editor);\n  var focus = isCollapsed ? anchor : findPoint(focusNode, focusOffset, editor);\n  if (!anchor || !focus) return null;\n\n  var document = value.document;\n\n  var range = document.createRange({\n    anchor: anchor,\n    focus: focus\n  });\n\n  return range;\n}\n\n/**\n * Get the target range from a DOM `event`.\n *\n * @param {Event} event\n * @param {Editor} editor\n * @return {Range}\n */\n\nfunction getEventRange(event, editor) {\n  warning(false, 'As of slate-react@0.22 the `getEventRange(event, editor)` helper is deprecated in favor of `editor.findEventRange(event)`.');\n\n  invariant(!slate.Value.isValue(editor), 'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.');\n\n  if (event.nativeEvent) {\n    event = event.nativeEvent;\n  }\n\n  var _event = event,\n      x = _event.clientX,\n      y = _event.clientY,\n      target = _event.target;\n\n  if (x == null || y == null) return null;\n\n  var value = editor.value;\n  var document = value.document;\n\n  var path = findPath(event.target, editor);\n  if (!path) return null;\n\n  var node = document.getNode(path);\n\n  // If the drop target is inside a void node, move it into either the next or\n  // previous node, depending on which side the `x` and `y` coordinates are\n  // closest to.\n  if (editor.isVoid(node)) {\n    var rect = target.getBoundingClientRect();\n    var isPrevious = node.object === 'inline' ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\n\n    var _range = document.createRange();\n    var move = isPrevious ? 'moveToEndOfNode' : 'moveToStartOfNode';\n    var entry = document[isPrevious ? 'getPreviousText' : 'getNextText'](path);\n\n    if (entry) {\n      return _range[move](entry);\n    }\n\n    return null;\n  }\n\n  // Else resolve a range from the caret position where the drop occured.\n  var window = getWindow(target);\n  var native = void 0;\n\n  // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\n  if (window.document.caretRangeFromPoint) {\n    native = window.document.caretRangeFromPoint(x, y);\n  } else if (window.document.caretPositionFromPoint) {\n    var position = window.document.caretPositionFromPoint(x, y);\n    native = window.document.createRange();\n    native.setStart(position.offsetNode, position.offset);\n    native.setEnd(position.offsetNode, position.offset);\n  } else if (window.document.body.createTextRange) {\n    // COMPAT: In IE, `caretRangeFromPoint` and\n    // `caretPositionFromPoint` don't exist. (2018/07/11)\n    native = window.document.body.createTextRange();\n\n    try {\n      native.moveToPoint(x, y);\n    } catch (error) {\n      // IE11 will raise an `unspecified error` if `moveToPoint` is\n      // called during a dropEvent.\n      return null;\n    }\n  }\n\n  // Resolve a Slate range from the DOM range.\n  var range = findRange(native, editor);\n  if (!range) return null;\n\n  return range;\n}\n\nvar index = {\n  Editor: Editor,\n  cloneFragment: cloneFragment,\n  findDOMNode: findDOMNode,\n  findDOMPoint: findDOMPoint,\n  findDOMRange: findDOMRange,\n  findNode: findNode,\n  findPath: findPath,\n  findPoint: findPoint,\n  findRange: findRange,\n  getEventRange: getEventRange,\n  getEventTransfer: getEventTransfer,\n  setEventTransfer: setEventTransfer,\n  ReactPlugin: ReactPlugin\n};\n\nexports.Editor = Editor;\nexports.cloneFragment = cloneFragment;\nexports.findDOMNode = findDOMNode;\nexports.findDOMPoint = findDOMPoint;\nexports.findDOMRange = findDOMRange;\nexports.findNode = findNode;\nexports.findPath = findPath;\nexports.findPoint = findPoint;\nexports.findRange = findRange;\nexports.getEventRange = getEventRange;\nexports.getEventTransfer = getEventTransfer;\nexports.setEventTransfer = setEventTransfer;\nexports.ReactPlugin = ReactPlugin;\nexports.default = index;\n//# sourceMappingURL=slate-react.js.map\n\n};","~:removed-requires",["~#set",[]],"~:actual-requires",["^5",["~$module$node_modules$slate_hotkeys$lib$slate_hotkeys","~$module$node_modules$selection_is_backward$index","~$module$node_modules$memoize_one$dist$memoize_one_cjs","~$module$node_modules$lodash$omit","~$module$node_modules$slate_prop_types$lib$slate_prop_types","~$module$node_modules$debug$src$browser","~$module$node_modules$lodash$throttle","~$module$node_modules$react_dom$index","~$module$node_modules$react$index","~$module$node_modules$prop_types$index","~$shadow.js","~$module$node_modules$tiny_invariant$dist$tiny_invariant_cjs","~$module$node_modules$react_immutable_proptypes$dist$ImmutablePropTypes","~$module$node_modules$immutable$dist$immutable","~$module$node_modules$slate$lib$slate","~$module$node_modules$tiny_warning$dist$tiny_warning_cjs","~$module$node_modules$get_window$index","~$module$node_modules$slate_plain_serializer$lib$slate_plain_serializer","~$module$node_modules$slate_react_placeholder$lib$slate_react_placeholder","~$module$node_modules$slate_base64_serializer$lib$slate_base64_serializer","~$module$node_modules$slate_dev_environment$lib$slate_dev_environment"]],"~:properties",["^5",["nodeRef","total","queries","isCollapsed","onCompositionStart","onDragEnter","onCut","findEventRange","role","range","nativeSelection","onComponentWillUnmount","Editor","OBJECT","onBeforeInput","isUpdatingSelection","onRender","anchorOffset","whiteSpace","onPaste","childList","contentRef","cancelable","activeElement","index","onChange","textRef","offset","restoreDOM","prototype","height","clearUserActionPerformed","tabIndex","onInput","findDOMRange","RICH","handlers","removeText","disconnect","scrollLeft","onDragLeave","className","resolveController","updates","el","SPACER","placeholder","suppressContentEditableWarning","BLOCK","mounted","key","textContent","parent","children","native","getEventRange","focus","VOID","__esModule","LENGTH","info","path","WebkitUserModify","leaves","decorateNode","ZERO_WIDTH","schema","updateSelection","error","LEAF","id","fragment","diff","files","block","FRAGMENT","event","outline","update","propTypes","focusNode","dropEffect","marks","anchorNode","findNode","onMouseDown","anchor","reconcileDOMNode","document","getEventTransfer","position","onComponentDidUpdate","onDrop","configurable","findRange","construct","style","isTrailing","value","findSelection","characterData","cloneFragment","commands","preventScroll","rangeCount","nodeRefs","connect","enumerable","contentKey","direction","onFocus","renderText","setRef","STRING","resolves","start","text","domSelection","cursor","writable","onNativeSelectionChange","autoCorrect","isLineBreak","debug","onDragOver","characterDataOldValue","current","findDOMNode","dir","decoration","when","EDITOR","onDragEnd","defaultMarks","length","onBlur","readOnly","onClick","TEXT","props","annotations","defaultProps","focusOffset","bubbles","attributes","clearDiff","findPath","renderMark","type","defaultBlock","KEY","tagName","onEvent","wordWrap","stringify","state","decorations","ref","__proto__","HTML","renderAnnotation","insertText","isSelected","findPoint","annotation","onCopy","renderDecoration","parse","OFFSET_KEY","onDragStart","selection","defaultValue","onKeyDown","html","rootEl","renderDocument","renderEditor","onSelect","findDOMPoint","onMouseUp","mark","options","tmp","scrollTop","onCompositionEnd","rich","onDragExit","view","get","onComponentDidMount","color","ReactPlugin","subtree","default","renderBlock","reconcileNode","controller","contentEditable","INLINE","spellCheck","plugins","isInEditor","setEventTransfer","end","domNode","left","node","change","constructor","autoFocus","renderInline","userActionPerformed","isFocused","editor","NODE"]],"~:compiled-at",1574889105375,"~:source-map-json","{\n\"version\":3,\n\"file\":\"module$node_modules$slate_react$lib$slate_react.js\",\n\"lineCount\":171,\n\"mappings\":\"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\",\n\"sources\":[\"node_modules/slate-react/lib/slate-react.js\"],\n\"sourcesContent\":[\"shadow$provide[\\\"module$node_modules$slate_react$lib$slate_react\\\"] = function(global,require,module,exports) {\\n'use strict';\\n\\nObject.defineProperty(exports, '__esModule', { value: true });\\n\\nfunction _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }\\n\\nvar React = _interopDefault(require('react'));\\nvar Types = _interopDefault(require('prop-types'));\\nvar SlateTypes = _interopDefault(require('slate-prop-types'));\\nvar ImmutableTypes = _interopDefault(require('react-immutable-proptypes'));\\nvar Debug = _interopDefault(require('debug'));\\nvar warning = _interopDefault(require('tiny-warning'));\\nvar slate = require('slate');\\nvar getWindow = _interopDefault(require('get-window'));\\nvar isBackward = _interopDefault(require('selection-is-backward'));\\nvar slateDevEnvironment = require('slate-dev-environment');\\nvar throttle = _interopDefault(require('lodash/throttle'));\\nvar omit = _interopDefault(require('lodash/omit'));\\nvar immutable = require('immutable');\\nvar Hotkeys = _interopDefault(require('slate-hotkeys'));\\nvar ReactDOM = _interopDefault(require('react-dom'));\\nvar Base64 = _interopDefault(require('slate-base64-serializer'));\\nvar Plain = _interopDefault(require('slate-plain-serializer'));\\nvar invariant = _interopDefault(require('tiny-invariant'));\\nvar PlaceholderPlugin = _interopDefault(require('slate-react-placeholder'));\\nvar memoizeOne = _interopDefault(require('memoize-one'));\\n\\n/**\\n * Event handlers used by Slate plugins.\\n *\\n * @type {Array}\\n */\\n\\nvar EVENT_HANDLERS = ['onBeforeInput', 'onBlur', 'onClick', 'onContextMenu', 'onCompositionEnd', 'onCompositionStart', 'onCopy', 'onCut', 'onDragEnd', 'onDragEnter', 'onDragExit', 'onDragLeave', 'onDragOver', 'onDragStart', 'onDrop', 'onInput', 'onFocus', 'onKeyDown', 'onKeyUp', 'onMouseDown', 'onMouseUp', 'onPaste', 'onSelect'];\\n\\n/**\\n * Other handlers used by Slate plugins.\\n *\\n * @type {Array}\\n */\\n\\nvar OTHER_HANDLERS = ['decorateNode', 'renderAnnotation', 'renderBlock', 'renderDecoration', 'renderDocument', 'renderEditor', 'renderInline', 'renderMark'];\\n\\n/**\\n * DOM data attribute strings that refer to Slate concepts.\\n *\\n * @type {String}\\n */\\n\\nvar DATA_ATTRS = {\\n  EDITOR: 'data-slate-editor',\\n  FRAGMENT: 'data-slate-fragment',\\n  KEY: 'data-key',\\n  LEAF: 'data-slate-leaf',\\n  LENGTH: 'data-slate-length',\\n  OBJECT: 'data-slate-object',\\n  OFFSET_KEY: 'data-offset-key',\\n  SPACER: 'data-slate-spacer',\\n  STRING: 'data-slate-string',\\n  TEXT: 'data-slate-object',\\n  VOID: 'data-slate-void',\\n  ZERO_WIDTH: 'data-slate-zero-width'\\n};\\n\\n/**\\n * DOM selector strings that refer to Slate concepts.\\n *\\n * @type {String}\\n */\\n\\nvar SELECTORS = {\\n  BLOCK: '[' + DATA_ATTRS.OBJECT + '=\\\"block\\\"]',\\n  EDITOR: '[' + DATA_ATTRS.EDITOR + ']',\\n  INLINE: '[' + DATA_ATTRS.OBJECT + '=\\\"inline\\\"]',\\n  KEY: '[' + DATA_ATTRS.KEY + ']',\\n  LEAF: '[' + DATA_ATTRS.LEAF + ']',\\n  OBJECT: '[' + DATA_ATTRS.OBJECT + ']',\\n  STRING: '[' + DATA_ATTRS.STRING + ']',\\n  TEXT: '[' + DATA_ATTRS.OBJECT + '=\\\"text\\\"]',\\n  VOID: '[' + DATA_ATTRS.VOID + ']',\\n  ZERO_WIDTH: '[' + DATA_ATTRS.ZERO_WIDTH + ']'\\n};\\n\\nvar classCallCheck = function (instance, Constructor) {\\n  if (!(instance instanceof Constructor)) {\\n    throw new TypeError(\\\"Cannot call a class as a function\\\");\\n  }\\n};\\n\\nvar createClass = function () {\\n  function defineProperties(target, props) {\\n    for (var i = 0; i < props.length; i++) {\\n      var descriptor = props[i];\\n      descriptor.enumerable = descriptor.enumerable || false;\\n      descriptor.configurable = true;\\n      if (\\\"value\\\" in descriptor) descriptor.writable = true;\\n      Object.defineProperty(target, descriptor.key, descriptor);\\n    }\\n  }\\n\\n  return function (Constructor, protoProps, staticProps) {\\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\\n    if (staticProps) defineProperties(Constructor, staticProps);\\n    return Constructor;\\n  };\\n}();\\n\\n\\n\\n\\n\\nvar defineProperty = function (obj, key, value) {\\n  if (key in obj) {\\n    Object.defineProperty(obj, key, {\\n      value: value,\\n      enumerable: true,\\n      configurable: true,\\n      writable: true\\n    });\\n  } else {\\n    obj[key] = value;\\n  }\\n\\n  return obj;\\n};\\n\\nvar _extends = Object.assign || function (target) {\\n  for (var i = 1; i < arguments.length; i++) {\\n    var source = arguments[i];\\n\\n    for (var key in source) {\\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\\n        target[key] = source[key];\\n      }\\n    }\\n  }\\n\\n  return target;\\n};\\n\\n\\n\\nvar inherits = function (subClass, superClass) {\\n  if (typeof superClass !== \\\"function\\\" && superClass !== null) {\\n    throw new TypeError(\\\"Super expression must either be null or a function, not \\\" + typeof superClass);\\n  }\\n\\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\\n    constructor: {\\n      value: subClass,\\n      enumerable: false,\\n      writable: true,\\n      configurable: true\\n    }\\n  });\\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\\n};\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar possibleConstructorReturn = function (self, call) {\\n  if (!self) {\\n    throw new ReferenceError(\\\"this hasn't been initialised - super() hasn't been called\\\");\\n  }\\n\\n  return call && (typeof call === \\\"object\\\" || typeof call === \\\"function\\\") ? call : self;\\n};\\n\\n\\n\\n\\n\\nvar slicedToArray = function () {\\n  function sliceIterator(arr, i) {\\n    var _arr = [];\\n    var _n = true;\\n    var _d = false;\\n    var _e = undefined;\\n\\n    try {\\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\\n        _arr.push(_s.value);\\n\\n        if (i && _arr.length === i) break;\\n      }\\n    } catch (err) {\\n      _d = true;\\n      _e = err;\\n    } finally {\\n      try {\\n        if (!_n && _i[\\\"return\\\"]) _i[\\\"return\\\"]();\\n      } finally {\\n        if (_d) throw _e;\\n      }\\n    }\\n\\n    return _arr;\\n  }\\n\\n  return function (arr, i) {\\n    if (Array.isArray(arr)) {\\n      return arr;\\n    } else if (Symbol.iterator in Object(arr)) {\\n      return sliceIterator(arr, i);\\n    } else {\\n      throw new TypeError(\\\"Invalid attempt to destructure non-iterable instance\\\");\\n    }\\n  };\\n}();\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nvar toConsumableArray = function (arr) {\\n  if (Array.isArray(arr)) {\\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\\n\\n    return arr2;\\n  } else {\\n    return Array.from(arr);\\n  }\\n};\\n\\n/**\\n * Offset key parser regex.\\n *\\n * @type {RegExp}\\n */\\n\\nvar PARSER = /^([\\\\w-]+)(?::(\\\\d+))?$/;\\n\\n/**\\n * Parse an offset key `string`.\\n *\\n * @param {String} string\\n * @return {Object}\\n */\\n\\nfunction parse(string) {\\n  var matches = PARSER.exec(string);\\n\\n  if (!matches) {\\n    throw new Error(\\\"Invalid offset key string \\\\\\\"\\\" + string + \\\"\\\\\\\".\\\");\\n  }\\n\\n  var _matches = slicedToArray(matches, 3),\\n      original = _matches[0],\\n      key = _matches[1],\\n      index = _matches[2]; // eslint-disable-line no-unused-vars\\n\\n\\n  return {\\n    key: key,\\n    index: parseInt(index, 10)\\n  };\\n}\\n\\n/**\\n * Stringify an offset key `object`.\\n *\\n * @param {Object} object\\n *   @property {String} key\\n *   @property {Number} index\\n * @return {String}\\n */\\n\\nfunction stringify(object) {\\n  return object.key + \\\":\\\" + object.index;\\n}\\n\\n/**\\n * Export.\\n *\\n * @type {Object}\\n */\\n\\nvar OffsetKey = {\\n  parse: parse,\\n  stringify: stringify\\n};\\n\\n/**\\n * Leaf strings with text in them.\\n *\\n * @type {Component}\\n */\\n\\nvar TextString = function TextString(_ref) {\\n  var _ref$text = _ref.text,\\n      text = _ref$text === undefined ? '' : _ref$text,\\n      _ref$isTrailing = _ref.isTrailing,\\n      isTrailing = _ref$isTrailing === undefined ? false : _ref$isTrailing;\\n\\n  return React.createElement(\\n    'span',\\n    defineProperty({}, DATA_ATTRS.STRING, true),\\n    text,\\n    isTrailing ? '\\\\n' : null\\n  );\\n};\\n\\n/**\\n * Leaf strings without text, render as zero-width strings.\\n *\\n * @type {Component}\\n */\\n\\nvar ZeroWidthString = function ZeroWidthString(_ref3) {\\n  var _ref4;\\n\\n  var _ref3$length = _ref3.length,\\n      length = _ref3$length === undefined ? 0 : _ref3$length,\\n      _ref3$isLineBreak = _ref3.isLineBreak,\\n      isLineBreak = _ref3$isLineBreak === undefined ? false : _ref3$isLineBreak;\\n\\n  return React.createElement(\\n    'span',\\n    (_ref4 = {}, defineProperty(_ref4, DATA_ATTRS.ZERO_WIDTH, isLineBreak ? 'n' : 'z'), defineProperty(_ref4, DATA_ATTRS.LENGTH, length), _ref4),\\n    '\\\\uFEFF',\\n    isLineBreak ? React.createElement('br', null) : null\\n  );\\n};\\n\\n/**\\n * Individual leaves in a text node with unique formatting.\\n *\\n * @type {Component}\\n */\\n\\nvar Leaf = function Leaf(props) {\\n  var _attrs;\\n\\n  var marks = props.marks,\\n      annotations = props.annotations,\\n      decorations = props.decorations,\\n      node = props.node,\\n      index = props.index,\\n      offset = props.offset,\\n      text = props.text,\\n      editor = props.editor,\\n      parent = props.parent,\\n      block = props.block,\\n      leaves = props.leaves;\\n\\n\\n  var offsetKey = OffsetKey.stringify({\\n    key: node.key,\\n    index: index\\n  });\\n\\n  var children = void 0;\\n\\n  if (editor.query('isVoid', parent)) {\\n    // COMPAT: Render text inside void nodes with a zero-width space.\\n    // So the node can contain selection but the text is not visible.\\n    children = React.createElement(ZeroWidthString, { length: parent.text.length });\\n  } else if (text === '' && parent.object === 'block' && parent.text === '' && parent.nodes.last() === node) {\\n    // COMPAT: If this is the last text node in an empty block, render a zero-\\n    // width space that will convert into a line break when copying and pasting\\n    // to support expected plain text.\\n    children = React.createElement(ZeroWidthString, { isLineBreak: true });\\n  } else if (text === '') {\\n    // COMPAT: If the text is empty, it's because it's on the edge of an inline\\n    // node, so we render a zero-width space so that the selection can be\\n    // inserted next to it still.\\n    children = React.createElement(ZeroWidthString, null);\\n  } else {\\n    // COMPAT: Browsers will collapse trailing new lines at the end of blocks,\\n    // so we need to add an extra trailing new lines to prevent that.\\n    var lastText = block.getLastText();\\n    var lastChar = text.charAt(text.length - 1);\\n    var isLastText = node === lastText;\\n    var isLastLeaf = index === leaves.size - 1;\\n\\n    if (isLastText && isLastLeaf && lastChar === '\\\\n') {\\n      children = React.createElement(TextString, { isTrailing: true, text: text });\\n    } else {\\n      children = React.createElement(TextString, { text: text });\\n    }\\n  }\\n\\n  var renderProps = {\\n    editor: editor,\\n    marks: marks,\\n    annotations: annotations,\\n    decorations: decorations,\\n    node: node,\\n    offset: offset,\\n    text: text\\n\\n    // COMPAT: Having the `data-` attributes on these leaf elements ensures that\\n    // in certain misbehaving browsers they aren't weirdly cloned/destroyed by\\n    // contenteditable behaviors. (2019/05/08)\\n  };var _iteratorNormalCompletion = true;\\n  var _didIteratorError = false;\\n  var _iteratorError = undefined;\\n\\n  try {\\n    for (var _iterator = marks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n      var mark = _step.value;\\n\\n      var ret = editor.run('renderMark', _extends({}, renderProps, {\\n        mark: mark,\\n        children: children,\\n        attributes: defineProperty({}, DATA_ATTRS.OBJECT, 'mark')\\n      }));\\n\\n      if (ret) {\\n        children = ret;\\n      }\\n    }\\n  } catch (err) {\\n    _didIteratorError = true;\\n    _iteratorError = err;\\n  } finally {\\n    try {\\n      if (!_iteratorNormalCompletion && _iterator.return) {\\n        _iterator.return();\\n      }\\n    } finally {\\n      if (_didIteratorError) {\\n        throw _iteratorError;\\n      }\\n    }\\n  }\\n\\n  var _iteratorNormalCompletion2 = true;\\n  var _didIteratorError2 = false;\\n  var _iteratorError2 = undefined;\\n\\n  try {\\n    for (var _iterator2 = decorations[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n      var decoration = _step2.value;\\n\\n      var ret = editor.run('renderDecoration', _extends({}, renderProps, {\\n        decoration: decoration,\\n        children: children,\\n        attributes: defineProperty({}, DATA_ATTRS.OBJECT, 'decoration')\\n      }));\\n\\n      if (ret) {\\n        children = ret;\\n      }\\n    }\\n  } catch (err) {\\n    _didIteratorError2 = true;\\n    _iteratorError2 = err;\\n  } finally {\\n    try {\\n      if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n        _iterator2.return();\\n      }\\n    } finally {\\n      if (_didIteratorError2) {\\n        throw _iteratorError2;\\n      }\\n    }\\n  }\\n\\n  var _iteratorNormalCompletion3 = true;\\n  var _didIteratorError3 = false;\\n  var _iteratorError3 = undefined;\\n\\n  try {\\n    for (var _iterator3 = annotations[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\\n      var annotation = _step3.value;\\n\\n      var ret = editor.run('renderAnnotation', _extends({}, renderProps, {\\n        annotation: annotation,\\n        children: children,\\n        attributes: defineProperty({}, DATA_ATTRS.OBJECT, 'annotation')\\n      }));\\n\\n      if (ret) {\\n        children = ret;\\n      }\\n    }\\n  } catch (err) {\\n    _didIteratorError3 = true;\\n    _iteratorError3 = err;\\n  } finally {\\n    try {\\n      if (!_iteratorNormalCompletion3 && _iterator3.return) {\\n        _iterator3.return();\\n      }\\n    } finally {\\n      if (_didIteratorError3) {\\n        throw _iteratorError3;\\n      }\\n    }\\n  }\\n\\n  var attrs = (_attrs = {}, defineProperty(_attrs, DATA_ATTRS.LEAF, true), defineProperty(_attrs, DATA_ATTRS.OFFSET_KEY, offsetKey), _attrs);\\n\\n  return React.createElement(\\n    'span',\\n    attrs,\\n    children\\n  );\\n};\\n\\n/**\\n * Prop types.\\n *\\n * @type {Object}\\n */\\n\\nLeaf.propTypes = {\\n  annotations: ImmutableTypes.list.isRequired,\\n  block: SlateTypes.block.isRequired,\\n  decorations: ImmutableTypes.list.isRequired,\\n  editor: Types.object.isRequired,\\n  index: Types.number.isRequired,\\n  leaves: Types.object.isRequired,\\n  marks: SlateTypes.marks.isRequired,\\n  node: SlateTypes.node.isRequired,\\n  offset: Types.number.isRequired,\\n  parent: SlateTypes.node.isRequired,\\n  text: Types.string.isRequired\\n\\n  /**\\n   * A memoized version of `Leaf` that updates less frequently.\\n   *\\n   * @type {Component}\\n   */\\n\\n};var MemoizedLeaf = React.memo(Leaf, function (prev, next) {\\n  return next.block === prev.block && next.index === prev.index && next.marks === prev.marks && next.parent === prev.parent && next.text === prev.text && next.annotations.equals(prev.annotations) && next.decorations.equals(prev.decorations);\\n});\\n\\n/**\\n * Text node.\\n *\\n * @type {Component}\\n */\\n\\nvar Text = React.forwardRef(function (props, ref) {\\n  var _ref;\\n\\n  var annotations = props.annotations,\\n      block = props.block,\\n      decorations = props.decorations,\\n      node = props.node,\\n      parent = props.parent,\\n      editor = props.editor,\\n      style = props.style;\\n  var key = node.key;\\n\\n  var leaves = node.getLeaves(annotations, decorations);\\n  var at = 0;\\n\\n  return React.createElement(\\n    'span',\\n    _extends({\\n      ref: ref,\\n      style: style\\n    }, (_ref = {}, defineProperty(_ref, DATA_ATTRS.OBJECT, node.object), defineProperty(_ref, DATA_ATTRS.KEY, key), _ref)),\\n    leaves.map(function (leaf, index) {\\n      var text = leaf.text;\\n\\n      var offset = at;\\n      at += text.length;\\n\\n      return React.createElement(MemoizedLeaf, {\\n        key: node.key + '-' + index,\\n        block: block,\\n        editor: editor,\\n        index: index,\\n        annotations: leaf.annotations,\\n        decorations: leaf.decorations,\\n        marks: leaf.marks,\\n        node: node,\\n        offset: offset,\\n        parent: parent,\\n        leaves: leaves,\\n        text: text\\n      });\\n    })\\n  );\\n});\\n\\n/**\\n * Prop types.\\n *\\n * @type {Object}\\n */\\n\\nText.propTypes = {\\n  annotations: ImmutableTypes.map.isRequired,\\n  block: SlateTypes.block,\\n  decorations: ImmutableTypes.list.isRequired,\\n  editor: Types.object.isRequired,\\n  node: SlateTypes.node.isRequired,\\n  parent: SlateTypes.node.isRequired,\\n  style: Types.object\\n\\n  /**\\n   * A memoized version of `Text` that updates less frequently.\\n   *\\n   * @type {Component}\\n   */\\n\\n};var MemoizedText = React.memo(Text, function (prev, next) {\\n  return (\\n    // PERF: There are cases where it will have\\n    // changed, but it's properties will be exactly the same (eg. copy-paste)\\n    // which this won't catch. But that's rare and not a drag on performance, so\\n    // for simplicity we just let them through.\\n    next.node === prev.node &&\\n    // If the node parent is a block node, and it was the last child of the\\n    // block, re-render to cleanup extra `\\\\n`.\\n    next.parent.object === 'block' && prev.parent.nodes.last() === prev.node && next.parent.nodes.last() !== next.node &&\\n    // The formatting hasn't changed.\\n    next.annotations.equals(prev.annotations) && next.decorations.equals(prev.decorations)\\n  );\\n});\\n\\n/**\\n * Debug.\\n *\\n * @type {Function}\\n */\\n\\nvar debug = Debug('slate:void');\\n\\n/**\\n * Void.\\n *\\n * @type {Component}\\n */\\n\\nvar Void = function (_React$Component) {\\n  inherits(Void, _React$Component);\\n\\n  function Void() {\\n    var _ref;\\n\\n    var _temp, _this, _ret;\\n\\n    classCallCheck(this, Void);\\n\\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\\n      args[_key] = arguments[_key];\\n    }\\n\\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Void.__proto__ || Object.getPrototypeOf(Void)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps.call(_this), _temp), possibleConstructorReturn(_this, _ret);\\n  }\\n  /**\\n   * Property types.\\n   *\\n   * @type {Object}\\n   */\\n\\n  /**\\n   * Debug.\\n   *\\n   * @param {String} message\\n   * @param {Mixed} ...args\\n   */\\n\\n  createClass(Void, [{\\n    key: 'render',\\n\\n\\n    /**\\n     * Render.\\n     *\\n     * @return {Element}\\n     */\\n\\n    value: function render() {\\n      var _attrs;\\n\\n      var props = this.props;\\n      var children = props.children,\\n          node = props.node,\\n          readOnly = props.readOnly;\\n\\n      var Tag = node.object === 'block' ? 'div' : 'span';\\n      var style = {\\n        height: '0',\\n        color: 'transparent',\\n        outline: 'none',\\n        position: 'absolute'\\n      };\\n\\n      var spacerAttrs = defineProperty({}, DATA_ATTRS.SPACER, true);\\n\\n      var spacer = React.createElement(\\n        Tag,\\n        _extends({ style: style }, spacerAttrs),\\n        this.renderText()\\n      );\\n\\n      var content = React.createElement(\\n        Tag,\\n        { contentEditable: readOnly ? null : false },\\n        children\\n      );\\n\\n      this.debug('render', { props: props });\\n\\n      var attrs = (_attrs = {}, defineProperty(_attrs, DATA_ATTRS.VOID, true), defineProperty(_attrs, DATA_ATTRS.KEY, node.key), _attrs);\\n\\n      return React.createElement(\\n        Tag,\\n        _extends({\\n          contentEditable: readOnly || node.object === 'block' ? null : false\\n        }, attrs),\\n        readOnly ? null : spacer,\\n        content\\n      );\\n    }\\n\\n    /**\\n     * Render the void node's text node, which will catch the cursor when it the\\n     * void node is navigated to with the arrow keys.\\n     *\\n     * Having this text node there means the browser continues to manage the\\n     * selection natively, so it keeps track of the right offset when moving\\n     * across the block.\\n     *\\n     * @return {Element}\\n     */\\n\\n  }]);\\n  return Void;\\n}(React.Component);\\n\\n/**\\n * Export.\\n *\\n * @type {Component}\\n */\\n\\nVoid.propTypes = {\\n  block: SlateTypes.block,\\n  children: Types.any.isRequired,\\n  editor: Types.object.isRequired,\\n  node: SlateTypes.node.isRequired,\\n  parent: SlateTypes.node.isRequired,\\n  readOnly: Types.bool.isRequired };\\n\\nvar _initialiseProps = function _initialiseProps() {\\n  var _this2 = this;\\n\\n  this.debug = function (message) {\\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\\n      args[_key2 - 1] = arguments[_key2];\\n    }\\n\\n    var node = _this2.props.node;\\n    var key = node.key,\\n        type = node.type;\\n\\n    var id = key + ' (' + type + ')';\\n    debug.apply(undefined, [message, '' + id].concat(args));\\n  };\\n\\n  this.renderText = function () {\\n    var _props = _this2.props,\\n        annotations = _props.annotations,\\n        block = _props.block,\\n        decorations = _props.decorations,\\n        node = _props.node,\\n        readOnly = _props.readOnly,\\n        editor = _props.editor,\\n        textRef = _props.textRef;\\n\\n    var child = node.getFirstText();\\n    return React.createElement(MemoizedText, {\\n      ref: textRef,\\n      annotations: annotations,\\n      block: node.object === 'block' ? node : block,\\n      decorations: decorations,\\n      editor: editor,\\n      key: child.key,\\n      node: child,\\n      parent: node,\\n      readOnly: readOnly\\n    });\\n  };\\n};\\n\\n/**\\n * Debug.\\n *\\n * @type {Function}\\n */\\n\\nvar debug$1 = Debug('slate:node');\\n\\n/**\\n * Node.\\n *\\n * @type {Component}\\n */\\n\\nvar Node = function (_React$Component) {\\n  inherits(Node, _React$Component);\\n\\n  function Node() {\\n    var _ref;\\n\\n    var _temp, _this, _ret;\\n\\n    classCallCheck(this, Node);\\n\\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\\n      args[_key] = arguments[_key];\\n    }\\n\\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Node.__proto__ || Object.getPrototypeOf(Node)).call.apply(_ref, [this].concat(args))), _this), _initialiseProps$1.call(_this), _temp), possibleConstructorReturn(_this, _ret);\\n  }\\n  /**\\n   * Property types.\\n   *\\n   * @type {Object}\\n   */\\n\\n  /**\\n   * Temporary values.\\n   *\\n   * @type {Object}\\n   */\\n\\n  /**\\n   * A ref for the contenteditable DOM node.\\n   *\\n   * @type {Object}\\n   */\\n\\n  /**\\n   * Debug.\\n   *\\n   * @param {String} message\\n   * @param {Mixed} ...args\\n   */\\n\\n  createClass(Node, [{\\n    key: 'shouldComponentUpdate',\\n\\n\\n    /**\\n     * Should the node update?\\n     *\\n     * @param {Object} nextProps\\n     * @param {Object} value\\n     * @return {Boolean}\\n     */\\n\\n    value: function shouldComponentUpdate(nextProps) {\\n      var props = this.props;\\n      var editor = props.editor;\\n\\n      var shouldUpdate = editor.run('shouldNodeComponentUpdate', props, nextProps);\\n      var n = nextProps;\\n      var p = props;\\n\\n      // If the `Component` has a custom logic to determine whether the component\\n      // needs to be updated or not, return true if it returns true. If it returns\\n      // false, we need to ignore it, because it shouldn't be allowed it.\\n      if (shouldUpdate != null) {\\n        warning(false, 'As of slate-react@0.22 the `shouldNodeComponentUpdate` middleware is deprecated. You can pass specific values down the tree using React\\\\'s built-in \\\"context\\\" construct instead.');\\n\\n        if (shouldUpdate) {\\n          return true;\\n        }\\n\\n        warning(shouldUpdate !== false, \\\"Returning false in `shouldNodeComponentUpdate` does not disable Slate's internal `shouldComponentUpdate` logic. If you want to prevent updates, use React's `shouldComponentUpdate` instead.\\\");\\n      }\\n\\n      // If the `readOnly` status has changed, re-render in case there is any\\n      // user-land logic that depends on it, like nested editable contents.\\n      if (n.readOnly !== p.readOnly) {\\n        return true;\\n      }\\n\\n      // If the node has changed, update. PERF: There are cases where it will have\\n      // changed, but it's properties will be exactly the same (eg. copy-paste)\\n      // which this won't catch. But that's rare and not a drag on performance, so\\n      // for simplicity we just let them through.\\n      if (n.node !== p.node) {\\n        return true;\\n      }\\n\\n      // If the selection value of the node or of some of its children has changed,\\n      // re-render in case there is any user-land logic depends on it to render.\\n      // if the node is selected update it, even if it was already selected: the\\n      // selection value of some of its children could have been changed and they\\n      // need to be rendered again.\\n      if (!n.selection && p.selection || n.selection && !p.selection || n.selection && p.selection && !n.selection.equals(p.selection)) {\\n        return true;\\n      }\\n\\n      // If the annotations have changed, update.\\n      if (!n.annotations.equals(p.annotations)) {\\n        return true;\\n      }\\n\\n      // If the decorations have changed, update.\\n      if (!n.decorations.equals(p.decorations)) {\\n        return true;\\n      }\\n\\n      // Otherwise, don't update.\\n      return false;\\n    }\\n\\n    /**\\n     * Render.\\n     *\\n     * @return {Element}\\n     */\\n\\n  }, {\\n    key: 'render',\\n    value: function render() {\\n      var _this2 = this,\\n          _attributes;\\n\\n      this.debug('render', this);\\n      var _props = this.props,\\n          annotations = _props.annotations,\\n          block = _props.block,\\n          decorations = _props.decorations,\\n          editor = _props.editor,\\n          node = _props.node,\\n          parent = _props.parent,\\n          readOnly = _props.readOnly,\\n          selection = _props.selection;\\n\\n\\n      var newDecorations = node.getDecorations(editor);\\n      var children = node.nodes.toArray().map(function (child, i) {\\n        var Component = child.object === 'text' ? MemoizedText : Node;\\n        var sel = selection && getRelativeRange(node, i, selection);\\n\\n        var decs = newDecorations.concat(decorations).map(function (d) {\\n          return getRelativeRange(node, i, d);\\n        }).filter(function (d) {\\n          return d;\\n        });\\n\\n        var anns = annotations.map(function (a) {\\n          return getRelativeRange(node, i, a);\\n        }).filter(function (a) {\\n          return a;\\n        });\\n\\n        return React.createElement(Component, {\\n          block: node.object === 'block' ? node : block,\\n          editor: editor,\\n          annotations: anns,\\n          decorations: decs,\\n          selection: sel,\\n          key: child.key,\\n          node: child,\\n          parent: node,\\n          readOnly: readOnly\\n          // COMPAT: We use this map of refs to lookup a DOM node down the\\n          // tree of components by path.\\n          , ref: function ref(_ref2) {\\n            if (_ref2) {\\n              _this2.tmp.nodeRefs[i] = _ref2;\\n            } else {\\n              delete _this2.tmp.nodeRefs[i];\\n            }\\n          }\\n        });\\n      });\\n\\n      // Attributes that the developer must mix into the element in their\\n      // custom node renderer component.\\n      var attributes = (_attributes = {}, defineProperty(_attributes, DATA_ATTRS.OBJECT, node.object), defineProperty(_attributes, DATA_ATTRS.KEY, node.key), defineProperty(_attributes, 'ref', this.ref), _attributes);\\n\\n      // If it's a block node with inline children, add the proper `dir` attribute\\n      // for text direction.\\n      if (node.isLeafBlock()) {\\n        var direction = node.getTextDirection();\\n        if (direction === 'rtl') attributes.dir = 'rtl';\\n      }\\n\\n      var render = void 0;\\n\\n      if (node.object === 'block') {\\n        render = 'renderBlock';\\n      } else if (node.object === 'document') {\\n        render = 'renderDocument';\\n      } else if (node.object === 'inline') {\\n        render = 'renderInline';\\n      }\\n\\n      var element = editor.run(render, {\\n        attributes: attributes,\\n        children: children,\\n        editor: editor,\\n        isFocused: !!selection && selection.isFocused,\\n        isSelected: !!selection,\\n        node: node,\\n        parent: parent,\\n        readOnly: readOnly\\n      });\\n\\n      return editor.isVoid(node) ? React.createElement(\\n        Void,\\n        _extends({}, this.props, {\\n          textRef: function textRef(ref) {\\n            if (ref) {\\n              _this2.tmp.nodeRefs[0] = ref;\\n            } else {\\n              delete _this2.tmp.nodeRefs[0];\\n            }\\n          }\\n        }),\\n        element\\n      ) : element;\\n    }\\n  }]);\\n  return Node;\\n}(React.Component);\\n\\n/**\\n * Return a `range` relative to a child at `index`.\\n *\\n * @param {Range} range\\n * @param {Number} index\\n * @return {Range}\\n */\\n\\nNode.propTypes = {\\n  annotations: ImmutableTypes.map.isRequired,\\n  block: SlateTypes.block,\\n  decorations: ImmutableTypes.list.isRequired,\\n  editor: Types.object.isRequired,\\n  node: SlateTypes.node.isRequired,\\n  parent: SlateTypes.node,\\n  readOnly: Types.bool.isRequired,\\n  selection: SlateTypes.selection };\\n\\nvar _initialiseProps$1 = function _initialiseProps() {\\n  var _this3 = this;\\n\\n  this.tmp = {\\n    nodeRefs: {} };\\n  this.ref = React.createRef();\\n\\n  this.debug = function (message) {\\n    for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\\n      args[_key2 - 1] = arguments[_key2];\\n    }\\n\\n    var node = _this3.props.node;\\n    var key = node.key,\\n        type = node.type;\\n\\n    debug$1.apply(undefined, [message, key + ' (' + type + ')'].concat(args));\\n  };\\n};\\n\\nfunction getRelativeRange(node, index, range) {\\n  if (range.isUnset) {\\n    return null;\\n  }\\n\\n  var child = node.nodes.get(index);\\n  var _range = range,\\n      start = _range.start,\\n      end = _range.end;\\n  var _start = start,\\n      startPath = _start.path;\\n  var _end = end,\\n      endPath = _end.path;\\n\\n  var startIndex = startPath.first();\\n  var endIndex = endPath.first();\\n\\n  if (startIndex === index) {\\n    start = start.setPath(startPath.rest());\\n  } else if (startIndex < index && index <= endIndex) {\\n    if (child.object === 'text') {\\n      start = start.moveTo(slate.PathUtils.create([index]), 0).setKey(child.key);\\n    } else {\\n      var _child$texts = child.texts(),\\n          _child$texts2 = slicedToArray(_child$texts, 1),\\n          first = _child$texts2[0];\\n\\n      var _first = slicedToArray(first, 2),\\n          firstNode = _first[0],\\n          firstPath = _first[1];\\n\\n      start = start.moveTo(firstPath, 0).setKey(firstNode.key);\\n    }\\n  } else {\\n    start = null;\\n  }\\n\\n  if (endIndex === index) {\\n    end = end.setPath(endPath.rest());\\n  } else if (startIndex <= index && index < endIndex) {\\n    if (child.object === 'text') {\\n      var length = child.text.length;\\n      end = end.moveTo(slate.PathUtils.create([index]), length).setKey(child.key);\\n    } else {\\n      var _child$texts3 = child.texts({ direction: 'backward' }),\\n          _child$texts4 = slicedToArray(_child$texts3, 1),\\n          last = _child$texts4[0];\\n\\n      var _last = slicedToArray(last, 2),\\n          lastNode = _last[0],\\n          lastPath = _last[1];\\n\\n      end = end.moveTo(lastPath, lastNode.text.length).setKey(lastNode.key);\\n    }\\n  } else {\\n    end = null;\\n  }\\n\\n  if (!start || !end) {\\n    return null;\\n  }\\n\\n  range = range.setAnchor(start);\\n  range = range.setFocus(end);\\n  return range;\\n}\\n\\n/**\\n * CSS overflow values that would cause scrolling.\\n *\\n * @type {Array}\\n */\\n\\nvar OVERFLOWS = ['auto', 'overlay', 'scroll'];\\n\\n/**\\n * Detect whether we are running IOS version 11\\n */\\n\\nvar IS_IOS_11 = slateDevEnvironment.IS_IOS && !!window.navigator.userAgent.match(/os 11_/i);\\n\\n/**\\n * Find the nearest parent with scrolling, or window.\\n *\\n * @param {el} Element\\n */\\n\\nfunction findScrollContainer(el, window) {\\n  var parent = el.parentNode;\\n  var scroller = void 0;\\n\\n  while (!scroller) {\\n    if (!parent.parentNode) break;\\n\\n    var style = window.getComputedStyle(parent);\\n    var overflowY = style.overflowY;\\n\\n\\n    if (OVERFLOWS.includes(overflowY)) {\\n      scroller = parent;\\n      break;\\n    }\\n\\n    parent = parent.parentNode;\\n  }\\n\\n  // COMPAT: Because Chrome does not allow doucment.body.scrollTop, we're\\n  // assuming that window.scrollTo() should be used if the scrollable element\\n  // turns out to be document.body or document.documentElement. This will work\\n  // unless body is intentionally set to scrollable by restricting its height\\n  // (e.g. height: 100vh).\\n  if (!scroller) {\\n    return window.document.body;\\n  }\\n\\n  return scroller;\\n}\\n\\n/**\\n * Scroll the current selection's focus point into view if needed.\\n *\\n * @param {Selection} selection\\n */\\n\\nfunction scrollToSelection(selection) {\\n  if (IS_IOS_11) return;\\n  if (!selection.anchorNode) return;\\n\\n  var window = getWindow(selection.anchorNode);\\n  var scroller = findScrollContainer(selection.anchorNode, window);\\n  var isWindow = scroller === window.document.body || scroller === window.document.documentElement;\\n  var backward = isBackward(selection);\\n\\n  var range = selection.getRangeAt(0).cloneRange();\\n  range.collapse(backward);\\n  var cursorRect = range.getBoundingClientRect();\\n\\n  // COMPAT: range.getBoundingClientRect() returns 0s in Safari when range is\\n  // collapsed. Expanding the range by 1 is a relatively effective workaround\\n  // for vertical scroll, although horizontal may be off by 1 character.\\n  // https://bugs.webkit.org/show_bug.cgi?id=138949\\n  // https://bugs.chromium.org/p/chromium/issues/detail?id=435438\\n  if (slateDevEnvironment.IS_SAFARI) {\\n    if (range.collapsed && cursorRect.top === 0 && cursorRect.height === 0) {\\n      if (range.startOffset === 0) {\\n        range.setEnd(range.endContainer, 1);\\n      } else {\\n        range.setStart(range.startContainer, range.startOffset - 1);\\n      }\\n\\n      cursorRect = range.getBoundingClientRect();\\n\\n      if (cursorRect.top === 0 && cursorRect.height === 0) {\\n        if (range.getClientRects().length) {\\n          cursorRect = range.getClientRects()[0];\\n        }\\n      }\\n    }\\n  }\\n\\n  var width = void 0;\\n  var height = void 0;\\n  var yOffset = void 0;\\n  var xOffset = void 0;\\n  var scrollerTop = 0;\\n  var scrollerLeft = 0;\\n  var scrollerBordersY = 0;\\n  var scrollerBordersX = 0;\\n  var scrollerPaddingTop = 0;\\n  var scrollerPaddingBottom = 0;\\n  var scrollerPaddingLeft = 0;\\n  var scrollerPaddingRight = 0;\\n\\n  if (isWindow) {\\n    var innerWidth = window.innerWidth,\\n        innerHeight = window.innerHeight,\\n        pageYOffset = window.pageYOffset,\\n        pageXOffset = window.pageXOffset;\\n\\n    width = innerWidth;\\n    height = innerHeight;\\n    yOffset = pageYOffset;\\n    xOffset = pageXOffset;\\n  } else {\\n    var offsetWidth = scroller.offsetWidth,\\n        offsetHeight = scroller.offsetHeight,\\n        scrollTop = scroller.scrollTop,\\n        scrollLeft = scroller.scrollLeft;\\n\\n    var _window$getComputedSt = window.getComputedStyle(scroller),\\n        borderTopWidth = _window$getComputedSt.borderTopWidth,\\n        borderBottomWidth = _window$getComputedSt.borderBottomWidth,\\n        borderLeftWidth = _window$getComputedSt.borderLeftWidth,\\n        borderRightWidth = _window$getComputedSt.borderRightWidth,\\n        paddingTop = _window$getComputedSt.paddingTop,\\n        paddingBottom = _window$getComputedSt.paddingBottom,\\n        paddingLeft = _window$getComputedSt.paddingLeft,\\n        paddingRight = _window$getComputedSt.paddingRight;\\n\\n    var scrollerRect = scroller.getBoundingClientRect();\\n    width = offsetWidth;\\n    height = offsetHeight;\\n    scrollerTop = scrollerRect.top + parseInt(borderTopWidth, 10);\\n    scrollerLeft = scrollerRect.left + parseInt(borderLeftWidth, 10);\\n\\n    scrollerBordersY = parseInt(borderTopWidth, 10) + parseInt(borderBottomWidth, 10);\\n\\n    scrollerBordersX = parseInt(borderLeftWidth, 10) + parseInt(borderRightWidth, 10);\\n\\n    scrollerPaddingTop = parseInt(paddingTop, 10);\\n    scrollerPaddingBottom = parseInt(paddingBottom, 10);\\n    scrollerPaddingLeft = parseInt(paddingLeft, 10);\\n    scrollerPaddingRight = parseInt(paddingRight, 10);\\n    yOffset = scrollTop;\\n    xOffset = scrollLeft;\\n  }\\n\\n  var cursorTop = cursorRect.top + yOffset - scrollerTop;\\n  var cursorLeft = cursorRect.left + xOffset - scrollerLeft;\\n\\n  var x = xOffset;\\n  var y = yOffset;\\n\\n  if (cursorLeft < xOffset) {\\n    // selection to the left of viewport\\n    x = cursorLeft - scrollerPaddingLeft;\\n  } else if (cursorLeft + cursorRect.width + scrollerBordersX > xOffset + width) {\\n    // selection to the right of viewport\\n    x = cursorLeft + scrollerBordersX + scrollerPaddingRight - width;\\n  }\\n\\n  if (cursorTop < yOffset) {\\n    // selection above viewport\\n    y = cursorTop - scrollerPaddingTop;\\n  } else if (cursorTop + cursorRect.height + scrollerBordersY > yOffset + height) {\\n    // selection below viewport\\n    y = cursorTop + scrollerBordersY + scrollerPaddingBottom + cursorRect.height - height;\\n  }\\n\\n  if (isWindow) {\\n    window.scrollTo(x, y);\\n  } else {\\n    scroller.scrollTop = y;\\n    scroller.scrollLeft = x;\\n  }\\n}\\n\\n/**\\n * Cross-browser remove all ranges from a `domSelection`.\\n *\\n * @param {Selection} domSelection\\n */\\n\\nfunction removeAllRanges(domSelection) {\\n  // COMPAT: In IE 11, if the selection contains nested tables, then\\n  // `removeAllRanges` will throw an error.\\n  if (slateDevEnvironment.IS_IE) {\\n    var range = window.document.body.createTextRange();\\n    range.collapse();\\n    range.select();\\n  } else {\\n    domSelection.removeAllRanges();\\n  }\\n}\\n\\nvar FIREFOX_NODE_TYPE_ACCESS_ERROR = /Permission denied to access property \\\"nodeType\\\"/;\\n\\n/**\\n * Debug.\\n *\\n * @type {Function}\\n */\\n\\nvar debug$2 = Debug('slate:content');\\n\\n/**\\n * Separate debug to easily see when the DOM has updated either by render or\\n * changing selection.\\n *\\n * @type {Function}\\n */\\n\\ndebug$2.update = Debug('slate:update');\\n\\n/**\\n * Content.\\n *\\n * @type {Component}\\n */\\n\\nvar Content = function (_React$Component) {\\n  inherits(Content, _React$Component);\\n\\n  function Content() {\\n    var _ref;\\n\\n    var _temp, _this, _ret;\\n\\n    classCallCheck(this, Content);\\n\\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\\n      args[_key] = arguments[_key];\\n    }\\n\\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Content.__proto__ || Object.getPrototypeOf(Content)).call.apply(_ref, [this].concat(args))), _this), _this.tmp = {\\n      isUpdatingSelection: false,\\n      nodeRef: React.createRef(),\\n      nodeRefs: {},\\n      contentKey: 0,\\n      nativeSelection: {} // Native selection object stored to check if `onNativeSelectionChange` has triggered yet\\n\\n\\n      /**\\n       * A ref for the contenteditable DOM node.\\n       *\\n       * @type {Object}\\n       */\\n\\n    }, _this.ref = React.createRef(), _this.setRef = function (el) {\\n      _this.ref.current = el;\\n      _this.props.editor.el = el;\\n    }, _this.handlers = EVENT_HANDLERS.reduce(function (obj, handler) {\\n      obj[handler] = function (event) {\\n        return _this.onEvent(handler, event);\\n      };\\n      return obj;\\n    }, {}), _this.updateSelection = function () {\\n      var editor = _this.props.editor;\\n      var value = editor.value;\\n      var selection = value.selection;\\n      var isBackward$$1 = selection.isBackward;\\n\\n      var window = getWindow(_this.ref.current);\\n      var native = window.getSelection();\\n      var activeElement = window.document.activeElement;\\n\\n\\n      if (debug$2.update.enabled) {\\n        debug$2.update('updateSelection', { selection: selection.toJSON() });\\n      }\\n\\n      // COMPAT: In Firefox, there's a but where `getSelection` can return `null`.\\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=827585 (2018/11/07)\\n      if (!native) {\\n        return;\\n      }\\n\\n      var rangeCount = native.rangeCount,\\n          anchorNode = native.anchorNode;\\n\\n      var updated = false;\\n\\n      // If the Slate selection is blurred, but the DOM's active element is still\\n      // the editor, we need to blur it.\\n      if (selection.isBlurred && activeElement === _this.ref.current) {\\n        _this.ref.current.blur();\\n        updated = true;\\n      }\\n\\n      // If the Slate selection is unset, but the DOM selection has a range\\n      // selected in the editor, we need to remove the range.\\n      // However we should _not_ remove the range if the selection as\\n      // reported by `getSelection` is not equal to `this.tmp.nativeSelection`\\n      // as this suggests `onNativeSelectionChange` has not triggered yet (which can occur in Firefox)\\n      // See: https://github.com/ianstormtaylor/slate/pull/2995\\n\\n      var propsToCompare = ['anchorNode', 'anchorOffset', 'focusNode', 'focusOffset', 'isCollapsed', 'rangeCount', 'type'];\\n\\n      var selectionsEqual = true;\\n\\n      var _iteratorNormalCompletion = true;\\n      var _didIteratorError = false;\\n      var _iteratorError = undefined;\\n\\n      try {\\n        for (var _iterator = propsToCompare[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n          var prop = _step.value;\\n\\n          if (_this.tmp.nativeSelection[prop] !== native[prop]) {\\n            selectionsEqual = false;\\n          }\\n        }\\n      } catch (err) {\\n        _didIteratorError = true;\\n        _iteratorError = err;\\n      } finally {\\n        try {\\n          if (!_iteratorNormalCompletion && _iterator.return) {\\n            _iterator.return();\\n          }\\n        } finally {\\n          if (_didIteratorError) {\\n            throw _iteratorError;\\n          }\\n        }\\n      }\\n\\n      if (selection.isUnset && rangeCount && _this.isInEditor(anchorNode) && selectionsEqual) {\\n        removeAllRanges(native);\\n        updated = true;\\n      }\\n\\n      // If the Slate selection is focused, but the DOM's active element is not\\n      // the editor, we need to focus it. We prevent scrolling because we handle\\n      // scrolling to the correct selection.\\n      if (selection.isFocused && activeElement !== _this.ref.current) {\\n        _this.ref.current.focus({ preventScroll: true });\\n        updated = true;\\n      }\\n\\n      // Otherwise, figure out which DOM nodes should be selected...\\n      if (selection.isFocused && selection.isSet) {\\n        var current = !!native.rangeCount && native.getRangeAt(0);\\n        var range = editor.findDOMRange(selection);\\n\\n        if (!range) {\\n          warning(false, 'Unable to find a native DOM range from the current selection.');\\n\\n          return;\\n        }\\n\\n        var startContainer = range.startContainer,\\n            startOffset = range.startOffset,\\n            endContainer = range.endContainer,\\n            endOffset = range.endOffset;\\n\\n        // If the new range matches the current selection, there is nothing to fix.\\n        // COMPAT: The native `Range` object always has it's \\\"start\\\" first and \\\"end\\\"\\n        // last in the DOM. It has no concept of \\\"backwards/forwards\\\", so we have\\n        // to check both orientations here. (2017/10/31)\\n\\n        if (current) {\\n          if (startContainer === current.startContainer && startOffset === current.startOffset && endContainer === current.endContainer && endOffset === current.endOffset || startContainer === current.endContainer && startOffset === current.endOffset && endContainer === current.startContainer && endOffset === current.startOffset) {\\n            return;\\n          }\\n        }\\n\\n        // Otherwise, set the `isUpdatingSelection` flag and update the selection.\\n        updated = true;\\n        _this.tmp.isUpdatingSelection = true;\\n        removeAllRanges(native);\\n\\n        // COMPAT: IE 11 does not support `setBaseAndExtent`. (2018/11/07)\\n        if (native.setBaseAndExtent) {\\n          // COMPAT: Since the DOM range has no concept of backwards/forwards\\n          // we need to check and do the right thing here.\\n          if (isBackward$$1) {\\n            native.setBaseAndExtent(range.endContainer, range.endOffset, range.startContainer, range.startOffset);\\n          } else {\\n            native.setBaseAndExtent(range.startContainer, range.startOffset, range.endContainer, range.endOffset);\\n          }\\n        } else {\\n          native.addRange(range);\\n        }\\n\\n        // Only scroll to selection when a user action is performed\\n        if (editor.userActionPerformed() === true) {\\n          // Scroll to the selection, in case it's out of view.\\n          scrollToSelection(native);\\n        }\\n\\n        // Then unset the `isUpdatingSelection` flag after a delay, to ensure that\\n        // it is still set when selection-related events from updating it fire.\\n        setTimeout(function () {\\n          // COMPAT: In Firefox, it's not enough to create a range, you also need\\n          // to focus the contenteditable element too. (2016/11/16)\\n          if (slateDevEnvironment.IS_FIREFOX && _this.ref.current) {\\n            _this.ref.current.focus();\\n          }\\n\\n          _this.tmp.isUpdatingSelection = false;\\n\\n          debug$2.update('updateSelection:setTimeout', {\\n            anchorOffset: window.getSelection().anchorOffset\\n          });\\n        });\\n      }\\n\\n      if (updated && (debug$2.enabled || debug$2.update.enabled)) {\\n        debug$2('updateSelection', { selection: selection, native: native, activeElement: activeElement });\\n\\n        debug$2.update('updateSelection:applied', {\\n          selection: selection.toJSON(),\\n          native: {\\n            anchorOffset: native.anchorOffset,\\n            focusOffset: native.focusOffset\\n          }\\n        });\\n      }\\n    }, _this.isInEditor = function (target) {\\n      var el = void 0;\\n\\n      try {\\n        // COMPAT: In Firefox, sometimes the node can be comment which doesn't\\n        // have .closest and it crashes.\\n        if (target.nodeType === 8) {\\n          return false;\\n        }\\n\\n        // COMPAT: Text nodes don't have `isContentEditable` property. So, when\\n        // `target` is a text node use its parent node for check.\\n        el = target.nodeType === 3 ? target.parentNode : target;\\n      } catch (err) {\\n        // COMPAT: In Firefox, `target.nodeType` will throw an error if target is\\n        // originating from an internal \\\"restricted\\\" element (e.g. a stepper\\n        // arrow on a number input)\\n        // see github.com/ianstormtaylor/slate/issues/1819\\n        if (slateDevEnvironment.IS_FIREFOX && FIREFOX_NODE_TYPE_ACCESS_ERROR.test(err.message)) {\\n          return false;\\n        }\\n\\n        throw err;\\n      }\\n\\n      return el.isContentEditable && (el === _this.ref.current || el.closest(SELECTORS.EDITOR) === _this.ref.current);\\n    }, _this.onNativeSelectionChange = throttle(function (event) {\\n      if (_this.props.readOnly) return;\\n\\n      var window = getWindow(event.target);\\n      var activeElement = window.document.activeElement;\\n\\n\\n      var native = window.getSelection();\\n\\n      debug$2.update('onNativeSelectionChange', {\\n        anchorOffset: native.anchorOffset\\n      });\\n\\n      if (activeElement !== _this.ref.current) return;\\n\\n      _this.tmp.nativeSelection = {\\n        anchorNode: native.anchorNode,\\n        anchorOffset: native.anchorOffset,\\n        focusNode: native.focusNode,\\n        focusOffset: native.focusOffset,\\n        isCollapsed: native.isCollapsed,\\n        rangeCount: native.rangeCount,\\n        type: native.type\\n      };\\n\\n      _this.props.onEvent('onSelect', event);\\n    }, 100), _temp), possibleConstructorReturn(_this, _ret);\\n  }\\n  /**\\n   * Property types.\\n   *\\n   * @type {Object}\\n   */\\n\\n  /**\\n   * Default properties.\\n   *\\n   * @type {Object}\\n   */\\n\\n  createClass(Content, [{\\n    key: 'componentDidCatch',\\n\\n\\n    /**\\n     * An error boundary. If there is a render error, we increment `errorKey`\\n     * which is part of the container `key` which forces a re-render from\\n     * scratch.\\n     *\\n     * @param {Error} error\\n     * @param {String} info\\n     */\\n\\n    value: function componentDidCatch(error, info) {\\n      debug$2('componentDidCatch', { error: error, info: info });\\n      // The call to `setState` is required despite not setting a value.\\n      // Without this call, React will not try to recreate the component tree.\\n      this.setState({});\\n    }\\n\\n    /**\\n     * Temporary values.\\n     *\\n     * @type {Object}\\n     */\\n\\n    /**\\n     * Set both `this.ref` and `editor.el`\\n     *\\n     * @type {DOMElement}\\n     */\\n\\n    /**\\n     * Create a set of bound event handlers.\\n     *\\n     * @type {Object}\\n     */\\n\\n  }, {\\n    key: 'componentDidMount',\\n\\n\\n    /**\\n     * When the editor first mounts in the DOM we need to:\\n     *\\n     *   - Add native DOM event listeners.\\n     *   - Update the selection, in case it starts focused.\\n     */\\n\\n    value: function componentDidMount() {\\n      var window = getWindow(this.ref.current);\\n\\n      window.document.addEventListener('selectionchange', this.onNativeSelectionChange);\\n\\n      // COMPAT: Restrict scope of `beforeinput` to clients that support the\\n      // Input Events Level 2 spec, since they are preventable events.\\n      if (slateDevEnvironment.HAS_INPUT_EVENTS_LEVEL_2) {\\n        this.ref.current.addEventListener('beforeinput', this.handlers.onBeforeInput);\\n      }\\n\\n      this.updateSelection();\\n\\n      this.props.onEvent('onComponentDidMount');\\n    }\\n\\n    /**\\n     * When unmounting, remove DOM event listeners.\\n     */\\n\\n  }, {\\n    key: 'componentWillUnmount',\\n    value: function componentWillUnmount() {\\n      var window = getWindow(this.ref.current);\\n\\n      if (window) {\\n        window.document.removeEventListener('selectionchange', this.onNativeSelectionChange);\\n      }\\n\\n      if (slateDevEnvironment.HAS_INPUT_EVENTS_LEVEL_2) {\\n        this.ref.current.removeEventListener('beforeinput', this.handlers.onBeforeInput);\\n      }\\n\\n      this.props.onEvent('onComponentWillUnmount');\\n    }\\n\\n    /**\\n     * On update, update the selection.\\n     */\\n\\n  }, {\\n    key: 'componentDidUpdate',\\n    value: function componentDidUpdate() {\\n      debug$2.update('componentDidUpdate');\\n\\n      this.updateSelection();\\n      this.props.editor.clearUserActionPerformed();\\n\\n      this.props.onEvent('onComponentDidUpdate');\\n    }\\n\\n    /**\\n     * Update the native DOM selection to reflect the internal model.\\n     */\\n\\n    /**\\n     * Check if an event `target` is fired from within the contenteditable\\n     * element. This should be false for edits happening in non-contenteditable\\n     * children, such as void nodes and other nested Slate editors.\\n     *\\n     * @param {Element} target\\n     * @return {Boolean}\\n     */\\n\\n  }, {\\n    key: 'onEvent',\\n\\n\\n    /**\\n     * On `event` with `handler`.\\n     *\\n     * @param {String} handler\\n     * @param {Event} event\\n     */\\n\\n    value: function onEvent(handler, event) {\\n      debug$2('onEvent', handler);\\n\\n      var nativeEvent = event.nativeEvent || event;\\n      var isUndoRedo = event.type === 'keydown' && (Hotkeys.isUndo(nativeEvent) || Hotkeys.isRedo(nativeEvent));\\n\\n      // Ignore `onBlur`, `onFocus` and `onSelect` events generated\\n      // programmatically while updating selection.\\n      if ((this.tmp.isUpdatingSelection || isUndoRedo) && (handler === 'onSelect' || handler === 'onBlur' || handler === 'onFocus')) {\\n        return;\\n      }\\n\\n      // COMPAT: There are situations where a select event will fire with a new\\n      // native selection that resolves to the same internal position. In those\\n      // cases we don't need to trigger any changes, since our internal model is\\n      // already up to date, but we do want to update the native selection again\\n      // to make sure it is in sync. (2017/10/16)\\n      //\\n      // ANDROID: The updateSelection causes issues in Android when you are\\n      // at the end of a block. The selection ends up to the left of the inserted\\n      // character instead of to the right. This behavior continues even if\\n      // you enter more than one character. (2019/01/03)\\n      if (!slateDevEnvironment.IS_ANDROID && handler === 'onSelect') {\\n        var editor = this.props.editor;\\n        var value = editor.value;\\n        var selection = value.selection;\\n\\n        var window = getWindow(event.target);\\n        var domSelection = window.getSelection();\\n        var range = editor.findRange(domSelection);\\n\\n        if (range && range.equals(selection.toRange())) {\\n          this.updateSelection();\\n          return;\\n        }\\n      }\\n\\n      // Don't handle drag and drop events coming from embedded editors.\\n      if (handler === 'onDragEnd' || handler === 'onDragEnter' || handler === 'onDragExit' || handler === 'onDragLeave' || handler === 'onDragOver' || handler === 'onDragStart' || handler === 'onDrop') {\\n        var closest = event.target.closest(SELECTORS.EDITOR);\\n\\n        if (closest !== this.ref.current) {\\n          return;\\n        }\\n      }\\n\\n      // Some events require being in editable in the editor, so if the event\\n      // target isn't, ignore them.\\n      if (handler === 'onBeforeInput' || handler === 'onBlur' || handler === 'onCompositionEnd' || handler === 'onCompositionStart' || handler === 'onCopy' || handler === 'onCut' || handler === 'onFocus' || handler === 'onInput' || handler === 'onKeyDown' || handler === 'onKeyUp' || handler === 'onPaste' || handler === 'onSelect') {\\n        if (!this.isInEditor(event.target)) {\\n          return;\\n        }\\n      }\\n\\n      this.props.onEvent(handler, event);\\n    }\\n\\n    /**\\n     * On native `selectionchange` event, trigger the `onSelect` handler. This is\\n     * needed to account for React's `onSelect` being non-standard and not firing\\n     * until after a selection has been released. This causes issues in situations\\n     * where another change happens while a selection is being made.\\n     *\\n     * @param {Event} event\\n     */\\n\\n  }, {\\n    key: 'render',\\n\\n\\n    /**\\n     * Render the editor content.\\n     *\\n     * @return {Element}\\n     */\\n\\n    value: function render() {\\n      var _data;\\n\\n      var props = this.props,\\n          handlers = this.handlers;\\n      var id = props.id,\\n          className = props.className,\\n          readOnly = props.readOnly,\\n          editor = props.editor,\\n          tabIndex = props.tabIndex,\\n          role = props.role,\\n          tagName = props.tagName,\\n          spellCheck = props.spellCheck;\\n      var value = editor.value;\\n\\n      var Container = tagName;\\n      var document = value.document,\\n          selection = value.selection;\\n\\n\\n      var style = _extends({\\n        // Prevent the default outline styles.\\n        outline: 'none',\\n        // Preserve adjacent whitespace and new lines.\\n        whiteSpace: 'pre-wrap',\\n        // Allow words to break if they are too long.\\n        wordWrap: 'break-word'\\n      }, readOnly ? {} : { WebkitUserModify: 'read-write-plaintext-only' }, props.style);\\n\\n      // console.log('rerender content', this.tmp.contentKey, document.text)\\n\\n      debug$2('render', { props: props });\\n      debug$2.update('render', this.tmp.contentKey, document.text);\\n\\n      this.props.onEvent('onRender');\\n\\n      var data = (_data = {}, defineProperty(_data, DATA_ATTRS.EDITOR, true), defineProperty(_data, DATA_ATTRS.KEY, document.key), _data);\\n\\n      var domProps = omit(this.props, Object.keys(Content.propTypes));\\n\\n      return React.createElement(\\n        Container,\\n        _extends({}, domProps, {\\n          key: this.tmp.contentKey\\n        }, handlers, data, {\\n          ref: this.setRef,\\n          contentEditable: readOnly ? null : true,\\n          suppressContentEditableWarning: true,\\n          id: id,\\n          className: className,\\n          autoCorrect: props.autoCorrect ? 'on' : 'off',\\n          spellCheck: spellCheck,\\n          style: style,\\n          role: readOnly ? null : role || 'textbox',\\n          tabIndex: tabIndex\\n          // COMPAT: The Grammarly Chrome extension works by changing the DOM out\\n          // from under `contenteditable` elements, which leads to weird behaviors\\n          // so we have to disable it like this. (2017/04/24)\\n\\n          // just the existence of the flag is disabling the extension irrespective of its value\\n          , 'data-gramm': domProps['data-gramm'] ? undefined : false\\n        }),\\n        React.createElement(Node, {\\n          annotations: value.annotations,\\n          block: null,\\n          decorations: immutable.List(),\\n          editor: editor,\\n          node: document,\\n          parent: null,\\n          readOnly: readOnly,\\n          selection: selection,\\n          ref: this.tmp.nodeRef\\n        })\\n      );\\n    }\\n  }]);\\n  return Content;\\n}(React.Component);\\n\\n/**\\n * Export.\\n *\\n * @type {Component}\\n */\\n\\nContent.propTypes = {\\n  autoCorrect: Types.bool.isRequired,\\n  className: Types.string,\\n  contentKey: Types.number,\\n  editor: Types.object.isRequired,\\n  id: Types.string,\\n  onEvent: Types.func.isRequired,\\n  readOnly: Types.bool.isRequired,\\n  role: Types.string,\\n  spellCheck: Types.bool.isRequired,\\n  style: Types.object,\\n  tabIndex: Types.number,\\n  tagName: Types.string };\\nContent.defaultProps = {\\n  style: {},\\n  tagName: 'div' };\\n\\n/**\\n * Props that can be defined by plugins.\\n *\\n * @type {Array}\\n */\\n\\nvar PROPS = [].concat(toConsumableArray(EVENT_HANDLERS), ['commands', 'decorateNode', 'queries', 'renderAnnotation', 'renderBlock', 'renderDecoration', 'renderDocument', 'renderEditor', 'renderInline', 'renderMark', 'schema']);\\n\\n/**\\n * The top-level editor props in a plugin.\\n *\\n * @param {Object} options\\n * @return {Object}\\n */\\n\\nfunction EditorPropsPlugin() {\\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n\\n  var plugin = PROPS.reduce(function (memo, prop) {\\n    if (prop in options) memo[prop] = options[prop];\\n    return memo;\\n  }, {});\\n\\n  return plugin;\\n}\\n\\n/**\\n * The default rendering behavior for the React plugin.\\n *\\n * @return {Object}\\n */\\n\\nfunction Rendering() {\\n  return {\\n    decorateNode: function decorateNode() {\\n      return [];\\n    },\\n    renderAnnotation: function renderAnnotation(_ref) {\\n      var attributes = _ref.attributes,\\n          children = _ref.children;\\n\\n      return React.createElement(\\n        'span',\\n        attributes,\\n        children\\n      );\\n    },\\n    renderBlock: function renderBlock(_ref2) {\\n      var attributes = _ref2.attributes,\\n          children = _ref2.children;\\n\\n      return React.createElement(\\n        'div',\\n        _extends({}, attributes, { style: { position: 'relative' } }),\\n        children\\n      );\\n    },\\n    renderDecoration: function renderDecoration(_ref3) {\\n      var attributes = _ref3.attributes,\\n          children = _ref3.children;\\n\\n      return React.createElement(\\n        'span',\\n        attributes,\\n        children\\n      );\\n    },\\n    renderDocument: function renderDocument(_ref4) {\\n      var children = _ref4.children;\\n\\n      return children;\\n    },\\n    renderEditor: function renderEditor(_ref5) {\\n      var children = _ref5.children;\\n\\n      return children;\\n    },\\n    renderInline: function renderInline(_ref6) {\\n      var attributes = _ref6.attributes,\\n          children = _ref6.children;\\n\\n      return React.createElement(\\n        'span',\\n        _extends({}, attributes, { style: { position: 'relative' } }),\\n        children\\n      );\\n    },\\n    renderMark: function renderMark(_ref7) {\\n      var attributes = _ref7.attributes,\\n          children = _ref7.children;\\n\\n      return React.createElement(\\n        'span',\\n        attributes,\\n        children\\n      );\\n    }\\n  };\\n}\\n\\n/**\\n * A set of commands for the React plugin.\\n *\\n * @return {Object}\\n */\\n\\nfunction CommandsPlugin() {\\n  /**\\n   * Takes a `node`, find the matching `domNode` and uses it to set the text\\n   * in the `node`.\\n   *\\n   * @param {Editor} editor\\n   * @param {Node} node\\n   */\\n\\n  function reconcileNode(editor, node) {\\n    var value = editor.value;\\n    var document = value.document,\\n        selection = value.selection;\\n\\n    var path = document.getPath(node.key);\\n\\n    var domElement = editor.findDOMNode(path);\\n    var block = document.getClosestBlock(path);\\n\\n    // Get text information\\n    var text = node.text;\\n    var domText = domElement.textContent;\\n\\n\\n    var isLastNode = block.nodes.last() === node;\\n    var lastChar = domText.charAt(domText.length - 1);\\n\\n    // COMPAT: If this is the last leaf, and the DOM text ends in a new line,\\n    // we will have added another new line in <Leaf>'s render method to account\\n    // for browsers collapsing a single trailing new lines, so remove it.\\n    if (isLastNode && lastChar === '\\\\n') {\\n      domText = domText.slice(0, -1);\\n    }\\n\\n    // If the text is no different, abort.\\n    if (text === domText) return;\\n\\n    var entire = selection.moveAnchorTo(path, 0).moveFocusTo(path, text.length);\\n\\n    entire = document.resolveRange(entire);\\n\\n    // Change the current value to have the leaf's text replaced.\\n    editor.insertTextAtRange(entire, domText, node.marks);\\n    return;\\n  }\\n\\n  /**\\n   * Takes text from the `domNode` and uses it to set the text in the matching\\n   * `node` in Slate.\\n   *\\n   * @param {Editor} editor\\n   * @param {DOMNode} domNode\\n   */\\n\\n  function reconcileDOMNode(editor, domNode) {\\n    var domElement = domNode.parentElement.closest('[data-key]');\\n    var node = editor.findNode(domElement);\\n    editor.reconcileNode(node);\\n  }\\n\\n  return {\\n    commands: {\\n      reconcileNode: reconcileNode,\\n      reconcileDOMNode: reconcileDOMNode\\n    }\\n  };\\n}\\n\\n/**\\n * A set of queries for the React plugin.\\n *\\n * @return {Object}\\n */\\n\\nfunction QueriesPlugin() {\\n  /**\\n   * Find the native DOM element for a node at `path`.\\n   *\\n   * @param {Editor} editor\\n   * @param {Array|List} path\\n   * @return {DOMNode|Null}\\n   */\\n\\n  function findDOMNode(editor, path) {\\n    path = slate.PathUtils.create(path);\\n    var content = editor.tmp.contentRef.current;\\n\\n    if (!content) {\\n      return null;\\n    }\\n\\n    if (!path.size) {\\n      return content.ref.current || null;\\n    }\\n\\n    var search = function search(instance, p) {\\n      if (!instance) {\\n        return null;\\n      }\\n\\n      if (!p.size) {\\n        if (instance.ref) {\\n          return instance.ref.current || null;\\n        } else {\\n          return instance || null;\\n        }\\n      }\\n\\n      var index = p.first();\\n      var rest = p.rest();\\n      var ref = instance.tmp.nodeRefs[index];\\n      return search(ref, rest);\\n    };\\n\\n    var document = content.tmp.nodeRef.current;\\n    var el = search(document, path);\\n    return el;\\n  }\\n\\n  /**\\n   * Find a native DOM selection point from a Slate `point`.\\n   *\\n   * @param {Editor} editor\\n   * @param {Point} point\\n   * @return {Object|Null}\\n   */\\n\\n  function findDOMPoint(editor, point) {\\n    var el = editor.findDOMNode(point.path);\\n    var start = 0;\\n\\n    if (!el) {\\n      return null;\\n    }\\n\\n    // For each leaf, we need to isolate its content, which means filtering to its\\n    // direct text and zero-width spans. (We have to filter out any other siblings\\n    // that may have been rendered alongside them.)\\n    var texts = Array.from(el.querySelectorAll(SELECTORS.STRING + ', ' + SELECTORS.ZERO_WIDTH));\\n\\n    var _iteratorNormalCompletion = true;\\n    var _didIteratorError = false;\\n    var _iteratorError = undefined;\\n\\n    try {\\n      for (var _iterator = texts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n        var text = _step.value;\\n\\n        var node = text.childNodes[0];\\n        var domLength = node.textContent.length;\\n        var slateLength = domLength;\\n\\n        if (text.hasAttribute(DATA_ATTRS.LENGTH)) {\\n          slateLength = parseInt(text.getAttribute(DATA_ATTRS.LENGTH), 10);\\n        }\\n\\n        var end = start + slateLength;\\n\\n        if (point.offset <= end) {\\n          var offset = Math.min(domLength, Math.max(0, point.offset - start));\\n          return { node: node, offset: offset };\\n        }\\n\\n        start = end;\\n      }\\n    } catch (err) {\\n      _didIteratorError = true;\\n      _iteratorError = err;\\n    } finally {\\n      try {\\n        if (!_iteratorNormalCompletion && _iterator.return) {\\n          _iterator.return();\\n        }\\n      } finally {\\n        if (_didIteratorError) {\\n          throw _iteratorError;\\n        }\\n      }\\n    }\\n\\n    return null;\\n  }\\n\\n  /**\\n   * Find a native DOM range from a Slate `range`.\\n   *\\n   * @param {Editor} editor\\n   * @param {Range} range\\n   * @return {DOMRange|Null}\\n   */\\n\\n  function findDOMRange(editor, range) {\\n    var anchor = range.anchor,\\n        focus = range.focus,\\n        isBackward$$1 = range.isBackward,\\n        isCollapsed = range.isCollapsed;\\n\\n    var domAnchor = editor.findDOMPoint(anchor);\\n    var domFocus = isCollapsed ? domAnchor : editor.findDOMPoint(focus);\\n\\n    if (!domAnchor || !domFocus) {\\n      return null;\\n    }\\n\\n    var window = getWindow(domAnchor.node);\\n    var r = window.document.createRange();\\n    var start = isBackward$$1 ? domFocus : domAnchor;\\n    var end = isBackward$$1 ? domAnchor : domFocus;\\n    r.setStart(start.node, start.offset);\\n    r.setEnd(end.node, end.offset);\\n    return r;\\n  }\\n\\n  /**\\n   * Find a Slate node from a native DOM `element`.\\n   *\\n   * @param {Editor} editor\\n   * @param {Element} element\\n   * @return {List|Null}\\n   */\\n\\n  function findNode(editor, element) {\\n    var path = editor.findPath(element);\\n\\n    if (!path) {\\n      return null;\\n    }\\n\\n    var value = editor.value;\\n    var document = value.document;\\n\\n    var node = document.getNode(path);\\n    return node;\\n  }\\n\\n  /**\\n   * Get the target range from a DOM `event`.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @return {Range}\\n   */\\n\\n  function findEventRange(editor, event) {\\n    if (event.nativeEvent) {\\n      event = event.nativeEvent;\\n    }\\n\\n    var _event = event,\\n        x = _event.clientX,\\n        y = _event.clientY,\\n        target = _event.target;\\n\\n    if (x == null || y == null) return null;\\n\\n    var value = editor.value;\\n    var document = value.document;\\n\\n    var path = editor.findPath(event.target);\\n    if (!path) return null;\\n\\n    var node = document.getNode(path);\\n\\n    // If the drop target is inside a void node, move it into either the next or\\n    // previous node, depending on which side the `x` and `y` coordinates are\\n    // closest to.\\n    if (editor.isVoid(node)) {\\n      var rect = target.getBoundingClientRect();\\n      var isPrevious = node.object === 'inline' ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\\n\\n      var _range = document.createRange();\\n      var move = isPrevious ? 'moveToEndOfNode' : 'moveToStartOfNode';\\n      var entry = document[isPrevious ? 'getPreviousText' : 'getNextText'](path);\\n\\n      if (entry) {\\n        return _range[move](entry);\\n      }\\n\\n      return null;\\n    }\\n\\n    // Else resolve a range from the caret position where the drop occured.\\n    var window = getWindow(target);\\n    var native = void 0;\\n\\n    // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\\n    if (window.document.caretRangeFromPoint) {\\n      native = window.document.caretRangeFromPoint(x, y);\\n    } else if (window.document.caretPositionFromPoint) {\\n      var position = window.document.caretPositionFromPoint(x, y);\\n      native = window.document.createRange();\\n      native.setStart(position.offsetNode, position.offset);\\n      native.setEnd(position.offsetNode, position.offset);\\n    } else if (window.document.body.createTextRange) {\\n      // COMPAT: In IE, `caretRangeFromPoint` and\\n      // `caretPositionFromPoint` don't exist. (2018/07/11)\\n      native = window.document.body.createTextRange();\\n\\n      try {\\n        native.moveToPoint(x, y);\\n      } catch (error) {\\n        // IE11 will raise an `unspecified error` if `moveToPoint` is\\n        // called during a dropEvent.\\n        return null;\\n      }\\n    }\\n\\n    // Resolve a Slate range from the DOM range.\\n    var range = editor.findRange(native);\\n    return range;\\n  }\\n\\n  /**\\n   * Find the path of a native DOM `element` by searching React refs.\\n   *\\n   * @param {Editor} editor\\n   * @param {Element} element\\n   * @return {List|Null}\\n   */\\n\\n  function findPath(editor, element) {\\n    var content = editor.tmp.contentRef.current;\\n    var nodeElement = element;\\n\\n    // If element does not have a key, it is likely a string or\\n    // mark, return the closest parent Node that can be looked up.\\n    if (!nodeElement.hasAttribute(DATA_ATTRS.KEY)) {\\n      nodeElement = nodeElement.closest(SELECTORS.KEY);\\n    }\\n\\n    if (!nodeElement || !nodeElement.getAttribute(DATA_ATTRS.KEY)) {\\n      return null;\\n    }\\n\\n    if (nodeElement === content.ref.current) {\\n      return slate.PathUtils.create([]);\\n    }\\n\\n    var search = function search(instance, p) {\\n      if (nodeElement === instance) {\\n        return p;\\n      }\\n\\n      if (!instance.ref) {\\n        return null;\\n      }\\n\\n      if (nodeElement === instance.ref.current) {\\n        return p;\\n      }\\n\\n      // If there's no `tmp` then we're at a leaf node without success.\\n      if (!instance.tmp) {\\n        return null;\\n      }\\n\\n      var nodeRefs = instance.tmp.nodeRefs;\\n\\n      var keys = Object.keys(nodeRefs);\\n\\n      var _iteratorNormalCompletion2 = true;\\n      var _didIteratorError2 = false;\\n      var _iteratorError2 = undefined;\\n\\n      try {\\n        for (var _iterator2 = keys[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\\n          var i = _step2.value;\\n\\n          var ref = nodeRefs[i];\\n          var n = parseInt(i, 10);\\n          var _path = search(ref, [].concat(toConsumableArray(p), [n]));\\n\\n          if (_path) {\\n            return _path;\\n          }\\n        }\\n      } catch (err) {\\n        _didIteratorError2 = true;\\n        _iteratorError2 = err;\\n      } finally {\\n        try {\\n          if (!_iteratorNormalCompletion2 && _iterator2.return) {\\n            _iterator2.return();\\n          }\\n        } finally {\\n          if (_didIteratorError2) {\\n            throw _iteratorError2;\\n          }\\n        }\\n      }\\n\\n      return null;\\n    };\\n\\n    var document = content.tmp.nodeRef.current;\\n    var path = search(document, []);\\n\\n    if (!path) {\\n      return null;\\n    }\\n\\n    return slate.PathUtils.create(path);\\n  }\\n\\n  /**\\n   * Find a Slate point from a DOM selection's `nativeNode` and `nativeOffset`.\\n   *\\n   * @param {Editor} editor\\n   * @param {Element} nativeNode\\n   * @param {Number} nativeOffset\\n   * @return {Point}\\n   */\\n\\n  function findPoint(editor, nativeNode, nativeOffset) {\\n    var _normalizeNodeAndOffs = normalizeNodeAndOffset(nativeNode, nativeOffset),\\n        nearestNode = _normalizeNodeAndOffs.node,\\n        nearestOffset = _normalizeNodeAndOffs.offset;\\n\\n    var window = getWindow(nativeNode);\\n    var parentNode = nearestNode.parentNode;\\n\\n    var leafNode = parentNode.closest(SELECTORS.LEAF);\\n    var textNode = void 0;\\n    var offset = void 0;\\n    var node = void 0;\\n\\n    // Calculate how far into the text node the `nearestNode` is, so that we can\\n    // determine what the offset relative to the text node is.\\n    if (leafNode) {\\n      textNode = leafNode.closest(SELECTORS.TEXT);\\n      var range = window.document.createRange();\\n      range.setStart(textNode, 0);\\n      range.setEnd(nearestNode, nearestOffset);\\n      var contents = range.cloneContents();\\n      var zeroWidths = contents.querySelectorAll(SELECTORS.ZERO_WIDTH);\\n\\n      Array.from(zeroWidths).forEach(function (el) {\\n        el.parentNode.removeChild(el);\\n      });\\n\\n      // COMPAT: Edge has a bug where Range.prototype.toString() will convert \\\\n\\n      // into \\\\r\\\\n. The bug causes a loop when slate-react attempts to reposition\\n      // its cursor to match the native position. Use textContent.length instead.\\n      // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\\n      offset = contents.textContent.length;\\n      node = textNode;\\n    } else {\\n      // For void nodes, the element with the offset key will be a cousin, not an\\n      // ancestor, so find it by going down from the nearest void parent.\\n      var voidNode = parentNode.closest(SELECTORS.VOID);\\n\\n      if (!voidNode) {\\n        return null;\\n      }\\n\\n      leafNode = voidNode.querySelector(SELECTORS.LEAF);\\n\\n      if (!leafNode) {\\n        return null;\\n      }\\n\\n      textNode = leafNode.closest(SELECTORS.TEXT);\\n      node = leafNode;\\n      offset = node.textContent.length;\\n    }\\n\\n    // COMPAT: If the parent node is a Slate zero-width space, this is because the\\n    // text node should have no characters. However, during IME composition the\\n    // ASCII characters will be prepended to the zero-width space, so subtract 1\\n    // from the offset to account for the zero-width space character.\\n    if (offset === node.textContent.length && parentNode.hasAttribute(DATA_ATTRS.ZERO_WIDTH)) {\\n      offset--;\\n    }\\n\\n    // COMPAT: If someone is clicking from one Slate editor into another, the\\n    // select event fires twice, once for the old editor's `element` first, and\\n    // then afterwards for the correct `element`. (2017/03/03)\\n    var path = editor.findPath(textNode);\\n\\n    if (!path) {\\n      return null;\\n    }\\n\\n    var value = editor.value;\\n    var document = value.document;\\n\\n    var point = document.createPoint({ path: path, offset: offset });\\n    return point;\\n  }\\n\\n  /**\\n   * Find a Slate range from a DOM range or selection.\\n   *\\n   * @param {Editor} editor\\n   * @param {Selection} domRange\\n   * @return {Range}\\n   */\\n\\n  function findRange(editor, domRange) {\\n    var el = domRange.anchorNode || domRange.startContainer;\\n\\n    if (!el) {\\n      return null;\\n    }\\n\\n    var window = getWindow(el);\\n\\n    // If the `domRange` object is a DOM `Range` or `StaticRange` object, change it\\n    // into something that looks like a DOM `Selection` instead.\\n    if (domRange instanceof window.Range || window.StaticRange && domRange instanceof window.StaticRange) {\\n      domRange = {\\n        anchorNode: domRange.startContainer,\\n        anchorOffset: domRange.startOffset,\\n        focusNode: domRange.endContainer,\\n        focusOffset: domRange.endOffset\\n      };\\n    }\\n\\n    var _domRange = domRange,\\n        anchorNode = _domRange.anchorNode,\\n        anchorOffset = _domRange.anchorOffset,\\n        focusNode = _domRange.focusNode,\\n        focusOffset = _domRange.focusOffset,\\n        isCollapsed = _domRange.isCollapsed;\\n    var value = editor.value;\\n\\n    var anchor = editor.findPoint(anchorNode, anchorOffset);\\n    var focus = isCollapsed ? anchor : editor.findPoint(focusNode, focusOffset);\\n\\n    if (!anchor || !focus) {\\n      return null;\\n    }\\n\\n    var document = value.document;\\n\\n    var range = document.createRange({\\n      anchor: anchor,\\n      focus: focus\\n    });\\n\\n    return range;\\n  }\\n\\n  /**\\n   * Find a Slate selection from a DOM selection.\\n   *\\n   * @param {Editor} editor\\n   * @param {Selection} domSelection\\n   * @return {Range}\\n   */\\n\\n  function findSelection(editor, domSelection) {\\n    var value = editor.value;\\n    var document = value.document;\\n\\n    // If there are no ranges, the editor was blurred natively.\\n\\n    if (!domSelection.rangeCount) {\\n      return null;\\n    }\\n\\n    // Otherwise, determine the Slate selection from the native one.\\n    var range = editor.findRange(domSelection);\\n\\n    if (!range) {\\n      return null;\\n    }\\n\\n    var _range2 = range,\\n        anchor = _range2.anchor,\\n        focus = _range2.focus;\\n\\n    var anchorText = document.getNode(anchor.path);\\n    var focusText = document.getNode(focus.path);\\n    var anchorInline = document.getClosestInline(anchor.path);\\n    var focusInline = document.getClosestInline(focus.path);\\n    var focusBlock = document.getClosestBlock(focus.path);\\n    var anchorBlock = document.getClosestBlock(anchor.path);\\n\\n    // COMPAT: If the anchor point is at the start of a non-void, and the\\n    // focus point is inside a void node with an offset that isn't `0`, set\\n    // the focus offset to `0`. This is due to void nodes <span>'s being\\n    // positioned off screen, resulting in the offset always being greater\\n    // than `0`. Since we can't know what it really should be, and since an\\n    // offset of `0` is less destructive because it creates a hanging\\n    // selection, go with `0`. (2017/09/07)\\n    if (anchorBlock && !editor.isVoid(anchorBlock) && anchor.offset === 0 && focusBlock && editor.isVoid(focusBlock) && focus.offset !== 0) {\\n      range = range.setFocus(focus.setOffset(0));\\n    }\\n\\n    // COMPAT: If the selection is at the end of a non-void inline node, and\\n    // there is a node after it, put it in the node after instead. This\\n    // standardizes the behavior, since it's indistinguishable to the user.\\n    if (anchorInline && !editor.isVoid(anchorInline) && anchor.offset === anchorText.text.length) {\\n      var block = document.getClosestBlock(anchor.path);\\n      var depth = document.getDepth(block.key);\\n      var relativePath = slate.PathUtils.drop(anchor.path, depth);\\n\\n      var _block$texts = block.texts({ path: relativePath }),\\n          _block$texts2 = slicedToArray(_block$texts, 1),\\n          next = _block$texts2[0];\\n\\n      if (next) {\\n        var _next = slicedToArray(next, 2),\\n            nextPath = _next[1];\\n\\n        var absolutePath = anchor.path.slice(0, depth).concat(nextPath);\\n        range = range.moveAnchorTo(absolutePath, 0);\\n      }\\n    }\\n\\n    if (focusInline && !editor.isVoid(focusInline) && focus.offset === focusText.text.length) {\\n      var _block = document.getClosestBlock(focus.path);\\n      var _depth = document.getDepth(_block.key);\\n      var _relativePath = slate.PathUtils.drop(focus.path, _depth);\\n\\n      var _block$texts3 = _block.texts({ path: _relativePath }),\\n          _block$texts4 = slicedToArray(_block$texts3, 1),\\n          _next2 = _block$texts4[0];\\n\\n      if (_next2) {\\n        var _next3 = slicedToArray(_next2, 2),\\n            _nextPath = _next3[1];\\n\\n        var _absolutePath = focus.path.slice(0, _depth).concat(_nextPath);\\n        range = range.moveFocusTo(_absolutePath, 0);\\n      }\\n    }\\n\\n    var selection = document.createSelection(range);\\n\\n    // COMPAT: Ensure that the `isFocused` argument is set.\\n    selection = selection.setIsFocused(true);\\n\\n    // COMPAT: Preserve the marks, since we have no way of knowing what the DOM\\n    // selection's marks were. They will be cleared automatically by the\\n    // `select` command if the selection moves.\\n    selection = selection.set('marks', value.selection.marks);\\n\\n    return selection;\\n  }\\n\\n  return {\\n    queries: {\\n      findDOMNode: findDOMNode,\\n      findDOMPoint: findDOMPoint,\\n      findDOMRange: findDOMRange,\\n      findEventRange: findEventRange,\\n      findNode: findNode,\\n      findPath: findPath,\\n      findPoint: findPoint,\\n      findRange: findRange,\\n      findSelection: findSelection\\n    }\\n  };\\n}\\n\\n/**\\n * From a DOM selection's `node` and `offset`, normalize so that it always\\n * refers to a text node.\\n *\\n * @param {Element} node\\n * @param {Number} offset\\n * @return {Object}\\n */\\n\\nfunction normalizeNodeAndOffset(node, offset) {\\n  // If it's an element node, its offset refers to the index of its children\\n  // including comment nodes, so try to find the right text child node.\\n  if (node.nodeType === 1 && node.childNodes.length) {\\n    var isLast = offset === node.childNodes.length;\\n    var direction = isLast ? 'backward' : 'forward';\\n    var index = isLast ? offset - 1 : offset;\\n    node = getEditableChild(node, index, direction);\\n\\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\\n    // can be either text nodes, or other void DOM nodes.\\n    while (node.nodeType === 1 && node.childNodes.length) {\\n      var i = isLast ? node.childNodes.length - 1 : 0;\\n      node = getEditableChild(node, i, direction);\\n    }\\n\\n    // Determine the new offset inside the text node.\\n    offset = isLast ? node.textContent.length : 0;\\n  }\\n\\n  // Return the node and offset.\\n  return { node: node, offset: offset };\\n}\\n\\n/**\\n * Get the nearest editable child at `index` in a `parent`, preferring\\n * `direction`.\\n *\\n * @param {Element} parent\\n * @param {Number} index\\n * @param {String} direction ('forward' or 'backward')\\n * @return {Element|Null}\\n */\\n\\nfunction getEditableChild(parent, index, direction) {\\n  var childNodes = parent.childNodes;\\n\\n  var child = childNodes[index];\\n  var i = index;\\n  var triedForward = false;\\n  var triedBackward = false;\\n\\n  // While the child is a comment node, or an element node with no children,\\n  // keep iterating to find a sibling non-void, non-comment node.\\n  while (child.nodeType === 8 || child.nodeType === 1 && child.childNodes.length === 0 || child.nodeType === 1 && child.getAttribute('contenteditable') === 'false') {\\n    if (triedForward && triedBackward) break;\\n\\n    if (i >= childNodes.length) {\\n      triedForward = true;\\n      i = index - 1;\\n      direction = 'backward';\\n      continue;\\n    }\\n\\n    if (i < 0) {\\n      triedBackward = true;\\n      i = index + 1;\\n      direction = 'forward';\\n      continue;\\n    }\\n\\n    child = childNodes[i];\\n    if (direction === 'forward') i++;\\n    if (direction === 'backward') i--;\\n  }\\n\\n  return child || null;\\n}\\n\\n/**\\n * Returns the number of characters that are the same at the beginning of the\\n * String.\\n *\\n * @param {String} prev\\n * @param {String} next\\n */\\n\\nfunction getDiffStart(prev, next) {\\n  var length = Math.min(prev.length, next.length);\\n\\n  for (var i = 0; i < length; i++) {\\n    if (prev.charAt(i) !== next.charAt(i)) return i;\\n  }\\n\\n  if (prev.length !== next.length) return length;\\n  return null;\\n}\\n\\n/**\\n * Returns the number of characters that are the same at the end of the String\\n * up to `max`. Max prevents double-counting characters when there are\\n * multiple duplicate characters around the diff area.\\n *\\n * @param {String} prev\\n * @param {String} next\\n * @param {Number} max\\n */\\n\\nfunction getDiffEnd(prev, next, max) {\\n  var prevLength = prev.length;\\n  var nextLength = next.length;\\n  var length = Math.min(prevLength, nextLength, max);\\n\\n  for (var i = 0; i < length; i++) {\\n    var prevChar = prev.charAt(prevLength - i - 1);\\n    var nextChar = next.charAt(nextLength - i - 1);\\n    if (prevChar !== nextChar) return i;\\n  }\\n\\n  if (prev.length !== next.length) return length;\\n  return null;\\n}\\n\\n/**\\n * Takes two strings and returns an object representing two offsets. The\\n * first, `start` represents the number of characters that are the same at\\n * the front of the String. The `end` represents the number of characters\\n * that are the same at the end of the String.\\n *\\n * Returns null if they are identical.\\n *\\n * @param {String} prev\\n * @param {String} next\\n */\\n\\nfunction getDiffOffsets(prev, next) {\\n  if (prev === next) return null;\\n  var start = getDiffStart(prev, next);\\n  var maxEnd = Math.min(prev.length - start, next.length - start);\\n  var end = getDiffEnd(prev, next, maxEnd);\\n  return { start: start, end: end, total: start + end };\\n}\\n\\n/**\\n * Takes a text string and returns a slice from the string at the given offses\\n *\\n * @param {String} text\\n * @param {Object} offsets\\n */\\n\\nfunction sliceText(text, offsets) {\\n  return text.slice(offsets.start, text.length - offsets.end);\\n}\\n\\n/**\\n * Takes two strings and returns a smart diff that can be used to describe the\\n * change in a way that can be used as operations like inserting, removing or\\n * replacing text.\\n *\\n * @param {String} prev\\n * @param {String} next\\n */\\n\\nfunction diff(prev, next) {\\n  var offsets = getDiffOffsets(prev, next);\\n  if (offsets == null) return null;\\n  var insertText = sliceText(next, offsets);\\n  var removeText = sliceText(prev, offsets);\\n  return {\\n    start: offsets.start,\\n    end: prev.length - offsets.end,\\n    cursor: offsets.start + insertText.length,\\n    insertText: insertText,\\n    removeText: removeText\\n  };\\n}\\n\\n/**\\n * @type {Debug}\\n */\\n\\nvar debug$3 = Debug('slate:composition-manager');\\n\\n/**\\n * Unicode String for a ZERO_WIDTH_SPACE\\n *\\n * @type {String}\\n */\\n\\nvar ZERO_WIDTH_SPACE = String.fromCharCode(65279);\\n\\n/**\\n * https://github.com/facebook/draft-js/commit/cda13cb8ff9c896cdb9ff832d1edeaa470d3b871\\n */\\n\\nvar flushControlled = ReactDOM.unstable_flushControlled;\\n\\nfunction renderSync(editor, fn) {\\n  flushControlled(function () {\\n    fn();\\n    editor.controller.flush();\\n  });\\n}\\n\\n/**\\n * Takes text from a dom node and an offset within that text and returns an\\n * object with fixed text and fixed offset which removes zero width spaces\\n * and adjusts the offset.\\n *\\n * Optionally, if an `isLastNode` argument is passed in, it will also remove\\n * a trailing newline.\\n *\\n * @param {String} text\\n * @param {Number} offset\\n * @param {Boolean} isLastNode\\n */\\n\\nfunction fixTextAndOffset(prevText) {\\n  var prevOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\\n  var isLastNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\\n\\n  var nextOffset = prevOffset;\\n  var nextText = prevText;\\n  var index = 0;\\n\\n  while (index !== -1) {\\n    index = nextText.indexOf(ZERO_WIDTH_SPACE, index);\\n    if (index === -1) break;\\n    if (nextOffset > index) nextOffset--;\\n    nextText = '' + nextText.slice(0, index) + nextText.slice(index + 1);\\n  }\\n\\n  // remove the last newline if we are in the last node of a block\\n  var lastChar = nextText.charAt(nextText.length - 1);\\n\\n  if (isLastNode && lastChar === '\\\\n') {\\n    nextText = nextText.slice(0, -1);\\n  }\\n\\n  var maxOffset = nextText.length;\\n\\n  if (nextOffset > maxOffset) nextOffset = maxOffset;\\n  return { text: nextText, offset: nextOffset };\\n}\\n\\n/**\\n * Based loosely on:\\n *\\n * https://github.com/facebook/draft-js/blob/master/src/component/handlers/composition/DOMObserver.js\\n * https://github.com/ProseMirror/prosemirror-view/blob/master/src/domobserver.js\\n *\\n * But is an analysis mainly for `backspace` and `enter` as we handle\\n * compositions as a single operation.\\n *\\n * @param {} element\\n */\\n\\nfunction CompositionManager(editor) {\\n  /**\\n   * A MutationObserver that flushes to the method `flush`\\n   *\\n   * @type {MutationObserver}\\n   */\\n\\n  var observer = new window.MutationObserver(flush);\\n\\n  var win = null;\\n\\n  /**\\n   * Object that keeps track of the most recent state\\n   *\\n   * @type {Range}\\n   */\\n\\n  var last = {\\n    rootEl: null, // root element that MutationObserver is attached to\\n    diff: null, // last text node diff between Slate and DOM\\n    range: null, // last range selected\\n    domNode: null // last DOM node the cursor was in\\n\\n\\n    /**\\n     * Connect the MutationObserver to a specific editor root element\\n     */\\n\\n  };function connect() {\\n    debug$3('connect', { rootEl: rootEl });\\n\\n    var rootEl = editor.findDOMNode([]);\\n\\n    if (last.rootEl === rootEl) return;\\n\\n    debug$3('connect:run');\\n\\n    win = getWindow(rootEl);\\n\\n    observer.observe(rootEl, {\\n      childList: true,\\n      characterData: true,\\n      attributes: true,\\n      subtree: true,\\n      characterDataOldValue: true\\n    });\\n  }\\n\\n  function disconnect() {\\n    debug$3('disconnect');\\n    observer.disconnect();\\n    last.rootEl = null;\\n  }\\n\\n  function clearDiff() {\\n    debug$3('clearDIff');\\n    last.diff = null;\\n  }\\n\\n  /**\\n   * Clear the `last` properties related to an action only\\n   */\\n\\n  function clearAction() {\\n    debug$3('clearAction');\\n    last.diff = null;\\n    last.domNode = null;\\n  }\\n\\n  /**\\n   * Apply the last `diff`\\n   *\\n   * We don't want to apply the `diff` at the time it is created because we\\n   * may be in a composition. There are a few things that trigger the applying\\n   * of the saved diff. Sometimeson its own and sometimes immediately before\\n   * doing something else with the Editor.\\n   *\\n   * - `onCompositionEnd` event\\n   * - `onSelect` event only when the user has moved into a different node\\n   * - The user hits `enter`\\n   * - The user hits `backspace` and removes an inline node\\n   * - The user hits `backspace` and merges two blocks\\n   */\\n\\n  function applyDiff() {\\n    debug$3('applyDiff');\\n    var diff$$1 = last.diff;\\n\\n    if (diff$$1 == null) return;\\n    debug$3('applyDiff:run');\\n    var document = editor.value.document;\\n\\n\\n    var entire = editor.value.selection.moveAnchorTo(diff$$1.path, diff$$1.start).moveFocusTo(diff$$1.path, diff$$1.end);\\n\\n    entire = document.resolveRange(entire);\\n\\n    editor.insertTextAtRange(entire, diff$$1.insertText);\\n  }\\n\\n  /**\\n   * Handle `enter` that splits block\\n   */\\n\\n  function splitBlock() {\\n    debug$3('splitBlock');\\n\\n    renderSync(editor, function () {\\n      applyDiff();\\n\\n      if (last.range) {\\n        editor.select(last.range);\\n      } else {\\n        debug$3('splitBlock:NO-SELECTION');\\n      }\\n\\n      editor.splitBlock().focus().restoreDOM();\\n\\n      clearAction();\\n    });\\n  }\\n\\n  /**\\n   * Handle `backspace` that merges blocks\\n   */\\n\\n  function mergeBlock() {\\n    debug$3('mergeBlock');\\n\\n    /**\\n     * The delay is required because hitting `enter`, `enter` then `backspace`\\n     * in a word results in the cursor being one position to the right in\\n     * Android 9.\\n     *\\n     * Slate sets the position to `0` and we even check it immediately after\\n     * setting it and it is correct, but somewhere Android moves it to the right.\\n     *\\n     * This happens only when using the virtual keyboard. Hitting enter on a\\n     * hardware keyboard does not trigger this bug.\\n     *\\n     * The call to `focus` is required because when we switch examples then\\n     * merge a block, we lose focus in Android 9 (possibly others).\\n     */\\n\\n    win.requestAnimationFrame(function () {\\n      renderSync(editor, function () {\\n        applyDiff();\\n\\n        editor.select(last.range).deleteBackward().focus().restoreDOM();\\n\\n        clearAction();\\n      });\\n    });\\n  }\\n\\n  /**\\n   * The requestId used to the save selection\\n   *\\n   * @type {Any}\\n   */\\n\\n  var onSelectTimeoutId = null;\\n\\n  var bufferedMutations = [];\\n  var startActionFrameId = null;\\n  var isFlushing = false;\\n\\n  /**\\n   * Mark the beginning of an action. The action happens when the\\n   * `requestAnimationFrame` expires.\\n   *\\n   * If `startAction` is called again, it pushes the `action` to a new\\n   * `requestAnimationFrame` and cancels the old one.\\n   */\\n\\n  function startAction() {\\n    if (onSelectTimeoutId) {\\n      window.cancelAnimationFrame(onSelectTimeoutId);\\n      onSelectTimeoutId = null;\\n    }\\n\\n    isFlushing = true;\\n\\n    if (startActionFrameId) window.cancelAnimationFrame(startActionFrameId);\\n\\n    startActionFrameId = window.requestAnimationFrame(function () {\\n      if (bufferedMutations.length > 0) {\\n        flushAction(bufferedMutations);\\n      }\\n\\n      startActionFrameId = null;\\n      bufferedMutations = [];\\n      isFlushing = false;\\n    });\\n  }\\n\\n  /**\\n   * Handle MutationObserver flush\\n   *\\n   * @param {MutationList} mutations\\n   */\\n\\n  function flush(mutations) {\\n    var _bufferedMutations;\\n\\n    debug$3('flush');\\n    (_bufferedMutations = bufferedMutations).push.apply(_bufferedMutations, toConsumableArray(mutations));\\n    startAction();\\n  }\\n\\n  /**\\n   * Handle a `requestAnimationFrame` long batch of mutations.\\n   *\\n   * @param {Array} mutations\\n   */\\n\\n  function flushAction(mutations) {\\n    debug$3('flushAction', mutations.length, mutations);\\n\\n    // If there is an expanded collection, delete it\\n    if (last.range && !last.range.isCollapsed) {\\n      renderSync(editor, function () {\\n        editor.select(last.range).deleteBackward().focus().restoreDOM();\\n      });\\n      return;\\n    }\\n\\n    if (mutations.length > 1) {\\n      // check if one of the mutations matches the signature of an `enter`\\n      // which we use to signify a `splitBlock`\\n      var splitBlockMutation = mutations.find(function (m) {\\n        if (m.type !== 'childList') return false;\\n        if (m.addedNodes.length === 0) return false;\\n        var addedNode = m.addedNodes[0];\\n\\n        // If a text node is created anywhere with a newline in it, it's an\\n        // enter\\n        if (addedNode.nodeType === window.Node.TEXT_NODE && addedNode.textContent === '\\\\n') return true;\\n\\n        // If an element is created with a key that matches a block in our\\n        // document, that means the mutation is splitting an existing block\\n        // by creating a new element with the same key.\\n        if (addedNode.nodeType !== window.Node.ELEMENT_NODE) return false;\\n        var dataset = addedNode.dataset;\\n        var key = dataset.key;\\n        if (key == null) return false;\\n        var block = editor.value.document.getClosestBlock(key);\\n        return !!block;\\n      });\\n\\n      if (splitBlockMutation) {\\n        splitBlock();\\n        return;\\n      }\\n    }\\n\\n    // If we haven't matched a more specific mutation already, these general\\n    // mutation catchers will try and determine what the user was trying to\\n    // do.\\n\\n    var firstMutation = mutations[0];\\n\\n    if (firstMutation.type === 'characterData') {\\n      resolveDOMNode(firstMutation.target.parentNode);\\n    } else if (firstMutation.type === 'childList') {\\n      if (firstMutation.removedNodes.length > 0) {\\n        if (mutations.length === 1) {\\n          removeNode(firstMutation.removedNodes[0]);\\n        } else {\\n          mergeBlock();\\n        }\\n      } else if (firstMutation.addedNodes.length > 0) {\\n        splitBlock();\\n      }\\n    }\\n  }\\n\\n  /**\\n   * Takes a DOM Node and resolves it against Slate's Document.\\n   *\\n   * Saves the changes to `last.diff` which can be applied later using\\n   * `applyDiff()`\\n   *\\n   * @param {DOMNode} domNode\\n   */\\n\\n  function resolveDOMNode(domNode) {\\n    debug$3('resolveDOMNode');\\n\\n    var value = editor.value;\\n    var document = value.document;\\n\\n\\n    var dataElement = domNode.closest('[data-key]');\\n    var key = dataElement.dataset.key;\\n    var path = document.getPath(key);\\n    var block = document.getClosestBlock(key);\\n    var node = document.getDescendant(key);\\n    var prevText = node.text;\\n\\n    // COMPAT: If this is the last leaf, and the DOM text ends in a new line,\\n    // we will have added another new line in <Leaf>'s render method to account\\n    // for browsers collapsing a single trailing new lines, so remove it.\\n    var isLastNode = block.nodes.last() === node;\\n\\n    var fix = fixTextAndOffset(domNode.textContent, 0, isLastNode);\\n\\n    var nextText = fix.text;\\n\\n    // If the text is no different, there is no diff.\\n    if (nextText === prevText) {\\n      last.diff = null;\\n      return;\\n    }\\n\\n    var diff$$1 = diff(prevText, nextText);\\n\\n    last.diff = {\\n      path: path,\\n      start: diff$$1.start,\\n      end: diff$$1.end,\\n      insertText: diff$$1.insertText\\n    };\\n\\n    debug$3('resolveDOMNode:diff', last.diff);\\n  }\\n\\n  /**\\n   * Remove an Inline DOM Node.\\n   *\\n   * Happens when you delete the last character in an Inline DOM Node\\n   */\\n\\n  function removeNode(domNode) {\\n    debug$3('removeNode');\\n    if (domNode.nodeType !== window.Node.ELEMENT_NODE) return;\\n    var value = editor.value;\\n    var document = value.document,\\n        selection = value.selection;\\n\\n    var node = editor.findNode(domNode);\\n    var nodeSelection = document.resolveRange(selection.moveToRangeOfNode(node));\\n\\n    renderSync(editor, function () {\\n      editor.select(nodeSelection).delete().restoreDOM();\\n    });\\n  }\\n\\n  /**\\n   * handle `onCompositionStart`\\n   */\\n\\n  function onCompositionStart() {\\n    debug$3('onCompositionStart');\\n  }\\n\\n  /**\\n   * handle `onCompositionEnd`\\n   */\\n\\n  function onCompositionEnd() {\\n    debug$3('onCompositionEnd');\\n\\n    /**\\n     * The timing on the `setTimeout` with `20` ms is sensitive.\\n     *\\n     * It cannot use `requestAnimationFrame` because it is too short.\\n     *\\n     * Android 9, for example, when you type `it ` the space will first trigger\\n     * a `compositionEnd` for the `it` part before the mutation for the ` `.\\n     * This means that we end up with `it` if we trigger too soon because it\\n     * is on the wrong value.\\n     */\\n\\n    window.setTimeout(function () {\\n      if (last.diff) {\\n        debug$3('onCompositionEnd:applyDiff');\\n\\n        renderSync(editor, function () {\\n          applyDiff();\\n\\n          var domRange = win.getSelection().getRangeAt(0);\\n          var domText = domRange.startContainer.textContent;\\n          var offset = domRange.startOffset;\\n\\n          var fix = fixTextAndOffset(domText, offset);\\n\\n          var range = editor.findRange({\\n            anchorNode: domRange.startContainer,\\n            anchorOffset: 0,\\n            focusNode: domRange.startContainer,\\n            focusOffset: 0,\\n            isCollapsed: true\\n          }).moveTo(fix.offset);\\n\\n          /**\\n           * We must call `restoreDOM` even though this is applying a `diff` which\\n           * should not require it. But if you type `it me. no.` on a blank line\\n           * with a block following it, the next line will merge with the this\\n           * line. A mysterious `keydown` with `input` of backspace appears in the\\n           * event stream which the user not React caused.\\n           *\\n           * `focus` is required as well because otherwise we lose focus on hitting\\n           * `enter` in such a scenario.\\n           */\\n\\n          editor.select(range).focus().restoreDOM();\\n        });\\n      }\\n\\n      clearAction();\\n    }, 20);\\n  }\\n\\n  /**\\n   * Handle `onSelect` event\\n   *\\n   * Save the selection after a `requestAnimationFrame`\\n   *\\n   * - If we're not in the middle of flushing mutations\\n   * - and cancel save if a mutation runs before the `requestAnimationFrame`\\n   */\\n\\n  function onSelect(event) {\\n    debug$3('onSelect:try');\\n\\n    // Event can be Synthetic React or native. Grab only the native one so\\n    // that we don't have to call `event.perist` for performance.\\n    event = event.nativeEvent ? event.nativeEvent : event;\\n\\n    window.cancelAnimationFrame(onSelectTimeoutId);\\n    onSelectTimeoutId = null;\\n\\n    // Don't capture the last selection if the selection was made during the\\n    // flushing of DOM mutations. This means it is all part of one user action.\\n    if (isFlushing) return;\\n\\n    onSelectTimeoutId = window.requestAnimationFrame(function () {\\n      debug$3('onSelect:save-selection');\\n\\n      var domSelection = getWindow(event.target).getSelection();\\n      var range = editor.findRange(domSelection);\\n\\n      var anchorFix = fixTextAndOffset(domSelection.anchorNode.textContent, domSelection.anchorOffset);\\n\\n      var focusFix = fixTextAndOffset(domSelection.focusNode.textContent, domSelection.focusOffset);\\n\\n      if (range.anchor.offset !== anchorFix.offset) {\\n        range = range.set('anchor', range.anchor.set('offset', anchorFix.offset));\\n      }\\n\\n      if (range.focus.offset !== focusFix.offset) {\\n        range = range.set('focus', range.focus.set('offset', focusFix.offset));\\n      }\\n\\n      debug$3('onSelect:save-data', {\\n        domSelection: normalizeDOMSelection(domSelection),\\n        range: range.toJS()\\n      });\\n\\n      // If the `domSelection` has moved into a new node, then reconcile with\\n      // `applyDiff`\\n      if (domSelection.isCollapsed && last.node !== domSelection.anchorNode && last.diff != null) {\\n        debug$3('onSelect:applyDiff', last.diff);\\n        applyDiff();\\n        editor.select(range);\\n        clearAction();\\n      }\\n\\n      last.range = range;\\n      last.node = domSelection.anchorNode;\\n    });\\n  }\\n\\n  return {\\n    clearDiff: clearDiff,\\n    connect: connect,\\n    disconnect: disconnect,\\n    onKeyDown: startAction,\\n    onCompositionStart: onCompositionStart,\\n    onCompositionEnd: onCompositionEnd,\\n    onSelect: onSelect\\n  };\\n}\\n\\nfunction normalizeDOMSelection(selection) {\\n  return {\\n    anchorNode: selection.anchorNode,\\n    anchorOffset: selection.anchorOffset,\\n    focusNode: selection.focusNode,\\n    focusOffset: selection.focusOffset\\n  };\\n}\\n\\n/**\\n * Fixes a selection within the DOM when the cursor is in Slate's special\\n * zero-width block. Slate handles empty blocks in a special manner and the\\n * cursor can end up either before or after the non-breaking space. This\\n * causes different behavior in Android and so we make sure the seleciton is\\n * always before the zero-width space.\\n *\\n * @param {Window} window\\n */\\n\\nfunction fixSelectionInZeroWidthBlock(window) {\\n  var domSelection = window.getSelection();\\n  var anchorNode = domSelection.anchorNode;\\n\\n  if (anchorNode == null) return;\\n  var dataset = anchorNode.parentElement.dataset;\\n\\n  var isZeroWidth = dataset ? dataset.slateZeroWidth === 'n' : false;\\n\\n  if (isZeroWidth && anchorNode.textContent.length === 1 && domSelection.anchorOffset !== 0) {\\n    var range = window.document.createRange();\\n    range.setStart(anchorNode, 0);\\n    range.setEnd(anchorNode, 0);\\n    domSelection.removeAllRanges();\\n    domSelection.addRange(range);\\n  }\\n}\\n\\n/**\\n * Android Plugin\\n *\\n * @param {Editor} options.editor\\n */\\n\\nfunction AndroidPlugin(_ref) {\\n  var editor = _ref.editor;\\n\\n  var observer = new CompositionManager(editor);\\n\\n  /**\\n   * handle `onCompositionStart`\\n   */\\n\\n  function onCompositionStart() {\\n    observer.onCompositionStart();\\n  }\\n\\n  /**\\n   * handle `onCompositionEnd`\\n   */\\n\\n  function onCompositionEnd() {\\n    observer.onCompositionEnd();\\n  }\\n\\n  /**\\n   * handle `onSelect`\\n   *\\n   * @param {Event} event\\n   */\\n\\n  function onSelect(event) {\\n    var window = getWindow(event.target);\\n    fixSelectionInZeroWidthBlock(window);\\n    observer.onSelect(event);\\n  }\\n\\n  /**\\n   * handle `onComponentDidMount`\\n   */\\n\\n  function onComponentDidMount() {\\n    observer.connect();\\n  }\\n\\n  /**\\n   * handle `onComponentDidUpdate`\\n   */\\n\\n  function onComponentDidUpdate() {\\n    observer.connect();\\n  }\\n\\n  /**\\n   * handle `onComponentWillUnmount`\\n   *\\n   * @param {Event} event\\n   */\\n\\n  function onComponentWillUnmount() {\\n    observer.disconnect();\\n  }\\n\\n  /**\\n   * handle `onRender`\\n   *\\n   * @param {Event} event\\n   */\\n\\n  function onRender() {\\n    observer.disconnect();\\n\\n    // We don't want the `diff` from a previous render to apply to a\\n    // potentially different value (e.g. when we switch examples)\\n    observer.clearDiff();\\n  }\\n\\n  return {\\n    onComponentDidMount: onComponentDidMount,\\n    onComponentDidUpdate: onComponentDidUpdate,\\n    onComponentWillUnmount: onComponentWillUnmount,\\n    onCompositionEnd: onCompositionEnd,\\n    onCompositionStart: onCompositionStart,\\n    onRender: onRender,\\n    onSelect: onSelect\\n  };\\n}\\n\\n/**\\n * This plugin prevents events from going any further and is useful in dev.\\n *\\n * The purpose is to see how the editor events and mutations behave without\\n * the noise of the editor also adding its own events and mutations.\\n *\\n * IMPORTANT:\\n *\\n * This plugin is detached (i.e. there is no way to turn it on in Slate).\\n * You must hard code it into `plugins/react/index`.\\n *\\n * @return {Object}\\n */\\n\\nfunction NoopPlugin() {\\n  /**\\n   * Plugin Object\\n   *\\n   * @type {Object}\\n   */\\n\\n  var plugin = {};\\n\\n  var _iteratorNormalCompletion = true;\\n  var _didIteratorError = false;\\n  var _iteratorError = undefined;\\n\\n  try {\\n    for (var _iterator = EVENT_HANDLERS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n      var eventName = _step.value;\\n\\n      plugin[eventName] = function (event, editor, next) {};\\n    }\\n\\n    /**\\n     * Return the plugin.\\n     *\\n     * @type {Object}\\n     */\\n  } catch (err) {\\n    _didIteratorError = true;\\n    _iteratorError = err;\\n  } finally {\\n    try {\\n      if (!_iteratorNormalCompletion && _iterator.return) {\\n        _iterator.return();\\n      }\\n    } finally {\\n      if (_didIteratorError) {\\n        throw _iteratorError;\\n      }\\n    }\\n  }\\n\\n  return plugin;\\n}\\n\\n/**\\n * The transfer types that Slate recognizes.\\n *\\n * @type {Object}\\n */\\n\\nvar TRANSFER_TYPES = {\\n  FRAGMENT: 'application/x-slate-fragment',\\n  HTML: 'text/html',\\n  NODE: 'application/x-slate-node',\\n  RICH: 'text/rtf',\\n  TEXT: 'text/plain'\\n};\\n\\nvar FRAGMENT = TRANSFER_TYPES.FRAGMENT;\\nvar HTML = TRANSFER_TYPES.HTML;\\nvar TEXT = TRANSFER_TYPES.TEXT;\\n\\n/**\\n * Prepares a Slate document fragment to be copied to the clipboard.\\n *\\n * @param {Event} event\\n * @param {Editor} editor\\n */\\n\\nfunction cloneFragment(event, editor) {\\n  var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {\\n    return undefined;\\n  };\\n\\n  invariant(!slate.Value.isValue(editor), 'As of Slate 0.42.0, the `cloneFragment` utility takes an `editor` instead of a `value`.');\\n\\n  var window = getWindow(event.target);\\n  var native = window.getSelection();\\n  var value = editor.value;\\n  var document = value.document,\\n      fragment = value.fragment,\\n      selection = value.selection;\\n  var start = selection.start,\\n      end = selection.end;\\n\\n  var startVoid = document.getClosestVoid(start.path, editor);\\n  var endVoid = document.getClosestVoid(end.path, editor);\\n\\n  // If the selection is collapsed, and it isn't inside a void node, abort.\\n  if (native.isCollapsed && !startVoid) return;\\n\\n  // Create a fake selection so that we can add a Base64-encoded copy of the\\n  // fragment to the HTML, to decode on future pastes.\\n  var encoded = Base64.serializeNode(fragment);\\n  var range = native.getRangeAt(0);\\n  var contents = range.cloneContents();\\n  var attach = contents.childNodes[0];\\n\\n  // Make sure attach is a non-empty node, since empty nodes will not get copied\\n  contents.childNodes.forEach(function (node) {\\n    if (node.textContent && node.textContent.trim() !== '') {\\n      attach = node;\\n    }\\n  });\\n\\n  // COMPAT: If the end node is a void node, we need to move the end of the\\n  // range from the void node's spacer span, to the end of the void node's\\n  // content, since the spacer is before void's content in the DOM.\\n  if (endVoid) {\\n    var r = range.cloneRange();\\n    var path = document.getPath(endVoid.key);\\n\\n    if (path) {\\n      var node = editor.findDOMNode(path);\\n      r.setEndAfter(node);\\n      contents = r.cloneContents();\\n    }\\n  }\\n\\n  // COMPAT: If the start node is a void node, we need to attach the encoded\\n  // fragment to the void node's content node instead of the spacer, because\\n  // attaching it to empty `<div>/<span>` nodes will end up having it erased by\\n  // most browsers. (2018/04/27)\\n  if (startVoid) {\\n    attach = contents.childNodes[0].childNodes[1].firstChild;\\n  }\\n\\n  // Remove any zero-width space spans from the cloned DOM so that they don't\\n  // show up elsewhere when pasted.\\n  [].slice.call(contents.querySelectorAll(SELECTORS.ZERO_WIDTH)).forEach(function (zw) {\\n    var isNewline = zw.getAttribute(DATA_ATTRS.ZERO_WIDTH) === 'n';\\n    zw.textContent = isNewline ? '\\\\n' : '';\\n  });\\n\\n  // Set a `data-slate-fragment` attribute on a non-empty node, so it shows up\\n  // in the HTML, and can be used for intra-Slate pasting. If it's a text\\n  // node, wrap it in a `<span>` so we have something to set an attribute on.\\n  if (attach.nodeType === 3) {\\n    var span = window.document.createElement('span');\\n\\n    // COMPAT: In Chrome and Safari, if we don't add the `white-space` style\\n    // then leading and trailing spaces will be ignored. (2017/09/21)\\n    span.style.whiteSpace = 'pre';\\n\\n    span.appendChild(attach);\\n    contents.appendChild(span);\\n    attach = span;\\n  }\\n\\n  attach.setAttribute(DATA_ATTRS.FRAGMENT, encoded);\\n\\n  //  Creates value from only the selected blocks\\n  //  Then gets plaintext for clipboard with proper linebreaks for BLOCK elements\\n  //  Via Plain serializer\\n  var valFromSelection = slate.Value.create({ document: fragment });\\n  var plainText = Plain.serialize(valFromSelection);\\n\\n  // Add the phony content to a div element. This is needed to copy the\\n  // contents into the html clipboard register.\\n  var div = window.document.createElement('div');\\n  div.appendChild(contents);\\n\\n  // For browsers supporting it, we set the clipboard registers manually,\\n  // since the result is more predictable.\\n  // COMPAT: IE supports the setData method, but only in restricted sense.\\n  // IE doesn't support arbitrary MIME types or common ones like 'text/plain';\\n  // it only accepts \\\"Text\\\" (which gets mapped to 'text/plain') and \\\"Url\\\"\\n  // (mapped to 'text/url-list'); so, we should only enter block if !IS_IE\\n  if (event.clipboardData && event.clipboardData.setData && !slateDevEnvironment.IS_IE) {\\n    event.preventDefault();\\n    event.clipboardData.setData(TEXT, plainText);\\n    event.clipboardData.setData(FRAGMENT, encoded);\\n    event.clipboardData.setData(HTML, div.innerHTML);\\n    callback();\\n    return;\\n  }\\n\\n  // COMPAT: For browser that don't support the Clipboard API's setData method,\\n  // we must rely on the browser to natively copy what's selected.\\n  // So we add the div (containing our content) to the DOM, and select it.\\n  var editorEl = event.target.closest(SELECTORS.EDITOR);\\n  div.setAttribute('contenteditable', true);\\n  div.style.position = 'absolute';\\n  div.style.left = '-9999px';\\n  editorEl.appendChild(div);\\n  native.selectAllChildren(div);\\n\\n  // Revert to the previous selection right after copying.\\n  window.requestAnimationFrame(function () {\\n    editorEl.removeChild(div);\\n    removeAllRanges(native);\\n    native.addRange(range);\\n    callback();\\n  });\\n}\\n\\n/**\\n * Transfer types.\\n *\\n * @type {String}\\n */\\n\\nvar FRAGMENT$1 = TRANSFER_TYPES.FRAGMENT;\\nvar HTML$1 = TRANSFER_TYPES.HTML;\\nvar NODE = TRANSFER_TYPES.NODE;\\nvar RICH = TRANSFER_TYPES.RICH;\\nvar TEXT$1 = TRANSFER_TYPES.TEXT;\\n\\n/**\\n * Fragment matching regexp for HTML nodes.\\n *\\n * @type {RegExp}\\n */\\n\\nvar FRAGMENT_MATCHER = / data-slate-fragment=\\\"([^\\\\s\\\"]+)\\\"/;\\n\\n/**\\n * Get the transfer data from an `event`.\\n *\\n * @param {Event} event\\n * @return {Object}\\n */\\n\\nfunction getEventTransfer(event) {\\n  // COMPAT: IE 11 doesn't populate nativeEvent with either\\n  // dataTransfer or clipboardData. We'll need to use the base event\\n  // object (2018/14/6)\\n  if (!slateDevEnvironment.IS_IE && event.nativeEvent) {\\n    event = event.nativeEvent;\\n  }\\n\\n  var transfer = event.dataTransfer || event.clipboardData;\\n  var fragment = getType(transfer, FRAGMENT$1);\\n  var node = getType(transfer, NODE);\\n  var html = getType(transfer, HTML$1);\\n  var rich = getType(transfer, RICH);\\n  var text = getType(transfer, TEXT$1);\\n  var files = void 0;\\n\\n  // If there isn't a fragment, but there is HTML, check to see if the HTML is\\n  // actually an encoded fragment.\\n  if (!fragment && html && ~html.indexOf(' ' + DATA_ATTRS.FRAGMENT + '=\\\"')) {\\n    var matches = FRAGMENT_MATCHER.exec(html);\\n\\n    var _matches = slicedToArray(matches, 2),\\n        full = _matches[0],\\n        encoded = _matches[1]; // eslint-disable-line no-unused-vars\\n\\n\\n    if (encoded) fragment = encoded;\\n  }\\n\\n  // COMPAT: Edge doesn't handle custom data types\\n  // These will be embedded in text/plain in this case (2017/7/12)\\n  if (text) {\\n    var embeddedTypes = getEmbeddedTypes(text);\\n\\n    if (embeddedTypes[FRAGMENT$1]) fragment = embeddedTypes[FRAGMENT$1];\\n    if (embeddedTypes[NODE]) node = embeddedTypes[NODE];\\n    if (embeddedTypes[TEXT$1]) text = embeddedTypes[TEXT$1];\\n  }\\n\\n  // Decode a fragment or node if they exist.\\n  if (fragment) fragment = Base64.deserializeNode(fragment);\\n  if (node) node = Base64.deserializeNode(node);\\n\\n  // COMPAT: Edge sometimes throws 'NotSupportedError'\\n  // when accessing `transfer.items` (2017/7/12)\\n  try {\\n    // Get and normalize files if they exist.\\n    if (transfer.items && transfer.items.length) {\\n      files = Array.from(transfer.items).map(function (item) {\\n        return item.kind === 'file' ? item.getAsFile() : null;\\n      }).filter(function (exists) {\\n        return exists;\\n      });\\n    } else if (transfer.files && transfer.files.length) {\\n      files = Array.from(transfer.files);\\n    }\\n  } catch (err) {\\n    if (transfer.files && transfer.files.length) {\\n      files = Array.from(transfer.files);\\n    }\\n  }\\n\\n  // Determine the type of the data.\\n  var data = { files: files, fragment: fragment, html: html, node: node, rich: rich, text: text };\\n  data.type = getTransferType(data);\\n  return data;\\n}\\n\\n/**\\n * Takes text input, checks whether contains embedded data\\n * and returns object with original text +/- additional data\\n *\\n * @param {String} text\\n * @return {Object}\\n */\\n\\nfunction getEmbeddedTypes(text) {\\n  var prefix = 'SLATE-DATA-EMBED::';\\n\\n  if (text.substring(0, prefix.length) !== prefix) {\\n    return { TEXT: text };\\n  }\\n\\n  // Attempt to parse, if fails then just standard text/plain\\n  // Otherwise, already had data embedded\\n  try {\\n    return JSON.parse(text.substring(prefix.length));\\n  } catch (err) {\\n    throw new Error('Unable to parse custom Slate drag event data.');\\n  }\\n}\\n\\n/**\\n * Get the type of a transfer from its `data`.\\n *\\n * @param {Object} data\\n * @return {String}\\n */\\n\\nfunction getTransferType(data) {\\n  if (data.fragment) return 'fragment';\\n  if (data.node) return 'node';\\n\\n  // COMPAT: Microsoft Word adds an image of the selected text to the data.\\n  // Since files are preferred over HTML or text, this would cause the type to\\n  // be considered `files`. But it also adds rich text data so we can check\\n  // for that and properly set the type to `html` or `text`. (2016/11/21)\\n  if (data.rich && data.html) return 'html';\\n  if (data.rich && data.text) return 'text';\\n\\n  if (data.files && data.files.length) return 'files';\\n  if (data.html) return 'html';\\n  if (data.text) return 'text';\\n  return 'unknown';\\n}\\n\\n/**\\n * Get one of types `TYPES.FRAGMENT`, `TYPES.NODE`, `text/html`, `text/rtf` or\\n * `text/plain` from transfers's `data` if possible, otherwise return null.\\n *\\n * @param {Object} transfer\\n * @param {String} type\\n * @return {String}\\n */\\n\\nfunction getType(transfer, type) {\\n  if (!transfer.types || !transfer.types.length) {\\n    // COMPAT: In IE 11, there is no `types` field but `getData('Text')`\\n    // is supported`. (2017/06/23)\\n    return type === TEXT$1 ? transfer.getData('Text') || null : null;\\n  }\\n\\n  // COMPAT: In Edge, transfer.types doesn't respond to `indexOf`. (2017/10/25)\\n  var types = Array.from(transfer.types);\\n\\n  return types.indexOf(type) !== -1 ? transfer.getData(type) || null : null;\\n}\\n\\n/**\\n * The default plain text transfer type.\\n *\\n * @type {String}\\n */\\n\\nvar TEXT$2 = TRANSFER_TYPES.TEXT;\\n\\n/**\\n * Set data with `type` and `content` on an `event`.\\n *\\n * COMPAT: In Edge, custom types throw errors, so embed all non-standard\\n * types in text/plain compound object. (2017/7/12)\\n *\\n * @param {Event} event\\n * @param {String} type\\n * @param {String} content\\n */\\n\\nfunction setEventTransfer(event, type, content) {\\n  var mime = TRANSFER_TYPES[type.toUpperCase()];\\n\\n  if (!mime) {\\n    throw new Error('Cannot set unknown transfer type \\\"' + mime + '\\\".');\\n  }\\n\\n  if (event.nativeEvent) {\\n    event = event.nativeEvent;\\n  }\\n\\n  var transfer = event.dataTransfer || event.clipboardData;\\n\\n  try {\\n    transfer.setData(mime, content);\\n    // COMPAT: Safari needs to have the 'text' (and not 'text/plain') value in dataTransfer\\n    // to display the cursor while dragging internally.\\n    transfer.setData('text', transfer.getData('text'));\\n  } catch (err) {\\n    var prefix = 'SLATE-DATA-EMBED::';\\n    var text = transfer.getData(TEXT$2);\\n    var obj = {};\\n\\n    // If the existing plain text data is prefixed, it's Slate JSON data.\\n    if (text.substring(0, prefix.length) === prefix) {\\n      try {\\n        obj = JSON.parse(text.substring(prefix.length));\\n      } catch (e) {\\n        throw new Error('Failed to parse Slate data from `DataTransfer` object.');\\n      }\\n    } else {\\n      // Otherwise, it's just set it as is.\\n      obj[TEXT$2] = text;\\n    }\\n\\n    obj[mime] = content;\\n    var string = '' + prefix + JSON.stringify(obj);\\n    transfer.setData(TEXT$2, string);\\n  }\\n}\\n\\n/**\\n * Debug.\\n *\\n * @type {Function}\\n */\\n\\nvar debug$4 = Debug('slate:after');\\n\\n/**\\n * A plugin that adds the \\\"after\\\" browser-specific logic to the editor.\\n *\\n * @param {Object} options\\n * @return {Object}\\n */\\n\\nfunction AfterPlugin() {\\n  var isDraggingInternally = null;\\n  var isMouseDown = false;\\n\\n  /**\\n   * On before input.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onBeforeInput(event, editor, next) {\\n    var value = editor.value;\\n\\n    var isSynthetic = !!event.nativeEvent;\\n\\n    // If the event is synthetic, it's React's polyfill of `beforeinput` that\\n    // isn't a true `beforeinput` event with meaningful information. It only\\n    // gets triggered for character insertions, so we can just insert directly.\\n    if (isSynthetic) {\\n      event.preventDefault();\\n      editor.insertText(event.data);\\n      return next();\\n    }\\n\\n    // Otherwise, we can use the information in the `beforeinput` event to\\n    // figure out the exact change that will occur, and prevent it.\\n\\n    var _event$getTargetRange = event.getTargetRanges(),\\n        _event$getTargetRange2 = slicedToArray(_event$getTargetRange, 1),\\n        targetRange = _event$getTargetRange2[0];\\n\\n    if (!targetRange) return next();\\n\\n    debug$4('onBeforeInput', { event: event });\\n\\n    event.preventDefault();\\n\\n    var document = value.document,\\n        selection = value.selection;\\n\\n    var range = editor.findRange(targetRange);\\n\\n    switch (event.inputType) {\\n      case 'deleteByDrag':\\n      case 'deleteByCut':\\n      case 'deleteContent':\\n      case 'deleteContentBackward':\\n      case 'deleteContentForward':\\n        {\\n          editor.deleteAtRange(range);\\n          break;\\n        }\\n\\n      case 'deleteWordBackward':\\n        {\\n          editor.deleteWordBackwardAtRange(range);\\n          break;\\n        }\\n\\n      case 'deleteWordForward':\\n        {\\n          editor.deleteWordForwardAtRange(range);\\n          break;\\n        }\\n\\n      case 'deleteSoftLineBackward':\\n      case 'deleteHardLineBackward':\\n        {\\n          editor.deleteLineBackwardAtRange(range);\\n          break;\\n        }\\n\\n      case 'deleteSoftLineForward':\\n      case 'deleteHardLineForward':\\n        {\\n          editor.deleteLineForwardAtRange(range);\\n          break;\\n        }\\n\\n      case 'insertLineBreak':\\n      case 'insertParagraph':\\n        {\\n          var hasVoidParent = document.hasVoidParent(selection.start.path, editor);\\n\\n          if (hasVoidParent) {\\n            editor.moveToStartOfNextText();\\n          } else {\\n            editor.splitBlockAtRange(range);\\n          }\\n\\n          break;\\n        }\\n\\n      case 'insertFromYank':\\n      case 'insertReplacementText':\\n      case 'insertText':\\n        {\\n          // COMPAT: `data` should have the text for the `insertText` input type\\n          // and `dataTransfer` should have the text for the\\n          // `insertReplacementText` input type, but Safari uses `insertText` for\\n          // spell check replacements and sets `data` to `null`. (2018/08/09)\\n          var text = event.data == null ? event.dataTransfer.getData('text/plain') : event.data;\\n\\n          if (text == null) break;\\n\\n          editor.insertTextAtRange(range, text, selection.marks);\\n\\n          // If the text was successfully inserted, and the selection had marks\\n          // on it, unset the selection's marks.\\n          if (selection.marks && value.document !== editor.value.document) {\\n            editor.select({ marks: null });\\n          }\\n\\n          break;\\n        }\\n    }\\n\\n    next();\\n  }\\n\\n  /**\\n   * On blur.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onBlur(event, editor, next) {\\n    debug$4('onBlur', { event: event });\\n    editor.blur();\\n    next();\\n  }\\n\\n  /**\\n   * On click.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onClick(event, editor, next) {\\n    if (editor.readOnly) return next();\\n\\n    var value = editor.value;\\n    var document = value.document;\\n\\n    var path = editor.findPath(event.target);\\n    if (!path) return next();\\n\\n    debug$4('onClick', { event: event });\\n\\n    var node = document.getNode(path);\\n    var ancestors = document.getAncestors(path);\\n    var isVoid = node && (editor.isVoid(node) || ancestors.some(function (a) {\\n      return editor.isVoid(a);\\n    }));\\n\\n    if (isVoid) {\\n      // COMPAT: In Chrome & Safari, selections that are at the zero offset of\\n      // an inline node will be automatically replaced to be at the last offset\\n      // of a previous inline node, which screws us up, so we always want to set\\n      // it to the end of the node. (2016/11/29)\\n      editor.focus().moveToEndOfNode(node);\\n    }\\n\\n    next();\\n  }\\n\\n  /**\\n   * On copy.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onCopy(event, editor, next) {\\n    debug$4('onCopy', { event: event });\\n    cloneFragment(event, editor);\\n    next();\\n  }\\n\\n  /**\\n   * On cut.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onCut(event, editor, next) {\\n    debug$4('onCut', { event: event });\\n\\n    // Once the fake cut content has successfully been added to the clipboard,\\n    // delete the content in the current selection.\\n    cloneFragment(event, editor, function () {\\n      // If user cuts a void block node or a void inline node,\\n      // manually removes it since selection is collapsed in this case.\\n      var value = editor.value;\\n      var document = value.document,\\n          selection = value.selection;\\n      var end = selection.end,\\n          isCollapsed = selection.isCollapsed;\\n\\n      var voidPath = void 0;\\n\\n      if (isCollapsed) {\\n        var _iteratorNormalCompletion = true;\\n        var _didIteratorError = false;\\n        var _iteratorError = undefined;\\n\\n        try {\\n          for (var _iterator = document.ancestors(end.path)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n            var _ref = _step.value;\\n\\n            var _ref2 = slicedToArray(_ref, 2);\\n\\n            var node = _ref2[0];\\n            var path = _ref2[1];\\n\\n            if (editor.isVoid(node)) {\\n              voidPath = path;\\n              break;\\n            }\\n          }\\n        } catch (err) {\\n          _didIteratorError = true;\\n          _iteratorError = err;\\n        } finally {\\n          try {\\n            if (!_iteratorNormalCompletion && _iterator.return) {\\n              _iterator.return();\\n            }\\n          } finally {\\n            if (_didIteratorError) {\\n              throw _iteratorError;\\n            }\\n          }\\n        }\\n      }\\n\\n      if (voidPath) {\\n        editor.removeNodeByKey(voidPath);\\n      } else {\\n        editor.delete();\\n      }\\n    });\\n\\n    next();\\n  }\\n\\n  /**\\n   * On drag end.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onDragEnd(event, editor, next) {\\n    debug$4('onDragEnd', { event: event });\\n    isDraggingInternally = null;\\n    next();\\n  }\\n\\n  /**\\n   * On drag start.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onDragStart(event, editor, next) {\\n    debug$4('onDragStart', { event: event });\\n\\n    isDraggingInternally = true;\\n\\n    var value = editor.value;\\n    var document = value.document;\\n\\n    var path = editor.findPath(event.target);\\n    var node = document.getNode(path);\\n    var ancestors = document.getAncestors(path);\\n    var isVoid = node && (editor.isVoid(node) || ancestors.some(function (a) {\\n      return editor.isVoid(a);\\n    }));\\n    var selectionIncludesNode = value.blocks.some(function (block) {\\n      return block === node;\\n    });\\n\\n    // If a void block is dragged and is not selected, select it (necessary for local drags).\\n    if (isVoid && !selectionIncludesNode) {\\n      editor.moveToRangeOfNode(node);\\n    }\\n\\n    var fragment = editor.value.fragment;\\n    var encoded = Base64.serializeNode(fragment);\\n    setEventTransfer(event, 'fragment', encoded);\\n    next();\\n  }\\n\\n  /**\\n   * On drop.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onDrop(event, editor, next) {\\n    var value = editor.value;\\n    var document = value.document,\\n        selection = value.selection;\\n\\n    var window = getWindow(event.target);\\n    var target = editor.findEventRange(event);\\n\\n    if (!target) {\\n      return next();\\n    }\\n\\n    debug$4('onDrop', { event: event });\\n\\n    var transfer = getEventTransfer(event);\\n    var type = transfer.type,\\n        fragment = transfer.fragment,\\n        text = transfer.text;\\n\\n\\n    editor.focus();\\n\\n    // COMPAT: React's onSelect event breaks after an onDrop event\\n    // has fired in a node: https://github.com/facebook/react/issues/11379.\\n    // Until this is fixed in React, we dispatch a mouseup event on that\\n    // DOM node, since that will make it go back to normal.\\n    var el = editor.findDOMNode(target.focus.path);\\n\\n    if (el) {\\n      el.dispatchEvent(new MouseEvent('mouseup', {\\n        view: window,\\n        bubbles: true,\\n        cancelable: true\\n      }));\\n    }\\n\\n    var draggedRange = selection;\\n\\n    editor.select(target);\\n\\n    if (isDraggingInternally) {\\n      editor.deleteAtRange(draggedRange);\\n    }\\n\\n    if (type === 'text' || type === 'html') {\\n      var anchor = target.anchor;\\n\\n      var hasVoidParent = document.hasVoidParent(anchor.path, editor);\\n\\n      if (hasVoidParent) {\\n        var p = anchor.path;\\n        var n = document.getNode(anchor.path);\\n\\n        while (hasVoidParent) {\\n          var _document$texts = document.texts({ path: p }),\\n              _document$texts2 = slicedToArray(_document$texts, 1),\\n              nxt = _document$texts2[0];\\n\\n          if (!nxt) {\\n            break;\\n          }\\n\\n          \\n          var _nxt = slicedToArray(nxt, 2);\\n\\n          n = _nxt[0];\\n          p = _nxt[1];\\n\\n          hasVoidParent = document.hasVoidParent(p, editor);\\n        }\\n\\n        if (n) editor.moveToStartOfNode(n);\\n      }\\n\\n      if (text) {\\n        text.split('\\\\n').forEach(function (line, i) {\\n          if (i > 0) editor.splitBlock();\\n          editor.insertText(line);\\n        });\\n      }\\n    }\\n\\n    if (type === 'fragment') {\\n      editor.insertFragment(fragment);\\n    }\\n\\n    next();\\n  }\\n\\n  /**\\n   * On focus.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onFocus(event, editor, next) {\\n    debug$4('onFocus', { event: event });\\n\\n    // COMPAT: If the focus event is a mouse-based one, it will be shortly\\n    // followed by a `selectionchange`, so we need to deselect here to prevent\\n    // the old selection from being set by the `updateSelection` of `<Content>`,\\n    // preventing the `selectionchange` from firing. (2018/11/07)\\n    if (isMouseDown && !slateDevEnvironment.IS_IE && !slateDevEnvironment.IS_EDGE) {\\n      editor.deselect().focus();\\n    } else {\\n      editor.focus();\\n    }\\n\\n    next();\\n  }\\n\\n  /**\\n   * On input.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onInput(event, editor, next) {\\n    debug$4('onInput');\\n\\n    var window = getWindow(event.target);\\n    var domSelection = window.getSelection();\\n    var selection = editor.findSelection(domSelection);\\n\\n    if (selection) {\\n      editor.select(selection);\\n    } else {\\n      editor.blur();\\n    }\\n\\n    var anchorNode = domSelection.anchorNode;\\n\\n    editor.reconcileDOMNode(anchorNode);\\n\\n    next();\\n  }\\n\\n  /**\\n   * On key down.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onKeyDown(event, editor, next) {\\n    debug$4('onKeyDown', { event: event });\\n\\n    var value = editor.value;\\n    var document = value.document,\\n        selection = value.selection;\\n    var start = selection.start;\\n\\n    var hasVoidParent = document.hasVoidParent(start.path, editor);\\n\\n    // COMPAT: In iOS, some of these hotkeys are handled in the\\n    // `onNativeBeforeInput` handler of the `<Content>` component in order to\\n    // preserve native autocorrect behavior, so they shouldn't be handled here.\\n    if (Hotkeys.isSplitBlock(event) && !slateDevEnvironment.IS_IOS) {\\n      return hasVoidParent ? editor.moveToStartOfNextText() : editor.splitBlock();\\n    }\\n\\n    if (Hotkeys.isDeleteBackward(event) && !slateDevEnvironment.IS_IOS) {\\n      return editor.deleteCharBackward();\\n    }\\n\\n    if (Hotkeys.isDeleteForward(event) && !slateDevEnvironment.IS_IOS) {\\n      return editor.deleteCharForward();\\n    }\\n\\n    if (Hotkeys.isDeleteLineBackward(event)) {\\n      return editor.deleteLineBackward();\\n    }\\n\\n    if (Hotkeys.isDeleteLineForward(event)) {\\n      return editor.deleteLineForward();\\n    }\\n\\n    if (Hotkeys.isDeleteWordBackward(event)) {\\n      return editor.deleteWordBackward();\\n    }\\n\\n    if (Hotkeys.isDeleteWordForward(event)) {\\n      return editor.deleteWordForward();\\n    }\\n\\n    if (Hotkeys.isRedo(event)) {\\n      return editor.redo();\\n    }\\n\\n    if (Hotkeys.isUndo(event)) {\\n      return editor.undo();\\n    }\\n\\n    // COMPAT: Certain browsers don't handle the selection updates properly. In\\n    // Chrome, the selection isn't properly extended. And in Firefox, the\\n    // selection isn't properly collapsed. (2017/10/17)\\n    if (Hotkeys.isMoveLineBackward(event)) {\\n      event.preventDefault();\\n      return editor.moveToStartOfBlock();\\n    }\\n\\n    if (Hotkeys.isMoveLineForward(event)) {\\n      event.preventDefault();\\n      return editor.moveToEndOfBlock();\\n    }\\n\\n    if (Hotkeys.isExtendLineBackward(event)) {\\n      event.preventDefault();\\n      return editor.moveFocusToStartOfBlock();\\n    }\\n\\n    if (Hotkeys.isExtendLineForward(event)) {\\n      event.preventDefault();\\n      return editor.moveFocusToEndOfBlock();\\n    }\\n\\n    // COMPAT: If a void node is selected, or a zero-width text node adjacent to\\n    // an inline is selected, we need to handle these hotkeys manually because\\n    // browsers won't know what to do.\\n    if (Hotkeys.isMoveBackward(event)) {\\n      event.preventDefault();\\n\\n      if (!selection.isCollapsed) {\\n        return editor.moveToStart();\\n      }\\n\\n      return editor.moveBackward();\\n    }\\n\\n    if (Hotkeys.isMoveForward(event)) {\\n      event.preventDefault();\\n\\n      if (!selection.isCollapsed) {\\n        return editor.moveToEnd();\\n      }\\n\\n      return editor.moveForward();\\n    }\\n\\n    if (Hotkeys.isMoveWordBackward(event)) {\\n      event.preventDefault();\\n      return editor.moveWordBackward();\\n    }\\n\\n    if (Hotkeys.isMoveWordForward(event)) {\\n      event.preventDefault();\\n      return editor.moveWordForward();\\n    }\\n\\n    if (Hotkeys.isExtendBackward(event)) {\\n      var startText = document.getNode(start.path);\\n\\n      var _document$texts3 = document.texts({\\n        path: start.path,\\n        direction: 'backward'\\n      }),\\n          _document$texts4 = slicedToArray(_document$texts3, 1),\\n          prevEntry = _document$texts4[0];\\n\\n      var isPrevInVoid = false;\\n\\n      if (prevEntry) {\\n        var _prevEntry = slicedToArray(prevEntry, 2),\\n            prevPath = _prevEntry[1];\\n\\n        isPrevInVoid = document.hasVoidParent(prevPath, editor);\\n      }\\n\\n      if (hasVoidParent || isPrevInVoid || startText.text === '') {\\n        event.preventDefault();\\n        return editor.moveFocusBackward();\\n      }\\n    }\\n\\n    if (Hotkeys.isExtendForward(event)) {\\n      var _startText = document.getNode(start.path);\\n\\n      var _document$texts5 = document.texts({ path: start.path }),\\n          _document$texts6 = slicedToArray(_document$texts5, 1),\\n          nextEntry = _document$texts6[0];\\n\\n      var isNextInVoid = false;\\n\\n      if (nextEntry) {\\n        var _nextEntry = slicedToArray(nextEntry, 2),\\n            nextPath = _nextEntry[1];\\n\\n        isNextInVoid = document.hasVoidParent(nextPath, editor);\\n      }\\n\\n      if (hasVoidParent || isNextInVoid || _startText.text === '') {\\n        event.preventDefault();\\n        return editor.moveFocusForward();\\n      }\\n    }\\n\\n    next();\\n  }\\n\\n  /**\\n   * On mouse down.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onMouseDown(event, editor, next) {\\n    debug$4('onMouseDown', { event: event });\\n    isMouseDown = true;\\n    next();\\n  }\\n\\n  /**\\n   * On mouse up.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onMouseUp(event, editor, next) {\\n    debug$4('onMouseUp', { event: event });\\n    isMouseDown = false;\\n    next();\\n  }\\n\\n  /**\\n   * On paste.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onPaste(event, editor, next) {\\n    debug$4('onPaste', { event: event });\\n\\n    var value = editor.value;\\n\\n    var transfer = getEventTransfer(event);\\n    var type = transfer.type,\\n        fragment = transfer.fragment,\\n        text = transfer.text;\\n\\n\\n    if (type === 'fragment') {\\n      editor.insertFragment(fragment);\\n    }\\n\\n    if (type === 'text' || type === 'html') {\\n      if (!text) return next();\\n      var document = value.document,\\n          selection = value.selection,\\n          startBlock = value.startBlock;\\n\\n      if (editor.isVoid(startBlock)) return next();\\n\\n      var defaultBlock = startBlock;\\n      var defaultMarks = document.getInsertMarksAtRange(selection);\\n      var frag = Plain.deserialize(text, { defaultBlock: defaultBlock, defaultMarks: defaultMarks }).document;\\n      editor.insertFragment(frag);\\n    }\\n\\n    next();\\n  }\\n\\n  /**\\n   * On select.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onSelect(event, editor, next) {\\n    debug$4('onSelect', { event: event });\\n    var window = getWindow(event.target);\\n    var domSelection = window.getSelection();\\n    var selection = editor.findSelection(domSelection);\\n\\n    if (selection) {\\n      editor.select(selection);\\n    } else {\\n      editor.blur();\\n    }\\n\\n    // COMPAT: reset the `isMouseDown` state here in case a `mouseup` event\\n    // happens outside the editor. This is needed for `onFocus` handling.\\n    isMouseDown = false;\\n\\n    next();\\n  }\\n\\n  /**\\n   * Return the plugin.\\n   *\\n   * @type {Object}\\n   */\\n\\n  return {\\n    onBeforeInput: onBeforeInput,\\n    onBlur: onBlur,\\n    onClick: onClick,\\n    onCopy: onCopy,\\n    onCut: onCut,\\n    onDragEnd: onDragEnd,\\n    onDragStart: onDragStart,\\n    onDrop: onDrop,\\n    onFocus: onFocus,\\n    onInput: onInput,\\n    onKeyDown: onKeyDown,\\n    onMouseDown: onMouseDown,\\n    onMouseUp: onMouseUp,\\n    onPaste: onPaste,\\n    onSelect: onSelect\\n  };\\n}\\n\\n/**\\n * Debug.\\n *\\n * @type {Function}\\n */\\n\\nvar debug$5 = Debug('slate:before');\\n\\n/**\\n * A plugin that adds the \\\"before\\\" browser-specific logic to the editor.\\n *\\n * @return {Object}\\n */\\n\\nfunction BeforePlugin() {\\n  var activeElement = null;\\n  var compositionCount = 0;\\n  var isComposing = false;\\n  var isCopying = false;\\n  var isDragging = false;\\n  var isUserActionPerformed = false;\\n\\n  /**\\n   * On before input.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onBeforeInput(event, editor, next) {\\n    var isSynthetic = !!event.nativeEvent;\\n    if (editor.readOnly) return;\\n    isUserActionPerformed = true;\\n\\n    // COMPAT: If the browser supports Input Events Level 2, we will have\\n    // attached a custom handler for the real `beforeinput` events, instead of\\n    // allowing React's synthetic polyfill, so we need to ignore synthetics.\\n    if (isSynthetic && slateDevEnvironment.HAS_INPUT_EVENTS_LEVEL_2) return;\\n\\n    debug$5('onBeforeInput', { event: event });\\n    next();\\n  }\\n\\n  /**\\n   * On blur.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onBlur(event, editor, next) {\\n    if (isCopying) return;\\n    if (editor.readOnly) return;\\n\\n    var relatedTarget = event.relatedTarget,\\n        target = event.target;\\n\\n    var window = getWindow(target);\\n\\n    // COMPAT: If the current `activeElement` is still the previous one, this is\\n    // due to the window being blurred when the tab itself becomes unfocused, so\\n    // we want to abort early to allow to editor to stay focused when the tab\\n    // becomes focused again.\\n    if (activeElement === window.document.activeElement) return;\\n\\n    // COMPAT: The `relatedTarget` can be null when the new focus target is not\\n    // a \\\"focusable\\\" element (eg. a `<div>` without `tabindex` set).\\n    if (relatedTarget) {\\n      var el = editor.findDOMNode([]);\\n\\n      // COMPAT: The event should be ignored if the focus is returning to the\\n      // editor from an embedded editable element (eg. an <input> element inside\\n      // a void node).\\n      if (relatedTarget === el) return;\\n\\n      // COMPAT: The event should be ignored if the focus is moving from the\\n      // editor to inside a void node's spacer element.\\n      if (relatedTarget.hasAttribute(DATA_ATTRS.SPACER)) return;\\n\\n      // COMPAT: The event should be ignored if the focus is moving to a non-\\n      // editable section of an element that isn't a void node (eg. a list item\\n      // of the check list example).\\n      var node = editor.findNode(relatedTarget);\\n\\n      if (el.contains(relatedTarget) && node && !editor.isVoid(node)) {\\n        return;\\n      }\\n    }\\n\\n    debug$5('onBlur', { event: event });\\n    next();\\n  }\\n\\n  /**\\n   * On composition end.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onCompositionEnd(event, editor, next) {\\n    var n = compositionCount;\\n    isUserActionPerformed = true;\\n\\n    // The `count` check here ensures that if another composition starts\\n    // before the timeout has closed out this one, we will abort unsetting the\\n    // `isComposing` flag, since a composition is still in affect.\\n    window.requestAnimationFrame(function () {\\n      if (compositionCount > n) return;\\n      isComposing = false;\\n    });\\n\\n    debug$5('onCompositionEnd', { event: event });\\n    next();\\n  }\\n\\n  /**\\n   * On click.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onClick(event, editor, next) {\\n    debug$5('onClick', { event: event });\\n    isUserActionPerformed = true;\\n    next();\\n  }\\n\\n  /**\\n   * On composition start.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onCompositionStart(event, editor, next) {\\n    isComposing = true;\\n    compositionCount++;\\n\\n    var value = editor.value;\\n    var selection = value.selection;\\n\\n    isUserActionPerformed = true;\\n\\n    if (!selection.isCollapsed) {\\n      // https://github.com/ianstormtaylor/slate/issues/1879\\n      // When composition starts and the current selection is not collapsed, the\\n      // second composition key-down would drop the text wrapping <spans> which\\n      // resulted on crash in content.updateSelection after composition ends\\n      // (because it cannot find <span> nodes in DOM). This is a workaround that\\n      // erases selection as soon as composition starts and preventing <spans>\\n      // to be dropped.\\n      editor.delete();\\n    }\\n\\n    debug$5('onCompositionStart', { event: event });\\n    next();\\n  }\\n\\n  /**\\n   * On copy.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onCopy(event, editor, next) {\\n    var window = getWindow(event.target);\\n    isCopying = true;\\n    window.requestAnimationFrame(function () {\\n      return isCopying = false;\\n    });\\n\\n    debug$5('onCopy', { event: event });\\n    next();\\n  }\\n\\n  /**\\n   * On cut.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onCut(event, editor, next) {\\n    if (editor.readOnly) return;\\n\\n    var window = getWindow(event.target);\\n    isCopying = true;\\n    window.requestAnimationFrame(function () {\\n      return isCopying = false;\\n    });\\n\\n    debug$5('onCut', { event: event });\\n    next();\\n  }\\n\\n  /**\\n   * On drag end.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onDragEnd(event, editor, next) {\\n    isDragging = false;\\n    debug$5('onDragEnd', { event: event });\\n    next();\\n  }\\n\\n  /**\\n   * On drag enter.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onDragEnter(event, editor, next) {\\n    debug$5('onDragEnter', { event: event });\\n    next();\\n  }\\n\\n  /**\\n   * On drag exit.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onDragExit(event, editor, next) {\\n    debug$5('onDragExit', { event: event });\\n    next();\\n  }\\n\\n  /**\\n   * On drag leave.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onDragLeave(event, editor, next) {\\n    debug$5('onDragLeave', { event: event });\\n    next();\\n  }\\n\\n  /**\\n   * On drag over.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onDragOver(event, editor, next) {\\n    // If the target is inside a void node, and only in this case,\\n    // call `preventDefault` to signal that drops are allowed.\\n    // When the target is editable, dropping is already allowed by\\n    // default, and calling `preventDefault` hides the cursor.\\n    var node = editor.findNode(event.target);\\n\\n    if (!node || editor.isVoid(node)) {\\n      event.preventDefault();\\n    }\\n\\n    // COMPAT: IE won't call onDrop on contentEditables unless the\\n    // default dragOver is prevented:\\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/913982/\\n    // (2018/07/11)\\n    if (slateDevEnvironment.IS_IE) {\\n      event.preventDefault();\\n    }\\n\\n    // If a drag is already in progress, don't do this again.\\n    if (!isDragging) {\\n      isDragging = true;\\n\\n      // COMPAT: IE will raise an `unspecified error` if dropEffect is\\n      // set. (2018/07/11)\\n      if (!slateDevEnvironment.IS_IE) {\\n        event.nativeEvent.dataTransfer.dropEffect = 'move';\\n      }\\n    }\\n\\n    debug$5('onDragOver', { event: event });\\n    next();\\n  }\\n\\n  /**\\n   * On drag start.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onDragStart(event, editor, next) {\\n    isDragging = true;\\n    debug$5('onDragStart', { event: event });\\n    next();\\n  }\\n\\n  /**\\n   * On drop.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onDrop(event, editor, next) {\\n    if (editor.readOnly) return;\\n    isUserActionPerformed = true;\\n\\n    // Prevent default so the DOM's value isn't corrupted.\\n    event.preventDefault();\\n\\n    debug$5('onDrop', { event: event });\\n    next();\\n  }\\n\\n  /**\\n   * On focus.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onFocus(event, editor, next) {\\n    if (isCopying) return;\\n    if (editor.readOnly) return;\\n\\n    var el = editor.findDOMNode([]);\\n\\n    // Save the new `activeElement`.\\n    var window = getWindow(event.target);\\n    activeElement = window.document.activeElement;\\n\\n    // COMPAT: If the editor has nested editable elements, the focus can go to\\n    // those elements. In Firefox, this must be prevented because it results in\\n    // issues with keyboard navigation. (2017/03/30)\\n    if (slateDevEnvironment.IS_FIREFOX && event.target !== el) {\\n      el.focus();\\n      return;\\n    }\\n\\n    debug$5('onFocus', { event: event });\\n    next();\\n  }\\n\\n  /**\\n   * On input.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onInput(event, editor, next) {\\n    if (isComposing) return;\\n    if (editor.value.selection.isBlurred) return;\\n    isUserActionPerformed = true;\\n    debug$5('onInput', { event: event });\\n    next();\\n  }\\n\\n  /**\\n   * On key down.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onKeyDown(event, editor, next) {\\n    if (editor.readOnly) return;\\n\\n    // When composing, we need to prevent all hotkeys from executing while\\n    // typing. However, certain characters also move the selection before\\n    // we're able to handle it, so prevent their default behavior.\\n    if (isComposing) {\\n      if (Hotkeys.isCompose(event)) event.preventDefault();\\n      return;\\n    }\\n\\n    // Certain hotkeys have native editing behaviors in `contenteditable`\\n    // elements which will editor the DOM and cause our value to be out of sync,\\n    // so they need to always be prevented.\\n    if (!slateDevEnvironment.IS_IOS && (Hotkeys.isBold(event) || Hotkeys.isDeleteBackward(event) || Hotkeys.isDeleteForward(event) || Hotkeys.isDeleteLineBackward(event) || Hotkeys.isDeleteLineForward(event) || Hotkeys.isDeleteWordBackward(event) || Hotkeys.isDeleteWordForward(event) || Hotkeys.isItalic(event) || Hotkeys.isRedo(event) || Hotkeys.isSplitBlock(event) || Hotkeys.isTransposeCharacter(event) || Hotkeys.isUndo(event))) {\\n      event.preventDefault();\\n    }\\n\\n    isUserActionPerformed = true;\\n    debug$5('onKeyDown', { event: event });\\n    next();\\n  }\\n\\n  /**\\n   * On paste.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onPaste(event, editor, next) {\\n    if (editor.readOnly) return;\\n    isUserActionPerformed = true;\\n\\n    // Prevent defaults so the DOM state isn't corrupted.\\n    event.preventDefault();\\n\\n    debug$5('onPaste', { event: event });\\n    next();\\n  }\\n\\n  /**\\n   * On select.\\n   *\\n   * @param {Event} event\\n   * @param {Editor} editor\\n   * @param {Function} next\\n   */\\n\\n  function onSelect(event, editor, next) {\\n    if (isCopying) return;\\n    if (isComposing) return;\\n\\n    if (editor.readOnly) return;\\n\\n    // Save the new `activeElement`.\\n    var window = getWindow(event.target);\\n    activeElement = window.document.activeElement;\\n    isUserActionPerformed = true;\\n\\n    debug$5('onSelect', { event: event });\\n    next();\\n  }\\n\\n  function userActionPerformed() {\\n    return isUserActionPerformed;\\n  }\\n\\n  function clearUserActionPerformed() {\\n    isUserActionPerformed = false;\\n    return null;\\n  }\\n\\n  /**\\n   * Return the plugin.\\n   *\\n   * @type {Object}\\n   */\\n\\n  return {\\n    onBeforeInput: onBeforeInput,\\n    onBlur: onBlur,\\n    onClick: onClick,\\n    onCompositionEnd: onCompositionEnd,\\n    onCompositionStart: onCompositionStart,\\n    onCopy: onCopy,\\n    onCut: onCut,\\n    onDragEnd: onDragEnd,\\n    onDragEnter: onDragEnter,\\n    onDragExit: onDragExit,\\n    onDragLeave: onDragLeave,\\n    onDragOver: onDragOver,\\n    onDragStart: onDragStart,\\n    onDrop: onDrop,\\n    onFocus: onFocus,\\n    onInput: onInput,\\n    onKeyDown: onKeyDown,\\n    onPaste: onPaste,\\n    onSelect: onSelect,\\n    queries: { userActionPerformed: userActionPerformed },\\n    commands: { clearUserActionPerformed: clearUserActionPerformed }\\n  };\\n}\\n\\n/**\\n * A plugin that adds the browser-specific logic to the editor.\\n *\\n * @param {Object} options\\n * @return {Object}\\n */\\n\\nfunction DOMPlugin() {\\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n  var _options$plugins = options.plugins,\\n      plugins = _options$plugins === undefined ? [] : _options$plugins;\\n\\n  var beforePlugin = BeforePlugin();\\n  var afterPlugin = AfterPlugin();\\n\\n  // COMPAT: Add Android specific handling separately before it gets to the\\n  // other plugins because it is specific (other browser don't need it) and\\n  // finicky (it has to come before other plugins to work).\\n  var androidPlugins = slateDevEnvironment.IS_ANDROID ? [AndroidPlugin(options), NoopPlugin(options)] : [];\\n\\n  return [].concat(androidPlugins, [beforePlugin], toConsumableArray(plugins), [afterPlugin]);\\n}\\n\\nfunction RestoreDOMPlugin() {\\n  /**\\n   * Makes sure that on the next Content `render` the DOM is restored.\\n   * This gets us around issues where the DOM is in a different state than\\n   * React's virtual DOM and would crash.\\n   *\\n   * @param {Editor} editor\\n   */\\n\\n  function restoreDOM(editor) {\\n    var tmp = editor.tmp.contentRef.current.tmp;\\n    tmp.contentKey = tmp.contentKey + 1;\\n  }\\n\\n  return {\\n    commands: {\\n      restoreDOM: restoreDOM\\n    }\\n  };\\n}\\n\\n/**\\n * Takes a React Synthetic Event or a DOM Event and turns it into a String that\\n * is easy to log. It's succinct and keeps info to a bare minimum.\\n *\\n * @param {Event} event\\n */\\n\\nfunction stringifyEvent(event) {\\n  var e = event.nativeEvent || event;\\n\\n  switch (e.type) {\\n    case 'keydown':\\n      return e.type + ' ' + JSON.stringify(e.key);\\n    case 'input':\\n    case 'beforeinput':\\n    case 'textInput':\\n      return e.type + ':' + e.inputType + ' ' + JSON.stringify(e.data);\\n    default:\\n      return e.type;\\n  }\\n}\\n\\n/**\\n * Debug events function.\\n *\\n * @type {Function}\\n */\\n\\nvar debug$6 = Debug('slate:events');\\n\\n/**\\n * A plugin that sends short easy to digest debug info about each event to\\n * browser.\\n *\\n * @return {Object}\\n */\\n\\nfunction DebugEventsPlugin() {\\n  /**\\n   * Plugin Object\\n   *\\n   * @type {Object}\\n   */\\n\\n  var plugin = {};\\n\\n  var _iteratorNormalCompletion = true;\\n  var _didIteratorError = false;\\n  var _iteratorError = undefined;\\n\\n  try {\\n    for (var _iterator = EVENT_HANDLERS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n      var eventName = _step.value;\\n\\n      plugin[eventName] = function (event, editor, next) {\\n        var s = stringifyEvent(event);\\n        debug$6(s);\\n        next();\\n      };\\n    }\\n\\n    /**\\n     * Return the plugin.\\n     *\\n     * @type {Object}\\n     */\\n  } catch (err) {\\n    _didIteratorError = true;\\n    _iteratorError = err;\\n  } finally {\\n    try {\\n      if (!_iteratorNormalCompletion && _iterator.return) {\\n        _iterator.return();\\n      }\\n    } finally {\\n      if (_didIteratorError) {\\n        throw _iteratorError;\\n      }\\n    }\\n  }\\n\\n  return plugin;\\n}\\n\\n/**\\n * Constants\\n */\\n\\nvar INTERVAL = 2000;\\n\\n/**\\n * Debug events function.\\n *\\n * @type {Function}\\n */\\n\\nvar debug$7 = Debug('slate:batch-events');\\n\\n/**\\n * A plugin that sends short easy to digest debug info about each event to\\n * browser.\\n *\\n * @return {Object}\\n */\\n\\nfunction DebugBatchEventsPlugin() {\\n  /**\\n   * When the batch started\\n   *\\n   * @type {Date}\\n   */\\n\\n  var startDate = null;\\n\\n  /**\\n   * The timeoutId used to cancel the timeout\\n   *\\n   * @type {Any}\\n   */\\n\\n  var timeoutId = null;\\n\\n  /**\\n   * An array of events not yet dumped with `debug`\\n   *\\n   * @type {Array}\\n   */\\n\\n  var events = [];\\n\\n  /**\\n   * Send all events to debug\\n   *\\n   * Note: Formatted so it can easily be cut and pasted as text for analysis or\\n   * documentation.\\n   */\\n\\n  function dumpEvents() {\\n    debug$7('\\\\n' + events.join('\\\\n'));\\n    events.length = 0;\\n  }\\n\\n  /**\\n   * Push an event on to the Array of events for debugging in a batch\\n   *\\n   * @param {Event} event\\n   */\\n\\n  function pushEvent(event) {\\n    if (events.length === 0) {\\n      startDate = new Date();\\n    }\\n\\n    var s = stringifyEvent(event);\\n    var now = new Date();\\n    events.push('- ' + (now - startDate) + ' - ' + s);\\n    clearTimeout(timeoutId);\\n    timeoutId = setTimeout(dumpEvents, INTERVAL);\\n  }\\n\\n  /**\\n   * Plugin Object\\n   *\\n   * @type {Object}\\n   */\\n\\n  var plugin = {};\\n\\n  var _iteratorNormalCompletion = true;\\n  var _didIteratorError = false;\\n  var _iteratorError = undefined;\\n\\n  try {\\n    for (var _iterator = EVENT_HANDLERS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n      var eventName = _step.value;\\n\\n      plugin[eventName] = function (event, editor, next) {\\n        pushEvent(event);\\n        next();\\n      };\\n    }\\n\\n    /**\\n     * Return the plugin.\\n     *\\n     * @type {Object}\\n     */\\n  } catch (err) {\\n    _didIteratorError = true;\\n    _iteratorError = err;\\n  } finally {\\n    try {\\n      if (!_iteratorNormalCompletion && _iterator.return) {\\n        _iterator.return();\\n      }\\n    } finally {\\n      if (_didIteratorError) {\\n        throw _iteratorError;\\n      }\\n    }\\n  }\\n\\n  return plugin;\\n}\\n\\n/**\\n * Debug mutations function.\\n *\\n * @type {Function}\\n */\\n\\nvar debug$8 = Debug('slate:mutations');\\n\\n/**\\n * Properties on a MutationRecord\\n *\\n * @type {Object}\\n */\\n\\nvar MUTATION_PROPERTIES = ['type', 'oldValue', 'target', 'addedNodes', 'removedNodes', 'attributeName', 'attributeNamespace', 'nextSibling', 'previousSibling'];\\n\\n/**\\n * Takes a DOM node and returns an easily readable version of it.\\n *\\n * @param {DOMNode} node\\n */\\n\\nfunction normalizeNode(node) {\\n  if (node.nodeType === window.Node.TEXT_NODE) {\\n    return node.textContent;\\n  } else if (node.nodeType === window.Node.ELEMENT_NODE) {\\n    var outerHTML = node.outerHTML,\\n        innerHTML = node.innerHTML;\\n\\n    if (outerHTML == null) return JSON.stringify(node.textContent);\\n    return outerHTML.slice(0, outerHTML.indexOf(innerHTML));\\n  } else {\\n    return 'Node(type=' + node.nodeType;\\n  }\\n}\\n\\n/**\\n * A plugin that sends short easy to digest debug info about each dom mutation\\n * to browser.\\n *\\n * More information about mutations here:\\n *\\n * <https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver>\\n * <https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord>\\n *\\n * @param {Object} options\\n */\\n\\nfunction DebugMutationsPlugin() {\\n  var observer = new window.MutationObserver(function (mutations) {\\n    var array = Array.from(mutations).map(function (mutationRecord) {\\n      var object = {};\\n\\n      // Only add properties that provide meaningful values to the object\\n      // to make the debug info easier to read\\n      MUTATION_PROPERTIES.forEach(function (key) {\\n        var value = mutationRecord[key];\\n        if (value == null) return;\\n\\n        // Make NodeList easier to read\\n        if (value instanceof window.NodeList) {\\n          if (value.length === 0) return;\\n\\n          object[key] = Array.from(value).map(normalizeNode).join(', ');\\n          return;\\n        }\\n\\n        // Make Node easier to read\\n        if (value instanceof window.Node) {\\n          value = normalizeNode(value);\\n        }\\n\\n        object[key] = value;\\n      });\\n\\n      return object;\\n    });\\n\\n    // The first argument must not be the array as `debug` renders the first\\n    // argument in a different way than the rest\\n    debug$8.apply(undefined, [array.length + ' Mutations'].concat(toConsumableArray(array)));\\n  });\\n\\n  /**\\n   * The previously observed DOM node\\n   *\\n   * @type {DOMNode}\\n   */\\n\\n  var prevRootEl = null;\\n\\n  /**\\n   * Start observing the DOM node for mutations if it isn't being observed\\n   */\\n\\n  function start(event, editor, next) {\\n    var rootEl = editor.findDOMNode([]);\\n\\n    if (rootEl === prevRootEl) return next();\\n\\n    debug$8('start');\\n\\n    observer.observe(rootEl, {\\n      childList: true,\\n      characterData: true,\\n      attributes: true,\\n      subtree: true,\\n      characterDataOldValue: true\\n    });\\n\\n    prevRootEl = rootEl;\\n\\n    next();\\n  }\\n\\n  /**\\n   * Stop observing the DOM node for mutations\\n   */\\n\\n  function stop(event, editor, next) {\\n    debug$8('stop');\\n\\n    observer.disconnect();\\n    prevRootEl = null;\\n    next();\\n  }\\n\\n  return {\\n    onComponentDidMount: start,\\n    onComponentDidUpdate: start,\\n    onComponentWillUnmount: stop\\n  };\\n}\\n\\n/**\\n * A plugin that adds the React-specific rendering logic to the editor.\\n *\\n * @param {Object} options\\n * @return {Object}\\n */\\n\\nfunction ReactPlugin() {\\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\\n  var _options$placeholder = options.placeholder,\\n      placeholder = _options$placeholder === undefined ? '' : _options$placeholder;\\n\\n  var debugEventsPlugin = Debug.enabled('slate:events') ? DebugEventsPlugin(options) : null;\\n  var debugBatchEventsPlugin = Debug.enabled('slate:batch-events') ? DebugBatchEventsPlugin(options) : null;\\n  var debugMutationsPlugin = Debug.enabled('slate:mutations') ? DebugMutationsPlugin(options) : null;\\n  var renderingPlugin = Rendering(options);\\n  var commandsPlugin = CommandsPlugin(options);\\n  var queriesPlugin = QueriesPlugin(options);\\n  var editorPropsPlugin = EditorPropsPlugin(options);\\n  var domPlugin = DOMPlugin(options);\\n  var restoreDomPlugin = RestoreDOMPlugin();\\n\\n  // Disable placeholder for Android because it messes with reconciliation\\n  // and doesn't disappear until composition is complete.\\n  // e.g. In empty, type \\\"h\\\" and autocomplete on Android 9 and deletes all text.\\n  var placeholderPlugin = slateDevEnvironment.IS_ANDROID ? null : PlaceholderPlugin({\\n    placeholder: placeholder,\\n    when: function when(editor, node) {\\n      return node.object === 'document' && node.text === '' && node.nodes.size === 1 && Array.from(node.texts()).length === 1;\\n    }\\n  });\\n\\n  return [debugEventsPlugin, debugBatchEventsPlugin, debugMutationsPlugin, editorPropsPlugin, domPlugin, restoreDomPlugin, placeholderPlugin, renderingPlugin, commandsPlugin, queriesPlugin];\\n}\\n\\n/**\\n * Debug.\\n *\\n * @type {Function}\\n */\\n\\nvar debug$9 = Debug('slate:editor');\\n\\n/**\\n * Editor.\\n *\\n * @type {Component}\\n */\\n\\nvar Editor = function (_React$Component) {\\n  inherits(Editor, _React$Component);\\n\\n  function Editor() {\\n    var _ref;\\n\\n    var _temp, _this, _ret;\\n\\n    classCallCheck(this, Editor);\\n\\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\\n      args[_key] = arguments[_key];\\n    }\\n\\n    return _ret = (_temp = (_this = possibleConstructorReturn(this, (_ref = Editor.__proto__ || Object.getPrototypeOf(Editor)).call.apply(_ref, [this].concat(args))), _this), _this.state = { value: _this.props.defaultValue, contentKey: 0\\n\\n      /**\\n       * Temporary values.\\n       *\\n       * @type {Object}\\n       */\\n\\n    }, _this.tmp = {\\n      mounted: false,\\n      change: null,\\n      resolves: 0,\\n      updates: 0,\\n      contentRef: React.createRef()\\n\\n      /**\\n       * When the component first mounts, flush a queued change if one exists.\\n       */\\n\\n    }, _this.resolveController = memoizeOne(function () {\\n      var TheReactPlugin = arguments[5];\\n\\n      // If we've resolved a few times already, and it's exactly in line with\\n      // the updates, then warn the user that they may be doing something wrong.\\n      warning(_this.tmp.resolves < 5 || _this.tmp.resolves !== _this.tmp.updates, 'A Slate <Editor> component is re-resolving the `plugins`, `schema`, `commands`, `queries` or `placeholder` prop on each update, which leads to poor performance. This is often due to passing in a new references for these props with each render by declaring them inline in your render function. Do not do this! Declare them outside your render function, or memoize them instead.');\\n\\n      _this.tmp.resolves++;\\n      var react = TheReactPlugin(_extends({}, _this.props, {\\n        editor: _this,\\n        value: _this.props.value || _this.state.value\\n      }));\\n\\n      var onChange = function onChange(change) {\\n        if (_this.tmp.mounted) {\\n          _this.handleChange(change);\\n        } else {\\n          _this.tmp.change = change;\\n        }\\n      };\\n\\n      _this.controller = new slate.Editor({ plugins: [react], onChange: onChange }, { controller: _this, construct: false });\\n\\n      _this.controller.run('onConstruct');\\n    }), _temp), possibleConstructorReturn(_this, _ret);\\n  }\\n  /**\\n   * Property types.\\n   *\\n   * @type {Object}\\n   */\\n\\n  /**\\n   * Default properties.\\n   *\\n   * @type {Object}\\n   */\\n\\n  /**\\n   * Initial state.\\n   *\\n   * @type {Object}\\n   */\\n\\n  createClass(Editor, [{\\n    key: 'componentDidMount',\\n    value: function componentDidMount() {\\n      this.tmp.mounted = true;\\n      this.tmp.updates++;\\n\\n      if (this.props.autoFocus) {\\n        this.focus();\\n      }\\n\\n      if (this.tmp.change) {\\n        this.handleChange(this.tmp.change);\\n        this.tmp.change = null;\\n      }\\n    }\\n\\n    /**\\n     * When the component updates, flush a queued change if one exists.\\n     */\\n\\n  }, {\\n    key: 'componentDidUpdate',\\n    value: function componentDidUpdate() {\\n      this.tmp.updates++;\\n\\n      if (this.tmp.change) {\\n        this.handleChange(this.tmp.change);\\n        this.tmp.change = null;\\n      }\\n    }\\n\\n    /**\\n     * When the component unmounts, make sure async commands don't trigger react updates.\\n     */\\n\\n  }, {\\n    key: 'componentWillUnmount',\\n    value: function componentWillUnmount() {\\n      this.tmp.mounted = false;\\n    }\\n\\n    /**\\n     * Render the editor.\\n     *\\n     * @return {Element}\\n     */\\n\\n  }, {\\n    key: 'render',\\n    value: function render() {\\n      var _this2 = this;\\n\\n      debug$9('render', this);\\n\\n      // Re-resolve the controller if needed based on memoized props.\\n      var _props = this.props,\\n          commands = _props.commands,\\n          placeholder = _props.placeholder,\\n          plugins = _props.plugins,\\n          queries = _props.queries,\\n          schema = _props.schema;\\n\\n\\n      this.resolveController(plugins, schema, commands, queries, placeholder, ReactPlugin);\\n\\n      // Set the current props on the controller.\\n      var _props2 = this.props,\\n          options = _props2.options,\\n          readOnly = _props2.readOnly,\\n          valueFromProps = _props2.value;\\n      var valueFromState = this.state.value;\\n\\n      var value = valueFromProps || valueFromState;\\n      var contentKey = this.state.contentKey;\\n\\n      this.controller.setReadOnly(readOnly);\\n      this.controller.setValue(value, options);\\n\\n      var _props3 = this.props,\\n          autoCorrect = _props3.autoCorrect,\\n          className = _props3.className,\\n          id = _props3.id,\\n          role = _props3.role,\\n          spellCheck = _props3.spellCheck,\\n          tabIndex = _props3.tabIndex,\\n          style = _props3.style,\\n          tagName = _props3.tagName;\\n\\n\\n      var domProps = omit(this.props, Object.keys(Editor.propTypes));\\n\\n      var children = React.createElement(Content, _extends({}, domProps, {\\n        ref: this.tmp.contentRef,\\n        autoCorrect: autoCorrect,\\n        className: className,\\n        contentKey: contentKey,\\n        editor: this,\\n        id: id,\\n        onEvent: function onEvent(handler, event) {\\n          return _this2.run(handler, event);\\n        },\\n        readOnly: readOnly,\\n        role: role,\\n        spellCheck: spellCheck,\\n        style: style,\\n        tabIndex: tabIndex,\\n        tagName: tagName\\n      }));\\n\\n      // Render the editor's children with the controller.\\n      var element = this.controller.run('renderEditor', _extends({}, this.props, {\\n        editor: this,\\n        children: children\\n      }));\\n\\n      return element;\\n    }\\n\\n    /**\\n     * Resolve an editor controller from the passed-in props. This method takes\\n     * all of the props as individual arguments to be able to properly memoize\\n     * against anything that could change and invalidate the old editor.\\n     *\\n     * @param {Array} plugins\\n     * @param {Object} schema\\n     * @param {Object} commands\\n     * @param {Object} queries\\n     * @param {String} placeholder\\n     * @return {Editor}\\n     */\\n\\n  }, {\\n    key: 'handleChange',\\n    value: function handleChange(change) {\\n      var onChange = this.props.onChange;\\n      var value = this.state.value;\\n\\n\\n      if (value) {\\n        // Syncing value inside this component since parent does not want control of it (defaultValue was used)\\n        this.setState({ value: change.value });\\n      }\\n\\n      onChange(change);\\n    }\\n\\n    /**\\n     * Mimic the API of the `Editor` controller, so that this component instance\\n     * can be passed in its place to plugins.\\n     */\\n\\n  }, {\\n    key: 'applyOperation',\\n    value: function applyOperation() {\\n      var _controller;\\n\\n      return (_controller = this.controller).applyOperation.apply(_controller, arguments);\\n    }\\n  }, {\\n    key: 'command',\\n    value: function command() {\\n      var _controller2;\\n\\n      return (_controller2 = this.controller).command.apply(_controller2, arguments);\\n    }\\n  }, {\\n    key: 'hasCommand',\\n    value: function hasCommand() {\\n      var _controller3;\\n\\n      return (_controller3 = this.controller).hasCommand.apply(_controller3, arguments);\\n    }\\n  }, {\\n    key: 'hasQuery',\\n    value: function hasQuery() {\\n      var _controller4;\\n\\n      return (_controller4 = this.controller).hasQuery.apply(_controller4, arguments);\\n    }\\n  }, {\\n    key: 'normalize',\\n    value: function normalize() {\\n      var _controller5;\\n\\n      return (_controller5 = this.controller).normalize.apply(_controller5, arguments);\\n    }\\n  }, {\\n    key: 'query',\\n    value: function query() {\\n      var _controller6;\\n\\n      return (_controller6 = this.controller).query.apply(_controller6, arguments);\\n    }\\n  }, {\\n    key: 'registerCommand',\\n    value: function registerCommand() {\\n      var _controller7;\\n\\n      return (_controller7 = this.controller).registerCommand.apply(_controller7, arguments);\\n    }\\n  }, {\\n    key: 'registerQuery',\\n    value: function registerQuery() {\\n      var _controller8;\\n\\n      return (_controller8 = this.controller).registerQuery.apply(_controller8, arguments);\\n    }\\n  }, {\\n    key: 'run',\\n    value: function run() {\\n      var _controller9;\\n\\n      return (_controller9 = this.controller).run.apply(_controller9, arguments);\\n    }\\n  }, {\\n    key: 'withoutNormalizing',\\n    value: function withoutNormalizing() {\\n      var _controller10;\\n\\n      return (_controller10 = this.controller).withoutNormalizing.apply(_controller10, arguments);\\n    }\\n\\n    /**\\n     * Deprecated.\\n     */\\n\\n  }, {\\n    key: 'call',\\n    value: function call() {\\n      var _controller11;\\n\\n      return (_controller11 = this.controller).call.apply(_controller11, arguments);\\n    }\\n  }, {\\n    key: 'change',\\n    value: function change() {\\n      var _controller12;\\n\\n      return (_controller12 = this.controller).change.apply(_controller12, arguments);\\n    }\\n  }, {\\n    key: 'onChange',\\n    value: function onChange() {\\n      var _controller13;\\n\\n      return (_controller13 = this.controller).onChange.apply(_controller13, arguments);\\n    }\\n  }, {\\n    key: 'applyOperations',\\n    value: function applyOperations() {\\n      var _controller14;\\n\\n      return (_controller14 = this.controller).applyOperations.apply(_controller14, arguments);\\n    }\\n  }, {\\n    key: 'setOperationFlag',\\n    value: function setOperationFlag() {\\n      var _controller15;\\n\\n      return (_controller15 = this.controller).setOperationFlag.apply(_controller15, arguments);\\n    }\\n  }, {\\n    key: 'getFlag',\\n    value: function getFlag() {\\n      var _controller16;\\n\\n      return (_controller16 = this.controller).getFlag.apply(_controller16, arguments);\\n    }\\n  }, {\\n    key: 'unsetOperationFlag',\\n    value: function unsetOperationFlag() {\\n      var _controller17;\\n\\n      return (_controller17 = this.controller).unsetOperationFlag.apply(_controller17, arguments);\\n    }\\n  }, {\\n    key: 'withoutNormalization',\\n    value: function withoutNormalization() {\\n      var _controller18;\\n\\n      return (_controller18 = this.controller).withoutNormalization.apply(_controller18, arguments);\\n    }\\n  }, {\\n    key: 'operations',\\n    get: function get$$1() {\\n      return this.controller.operations;\\n    }\\n  }, {\\n    key: 'readOnly',\\n    get: function get$$1() {\\n      return this.controller.readOnly;\\n    }\\n  }, {\\n    key: 'value',\\n    get: function get$$1() {\\n      return this.controller.value;\\n    }\\n  }, {\\n    key: 'editor',\\n    get: function get$$1() {\\n      return this.controller.editor;\\n    }\\n  }, {\\n    key: 'schema',\\n    get: function get$$1() {\\n      invariant(false, 'As of Slate 0.42, the `editor.schema` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.');\\n    }\\n  }, {\\n    key: 'stack',\\n    get: function get$$1() {\\n      invariant(false, 'As of Slate 0.42, the `editor.stack` property no longer exists, and its functionality has been folded into the editor itself. Use the `editor` instead.');\\n    }\\n  }]);\\n  return Editor;\\n}(React.Component);\\n\\n/**\\n * Export.\\n *\\n * @type {Component}\\n */\\n\\nEditor.propTypes = _extends({\\n  autoCorrect: Types.bool,\\n  autoFocus: Types.bool,\\n  className: Types.string,\\n  defaultValue: SlateTypes.value,\\n  id: Types.string,\\n  onChange: Types.func,\\n  options: Types.object,\\n  placeholder: Types.any,\\n  plugins: Types.array,\\n  readOnly: Types.bool,\\n  role: Types.string,\\n  schema: Types.object,\\n  spellCheck: Types.bool,\\n  style: Types.object,\\n  tabIndex: Types.number,\\n  value: SlateTypes.value\\n}, EVENT_HANDLERS.reduce(function (obj, handler) {\\n  obj[handler] = Types.func;\\n  return obj;\\n}, {}), OTHER_HANDLERS.reduce(function (obj, handler) {\\n  obj[handler] = Types.func;\\n  return obj;\\n}, {}));\\nEditor.defaultProps = {\\n  autoFocus: false,\\n  autoCorrect: true,\\n  onChange: function onChange() {},\\n  options: {},\\n  placeholder: '',\\n  plugins: [],\\n  readOnly: false,\\n  schema: {},\\n  spellCheck: true };\\n\\n/**\\n * Find the DOM node for a `key`.\\n *\\n * @param {String|Node} key\\n * @param {Window} win (optional)\\n * @return {Element}\\n */\\n\\nfunction findDOMNode(key) {\\n  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\\n\\n  warning(false, 'As of slate-react@0.22 the `findDOMNode(key)` helper is deprecated in favor of `editor.findDOMNode(path)`.');\\n\\n  if (slate.Node.isNode(key)) {\\n    key = key.key;\\n  }\\n\\n  var el = win.document.querySelector('[' + DATA_ATTRS.KEY + '=\\\"' + key + '\\\"]');\\n\\n  if (!el) {\\n    throw new Error('Unable to find a DOM node for \\\"' + key + '\\\". This is often because of forgetting to add `props.attributes` to a custom component.');\\n  }\\n\\n  return el;\\n}\\n\\n/**\\n * Find a native DOM selection point from a Slate `point`.\\n *\\n * @param {Point} point\\n * @param {Window} win (optional)\\n * @return {Object|Null}\\n */\\n\\nfunction findDOMPoint(point) {\\n  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\\n\\n  warning(false, 'As of slate-react@0.22 the `findDOMPoint(point)` helper is deprecated in favor of `editor.findDOMPoint(point)`.');\\n\\n  var el = findDOMNode(point.key, win);\\n  var start = 0;\\n\\n  // For each leaf, we need to isolate its content, which means filtering to its\\n  // direct text and zero-width spans. (We have to filter out any other siblings\\n  // that may have been rendered alongside them.)\\n  var texts = Array.from(el.querySelectorAll(SELECTORS.STRING + ', ' + SELECTORS.ZERO_WIDTH));\\n\\n  var _iteratorNormalCompletion = true;\\n  var _didIteratorError = false;\\n  var _iteratorError = undefined;\\n\\n  try {\\n    for (var _iterator = texts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\\n      var text = _step.value;\\n\\n      var node = text.childNodes[0];\\n      var domLength = node.textContent.length;\\n      var slateLength = domLength;\\n\\n      if (text.hasAttribute(DATA_ATTRS.LENGTH)) {\\n        slateLength = parseInt(text.getAttribute(DATA_ATTRS.LENGTH), 10);\\n      }\\n\\n      var end = start + slateLength;\\n\\n      if (point.offset <= end) {\\n        var offset = Math.min(domLength, Math.max(0, point.offset - start));\\n        return { node: node, offset: offset };\\n      }\\n\\n      start = end;\\n    }\\n  } catch (err) {\\n    _didIteratorError = true;\\n    _iteratorError = err;\\n  } finally {\\n    try {\\n      if (!_iteratorNormalCompletion && _iterator.return) {\\n        _iterator.return();\\n      }\\n    } finally {\\n      if (_didIteratorError) {\\n        throw _iteratorError;\\n      }\\n    }\\n  }\\n\\n  return null;\\n}\\n\\n/**\\n * Find a native DOM range Slate `range`.\\n *\\n * @param {Range} range\\n * @param {Window} win (optional)\\n * @return {Object|Null}\\n */\\n\\nfunction findDOMRange(range) {\\n  var win = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;\\n\\n  warning(false, 'As of slate-react@0.22 the `findDOMRange(range)` helper is deprecated in favor of `editor.findDOMRange(range)`.');\\n\\n  var anchor = range.anchor,\\n      focus = range.focus,\\n      isBackward$$1 = range.isBackward,\\n      isCollapsed = range.isCollapsed;\\n\\n  var domAnchor = findDOMPoint(anchor, win);\\n  var domFocus = isCollapsed ? domAnchor : findDOMPoint(focus, win);\\n\\n  if (!domAnchor || !domFocus) return null;\\n\\n  var r = win.document.createRange();\\n  var start = isBackward$$1 ? domFocus : domAnchor;\\n  var end = isBackward$$1 ? domAnchor : domFocus;\\n  r.setStart(start.node, start.offset);\\n  r.setEnd(end.node, end.offset);\\n  return r;\\n}\\n\\n/**\\n * Find a Slate node from a DOM `element`.\\n *\\n * @param {Element} element\\n * @param {Editor} editor\\n * @return {Node|Null}\\n */\\n\\nfunction findNode(element, editor) {\\n  warning(false, 'As of slate-react@0.22 the `findNode(element)` helper is deprecated in favor of `editor.findNode(element)`.');\\n\\n  invariant(!slate.Value.isValue(editor), 'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.');\\n\\n  var closest = element.closest(SELECTORS.KEY);\\n  if (!closest) return null;\\n\\n  var key = closest.getAttribute(DATA_ATTRS.KEY);\\n  if (!key) return null;\\n\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var node = document.getNode(key);\\n  return node || null;\\n}\\n\\n/**\\n * Find a Slate path from a DOM `element`.\\n *\\n * @param {Element} element\\n * @param {Editor} editor\\n * @return {List|Null}\\n */\\n\\nfunction findPath(element, editor) {\\n  warning(false, 'As of slate-react@0.22 the `findPath(element)` helper is deprecated in favor of `editor.findPath(element)`.');\\n\\n  var node = findNode(element, editor);\\n\\n  if (!node) {\\n    return null;\\n  }\\n\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var path = document.getPath(node);\\n  return path;\\n}\\n\\n/**\\n * Find a Slate point from a DOM selection's `nativeNode` and `nativeOffset`.\\n *\\n * @param {Element} nativeNode\\n * @param {Number} nativeOffset\\n * @param {Editor} editor\\n * @return {Point}\\n */\\n\\nfunction findPoint(nativeNode, nativeOffset, editor) {\\n  warning(false, 'As of slate-react@0.22 the `findPoint(node, offset)` helper is deprecated in favor of `editor.findPoint(node, offset)`.');\\n\\n  invariant(!slate.Value.isValue(editor), 'As of Slate 0.42.0, the `findPoint` utility takes an `editor` instead of a `value`.');\\n\\n  var _normalizeNodeAndOffs = normalizeNodeAndOffset$1(nativeNode, nativeOffset),\\n      nearestNode = _normalizeNodeAndOffs.node,\\n      nearestOffset = _normalizeNodeAndOffs.offset;\\n\\n  var window = getWindow(nativeNode);\\n  var parentNode = nearestNode.parentNode;\\n\\n  var rangeNode = parentNode.closest(SELECTORS.LEAF);\\n  var offset = void 0;\\n  var node = void 0;\\n\\n  // Calculate how far into the text node the `nearestNode` is, so that we can\\n  // determine what the offset relative to the text node is.\\n  if (rangeNode) {\\n    var range = window.document.createRange();\\n    var textNode = rangeNode.closest(SELECTORS.TEXT);\\n    range.setStart(textNode, 0);\\n    range.setEnd(nearestNode, nearestOffset);\\n    node = textNode;\\n\\n    // COMPAT: Edge has a bug where Range.prototype.toString() will convert \\\\n\\n    // into \\\\r\\\\n. The bug causes a loop when slate-react attempts to reposition\\n    // its cursor to match the native position. Use textContent.length instead.\\n    // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10291116/\\n    var fragment = range.cloneContents();\\n    var zeroWidthNodes = fragment.querySelectorAll('[' + DATA_ATTRS.ZERO_WIDTH + ']');\\n    offset = fragment.textContent.length - zeroWidthNodes.length;\\n  } else {\\n    // For void nodes, the element with the offset key will be a cousin, not an\\n    // ancestor, so find it by going down from the nearest void parent.\\n    var voidNode = parentNode.closest(SELECTORS.VOID);\\n    if (!voidNode) return null;\\n    rangeNode = voidNode.querySelector(SELECTORS.LEAF);\\n    if (!rangeNode) return null;\\n    node = rangeNode;\\n    offset = node.textContent.length;\\n  }\\n\\n  // COMPAT: If the parent node is a Slate zero-width space, this is because the\\n  // text node should have no characters. However, during IME composition the\\n  // ASCII characters will be prepended to the zero-width space, so subtract 1\\n  // from the offset to account for the zero-width space character.\\n  if (offset === node.textContent.length && parentNode.hasAttribute(DATA_ATTRS.ZERO_WIDTH)) {\\n    offset--;\\n  }\\n\\n  // Get the string value of the offset key attribute.\\n  var offsetKey = rangeNode.getAttribute(DATA_ATTRS.OFFSET_KEY);\\n  if (!offsetKey) return null;\\n\\n  var _OffsetKey$parse = OffsetKey.parse(offsetKey),\\n      key = _OffsetKey$parse.key;\\n\\n  // COMPAT: If someone is clicking from one Slate editor into another, the\\n  // select event fires twice, once for the old editor's `element` first, and\\n  // then afterwards for the correct `element`. (2017/03/03)\\n\\n\\n  var value = editor.value;\\n\\n  if (!value.document.hasDescendant(key)) return null;\\n\\n  var point = value.document.createPoint({ key: key, offset: offset });\\n  return point;\\n}\\n\\n/**\\n * From a DOM selection's `node` and `offset`, normalize so that it always\\n * refers to a text node.\\n *\\n * @param {Element} node\\n * @param {Number} offset\\n * @return {Object}\\n */\\n\\nfunction normalizeNodeAndOffset$1(node, offset) {\\n  // If it's an element node, its offset refers to the index of its children\\n  // including comment nodes, so try to find the right text child node.\\n  if (node.nodeType === 1 && node.childNodes.length) {\\n    var isLast = offset === node.childNodes.length;\\n    var direction = isLast ? 'backward' : 'forward';\\n    var index = isLast ? offset - 1 : offset;\\n    node = getEditableChild$1(node, index, direction);\\n\\n    // If the node has children, traverse until we have a leaf node. Leaf nodes\\n    // can be either text nodes, or other void DOM nodes.\\n    while (node.nodeType === 1 && node.childNodes.length) {\\n      var i = isLast ? node.childNodes.length - 1 : 0;\\n      node = getEditableChild$1(node, i, direction);\\n    }\\n\\n    // Determine the new offset inside the text node.\\n    offset = isLast ? node.textContent.length : 0;\\n  }\\n\\n  // Return the node and offset.\\n  return { node: node, offset: offset };\\n}\\n\\n/**\\n * Get the nearest editable child at `index` in a `parent`, preferring\\n * `direction`.\\n *\\n * @param {Element} parent\\n * @param {Number} index\\n * @param {String} direction ('forward' or 'backward')\\n * @return {Element|Null}\\n */\\n\\nfunction getEditableChild$1(parent, index, direction) {\\n  var childNodes = parent.childNodes;\\n\\n  var child = childNodes[index];\\n  var i = index;\\n  var triedForward = false;\\n  var triedBackward = false;\\n\\n  // While the child is a comment node, or an element node with no children,\\n  // keep iterating to find a sibling non-void, non-comment node.\\n  while (child.nodeType === 8 || child.nodeType === 1 && child.childNodes.length === 0 || child.nodeType === 1 && child.getAttribute('contenteditable') === 'false') {\\n    if (triedForward && triedBackward) break;\\n\\n    if (i >= childNodes.length) {\\n      triedForward = true;\\n      i = index - 1;\\n      direction = 'backward';\\n      continue;\\n    }\\n\\n    if (i < 0) {\\n      triedBackward = true;\\n      i = index + 1;\\n      direction = 'forward';\\n      continue;\\n    }\\n\\n    child = childNodes[i];\\n    if (direction === 'forward') i++;\\n    if (direction === 'backward') i--;\\n  }\\n\\n  return child || null;\\n}\\n\\n/**\\n * Find a Slate range from a DOM `native` selection.\\n *\\n * @param {Selection} native\\n * @param {Editor} editor\\n * @return {Range}\\n */\\n\\nfunction findRange(native, editor) {\\n  warning(false, 'As of slate-react@0.22 the `findRange(selection)` helper is deprecated in favor of `editor.findRange(selection)`.');\\n\\n  invariant(!slate.Value.isValue(editor), 'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.');\\n\\n  var el = native.anchorNode || native.startContainer;\\n  if (!el) return null;\\n\\n  var window = getWindow(el);\\n\\n  // If the `native` object is a DOM `Range` or `StaticRange` object, change it\\n  // into something that looks like a DOM `Selection` instead.\\n  if (native instanceof window.Range || window.StaticRange && native instanceof window.StaticRange) {\\n    native = {\\n      anchorNode: native.startContainer,\\n      anchorOffset: native.startOffset,\\n      focusNode: native.endContainer,\\n      focusOffset: native.endOffset\\n    };\\n  }\\n\\n  var _native = native,\\n      anchorNode = _native.anchorNode,\\n      anchorOffset = _native.anchorOffset,\\n      focusNode = _native.focusNode,\\n      focusOffset = _native.focusOffset,\\n      isCollapsed = _native.isCollapsed;\\n  var value = editor.value;\\n\\n  var anchor = findPoint(anchorNode, anchorOffset, editor);\\n  var focus = isCollapsed ? anchor : findPoint(focusNode, focusOffset, editor);\\n  if (!anchor || !focus) return null;\\n\\n  var document = value.document;\\n\\n  var range = document.createRange({\\n    anchor: anchor,\\n    focus: focus\\n  });\\n\\n  return range;\\n}\\n\\n/**\\n * Get the target range from a DOM `event`.\\n *\\n * @param {Event} event\\n * @param {Editor} editor\\n * @return {Range}\\n */\\n\\nfunction getEventRange(event, editor) {\\n  warning(false, 'As of slate-react@0.22 the `getEventRange(event, editor)` helper is deprecated in favor of `editor.findEventRange(event)`.');\\n\\n  invariant(!slate.Value.isValue(editor), 'As of Slate 0.42.0, the `findNode` utility takes an `editor` instead of a `value`.');\\n\\n  if (event.nativeEvent) {\\n    event = event.nativeEvent;\\n  }\\n\\n  var _event = event,\\n      x = _event.clientX,\\n      y = _event.clientY,\\n      target = _event.target;\\n\\n  if (x == null || y == null) return null;\\n\\n  var value = editor.value;\\n  var document = value.document;\\n\\n  var path = findPath(event.target, editor);\\n  if (!path) return null;\\n\\n  var node = document.getNode(path);\\n\\n  // If the drop target is inside a void node, move it into either the next or\\n  // previous node, depending on which side the `x` and `y` coordinates are\\n  // closest to.\\n  if (editor.isVoid(node)) {\\n    var rect = target.getBoundingClientRect();\\n    var isPrevious = node.object === 'inline' ? x - rect.left < rect.left + rect.width - x : y - rect.top < rect.top + rect.height - y;\\n\\n    var _range = document.createRange();\\n    var move = isPrevious ? 'moveToEndOfNode' : 'moveToStartOfNode';\\n    var entry = document[isPrevious ? 'getPreviousText' : 'getNextText'](path);\\n\\n    if (entry) {\\n      return _range[move](entry);\\n    }\\n\\n    return null;\\n  }\\n\\n  // Else resolve a range from the caret position where the drop occured.\\n  var window = getWindow(target);\\n  var native = void 0;\\n\\n  // COMPAT: In Firefox, `caretRangeFromPoint` doesn't exist. (2016/07/25)\\n  if (window.document.caretRangeFromPoint) {\\n    native = window.document.caretRangeFromPoint(x, y);\\n  } else if (window.document.caretPositionFromPoint) {\\n    var position = window.document.caretPositionFromPoint(x, y);\\n    native = window.document.createRange();\\n    native.setStart(position.offsetNode, position.offset);\\n    native.setEnd(position.offsetNode, position.offset);\\n  } else if (window.document.body.createTextRange) {\\n    // COMPAT: In IE, `caretRangeFromPoint` and\\n    // `caretPositionFromPoint` don't exist. (2018/07/11)\\n    native = window.document.body.createTextRange();\\n\\n    try {\\n      native.moveToPoint(x, y);\\n    } catch (error) {\\n      // IE11 will raise an `unspecified error` if `moveToPoint` is\\n      // called during a dropEvent.\\n      return null;\\n    }\\n  }\\n\\n  // Resolve a Slate range from the DOM range.\\n  var range = findRange(native, editor);\\n  if (!range) return null;\\n\\n  return range;\\n}\\n\\nvar index = {\\n  Editor: Editor,\\n  cloneFragment: cloneFragment,\\n  findDOMNode: findDOMNode,\\n  findDOMPoint: findDOMPoint,\\n  findDOMRange: findDOMRange,\\n  findNode: findNode,\\n  findPath: findPath,\\n  findPoint: findPoint,\\n  findRange: findRange,\\n  getEventRange: getEventRange,\\n  getEventTransfer: getEventTransfer,\\n  setEventTransfer: setEventTransfer,\\n  ReactPlugin: ReactPlugin\\n};\\n\\nexports.Editor = Editor;\\nexports.cloneFragment = cloneFragment;\\nexports.findDOMNode = findDOMNode;\\nexports.findDOMPoint = findDOMPoint;\\nexports.findDOMRange = findDOMRange;\\nexports.findNode = findNode;\\nexports.findPath = findPath;\\nexports.findPoint = findPoint;\\nexports.findRange = findRange;\\nexports.getEventRange = getEventRange;\\nexports.getEventTransfer = getEventTransfer;\\nexports.setEventTransfer = setEventTransfer;\\nexports.ReactPlugin = ReactPlugin;\\nexports.default = index;\\n//# sourceMappingURL=slate-react.js.map\\n\\n};\"],\n\"names\":[\"shadow$provide\",\"global\",\"require\",\"module\",\"exports\",\"_interopDefault\",\"ex\",\"getRelativeRange\",\"node\",\"index\",\"range\",\"isUnset\",\"child\",\"nodes\",\"get\",\"_range\",\"start\",\"end\",\"startPath\",\"path\",\"endPath\",\"startIndex\",\"first\",\"endIndex\",\"setPath\",\"rest\",\"object\",\"moveTo\",\"slate\",\"PathUtils\",\"create\",\"setKey\",\"key\",\"_child$texts\",\"texts\",\"slicedToArray\",\"_child$texts2\",\"_first\",\"firstNode\",\"firstPath\",\"length\",\"text\",\"_child$texts3\",\"direction\",\"last\",\"_child$texts4\",\"_last\",\"lastNode\",\"lastPath\",\"setAnchor\",\"setFocus\",\"scrollToSelection\",\"selection\",\"IS_IOS_11\",\"anchorNode\",\"window\",\"getWindow\",\"parent\",\"parentNode\",\"scroller\",\"overflowY\",\"getComputedStyle\",\"style\",\"OVERFLOWS\",\"includes\",\"document\",\"body\",\"isWindow\",\"documentElement\",\"backward\",\"isBackward\",\"getRangeAt\",\"cloneRange\",\"collapse\",\"cursorRect\",\"getBoundingClientRect\",\"slateDevEnvironment\",\"IS_SAFARI\",\"collapsed\",\"top\",\"height\",\"startOffset\",\"setEnd\",\"endContainer\",\"setStart\",\"startContainer\",\"getClientRects\",\"scrollerTop\",\"scrollerLeft\",\"scrollerBordersY\",\"scrollerBordersX\",\"scrollerPaddingTop\",\"scrollerPaddingBottom\",\"scrollerPaddingLeft\",\"scrollerPaddingRight\",\"innerHeight\",\"pageYOffset\",\"pageXOffset\",\"width\",\"innerWidth\",\"offsetWidth\",\"offsetHeight\",\"scrollTop\",\"scrollLeft\",\"_window$getComputedSt\",\"borderTopWidth\",\"borderBottomWidth\",\"borderLeftWidth\",\"borderRightWidth\",\"paddingTop\",\"paddingBottom\",\"paddingLeft\",\"paddingRight\",\"scrollerRect\",\"parseInt\",\"left\",\"cursorTop\",\"yOffset\",\"cursorLeft\",\"xOffset\",\"x\",\"y\",\"scrollTo\",\"removeAllRanges\",\"domSelection\",\"IS_IE\",\"createTextRange\",\"select\",\"EditorPropsPlugin\",\"options\",\"arguments\",\"undefined\",\"PROPS\",\"reduce\",\"plugin\",\"memo\",\"prop\",\"Rendering\",\"decorateNode\",\"renderAnnotation\",\"_ref\",\"React\",\"createElement\",\"attributes\",\"children\",\"renderBlock\",\"_ref2\",\"_extends\",\"position\",\"renderDecoration\",\"_ref3\",\"renderDocument\",\"_ref4\",\"renderEditor\",\"_ref5\",\"renderInline\",\"_ref6\",\"renderMark\",\"_ref7\",\"CommandsPlugin\",\"commands\",\"reconcileNode\",\"editor\",\"value\",\"getPath\",\"domElement\",\"findDOMNode\",\"block\",\"getClosestBlock\",\"domText\",\"textContent\",\"isLastNode\",\"lastChar\",\"charAt\",\"slice\",\"entire\",\"moveAnchorTo\",\"moveFocusTo\",\"resolveRange\",\"insertTextAtRange\",\"marks\",\"reconcileDOMNode\",\"domNode\",\"parentElement\",\"closest\",\"findNode\",\"QueriesPlugin\",\"queries\",\"content\",\"tmp\",\"contentRef\",\"current\",\"size\",\"search\",\"instance\",\"p\",\"ref\",\"nodeRefs\",\"el\",\"nodeRef\",\"findDOMPoint\",\"point\",\"Array\",\"from\",\"querySelectorAll\",\"SELECTORS\",\"STRING\",\"ZERO_WIDTH\",\"_iteratorNormalCompletion\",\"_didIteratorError\",\"_iteratorError\",\"_iterator\",\"Symbol\",\"iterator\",\"_step\",\"done\",\"next\",\"childNodes\",\"domLength\",\"slateLength\",\"hasAttribute\",\"DATA_ATTRS\",\"LENGTH\",\"getAttribute\",\"offset\",\"Math\",\"min\",\"max\",\"err\",\"return\",\"findDOMRange\",\"focus\",\"isBackward$$1\",\"isCollapsed\",\"domAnchor\",\"anchor\",\"domFocus\",\"r\",\"createRange\",\"findEventRange\",\"event\",\"nativeEvent\",\"_event\",\"clientX\",\"clientY\",\"target\",\"findPath\",\"getNode\",\"isVoid\",\"rect\",\"isPrevious\",\"move\",\"entry\",\"native\",\"caretRangeFromPoint\",\"caretPositionFromPoint\",\"offsetNode\",\"moveToPoint\",\"error\",\"findRange\",\"element\",\"nodeElement\",\"KEY\",\"keys\",\"Object\",\"_iteratorNormalCompletion2\",\"_didIteratorError2\",\"_iteratorError2\",\"_iterator2\",\"_step2\",\"i\",\"n\",\"_path\",\"concat\",\"toConsumableArray\",\"findPoint\",\"nativeNode\",\"nativeOffset\",\"_normalizeNodeAndOffs\",\"normalizeNodeAndOffset\",\"nearestNode\",\"nearestOffset\",\"leafNode\",\"LEAF\",\"textNode\",\"TEXT\",\"contents\",\"cloneContents\",\"zeroWidths\",\"forEach\",\"removeChild\",\"voidNode\",\"VOID\",\"querySelector\",\"createPoint\",\"domRange\",\"Range\",\"StaticRange\",\"anchorOffset\",\"focusNode\",\"focusOffset\",\"endOffset\",\"_domRange\",\"findSelection\",\"rangeCount\",\"_range2\",\"anchorText\",\"focusText\",\"anchorInline\",\"getClosestInline\",\"focusInline\",\"focusBlock\",\"anchorBlock\",\"setOffset\",\"depth\",\"getDepth\",\"relativePath\",\"drop\",\"_block$texts\",\"_block$texts2\",\"nextPath\",\"_next\",\"absolutePath\",\"_block\",\"_next2\",\"_depth\",\"_relativePath\",\"_block$texts3\",\"_block$texts4\",\"_nextPath\",\"_next3\",\"_absolutePath\",\"createSelection\",\"setIsFocused\",\"set\",\"nodeType\",\"isLast\",\"getEditableChild\",\"triedForward\",\"triedBackward\",\"renderSync\",\"fn\",\"flushControlled\",\"controller\",\"flush\",\"fixTextAndOffset\",\"prevText\",\"nextOffset\",\"prevOffset\",\"nextText\",\"indexOf\",\"ZERO_WIDTH_SPACE\",\"maxOffset\",\"CompositionManager\",\"clearAction\",\"debug$3\",\"diff\",\"applyDiff\",\"diff$$1\",\"insertText\",\"splitBlock\",\"restoreDOM\",\"mergeBlock\",\"win\",\"requestAnimationFrame\",\"deleteBackward\",\"startAction\",\"onSelectTimeoutId\",\"cancelAnimationFrame\",\"isFlushing\",\"startActionFrameId\",\"bufferedMutations\",\"flushAction\",\"mutations\",\"find\",\"splitBlockMutation\",\"m\",\"type\",\"addedNodes\",\"addedNode\",\"Node\",\"TEXT_NODE\",\"ELEMENT_NODE\",\"dataset\",\"firstMutation\",\"resolveDOMNode\",\"removedNodes\",\"removeNode\",\"dataElement\",\"getDescendant\",\"fix\",\"prevLength\",\"nextLength\",\"maxEnd\",\"prevChar\",\"nextChar\",\"total\",\"offsets\",\"removeText\",\"cursor\",\"nodeSelection\",\"moveToRangeOfNode\",\"delete\",\"observer\",\"MutationObserver\",\"_bufferedMutations\",\"push\",\"apply\",\"rootEl\",\"clearDiff\",\"connect\",\"observe\",\"childList\",\"characterData\",\"subtree\",\"characterDataOldValue\",\"disconnect\",\"onKeyDown\",\"onCompositionStart\",\"onCompositionEnd\",\"setTimeout\",\"getSelection\",\"onSelect\",\"anchorFix\",\"focusFix\",\"toJS\",\"AndroidPlugin\",\"onComponentDidMount\",\"onComponentDidUpdate\",\"onComponentWillUnmount\",\"onRender\",\"slateZeroWidth\",\"addRange\",\"NoopPlugin\",\"EVENT_HANDLERS\",\"cloneFragment\",\"callback\",\"invariant\",\"Value\",\"isValue\",\"fragment\",\"startVoid\",\"getClosestVoid\",\"endVoid\",\"encoded\",\"Base64\",\"serializeNode\",\"attach\",\"trim\",\"setEndAfter\",\"firstChild\",\"call\",\"zw\",\"isNewline\",\"span\",\"whiteSpace\",\"appendChild\",\"setAttribute\",\"FRAGMENT\",\"valFromSelection\",\"plainText\",\"Plain\",\"serialize\",\"div\",\"clipboardData\",\"setData\",\"preventDefault\",\"HTML\",\"innerHTML\",\"editorEl\",\"EDITOR\",\"selectAllChildren\",\"getEventTransfer\",\"transfer\",\"dataTransfer\",\"getType\",\"FRAGMENT$1\",\"NODE\",\"html\",\"HTML$1\",\"rich\",\"RICH\",\"TEXT$1\",\"files\",\"matches\",\"FRAGMENT_MATCHER\",\"exec\",\"_matches\",\"embeddedTypes\",\"getEmbeddedTypes\",\"deserializeNode\",\"items\",\"map\",\"item\",\"kind\",\"getAsFile\",\"filter\",\"exists\",\"data\",\"prefix\",\"substring\",\"JSON\",\"parse\",\"Error\",\"types\",\"getData\",\"setEventTransfer\",\"mime\",\"TRANSFER_TYPES\",\"toUpperCase\",\"TEXT$2\",\"obj\",\"e\",\"string\",\"stringify\",\"AfterPlugin\",\"isDraggingInternally\",\"isMouseDown\",\"onBeforeInput\",\"_event$getTargetRange\",\"getTargetRanges\",\"targetRange\",\"_event$getTargetRange2\",\"debug$4\",\"inputType\",\"deleteAtRange\",\"deleteWordBackwardAtRange\",\"deleteWordForwardAtRange\",\"deleteLineBackwardAtRange\",\"deleteLineForwardAtRange\",\"hasVoidParent\",\"moveToStartOfNextText\",\"splitBlockAtRange\",\"onBlur\",\"blur\",\"onClick\",\"readOnly\",\"ancestors\",\"getAncestors\",\"some\",\"a\",\"moveToEndOfNode\",\"onCopy\",\"onCut\",\"voidPath\",\"removeNodeByKey\",\"onDragEnd\",\"onDragStart\",\"selectionIncludesNode\",\"blocks\",\"onDrop\",\"dispatchEvent\",\"MouseEvent\",\"view\",\"bubbles\",\"cancelable\",\"_document$texts\",\"nxt\",\"_document$texts2\",\"_nxt\",\"moveToStartOfNode\",\"split\",\"line\",\"insertFragment\",\"onFocus\",\"IS_EDGE\",\"deselect\",\"onInput\",\"Hotkeys\",\"isSplitBlock\",\"IS_IOS\",\"isDeleteBackward\",\"deleteCharBackward\",\"isDeleteForward\",\"deleteCharForward\",\"isDeleteLineBackward\",\"deleteLineBackward\",\"isDeleteLineForward\",\"deleteLineForward\",\"isDeleteWordBackward\",\"deleteWordBackward\",\"isDeleteWordForward\",\"deleteWordForward\",\"isRedo\",\"redo\",\"isUndo\",\"undo\",\"isMoveLineBackward\",\"moveToStartOfBlock\",\"isMoveLineForward\",\"moveToEndOfBlock\",\"isExtendLineBackward\",\"moveFocusToStartOfBlock\",\"isExtendLineForward\",\"moveFocusToEndOfBlock\",\"isMoveBackward\",\"moveBackward\",\"moveToStart\",\"isMoveForward\",\"moveForward\",\"moveToEnd\",\"isMoveWordBackward\",\"moveWordBackward\",\"isMoveWordForward\",\"moveWordForward\",\"isExtendBackward\",\"startText\",\"_document$texts3\",\"prevEntry\",\"_document$texts4\",\"isPrevInVoid\",\"prevPath\",\"_prevEntry\",\"moveFocusBackward\",\"isExtendForward\",\"_startText\",\"_document$texts5\",\"nextEntry\",\"_document$texts6\",\"isNextInVoid\",\"_nextEntry\",\"moveFocusForward\",\"onMouseDown\",\"onMouseUp\",\"onPaste\",\"startBlock\",\"defaultMarks\",\"getInsertMarksAtRange\",\"frag\",\"deserialize\",\"defaultBlock\",\"BeforePlugin\",\"activeElement\",\"compositionCount\",\"isComposing\",\"isCopying\",\"isDragging\",\"isUserActionPerformed\",\"isSynthetic\",\"HAS_INPUT_EVENTS_LEVEL_2\",\"debug$5\",\"relatedTarget\",\"SPACER\",\"contains\",\"onDragEnter\",\"onDragExit\",\"onDragLeave\",\"onDragOver\",\"dropEffect\",\"IS_FIREFOX\",\"isBlurred\",\"isCompose\",\"isBold\",\"isItalic\",\"isTransposeCharacter\",\"userActionPerformed\",\"clearUserActionPerformed\",\"DOMPlugin\",\"_options$plugins\",\"plugins\",\"beforePlugin\",\"afterPlugin\",\"androidPlugins\",\"IS_ANDROID\",\"RestoreDOMPlugin\",\"contentKey\",\"stringifyEvent\",\"DebugEventsPlugin\",\"s\",\"debug$6\",\"DebugBatchEventsPlugin\",\"dumpEvents\",\"debug$7\",\"events\",\"join\",\"startDate\",\"timeoutId\",\"Date\",\"now\",\"clearTimeout\",\"INTERVAL\",\"normalizeNode\",\"outerHTML\",\"DebugMutationsPlugin\",\"prevRootEl\",\"debug$8\",\"array\",\"mutationRecord\",\"MUTATION_PROPERTIES\",\"NodeList\",\"stop\",\"ReactPlugin\",\"_options$placeholder\",\"placeholder\",\"debugEventsPlugin\",\"Debug\",\"enabled\",\"debugBatchEventsPlugin\",\"debugMutationsPlugin\",\"renderingPlugin\",\"commandsPlugin\",\"queriesPlugin\",\"editorPropsPlugin\",\"domPlugin\",\"restoreDomPlugin\",\"placeholderPlugin\",\"PlaceholderPlugin\",\"when\",\"warning\",\"isNode\",\"getEditableChild$1\",\"rangeNode\",\"zeroWidthNodes\",\"offsetKey\",\"OFFSET_KEY\",\"OffsetKey\",\"_OffsetKey$parse\",\"hasDescendant\",\"_native\",\"getEventRange\",\"defineProperty\",\"Types\",\"SlateTypes\",\"ImmutableTypes\",\"throttle\",\"omit\",\"immutable\",\"ReactDOM\",\"memoizeOne\",\"OBJECT\",\"BLOCK\",\"INLINE\",\"classCallCheck\",\"Constructor\",\"TypeError\",\"createClass\",\"defineProperties\",\"props\",\"descriptor\",\"enumerable\",\"configurable\",\"writable\",\"protoProps\",\"staticProps\",\"prototype\",\"assign\",\"source\",\"hasOwnProperty\",\"inherits\",\"subClass\",\"superClass\",\"constructor\",\"setPrototypeOf\",\"__proto__\",\"possibleConstructorReturn\",\"self\",\"ReferenceError\",\"arr\",\"isArray\",\"_arr\",\"_n\",\"_d\",\"_e\",\"_i\",\"_s\",\"arr2\",\"PARSER\",\"TextString\",\"_ref$text\",\"_ref$isTrailing\",\"isTrailing\",\"ZeroWidthString\",\"_ref3$length\",\"_ref3$isLineBreak\",\"isLineBreak\",\"Leaf\",\"_attrs\",\"annotations\",\"decorations\",\"leaves\",\"query\",\"lastText\",\"getLastText\",\"isLastLeaf\",\"renderProps\",\"ret\",\"run\",\"mark\",\"decoration\",\"_iteratorNormalCompletion3\",\"_didIteratorError3\",\"_iteratorError3\",\"_iterator3\",\"_step3\",\"annotation\",\"attrs\",\"propTypes\",\"list\",\"isRequired\",\"number\",\"MemoizedLeaf\",\"prev\",\"equals\",\"Text\",\"forwardRef\",\"getLeaves\",\"at\",\"leaf\",\"MemoizedText\",\"debug\",\"Void\",\"_React$Component\",\"_temp\",\"_this\",\"_ret\",\"_len\",\"args\",\"_key\",\"getPrototypeOf\",\"_initialiseProps\",\"render\",\"Tag\",\"spacerAttrs\",\"spacer\",\"color\",\"outline\",\"renderText\",\"contentEditable\",\"Component\",\"any\",\"bool\",\"_this2\",\"this.debug\",\"message\",\"_len2\",\"_key2\",\"this.renderText\",\"_props\",\"textRef\",\"getFirstText\",\"debug$1\",\"_initialiseProps$1\",\"shouldComponentUpdate\",\"nextProps\",\"shouldUpdate\",\"_attributes\",\"newDecorations\",\"getDecorations\",\"toArray\",\"sel\",\"decs\",\"d\",\"anns\",\"isLeafBlock\",\"getTextDirection\",\"dir\",\"isFocused\",\"isSelected\",\"_this3\",\"createRef\",\"navigator\",\"userAgent\",\"match\",\"FIREFOX_NODE_TYPE_ACCESS_ERROR\",\"debug$2\",\"update\",\"Content\",\"isUpdatingSelection\",\"nativeSelection\",\"setRef\",\"_this.setRef\",\"handlers\",\"handler\",\"onEvent\",\"updateSelection\",\"_this.updateSelection\",\"toJSON\",\"updated\",\"propsToCompare\",\"selectionsEqual\",\"isInEditor\",\"preventScroll\",\"isSet\",\"setBaseAndExtent\",\"_this.isInEditor\",\"test\",\"isContentEditable\",\"onNativeSelectionChange\",\"componentDidCatch\",\"info\",\"setState\",\"componentDidMount\",\"addEventListener\",\"componentWillUnmount\",\"removeEventListener\",\"componentDidUpdate\",\"isUndoRedo\",\"toRange\",\"_data\",\"id\",\"className\",\"tabIndex\",\"role\",\"spellCheck\",\"Container\",\"tagName\",\"wordWrap\",\"WebkitUserModify\",\"domProps\",\"suppressContentEditableWarning\",\"autoCorrect\",\"List\",\"func\",\"defaultProps\",\"String\",\"fromCharCode\",\"unstable_flushControlled\",\"debug$9\",\"Editor\",\"state\",\"defaultValue\",\"mounted\",\"change\",\"resolves\",\"updates\",\"resolveController\",\"react\",\"TheReactPlugin\",\"onChange\",\"handleChange\",\"construct\",\"autoFocus\",\"schema\",\"_props2\",\"valueFromState\",\"setReadOnly\",\"setValue\",\"_props3\",\"applyOperation\",\"_controller\",\"command\",\"_controller2\",\"hasCommand\",\"_controller3\",\"hasQuery\",\"_controller4\",\"normalize\",\"_controller5\",\"_controller6\",\"registerCommand\",\"_controller7\",\"registerQuery\",\"_controller8\",\"_controller9\",\"withoutNormalizing\",\"_controller10\",\"_controller11\",\"_controller12\",\"_controller13\",\"applyOperations\",\"_controller14\",\"setOperationFlag\",\"_controller15\",\"getFlag\",\"_controller16\",\"unsetOperationFlag\",\"_controller17\",\"withoutNormalization\",\"_controller18\",\"get$$1\",\"operations\",\"OTHER_HANDLERS\",\"default\"]\n}\n"]